
build/BLDC_4_ChibiOS.elf:     file format elf32-littlearm


Disassembly of section .text:

0800c000 <Reset_Handler>:
 800c000:	b672      	cpsid	i
 800c002:	4833      	ldr	r0, [pc, #204]	; (800c0d0 <endfiniloop+0x4>)
 800c004:	f380 8809 	msr	PSP, r0
 800c008:	f240 0000 	movw	r0, #0
 800c00c:	f2cc 0000 	movt	r0, #49152	; 0xc000
 800c010:	f64e 7134 	movw	r1, #61236	; 0xef34
 800c014:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c018:	6008      	str	r0, [r1, #0]
 800c01a:	f3bf 8f4f 	dsb	sy
 800c01e:	f3bf 8f6f 	isb	sy
 800c022:	f240 0000 	movw	r0, #0
 800c026:	f2c0 00f0 	movt	r0, #240	; 0xf0
 800c02a:	f64e 5188 	movw	r1, #60808	; 0xed88
 800c02e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c032:	6008      	str	r0, [r1, #0]
 800c034:	f3bf 8f4f 	dsb	sy
 800c038:	f3bf 8f6f 	isb	sy
 800c03c:	f04f 0000 	mov.w	r0, #0
 800c040:	eee1 0a10 	vmsr	fpscr, r0
 800c044:	f64e 713c 	movw	r1, #61244	; 0xef3c
 800c048:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800c04c:	6008      	str	r0, [r1, #0]
 800c04e:	2006      	movs	r0, #6
 800c050:	f380 8814 	msr	CONTROL, r0
 800c054:	f3bf 8f6f 	isb	sy
 800c058:	f001 f9da 	bl	800d410 <__core_init>
 800c05c:	f005 fba8 	bl	80117b0 <__early_init>
 800c060:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800c064:	491b      	ldr	r1, [pc, #108]	; (800c0d4 <endfiniloop+0x8>)
 800c066:	4a1c      	ldr	r2, [pc, #112]	; (800c0d8 <endfiniloop+0xc>)

0800c068 <msloop>:
 800c068:	4291      	cmp	r1, r2
 800c06a:	bf3c      	itt	cc
 800c06c:	f841 0b04 	strcc.w	r0, [r1], #4
 800c070:	e7fa      	bcc.n	800c068 <msloop>
 800c072:	491a      	ldr	r1, [pc, #104]	; (800c0dc <endfiniloop+0x10>)
 800c074:	4a16      	ldr	r2, [pc, #88]	; (800c0d0 <endfiniloop+0x4>)

0800c076 <psloop>:
 800c076:	4291      	cmp	r1, r2
 800c078:	bf3c      	itt	cc
 800c07a:	f841 0b04 	strcc.w	r0, [r1], #4
 800c07e:	e7fa      	bcc.n	800c076 <psloop>
 800c080:	4917      	ldr	r1, [pc, #92]	; (800c0e0 <endfiniloop+0x14>)
 800c082:	4a18      	ldr	r2, [pc, #96]	; (800c0e4 <endfiniloop+0x18>)
 800c084:	4b18      	ldr	r3, [pc, #96]	; (800c0e8 <endfiniloop+0x1c>)

0800c086 <dloop>:
 800c086:	429a      	cmp	r2, r3
 800c088:	bf3e      	ittt	cc
 800c08a:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800c08e:	f842 0b04 	strcc.w	r0, [r2], #4
 800c092:	e7f8      	bcc.n	800c086 <dloop>
 800c094:	2000      	movs	r0, #0
 800c096:	4915      	ldr	r1, [pc, #84]	; (800c0ec <endfiniloop+0x20>)
 800c098:	4a15      	ldr	r2, [pc, #84]	; (800c0f0 <endfiniloop+0x24>)

0800c09a <bloop>:
 800c09a:	4291      	cmp	r1, r2
 800c09c:	bf3c      	itt	cc
 800c09e:	f841 0b04 	strcc.w	r0, [r1], #4
 800c0a2:	e7fa      	bcc.n	800c09a <bloop>
 800c0a4:	f001 f9bc 	bl	800d420 <__late_init>
 800c0a8:	4c12      	ldr	r4, [pc, #72]	; (800c0f4 <endfiniloop+0x28>)
 800c0aa:	4d13      	ldr	r5, [pc, #76]	; (800c0f8 <endfiniloop+0x2c>)

0800c0ac <initloop>:
 800c0ac:	42ac      	cmp	r4, r5
 800c0ae:	da03      	bge.n	800c0b8 <endinitloop>
 800c0b0:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0b4:	4788      	blx	r1
 800c0b6:	e7f9      	b.n	800c0ac <initloop>

0800c0b8 <endinitloop>:
 800c0b8:	f005 fc32 	bl	8011920 <main>
 800c0bc:	4c0f      	ldr	r4, [pc, #60]	; (800c0fc <endfiniloop+0x30>)
 800c0be:	4d10      	ldr	r5, [pc, #64]	; (800c100 <endfiniloop+0x34>)

0800c0c0 <finiloop>:
 800c0c0:	42ac      	cmp	r4, r5
 800c0c2:	da03      	bge.n	800c0cc <endfiniloop>
 800c0c4:	f854 1b04 	ldr.w	r1, [r4], #4
 800c0c8:	4788      	blx	r1
 800c0ca:	e7f9      	b.n	800c0c0 <finiloop>

0800c0cc <endfiniloop>:
 800c0cc:	f001 b9b0 	b.w	800d430 <__default_exit>
 800c0d0:	20001000 	.word	0x20001000
 800c0d4:	20000000 	.word	0x20000000
 800c0d8:	20000800 	.word	0x20000800
 800c0dc:	20000800 	.word	0x20000800
 800c0e0:	08030328 	.word	0x08030328
 800c0e4:	20001000 	.word	0x20001000
 800c0e8:	20001a44 	.word	0x20001a44
 800c0ec:	20001a48 	.word	0x20001a48
 800c0f0:	20011ce8 	.word	0x20011ce8
 800c0f4:	0800c000 	.word	0x0800c000
 800c0f8:	0800c000 	.word	0x0800c000
 800c0fc:	0800c000 	.word	0x0800c000
 800c100:	0800c000 	.word	0x0800c000
	...

0800c110 <_port_switch>:
 800c110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c114:	ed2d 8a10 	vpush	{s16-s31}
 800c118:	f8c1 d00c 	str.w	sp, [r1, #12]
 800c11c:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800c120:	ecbd 8a10 	vpop	{s16-s31}
 800c124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c128 <_port_thread_start>:
 800c128:	2300      	movs	r3, #0
 800c12a:	f383 8811 	msr	BASEPRI, r3
 800c12e:	4628      	mov	r0, r5
 800c130:	47a0      	blx	r4
 800c132:	2000      	movs	r0, #0
 800c134:	f001 fc84 	bl	800da40 <chThdExit>

0800c138 <_port_switch_from_isr>:
 800c138:	f001 fbb2 	bl	800d8a0 <chSchDoReschedule>

0800c13c <_port_exit_from_isr>:
 800c13c:	df00      	svc	0
 800c13e:	e7fe      	b.n	800c13e <_port_exit_from_isr+0x2>

0800c140 <__aeabi_drsub>:
 800c140:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800c144:	e002      	b.n	800c14c <__adddf3>
 800c146:	bf00      	nop

0800c148 <__aeabi_dsub>:
 800c148:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800c14c <__adddf3>:
 800c14c:	b530      	push	{r4, r5, lr}
 800c14e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800c152:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800c156:	ea94 0f05 	teq	r4, r5
 800c15a:	bf08      	it	eq
 800c15c:	ea90 0f02 	teqeq	r0, r2
 800c160:	bf1f      	itttt	ne
 800c162:	ea54 0c00 	orrsne.w	ip, r4, r0
 800c166:	ea55 0c02 	orrsne.w	ip, r5, r2
 800c16a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800c16e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800c172:	f000 80e2 	beq.w	800c33a <__adddf3+0x1ee>
 800c176:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800c17a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800c17e:	bfb8      	it	lt
 800c180:	426d      	neglt	r5, r5
 800c182:	dd0c      	ble.n	800c19e <__adddf3+0x52>
 800c184:	442c      	add	r4, r5
 800c186:	ea80 0202 	eor.w	r2, r0, r2
 800c18a:	ea81 0303 	eor.w	r3, r1, r3
 800c18e:	ea82 0000 	eor.w	r0, r2, r0
 800c192:	ea83 0101 	eor.w	r1, r3, r1
 800c196:	ea80 0202 	eor.w	r2, r0, r2
 800c19a:	ea81 0303 	eor.w	r3, r1, r3
 800c19e:	2d36      	cmp	r5, #54	; 0x36
 800c1a0:	bf88      	it	hi
 800c1a2:	bd30      	pophi	{r4, r5, pc}
 800c1a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800c1a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c1ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800c1b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800c1b4:	d002      	beq.n	800c1bc <__adddf3+0x70>
 800c1b6:	4240      	negs	r0, r0
 800c1b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c1bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800c1c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c1c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800c1c8:	d002      	beq.n	800c1d0 <__adddf3+0x84>
 800c1ca:	4252      	negs	r2, r2
 800c1cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c1d0:	ea94 0f05 	teq	r4, r5
 800c1d4:	f000 80a7 	beq.w	800c326 <__adddf3+0x1da>
 800c1d8:	f1a4 0401 	sub.w	r4, r4, #1
 800c1dc:	f1d5 0e20 	rsbs	lr, r5, #32
 800c1e0:	db0d      	blt.n	800c1fe <__adddf3+0xb2>
 800c1e2:	fa02 fc0e 	lsl.w	ip, r2, lr
 800c1e6:	fa22 f205 	lsr.w	r2, r2, r5
 800c1ea:	1880      	adds	r0, r0, r2
 800c1ec:	f141 0100 	adc.w	r1, r1, #0
 800c1f0:	fa03 f20e 	lsl.w	r2, r3, lr
 800c1f4:	1880      	adds	r0, r0, r2
 800c1f6:	fa43 f305 	asr.w	r3, r3, r5
 800c1fa:	4159      	adcs	r1, r3
 800c1fc:	e00e      	b.n	800c21c <__adddf3+0xd0>
 800c1fe:	f1a5 0520 	sub.w	r5, r5, #32
 800c202:	f10e 0e20 	add.w	lr, lr, #32
 800c206:	2a01      	cmp	r2, #1
 800c208:	fa03 fc0e 	lsl.w	ip, r3, lr
 800c20c:	bf28      	it	cs
 800c20e:	f04c 0c02 	orrcs.w	ip, ip, #2
 800c212:	fa43 f305 	asr.w	r3, r3, r5
 800c216:	18c0      	adds	r0, r0, r3
 800c218:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800c21c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c220:	d507      	bpl.n	800c232 <__adddf3+0xe6>
 800c222:	f04f 0e00 	mov.w	lr, #0
 800c226:	f1dc 0c00 	rsbs	ip, ip, #0
 800c22a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800c22e:	eb6e 0101 	sbc.w	r1, lr, r1
 800c232:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800c236:	d31b      	bcc.n	800c270 <__adddf3+0x124>
 800c238:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800c23c:	d30c      	bcc.n	800c258 <__adddf3+0x10c>
 800c23e:	0849      	lsrs	r1, r1, #1
 800c240:	ea5f 0030 	movs.w	r0, r0, rrx
 800c244:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800c248:	f104 0401 	add.w	r4, r4, #1
 800c24c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800c250:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800c254:	f080 809a 	bcs.w	800c38c <__adddf3+0x240>
 800c258:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800c25c:	bf08      	it	eq
 800c25e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c262:	f150 0000 	adcs.w	r0, r0, #0
 800c266:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c26a:	ea41 0105 	orr.w	r1, r1, r5
 800c26e:	bd30      	pop	{r4, r5, pc}
 800c270:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800c274:	4140      	adcs	r0, r0
 800c276:	eb41 0101 	adc.w	r1, r1, r1
 800c27a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c27e:	f1a4 0401 	sub.w	r4, r4, #1
 800c282:	d1e9      	bne.n	800c258 <__adddf3+0x10c>
 800c284:	f091 0f00 	teq	r1, #0
 800c288:	bf04      	itt	eq
 800c28a:	4601      	moveq	r1, r0
 800c28c:	2000      	moveq	r0, #0
 800c28e:	fab1 f381 	clz	r3, r1
 800c292:	bf08      	it	eq
 800c294:	3320      	addeq	r3, #32
 800c296:	f1a3 030b 	sub.w	r3, r3, #11
 800c29a:	f1b3 0220 	subs.w	r2, r3, #32
 800c29e:	da0c      	bge.n	800c2ba <__adddf3+0x16e>
 800c2a0:	320c      	adds	r2, #12
 800c2a2:	dd08      	ble.n	800c2b6 <__adddf3+0x16a>
 800c2a4:	f102 0c14 	add.w	ip, r2, #20
 800c2a8:	f1c2 020c 	rsb	r2, r2, #12
 800c2ac:	fa01 f00c 	lsl.w	r0, r1, ip
 800c2b0:	fa21 f102 	lsr.w	r1, r1, r2
 800c2b4:	e00c      	b.n	800c2d0 <__adddf3+0x184>
 800c2b6:	f102 0214 	add.w	r2, r2, #20
 800c2ba:	bfd8      	it	le
 800c2bc:	f1c2 0c20 	rsble	ip, r2, #32
 800c2c0:	fa01 f102 	lsl.w	r1, r1, r2
 800c2c4:	fa20 fc0c 	lsr.w	ip, r0, ip
 800c2c8:	bfdc      	itt	le
 800c2ca:	ea41 010c 	orrle.w	r1, r1, ip
 800c2ce:	4090      	lslle	r0, r2
 800c2d0:	1ae4      	subs	r4, r4, r3
 800c2d2:	bfa2      	ittt	ge
 800c2d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800c2d8:	4329      	orrge	r1, r5
 800c2da:	bd30      	popge	{r4, r5, pc}
 800c2dc:	ea6f 0404 	mvn.w	r4, r4
 800c2e0:	3c1f      	subs	r4, #31
 800c2e2:	da1c      	bge.n	800c31e <__adddf3+0x1d2>
 800c2e4:	340c      	adds	r4, #12
 800c2e6:	dc0e      	bgt.n	800c306 <__adddf3+0x1ba>
 800c2e8:	f104 0414 	add.w	r4, r4, #20
 800c2ec:	f1c4 0220 	rsb	r2, r4, #32
 800c2f0:	fa20 f004 	lsr.w	r0, r0, r4
 800c2f4:	fa01 f302 	lsl.w	r3, r1, r2
 800c2f8:	ea40 0003 	orr.w	r0, r0, r3
 800c2fc:	fa21 f304 	lsr.w	r3, r1, r4
 800c300:	ea45 0103 	orr.w	r1, r5, r3
 800c304:	bd30      	pop	{r4, r5, pc}
 800c306:	f1c4 040c 	rsb	r4, r4, #12
 800c30a:	f1c4 0220 	rsb	r2, r4, #32
 800c30e:	fa20 f002 	lsr.w	r0, r0, r2
 800c312:	fa01 f304 	lsl.w	r3, r1, r4
 800c316:	ea40 0003 	orr.w	r0, r0, r3
 800c31a:	4629      	mov	r1, r5
 800c31c:	bd30      	pop	{r4, r5, pc}
 800c31e:	fa21 f004 	lsr.w	r0, r1, r4
 800c322:	4629      	mov	r1, r5
 800c324:	bd30      	pop	{r4, r5, pc}
 800c326:	f094 0f00 	teq	r4, #0
 800c32a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800c32e:	bf06      	itte	eq
 800c330:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800c334:	3401      	addeq	r4, #1
 800c336:	3d01      	subne	r5, #1
 800c338:	e74e      	b.n	800c1d8 <__adddf3+0x8c>
 800c33a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800c33e:	bf18      	it	ne
 800c340:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800c344:	d029      	beq.n	800c39a <__adddf3+0x24e>
 800c346:	ea94 0f05 	teq	r4, r5
 800c34a:	bf08      	it	eq
 800c34c:	ea90 0f02 	teqeq	r0, r2
 800c350:	d005      	beq.n	800c35e <__adddf3+0x212>
 800c352:	ea54 0c00 	orrs.w	ip, r4, r0
 800c356:	bf04      	itt	eq
 800c358:	4619      	moveq	r1, r3
 800c35a:	4610      	moveq	r0, r2
 800c35c:	bd30      	pop	{r4, r5, pc}
 800c35e:	ea91 0f03 	teq	r1, r3
 800c362:	bf1e      	ittt	ne
 800c364:	2100      	movne	r1, #0
 800c366:	2000      	movne	r0, #0
 800c368:	bd30      	popne	{r4, r5, pc}
 800c36a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800c36e:	d105      	bne.n	800c37c <__adddf3+0x230>
 800c370:	0040      	lsls	r0, r0, #1
 800c372:	4149      	adcs	r1, r1
 800c374:	bf28      	it	cs
 800c376:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800c37a:	bd30      	pop	{r4, r5, pc}
 800c37c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800c380:	bf3c      	itt	cc
 800c382:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800c386:	bd30      	popcc	{r4, r5, pc}
 800c388:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c38c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800c390:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c394:	f04f 0000 	mov.w	r0, #0
 800c398:	bd30      	pop	{r4, r5, pc}
 800c39a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800c39e:	bf1a      	itte	ne
 800c3a0:	4619      	movne	r1, r3
 800c3a2:	4610      	movne	r0, r2
 800c3a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800c3a8:	bf1c      	itt	ne
 800c3aa:	460b      	movne	r3, r1
 800c3ac:	4602      	movne	r2, r0
 800c3ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c3b2:	bf06      	itte	eq
 800c3b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800c3b8:	ea91 0f03 	teqeq	r1, r3
 800c3bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800c3c0:	bd30      	pop	{r4, r5, pc}
 800c3c2:	bf00      	nop

0800c3c4 <__aeabi_ui2d>:
 800c3c4:	f090 0f00 	teq	r0, #0
 800c3c8:	bf04      	itt	eq
 800c3ca:	2100      	moveq	r1, #0
 800c3cc:	4770      	bxeq	lr
 800c3ce:	b530      	push	{r4, r5, lr}
 800c3d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c3d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c3d8:	f04f 0500 	mov.w	r5, #0
 800c3dc:	f04f 0100 	mov.w	r1, #0
 800c3e0:	e750      	b.n	800c284 <__adddf3+0x138>
 800c3e2:	bf00      	nop

0800c3e4 <__aeabi_i2d>:
 800c3e4:	f090 0f00 	teq	r0, #0
 800c3e8:	bf04      	itt	eq
 800c3ea:	2100      	moveq	r1, #0
 800c3ec:	4770      	bxeq	lr
 800c3ee:	b530      	push	{r4, r5, lr}
 800c3f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c3f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c3f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800c3fc:	bf48      	it	mi
 800c3fe:	4240      	negmi	r0, r0
 800c400:	f04f 0100 	mov.w	r1, #0
 800c404:	e73e      	b.n	800c284 <__adddf3+0x138>
 800c406:	bf00      	nop

0800c408 <__aeabi_f2d>:
 800c408:	0042      	lsls	r2, r0, #1
 800c40a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800c40e:	ea4f 0131 	mov.w	r1, r1, rrx
 800c412:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800c416:	bf1f      	itttt	ne
 800c418:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800c41c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800c420:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800c424:	4770      	bxne	lr
 800c426:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800c42a:	bf08      	it	eq
 800c42c:	4770      	bxeq	lr
 800c42e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 800c432:	bf04      	itt	eq
 800c434:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 800c438:	4770      	bxeq	lr
 800c43a:	b530      	push	{r4, r5, lr}
 800c43c:	f44f 7460 	mov.w	r4, #896	; 0x380
 800c440:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800c444:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c448:	e71c      	b.n	800c284 <__adddf3+0x138>
 800c44a:	bf00      	nop

0800c44c <__aeabi_ul2d>:
 800c44c:	ea50 0201 	orrs.w	r2, r0, r1
 800c450:	bf08      	it	eq
 800c452:	4770      	bxeq	lr
 800c454:	b530      	push	{r4, r5, lr}
 800c456:	f04f 0500 	mov.w	r5, #0
 800c45a:	e00a      	b.n	800c472 <__aeabi_l2d+0x16>

0800c45c <__aeabi_l2d>:
 800c45c:	ea50 0201 	orrs.w	r2, r0, r1
 800c460:	bf08      	it	eq
 800c462:	4770      	bxeq	lr
 800c464:	b530      	push	{r4, r5, lr}
 800c466:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800c46a:	d502      	bpl.n	800c472 <__aeabi_l2d+0x16>
 800c46c:	4240      	negs	r0, r0
 800c46e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c472:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c476:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800c47a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800c47e:	f43f aed8 	beq.w	800c232 <__adddf3+0xe6>
 800c482:	f04f 0203 	mov.w	r2, #3
 800c486:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800c48a:	bf18      	it	ne
 800c48c:	3203      	addne	r2, #3
 800c48e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800c492:	bf18      	it	ne
 800c494:	3203      	addne	r2, #3
 800c496:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800c49a:	f1c2 0320 	rsb	r3, r2, #32
 800c49e:	fa00 fc03 	lsl.w	ip, r0, r3
 800c4a2:	fa20 f002 	lsr.w	r0, r0, r2
 800c4a6:	fa01 fe03 	lsl.w	lr, r1, r3
 800c4aa:	ea40 000e 	orr.w	r0, r0, lr
 800c4ae:	fa21 f102 	lsr.w	r1, r1, r2
 800c4b2:	4414      	add	r4, r2
 800c4b4:	e6bd      	b.n	800c232 <__adddf3+0xe6>
 800c4b6:	bf00      	nop
	...

0800c4c0 <__aeabi_dmul>:
 800c4c0:	b570      	push	{r4, r5, r6, lr}
 800c4c2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c4c6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c4ca:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c4ce:	bf1d      	ittte	ne
 800c4d0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c4d4:	ea94 0f0c 	teqne	r4, ip
 800c4d8:	ea95 0f0c 	teqne	r5, ip
 800c4dc:	f000 f8de 	bleq	800c69c <__aeabi_dmul+0x1dc>
 800c4e0:	442c      	add	r4, r5
 800c4e2:	ea81 0603 	eor.w	r6, r1, r3
 800c4e6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800c4ea:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800c4ee:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800c4f2:	bf18      	it	ne
 800c4f4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800c4f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c4fc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c500:	d038      	beq.n	800c574 <__aeabi_dmul+0xb4>
 800c502:	fba0 ce02 	umull	ip, lr, r0, r2
 800c506:	f04f 0500 	mov.w	r5, #0
 800c50a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800c50e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800c512:	fbe0 e503 	umlal	lr, r5, r0, r3
 800c516:	f04f 0600 	mov.w	r6, #0
 800c51a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800c51e:	f09c 0f00 	teq	ip, #0
 800c522:	bf18      	it	ne
 800c524:	f04e 0e01 	orrne.w	lr, lr, #1
 800c528:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800c52c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800c530:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800c534:	d204      	bcs.n	800c540 <__aeabi_dmul+0x80>
 800c536:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800c53a:	416d      	adcs	r5, r5
 800c53c:	eb46 0606 	adc.w	r6, r6, r6
 800c540:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800c544:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800c548:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800c54c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800c550:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800c554:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c558:	bf88      	it	hi
 800c55a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c55e:	d81e      	bhi.n	800c59e <__aeabi_dmul+0xde>
 800c560:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800c564:	bf08      	it	eq
 800c566:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800c56a:	f150 0000 	adcs.w	r0, r0, #0
 800c56e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c572:	bd70      	pop	{r4, r5, r6, pc}
 800c574:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800c578:	ea46 0101 	orr.w	r1, r6, r1
 800c57c:	ea40 0002 	orr.w	r0, r0, r2
 800c580:	ea81 0103 	eor.w	r1, r1, r3
 800c584:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800c588:	bfc2      	ittt	gt
 800c58a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c58e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c592:	bd70      	popgt	{r4, r5, r6, pc}
 800c594:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c598:	f04f 0e00 	mov.w	lr, #0
 800c59c:	3c01      	subs	r4, #1
 800c59e:	f300 80ab 	bgt.w	800c6f8 <__aeabi_dmul+0x238>
 800c5a2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800c5a6:	bfde      	ittt	le
 800c5a8:	2000      	movle	r0, #0
 800c5aa:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800c5ae:	bd70      	pople	{r4, r5, r6, pc}
 800c5b0:	f1c4 0400 	rsb	r4, r4, #0
 800c5b4:	3c20      	subs	r4, #32
 800c5b6:	da35      	bge.n	800c624 <__aeabi_dmul+0x164>
 800c5b8:	340c      	adds	r4, #12
 800c5ba:	dc1b      	bgt.n	800c5f4 <__aeabi_dmul+0x134>
 800c5bc:	f104 0414 	add.w	r4, r4, #20
 800c5c0:	f1c4 0520 	rsb	r5, r4, #32
 800c5c4:	fa00 f305 	lsl.w	r3, r0, r5
 800c5c8:	fa20 f004 	lsr.w	r0, r0, r4
 800c5cc:	fa01 f205 	lsl.w	r2, r1, r5
 800c5d0:	ea40 0002 	orr.w	r0, r0, r2
 800c5d4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800c5d8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c5dc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c5e0:	fa21 f604 	lsr.w	r6, r1, r4
 800c5e4:	eb42 0106 	adc.w	r1, r2, r6
 800c5e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c5ec:	bf08      	it	eq
 800c5ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c5f2:	bd70      	pop	{r4, r5, r6, pc}
 800c5f4:	f1c4 040c 	rsb	r4, r4, #12
 800c5f8:	f1c4 0520 	rsb	r5, r4, #32
 800c5fc:	fa00 f304 	lsl.w	r3, r0, r4
 800c600:	fa20 f005 	lsr.w	r0, r0, r5
 800c604:	fa01 f204 	lsl.w	r2, r1, r4
 800c608:	ea40 0002 	orr.w	r0, r0, r2
 800c60c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c610:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c614:	f141 0100 	adc.w	r1, r1, #0
 800c618:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c61c:	bf08      	it	eq
 800c61e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c622:	bd70      	pop	{r4, r5, r6, pc}
 800c624:	f1c4 0520 	rsb	r5, r4, #32
 800c628:	fa00 f205 	lsl.w	r2, r0, r5
 800c62c:	ea4e 0e02 	orr.w	lr, lr, r2
 800c630:	fa20 f304 	lsr.w	r3, r0, r4
 800c634:	fa01 f205 	lsl.w	r2, r1, r5
 800c638:	ea43 0302 	orr.w	r3, r3, r2
 800c63c:	fa21 f004 	lsr.w	r0, r1, r4
 800c640:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c644:	fa21 f204 	lsr.w	r2, r1, r4
 800c648:	ea20 0002 	bic.w	r0, r0, r2
 800c64c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800c650:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c654:	bf08      	it	eq
 800c656:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c65a:	bd70      	pop	{r4, r5, r6, pc}
 800c65c:	f094 0f00 	teq	r4, #0
 800c660:	d10f      	bne.n	800c682 <__aeabi_dmul+0x1c2>
 800c662:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800c666:	0040      	lsls	r0, r0, #1
 800c668:	eb41 0101 	adc.w	r1, r1, r1
 800c66c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c670:	bf08      	it	eq
 800c672:	3c01      	subeq	r4, #1
 800c674:	d0f7      	beq.n	800c666 <__aeabi_dmul+0x1a6>
 800c676:	ea41 0106 	orr.w	r1, r1, r6
 800c67a:	f095 0f00 	teq	r5, #0
 800c67e:	bf18      	it	ne
 800c680:	4770      	bxne	lr
 800c682:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800c686:	0052      	lsls	r2, r2, #1
 800c688:	eb43 0303 	adc.w	r3, r3, r3
 800c68c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800c690:	bf08      	it	eq
 800c692:	3d01      	subeq	r5, #1
 800c694:	d0f7      	beq.n	800c686 <__aeabi_dmul+0x1c6>
 800c696:	ea43 0306 	orr.w	r3, r3, r6
 800c69a:	4770      	bx	lr
 800c69c:	ea94 0f0c 	teq	r4, ip
 800c6a0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c6a4:	bf18      	it	ne
 800c6a6:	ea95 0f0c 	teqne	r5, ip
 800c6aa:	d00c      	beq.n	800c6c6 <__aeabi_dmul+0x206>
 800c6ac:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c6b0:	bf18      	it	ne
 800c6b2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c6b6:	d1d1      	bne.n	800c65c <__aeabi_dmul+0x19c>
 800c6b8:	ea81 0103 	eor.w	r1, r1, r3
 800c6bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c6c0:	f04f 0000 	mov.w	r0, #0
 800c6c4:	bd70      	pop	{r4, r5, r6, pc}
 800c6c6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c6ca:	bf06      	itte	eq
 800c6cc:	4610      	moveq	r0, r2
 800c6ce:	4619      	moveq	r1, r3
 800c6d0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c6d4:	d019      	beq.n	800c70a <__aeabi_dmul+0x24a>
 800c6d6:	ea94 0f0c 	teq	r4, ip
 800c6da:	d102      	bne.n	800c6e2 <__aeabi_dmul+0x222>
 800c6dc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800c6e0:	d113      	bne.n	800c70a <__aeabi_dmul+0x24a>
 800c6e2:	ea95 0f0c 	teq	r5, ip
 800c6e6:	d105      	bne.n	800c6f4 <__aeabi_dmul+0x234>
 800c6e8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800c6ec:	bf1c      	itt	ne
 800c6ee:	4610      	movne	r0, r2
 800c6f0:	4619      	movne	r1, r3
 800c6f2:	d10a      	bne.n	800c70a <__aeabi_dmul+0x24a>
 800c6f4:	ea81 0103 	eor.w	r1, r1, r3
 800c6f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c6fc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c700:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c704:	f04f 0000 	mov.w	r0, #0
 800c708:	bd70      	pop	{r4, r5, r6, pc}
 800c70a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c70e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800c712:	bd70      	pop	{r4, r5, r6, pc}

0800c714 <__aeabi_ddiv>:
 800c714:	b570      	push	{r4, r5, r6, lr}
 800c716:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c71a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c71e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c722:	bf1d      	ittte	ne
 800c724:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c728:	ea94 0f0c 	teqne	r4, ip
 800c72c:	ea95 0f0c 	teqne	r5, ip
 800c730:	f000 f8a7 	bleq	800c882 <__aeabi_ddiv+0x16e>
 800c734:	eba4 0405 	sub.w	r4, r4, r5
 800c738:	ea81 0e03 	eor.w	lr, r1, r3
 800c73c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c740:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c744:	f000 8088 	beq.w	800c858 <__aeabi_ddiv+0x144>
 800c748:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c74c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c750:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800c754:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c758:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c75c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800c760:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800c764:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800c768:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800c76c:	429d      	cmp	r5, r3
 800c76e:	bf08      	it	eq
 800c770:	4296      	cmpeq	r6, r2
 800c772:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800c776:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800c77a:	d202      	bcs.n	800c782 <__aeabi_ddiv+0x6e>
 800c77c:	085b      	lsrs	r3, r3, #1
 800c77e:	ea4f 0232 	mov.w	r2, r2, rrx
 800c782:	1ab6      	subs	r6, r6, r2
 800c784:	eb65 0503 	sbc.w	r5, r5, r3
 800c788:	085b      	lsrs	r3, r3, #1
 800c78a:	ea4f 0232 	mov.w	r2, r2, rrx
 800c78e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800c792:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800c796:	ebb6 0e02 	subs.w	lr, r6, r2
 800c79a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c79e:	bf22      	ittt	cs
 800c7a0:	1ab6      	subcs	r6, r6, r2
 800c7a2:	4675      	movcs	r5, lr
 800c7a4:	ea40 000c 	orrcs.w	r0, r0, ip
 800c7a8:	085b      	lsrs	r3, r3, #1
 800c7aa:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7ae:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7b6:	bf22      	ittt	cs
 800c7b8:	1ab6      	subcs	r6, r6, r2
 800c7ba:	4675      	movcs	r5, lr
 800c7bc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800c7c0:	085b      	lsrs	r3, r3, #1
 800c7c2:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7c6:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7ce:	bf22      	ittt	cs
 800c7d0:	1ab6      	subcs	r6, r6, r2
 800c7d2:	4675      	movcs	r5, lr
 800c7d4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800c7d8:	085b      	lsrs	r3, r3, #1
 800c7da:	ea4f 0232 	mov.w	r2, r2, rrx
 800c7de:	ebb6 0e02 	subs.w	lr, r6, r2
 800c7e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c7e6:	bf22      	ittt	cs
 800c7e8:	1ab6      	subcs	r6, r6, r2
 800c7ea:	4675      	movcs	r5, lr
 800c7ec:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800c7f0:	ea55 0e06 	orrs.w	lr, r5, r6
 800c7f4:	d018      	beq.n	800c828 <__aeabi_ddiv+0x114>
 800c7f6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800c7fa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800c7fe:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800c802:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800c806:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800c80a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800c80e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800c812:	d1c0      	bne.n	800c796 <__aeabi_ddiv+0x82>
 800c814:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c818:	d10b      	bne.n	800c832 <__aeabi_ddiv+0x11e>
 800c81a:	ea41 0100 	orr.w	r1, r1, r0
 800c81e:	f04f 0000 	mov.w	r0, #0
 800c822:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c826:	e7b6      	b.n	800c796 <__aeabi_ddiv+0x82>
 800c828:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c82c:	bf04      	itt	eq
 800c82e:	4301      	orreq	r1, r0
 800c830:	2000      	moveq	r0, #0
 800c832:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c836:	bf88      	it	hi
 800c838:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c83c:	f63f aeaf 	bhi.w	800c59e <__aeabi_dmul+0xde>
 800c840:	ebb5 0c03 	subs.w	ip, r5, r3
 800c844:	bf04      	itt	eq
 800c846:	ebb6 0c02 	subseq.w	ip, r6, r2
 800c84a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c84e:	f150 0000 	adcs.w	r0, r0, #0
 800c852:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c856:	bd70      	pop	{r4, r5, r6, pc}
 800c858:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800c85c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800c860:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800c864:	bfc2      	ittt	gt
 800c866:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c86a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c86e:	bd70      	popgt	{r4, r5, r6, pc}
 800c870:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c874:	f04f 0e00 	mov.w	lr, #0
 800c878:	3c01      	subs	r4, #1
 800c87a:	e690      	b.n	800c59e <__aeabi_dmul+0xde>
 800c87c:	ea45 0e06 	orr.w	lr, r5, r6
 800c880:	e68d      	b.n	800c59e <__aeabi_dmul+0xde>
 800c882:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c886:	ea94 0f0c 	teq	r4, ip
 800c88a:	bf08      	it	eq
 800c88c:	ea95 0f0c 	teqeq	r5, ip
 800c890:	f43f af3b 	beq.w	800c70a <__aeabi_dmul+0x24a>
 800c894:	ea94 0f0c 	teq	r4, ip
 800c898:	d10a      	bne.n	800c8b0 <__aeabi_ddiv+0x19c>
 800c89a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c89e:	f47f af34 	bne.w	800c70a <__aeabi_dmul+0x24a>
 800c8a2:	ea95 0f0c 	teq	r5, ip
 800c8a6:	f47f af25 	bne.w	800c6f4 <__aeabi_dmul+0x234>
 800c8aa:	4610      	mov	r0, r2
 800c8ac:	4619      	mov	r1, r3
 800c8ae:	e72c      	b.n	800c70a <__aeabi_dmul+0x24a>
 800c8b0:	ea95 0f0c 	teq	r5, ip
 800c8b4:	d106      	bne.n	800c8c4 <__aeabi_ddiv+0x1b0>
 800c8b6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c8ba:	f43f aefd 	beq.w	800c6b8 <__aeabi_dmul+0x1f8>
 800c8be:	4610      	mov	r0, r2
 800c8c0:	4619      	mov	r1, r3
 800c8c2:	e722      	b.n	800c70a <__aeabi_dmul+0x24a>
 800c8c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c8c8:	bf18      	it	ne
 800c8ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c8ce:	f47f aec5 	bne.w	800c65c <__aeabi_dmul+0x19c>
 800c8d2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800c8d6:	f47f af0d 	bne.w	800c6f4 <__aeabi_dmul+0x234>
 800c8da:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800c8de:	f47f aeeb 	bne.w	800c6b8 <__aeabi_dmul+0x1f8>
 800c8e2:	e712      	b.n	800c70a <__aeabi_dmul+0x24a>
	...

0800c8f0 <__gedf2>:
 800c8f0:	f04f 3cff 	mov.w	ip, #4294967295
 800c8f4:	e006      	b.n	800c904 <__cmpdf2+0x4>
 800c8f6:	bf00      	nop

0800c8f8 <__ledf2>:
 800c8f8:	f04f 0c01 	mov.w	ip, #1
 800c8fc:	e002      	b.n	800c904 <__cmpdf2+0x4>
 800c8fe:	bf00      	nop

0800c900 <__cmpdf2>:
 800c900:	f04f 0c01 	mov.w	ip, #1
 800c904:	f84d cd04 	str.w	ip, [sp, #-4]!
 800c908:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c90c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c910:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c914:	bf18      	it	ne
 800c916:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800c91a:	d01b      	beq.n	800c954 <__cmpdf2+0x54>
 800c91c:	b001      	add	sp, #4
 800c91e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800c922:	bf0c      	ite	eq
 800c924:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800c928:	ea91 0f03 	teqne	r1, r3
 800c92c:	bf02      	ittt	eq
 800c92e:	ea90 0f02 	teqeq	r0, r2
 800c932:	2000      	moveq	r0, #0
 800c934:	4770      	bxeq	lr
 800c936:	f110 0f00 	cmn.w	r0, #0
 800c93a:	ea91 0f03 	teq	r1, r3
 800c93e:	bf58      	it	pl
 800c940:	4299      	cmppl	r1, r3
 800c942:	bf08      	it	eq
 800c944:	4290      	cmpeq	r0, r2
 800c946:	bf2c      	ite	cs
 800c948:	17d8      	asrcs	r0, r3, #31
 800c94a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800c94e:	f040 0001 	orr.w	r0, r0, #1
 800c952:	4770      	bx	lr
 800c954:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c958:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c95c:	d102      	bne.n	800c964 <__cmpdf2+0x64>
 800c95e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800c962:	d107      	bne.n	800c974 <__cmpdf2+0x74>
 800c964:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c968:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c96c:	d1d6      	bne.n	800c91c <__cmpdf2+0x1c>
 800c96e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800c972:	d0d3      	beq.n	800c91c <__cmpdf2+0x1c>
 800c974:	f85d 0b04 	ldr.w	r0, [sp], #4
 800c978:	4770      	bx	lr
 800c97a:	bf00      	nop

0800c97c <__aeabi_cdrcmple>:
 800c97c:	4684      	mov	ip, r0
 800c97e:	4610      	mov	r0, r2
 800c980:	4662      	mov	r2, ip
 800c982:	468c      	mov	ip, r1
 800c984:	4619      	mov	r1, r3
 800c986:	4663      	mov	r3, ip
 800c988:	e000      	b.n	800c98c <__aeabi_cdcmpeq>
 800c98a:	bf00      	nop

0800c98c <__aeabi_cdcmpeq>:
 800c98c:	b501      	push	{r0, lr}
 800c98e:	f7ff ffb7 	bl	800c900 <__cmpdf2>
 800c992:	2800      	cmp	r0, #0
 800c994:	bf48      	it	mi
 800c996:	f110 0f00 	cmnmi.w	r0, #0
 800c99a:	bd01      	pop	{r0, pc}

0800c99c <__aeabi_dcmpeq>:
 800c99c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c9a0:	f7ff fff4 	bl	800c98c <__aeabi_cdcmpeq>
 800c9a4:	bf0c      	ite	eq
 800c9a6:	2001      	moveq	r0, #1
 800c9a8:	2000      	movne	r0, #0
 800c9aa:	f85d fb08 	ldr.w	pc, [sp], #8
 800c9ae:	bf00      	nop

0800c9b0 <__aeabi_dcmplt>:
 800c9b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c9b4:	f7ff ffea 	bl	800c98c <__aeabi_cdcmpeq>
 800c9b8:	bf34      	ite	cc
 800c9ba:	2001      	movcc	r0, #1
 800c9bc:	2000      	movcs	r0, #0
 800c9be:	f85d fb08 	ldr.w	pc, [sp], #8
 800c9c2:	bf00      	nop

0800c9c4 <__aeabi_dcmple>:
 800c9c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c9c8:	f7ff ffe0 	bl	800c98c <__aeabi_cdcmpeq>
 800c9cc:	bf94      	ite	ls
 800c9ce:	2001      	movls	r0, #1
 800c9d0:	2000      	movhi	r0, #0
 800c9d2:	f85d fb08 	ldr.w	pc, [sp], #8
 800c9d6:	bf00      	nop

0800c9d8 <__aeabi_dcmpge>:
 800c9d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c9dc:	f7ff ffce 	bl	800c97c <__aeabi_cdrcmple>
 800c9e0:	bf94      	ite	ls
 800c9e2:	2001      	movls	r0, #1
 800c9e4:	2000      	movhi	r0, #0
 800c9e6:	f85d fb08 	ldr.w	pc, [sp], #8
 800c9ea:	bf00      	nop

0800c9ec <__aeabi_dcmpgt>:
 800c9ec:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c9f0:	f7ff ffc4 	bl	800c97c <__aeabi_cdrcmple>
 800c9f4:	bf34      	ite	cc
 800c9f6:	2001      	movcc	r0, #1
 800c9f8:	2000      	movcs	r0, #0
 800c9fa:	f85d fb08 	ldr.w	pc, [sp], #8
 800c9fe:	bf00      	nop

0800ca00 <__aeabi_dcmpun>:
 800ca00:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ca04:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ca08:	d102      	bne.n	800ca10 <__aeabi_dcmpun+0x10>
 800ca0a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800ca0e:	d10a      	bne.n	800ca26 <__aeabi_dcmpun+0x26>
 800ca10:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ca14:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ca18:	d102      	bne.n	800ca20 <__aeabi_dcmpun+0x20>
 800ca1a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800ca1e:	d102      	bne.n	800ca26 <__aeabi_dcmpun+0x26>
 800ca20:	f04f 0000 	mov.w	r0, #0
 800ca24:	4770      	bx	lr
 800ca26:	f04f 0001 	mov.w	r0, #1
 800ca2a:	4770      	bx	lr
 800ca2c:	0000      	movs	r0, r0
	...

0800ca30 <__aeabi_d2iz>:
 800ca30:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800ca34:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800ca38:	d215      	bcs.n	800ca66 <__aeabi_d2iz+0x36>
 800ca3a:	d511      	bpl.n	800ca60 <__aeabi_d2iz+0x30>
 800ca3c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800ca40:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800ca44:	d912      	bls.n	800ca6c <__aeabi_d2iz+0x3c>
 800ca46:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800ca4a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800ca4e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800ca52:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800ca56:	fa23 f002 	lsr.w	r0, r3, r2
 800ca5a:	bf18      	it	ne
 800ca5c:	4240      	negne	r0, r0
 800ca5e:	4770      	bx	lr
 800ca60:	f04f 0000 	mov.w	r0, #0
 800ca64:	4770      	bx	lr
 800ca66:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800ca6a:	d105      	bne.n	800ca78 <__aeabi_d2iz+0x48>
 800ca6c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800ca70:	bf08      	it	eq
 800ca72:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800ca76:	4770      	bx	lr
 800ca78:	f04f 0000 	mov.w	r0, #0
 800ca7c:	4770      	bx	lr
 800ca7e:	bf00      	nop

0800ca80 <__aeabi_d2f>:
 800ca80:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800ca84:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 800ca88:	bf24      	itt	cs
 800ca8a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 800ca8e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 800ca92:	d90d      	bls.n	800cab0 <__aeabi_d2f+0x30>
 800ca94:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800ca98:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 800ca9c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 800caa0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 800caa4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 800caa8:	bf08      	it	eq
 800caaa:	f020 0001 	biceq.w	r0, r0, #1
 800caae:	4770      	bx	lr
 800cab0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 800cab4:	d121      	bne.n	800cafa <__aeabi_d2f+0x7a>
 800cab6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 800caba:	bfbc      	itt	lt
 800cabc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 800cac0:	4770      	bxlt	lr
 800cac2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800cac6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 800caca:	f1c2 0218 	rsb	r2, r2, #24
 800cace:	f1c2 0c20 	rsb	ip, r2, #32
 800cad2:	fa10 f30c 	lsls.w	r3, r0, ip
 800cad6:	fa20 f002 	lsr.w	r0, r0, r2
 800cada:	bf18      	it	ne
 800cadc:	f040 0001 	orrne.w	r0, r0, #1
 800cae0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800cae4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 800cae8:	fa03 fc0c 	lsl.w	ip, r3, ip
 800caec:	ea40 000c 	orr.w	r0, r0, ip
 800caf0:	fa23 f302 	lsr.w	r3, r3, r2
 800caf4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800caf8:	e7cc      	b.n	800ca94 <__aeabi_d2f+0x14>
 800cafa:	ea7f 5362 	mvns.w	r3, r2, asr #21
 800cafe:	d107      	bne.n	800cb10 <__aeabi_d2f+0x90>
 800cb00:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800cb04:	bf1e      	ittt	ne
 800cb06:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 800cb0a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 800cb0e:	4770      	bxne	lr
 800cb10:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 800cb14:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 800cb18:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800cb1c:	4770      	bx	lr
 800cb1e:	bf00      	nop

0800cb20 <memcpy>:
 800cb20:	4684      	mov	ip, r0
 800cb22:	ea41 0300 	orr.w	r3, r1, r0
 800cb26:	f013 0303 	ands.w	r3, r3, #3
 800cb2a:	d16d      	bne.n	800cc08 <memcpy+0xe8>
 800cb2c:	3a40      	subs	r2, #64	; 0x40
 800cb2e:	d341      	bcc.n	800cbb4 <memcpy+0x94>
 800cb30:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb34:	f840 3b04 	str.w	r3, [r0], #4
 800cb38:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb3c:	f840 3b04 	str.w	r3, [r0], #4
 800cb40:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb44:	f840 3b04 	str.w	r3, [r0], #4
 800cb48:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb4c:	f840 3b04 	str.w	r3, [r0], #4
 800cb50:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb54:	f840 3b04 	str.w	r3, [r0], #4
 800cb58:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb5c:	f840 3b04 	str.w	r3, [r0], #4
 800cb60:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb64:	f840 3b04 	str.w	r3, [r0], #4
 800cb68:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb6c:	f840 3b04 	str.w	r3, [r0], #4
 800cb70:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb74:	f840 3b04 	str.w	r3, [r0], #4
 800cb78:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb7c:	f840 3b04 	str.w	r3, [r0], #4
 800cb80:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb84:	f840 3b04 	str.w	r3, [r0], #4
 800cb88:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb8c:	f840 3b04 	str.w	r3, [r0], #4
 800cb90:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb94:	f840 3b04 	str.w	r3, [r0], #4
 800cb98:	f851 3b04 	ldr.w	r3, [r1], #4
 800cb9c:	f840 3b04 	str.w	r3, [r0], #4
 800cba0:	f851 3b04 	ldr.w	r3, [r1], #4
 800cba4:	f840 3b04 	str.w	r3, [r0], #4
 800cba8:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbac:	f840 3b04 	str.w	r3, [r0], #4
 800cbb0:	3a40      	subs	r2, #64	; 0x40
 800cbb2:	d2bd      	bcs.n	800cb30 <memcpy+0x10>
 800cbb4:	3230      	adds	r2, #48	; 0x30
 800cbb6:	d311      	bcc.n	800cbdc <memcpy+0xbc>
 800cbb8:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbbc:	f840 3b04 	str.w	r3, [r0], #4
 800cbc0:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbc4:	f840 3b04 	str.w	r3, [r0], #4
 800cbc8:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbcc:	f840 3b04 	str.w	r3, [r0], #4
 800cbd0:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbd4:	f840 3b04 	str.w	r3, [r0], #4
 800cbd8:	3a10      	subs	r2, #16
 800cbda:	d2ed      	bcs.n	800cbb8 <memcpy+0x98>
 800cbdc:	320c      	adds	r2, #12
 800cbde:	d305      	bcc.n	800cbec <memcpy+0xcc>
 800cbe0:	f851 3b04 	ldr.w	r3, [r1], #4
 800cbe4:	f840 3b04 	str.w	r3, [r0], #4
 800cbe8:	3a04      	subs	r2, #4
 800cbea:	d2f9      	bcs.n	800cbe0 <memcpy+0xc0>
 800cbec:	3204      	adds	r2, #4
 800cbee:	d008      	beq.n	800cc02 <memcpy+0xe2>
 800cbf0:	07d2      	lsls	r2, r2, #31
 800cbf2:	bf1c      	itt	ne
 800cbf4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800cbf8:	f800 3b01 	strbne.w	r3, [r0], #1
 800cbfc:	d301      	bcc.n	800cc02 <memcpy+0xe2>
 800cbfe:	880b      	ldrh	r3, [r1, #0]
 800cc00:	8003      	strh	r3, [r0, #0]
 800cc02:	4660      	mov	r0, ip
 800cc04:	4770      	bx	lr
 800cc06:	bf00      	nop
 800cc08:	2a08      	cmp	r2, #8
 800cc0a:	d313      	bcc.n	800cc34 <memcpy+0x114>
 800cc0c:	078b      	lsls	r3, r1, #30
 800cc0e:	d08d      	beq.n	800cb2c <memcpy+0xc>
 800cc10:	f010 0303 	ands.w	r3, r0, #3
 800cc14:	d08a      	beq.n	800cb2c <memcpy+0xc>
 800cc16:	f1c3 0304 	rsb	r3, r3, #4
 800cc1a:	1ad2      	subs	r2, r2, r3
 800cc1c:	07db      	lsls	r3, r3, #31
 800cc1e:	bf1c      	itt	ne
 800cc20:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800cc24:	f800 3b01 	strbne.w	r3, [r0], #1
 800cc28:	d380      	bcc.n	800cb2c <memcpy+0xc>
 800cc2a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800cc2e:	f820 3b02 	strh.w	r3, [r0], #2
 800cc32:	e77b      	b.n	800cb2c <memcpy+0xc>
 800cc34:	3a04      	subs	r2, #4
 800cc36:	d3d9      	bcc.n	800cbec <memcpy+0xcc>
 800cc38:	3a01      	subs	r2, #1
 800cc3a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800cc3e:	f800 3b01 	strb.w	r3, [r0], #1
 800cc42:	d2f9      	bcs.n	800cc38 <memcpy+0x118>
 800cc44:	780b      	ldrb	r3, [r1, #0]
 800cc46:	7003      	strb	r3, [r0, #0]
 800cc48:	784b      	ldrb	r3, [r1, #1]
 800cc4a:	7043      	strb	r3, [r0, #1]
 800cc4c:	788b      	ldrb	r3, [r1, #2]
 800cc4e:	7083      	strb	r3, [r0, #2]
 800cc50:	4660      	mov	r0, ip
 800cc52:	4770      	bx	lr
	...
 800cc60:	eba2 0003 	sub.w	r0, r2, r3
 800cc64:	4770      	bx	lr
 800cc66:	bf00      	nop

0800cc68 <strcmp>:
 800cc68:	7802      	ldrb	r2, [r0, #0]
 800cc6a:	780b      	ldrb	r3, [r1, #0]
 800cc6c:	2a01      	cmp	r2, #1
 800cc6e:	bf28      	it	cs
 800cc70:	429a      	cmpcs	r2, r3
 800cc72:	d1f5      	bne.n	800cc60 <memcpy+0x140>
 800cc74:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 800cc78:	ea40 0401 	orr.w	r4, r0, r1
 800cc7c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 800cc80:	f06f 0c00 	mvn.w	ip, #0
 800cc84:	ea4f 7244 	mov.w	r2, r4, lsl #29
 800cc88:	b312      	cbz	r2, 800ccd0 <strcmp+0x68>
 800cc8a:	ea80 0401 	eor.w	r4, r0, r1
 800cc8e:	f014 0f07 	tst.w	r4, #7
 800cc92:	d16a      	bne.n	800cd6a <strcmp+0x102>
 800cc94:	f000 0407 	and.w	r4, r0, #7
 800cc98:	f020 0007 	bic.w	r0, r0, #7
 800cc9c:	f004 0503 	and.w	r5, r4, #3
 800cca0:	f021 0107 	bic.w	r1, r1, #7
 800cca4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800cca8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800ccac:	f014 0f04 	tst.w	r4, #4
 800ccb0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 800ccb4:	fa0c f405 	lsl.w	r4, ip, r5
 800ccb8:	ea62 0204 	orn	r2, r2, r4
 800ccbc:	ea66 0604 	orn	r6, r6, r4
 800ccc0:	d00a      	beq.n	800ccd8 <strcmp+0x70>
 800ccc2:	ea63 0304 	orn	r3, r3, r4
 800ccc6:	4662      	mov	r2, ip
 800ccc8:	ea67 0704 	orn	r7, r7, r4
 800cccc:	4666      	mov	r6, ip
 800ccce:	e003      	b.n	800ccd8 <strcmp+0x70>
 800ccd0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800ccd4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 800ccd8:	fa82 f54c 	uadd8	r5, r2, ip
 800ccdc:	ea82 0406 	eor.w	r4, r2, r6
 800cce0:	faa4 f48c 	sel	r4, r4, ip
 800cce4:	bb6c      	cbnz	r4, 800cd42 <strcmp+0xda>
 800cce6:	fa83 f54c 	uadd8	r5, r3, ip
 800ccea:	ea83 0507 	eor.w	r5, r3, r7
 800ccee:	faa5 f58c 	sel	r5, r5, ip
 800ccf2:	b995      	cbnz	r5, 800cd1a <strcmp+0xb2>
 800ccf4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 800ccf8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800ccfc:	fa82 f54c 	uadd8	r5, r2, ip
 800cd00:	ea82 0406 	eor.w	r4, r2, r6
 800cd04:	faa4 f48c 	sel	r4, r4, ip
 800cd08:	fa83 f54c 	uadd8	r5, r3, ip
 800cd0c:	ea83 0507 	eor.w	r5, r3, r7
 800cd10:	faa5 f58c 	sel	r5, r5, ip
 800cd14:	4325      	orrs	r5, r4
 800cd16:	d0db      	beq.n	800ccd0 <strcmp+0x68>
 800cd18:	b99c      	cbnz	r4, 800cd42 <strcmp+0xda>
 800cd1a:	ba2d      	rev	r5, r5
 800cd1c:	fab5 f485 	clz	r4, r5
 800cd20:	f024 0407 	bic.w	r4, r4, #7
 800cd24:	fa27 f104 	lsr.w	r1, r7, r4
 800cd28:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800cd2c:	fa23 f304 	lsr.w	r3, r3, r4
 800cd30:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 800cd34:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800cd38:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800cd3c:	eba0 0001 	sub.w	r0, r0, r1
 800cd40:	4770      	bx	lr
 800cd42:	ba24      	rev	r4, r4
 800cd44:	fab4 f484 	clz	r4, r4
 800cd48:	f024 0407 	bic.w	r4, r4, #7
 800cd4c:	fa26 f104 	lsr.w	r1, r6, r4
 800cd50:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800cd54:	fa22 f204 	lsr.w	r2, r2, r4
 800cd58:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800cd5c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800cd60:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800cd64:	eba0 0001 	sub.w	r0, r0, r1
 800cd68:	4770      	bx	lr
 800cd6a:	f014 0f03 	tst.w	r4, #3
 800cd6e:	d13c      	bne.n	800cdea <strcmp+0x182>
 800cd70:	f010 0403 	ands.w	r4, r0, #3
 800cd74:	d128      	bne.n	800cdc8 <strcmp+0x160>
 800cd76:	f850 2b08 	ldr.w	r2, [r0], #8
 800cd7a:	f851 3b08 	ldr.w	r3, [r1], #8
 800cd7e:	fa82 f54c 	uadd8	r5, r2, ip
 800cd82:	ea82 0503 	eor.w	r5, r2, r3
 800cd86:	faa5 f58c 	sel	r5, r5, ip
 800cd8a:	b95d      	cbnz	r5, 800cda4 <strcmp+0x13c>
 800cd8c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800cd90:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800cd94:	fa82 f54c 	uadd8	r5, r2, ip
 800cd98:	ea82 0503 	eor.w	r5, r2, r3
 800cd9c:	faa5 f58c 	sel	r5, r5, ip
 800cda0:	2d00      	cmp	r5, #0
 800cda2:	d0e8      	beq.n	800cd76 <strcmp+0x10e>
 800cda4:	ba2d      	rev	r5, r5
 800cda6:	fab5 f485 	clz	r4, r5
 800cdaa:	f024 0407 	bic.w	r4, r4, #7
 800cdae:	fa23 f104 	lsr.w	r1, r3, r4
 800cdb2:	fa22 f204 	lsr.w	r2, r2, r4
 800cdb6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800cdba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800cdbe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800cdc2:	eba0 0001 	sub.w	r0, r0, r1
 800cdc6:	4770      	bx	lr
 800cdc8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800cdcc:	f020 0003 	bic.w	r0, r0, #3
 800cdd0:	f850 2b08 	ldr.w	r2, [r0], #8
 800cdd4:	f021 0103 	bic.w	r1, r1, #3
 800cdd8:	f851 3b08 	ldr.w	r3, [r1], #8
 800cddc:	fa0c f404 	lsl.w	r4, ip, r4
 800cde0:	ea62 0204 	orn	r2, r2, r4
 800cde4:	ea63 0304 	orn	r3, r3, r4
 800cde8:	e7c9      	b.n	800cd7e <strcmp+0x116>
 800cdea:	f010 0403 	ands.w	r4, r0, #3
 800cdee:	d01a      	beq.n	800ce26 <strcmp+0x1be>
 800cdf0:	eba1 0104 	sub.w	r1, r1, r4
 800cdf4:	f020 0003 	bic.w	r0, r0, #3
 800cdf8:	07e4      	lsls	r4, r4, #31
 800cdfa:	f850 2b04 	ldr.w	r2, [r0], #4
 800cdfe:	d006      	beq.n	800ce0e <strcmp+0x1a6>
 800ce00:	d20f      	bcs.n	800ce22 <strcmp+0x1ba>
 800ce02:	788b      	ldrb	r3, [r1, #2]
 800ce04:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 800ce08:	1ae4      	subs	r4, r4, r3
 800ce0a:	d106      	bne.n	800ce1a <strcmp+0x1b2>
 800ce0c:	b12b      	cbz	r3, 800ce1a <strcmp+0x1b2>
 800ce0e:	78cb      	ldrb	r3, [r1, #3]
 800ce10:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 800ce14:	1ae4      	subs	r4, r4, r3
 800ce16:	d100      	bne.n	800ce1a <strcmp+0x1b2>
 800ce18:	b91b      	cbnz	r3, 800ce22 <strcmp+0x1ba>
 800ce1a:	4620      	mov	r0, r4
 800ce1c:	f85d 4b10 	ldr.w	r4, [sp], #16
 800ce20:	4770      	bx	lr
 800ce22:	f101 0104 	add.w	r1, r1, #4
 800ce26:	f850 2b04 	ldr.w	r2, [r0], #4
 800ce2a:	07cc      	lsls	r4, r1, #31
 800ce2c:	f021 0103 	bic.w	r1, r1, #3
 800ce30:	f851 3b04 	ldr.w	r3, [r1], #4
 800ce34:	d848      	bhi.n	800cec8 <strcmp+0x260>
 800ce36:	d224      	bcs.n	800ce82 <strcmp+0x21a>
 800ce38:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800ce3c:	fa82 f54c 	uadd8	r5, r2, ip
 800ce40:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 800ce44:	faa5 f58c 	sel	r5, r5, ip
 800ce48:	d10a      	bne.n	800ce60 <strcmp+0x1f8>
 800ce4a:	b965      	cbnz	r5, 800ce66 <strcmp+0x1fe>
 800ce4c:	f851 3b04 	ldr.w	r3, [r1], #4
 800ce50:	ea84 0402 	eor.w	r4, r4, r2
 800ce54:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 800ce58:	d10e      	bne.n	800ce78 <strcmp+0x210>
 800ce5a:	f850 2b04 	ldr.w	r2, [r0], #4
 800ce5e:	e7eb      	b.n	800ce38 <strcmp+0x1d0>
 800ce60:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800ce64:	e055      	b.n	800cf12 <strcmp+0x2aa>
 800ce66:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800ce6a:	d14d      	bne.n	800cf08 <strcmp+0x2a0>
 800ce6c:	7808      	ldrb	r0, [r1, #0]
 800ce6e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800ce72:	f1c0 0000 	rsb	r0, r0, #0
 800ce76:	4770      	bx	lr
 800ce78:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800ce7c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 800ce80:	e047      	b.n	800cf12 <strcmp+0x2aa>
 800ce82:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 800ce86:	fa82 f54c 	uadd8	r5, r2, ip
 800ce8a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800ce8e:	faa5 f58c 	sel	r5, r5, ip
 800ce92:	d10a      	bne.n	800ceaa <strcmp+0x242>
 800ce94:	b965      	cbnz	r5, 800ceb0 <strcmp+0x248>
 800ce96:	f851 3b04 	ldr.w	r3, [r1], #4
 800ce9a:	ea84 0402 	eor.w	r4, r4, r2
 800ce9e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 800cea2:	d10c      	bne.n	800cebe <strcmp+0x256>
 800cea4:	f850 2b04 	ldr.w	r2, [r0], #4
 800cea8:	e7eb      	b.n	800ce82 <strcmp+0x21a>
 800ceaa:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800ceae:	e030      	b.n	800cf12 <strcmp+0x2aa>
 800ceb0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 800ceb4:	d128      	bne.n	800cf08 <strcmp+0x2a0>
 800ceb6:	880b      	ldrh	r3, [r1, #0]
 800ceb8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800cebc:	e029      	b.n	800cf12 <strcmp+0x2aa>
 800cebe:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800cec2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 800cec6:	e024      	b.n	800cf12 <strcmp+0x2aa>
 800cec8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800cecc:	fa82 f54c 	uadd8	r5, r2, ip
 800ced0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 800ced4:	faa5 f58c 	sel	r5, r5, ip
 800ced8:	d10a      	bne.n	800cef0 <strcmp+0x288>
 800ceda:	b965      	cbnz	r5, 800cef6 <strcmp+0x28e>
 800cedc:	f851 3b04 	ldr.w	r3, [r1], #4
 800cee0:	ea84 0402 	eor.w	r4, r4, r2
 800cee4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 800cee8:	d109      	bne.n	800cefe <strcmp+0x296>
 800ceea:	f850 2b04 	ldr.w	r2, [r0], #4
 800ceee:	e7eb      	b.n	800cec8 <strcmp+0x260>
 800cef0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800cef4:	e00d      	b.n	800cf12 <strcmp+0x2aa>
 800cef6:	f015 0fff 	tst.w	r5, #255	; 0xff
 800cefa:	d105      	bne.n	800cf08 <strcmp+0x2a0>
 800cefc:	680b      	ldr	r3, [r1, #0]
 800cefe:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800cf02:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800cf06:	e004      	b.n	800cf12 <strcmp+0x2aa>
 800cf08:	f04f 0000 	mov.w	r0, #0
 800cf0c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800cf10:	4770      	bx	lr
 800cf12:	ba12      	rev	r2, r2
 800cf14:	ba1b      	rev	r3, r3
 800cf16:	fa82 f44c 	uadd8	r4, r2, ip
 800cf1a:	ea82 0403 	eor.w	r4, r2, r3
 800cf1e:	faa4 f58c 	sel	r5, r4, ip
 800cf22:	fab5 f485 	clz	r4, r5
 800cf26:	fa02 f204 	lsl.w	r2, r2, r4
 800cf2a:	fa03 f304 	lsl.w	r3, r3, r4
 800cf2e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 800cf32:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800cf36:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800cf3a:	4770      	bx	lr
 800cf3c:	0000      	movs	r0, r0
	...

0800cf40 <strlen>:
 800cf40:	f890 f000 	pld	[r0]
 800cf44:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 800cf48:	f020 0107 	bic.w	r1, r0, #7
 800cf4c:	f06f 0c00 	mvn.w	ip, #0
 800cf50:	f010 0407 	ands.w	r4, r0, #7
 800cf54:	f891 f020 	pld	[r1, #32]
 800cf58:	f040 8049 	bne.w	800cfee <strlen+0xae>
 800cf5c:	f04f 0400 	mov.w	r4, #0
 800cf60:	f06f 0007 	mvn.w	r0, #7
 800cf64:	e9d1 2300 	ldrd	r2, r3, [r1]
 800cf68:	f891 f040 	pld	[r1, #64]	; 0x40
 800cf6c:	f100 0008 	add.w	r0, r0, #8
 800cf70:	fa82 f24c 	uadd8	r2, r2, ip
 800cf74:	faa4 f28c 	sel	r2, r4, ip
 800cf78:	fa83 f34c 	uadd8	r3, r3, ip
 800cf7c:	faa2 f38c 	sel	r3, r2, ip
 800cf80:	bb4b      	cbnz	r3, 800cfd6 <strlen+0x96>
 800cf82:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 800cf86:	fa82 f24c 	uadd8	r2, r2, ip
 800cf8a:	f100 0008 	add.w	r0, r0, #8
 800cf8e:	faa4 f28c 	sel	r2, r4, ip
 800cf92:	fa83 f34c 	uadd8	r3, r3, ip
 800cf96:	faa2 f38c 	sel	r3, r2, ip
 800cf9a:	b9e3      	cbnz	r3, 800cfd6 <strlen+0x96>
 800cf9c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 800cfa0:	fa82 f24c 	uadd8	r2, r2, ip
 800cfa4:	f100 0008 	add.w	r0, r0, #8
 800cfa8:	faa4 f28c 	sel	r2, r4, ip
 800cfac:	fa83 f34c 	uadd8	r3, r3, ip
 800cfb0:	faa2 f38c 	sel	r3, r2, ip
 800cfb4:	b97b      	cbnz	r3, 800cfd6 <strlen+0x96>
 800cfb6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 800cfba:	f101 0120 	add.w	r1, r1, #32
 800cfbe:	fa82 f24c 	uadd8	r2, r2, ip
 800cfc2:	f100 0008 	add.w	r0, r0, #8
 800cfc6:	faa4 f28c 	sel	r2, r4, ip
 800cfca:	fa83 f34c 	uadd8	r3, r3, ip
 800cfce:	faa2 f38c 	sel	r3, r2, ip
 800cfd2:	2b00      	cmp	r3, #0
 800cfd4:	d0c6      	beq.n	800cf64 <strlen+0x24>
 800cfd6:	2a00      	cmp	r2, #0
 800cfd8:	bf04      	itt	eq
 800cfda:	3004      	addeq	r0, #4
 800cfdc:	461a      	moveq	r2, r3
 800cfde:	ba12      	rev	r2, r2
 800cfe0:	fab2 f282 	clz	r2, r2
 800cfe4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 800cfe8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800cfec:	4770      	bx	lr
 800cfee:	e9d1 2300 	ldrd	r2, r3, [r1]
 800cff2:	f004 0503 	and.w	r5, r4, #3
 800cff6:	f1c4 0000 	rsb	r0, r4, #0
 800cffa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800cffe:	f014 0f04 	tst.w	r4, #4
 800d002:	f891 f040 	pld	[r1, #64]	; 0x40
 800d006:	fa0c f505 	lsl.w	r5, ip, r5
 800d00a:	ea62 0205 	orn	r2, r2, r5
 800d00e:	bf1c      	itt	ne
 800d010:	ea63 0305 	ornne	r3, r3, r5
 800d014:	4662      	movne	r2, ip
 800d016:	f04f 0400 	mov.w	r4, #0
 800d01a:	e7a9      	b.n	800cf70 <strlen+0x30>
 800d01c:	0000      	movs	r0, r0
	...

0800d020 <memchr>:
 800d020:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800d024:	2a10      	cmp	r2, #16
 800d026:	db2b      	blt.n	800d080 <memchr+0x60>
 800d028:	f010 0f07 	tst.w	r0, #7
 800d02c:	d008      	beq.n	800d040 <memchr+0x20>
 800d02e:	f810 3b01 	ldrb.w	r3, [r0], #1
 800d032:	3a01      	subs	r2, #1
 800d034:	428b      	cmp	r3, r1
 800d036:	d02d      	beq.n	800d094 <memchr+0x74>
 800d038:	f010 0f07 	tst.w	r0, #7
 800d03c:	b342      	cbz	r2, 800d090 <memchr+0x70>
 800d03e:	d1f6      	bne.n	800d02e <memchr+0xe>
 800d040:	b4f0      	push	{r4, r5, r6, r7}
 800d042:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 800d046:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800d04a:	f022 0407 	bic.w	r4, r2, #7
 800d04e:	f07f 0700 	mvns.w	r7, #0
 800d052:	2300      	movs	r3, #0
 800d054:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 800d058:	3c08      	subs	r4, #8
 800d05a:	ea85 0501 	eor.w	r5, r5, r1
 800d05e:	ea86 0601 	eor.w	r6, r6, r1
 800d062:	fa85 f547 	uadd8	r5, r5, r7
 800d066:	faa3 f587 	sel	r5, r3, r7
 800d06a:	fa86 f647 	uadd8	r6, r6, r7
 800d06e:	faa5 f687 	sel	r6, r5, r7
 800d072:	b98e      	cbnz	r6, 800d098 <memchr+0x78>
 800d074:	d1ee      	bne.n	800d054 <memchr+0x34>
 800d076:	bcf0      	pop	{r4, r5, r6, r7}
 800d078:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800d07c:	f002 0207 	and.w	r2, r2, #7
 800d080:	b132      	cbz	r2, 800d090 <memchr+0x70>
 800d082:	f810 3b01 	ldrb.w	r3, [r0], #1
 800d086:	3a01      	subs	r2, #1
 800d088:	ea83 0301 	eor.w	r3, r3, r1
 800d08c:	b113      	cbz	r3, 800d094 <memchr+0x74>
 800d08e:	d1f8      	bne.n	800d082 <memchr+0x62>
 800d090:	2000      	movs	r0, #0
 800d092:	4770      	bx	lr
 800d094:	3801      	subs	r0, #1
 800d096:	4770      	bx	lr
 800d098:	2d00      	cmp	r5, #0
 800d09a:	bf06      	itte	eq
 800d09c:	4635      	moveq	r5, r6
 800d09e:	3803      	subeq	r0, #3
 800d0a0:	3807      	subne	r0, #7
 800d0a2:	f015 0f01 	tst.w	r5, #1
 800d0a6:	d107      	bne.n	800d0b8 <memchr+0x98>
 800d0a8:	3001      	adds	r0, #1
 800d0aa:	f415 7f80 	tst.w	r5, #256	; 0x100
 800d0ae:	bf02      	ittt	eq
 800d0b0:	3001      	addeq	r0, #1
 800d0b2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 800d0b6:	3001      	addeq	r0, #1
 800d0b8:	bcf0      	pop	{r4, r5, r6, r7}
 800d0ba:	3801      	subs	r0, #1
 800d0bc:	4770      	bx	lr
 800d0be:	bf00      	nop

0800d0c0 <__aeabi_d2uiz>:
 800d0c0:	004a      	lsls	r2, r1, #1
 800d0c2:	d211      	bcs.n	800d0e8 <__aeabi_d2uiz+0x28>
 800d0c4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800d0c8:	d211      	bcs.n	800d0ee <__aeabi_d2uiz+0x2e>
 800d0ca:	d50d      	bpl.n	800d0e8 <__aeabi_d2uiz+0x28>
 800d0cc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800d0d0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800d0d4:	d40e      	bmi.n	800d0f4 <__aeabi_d2uiz+0x34>
 800d0d6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800d0da:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800d0de:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800d0e2:	fa23 f002 	lsr.w	r0, r3, r2
 800d0e6:	4770      	bx	lr
 800d0e8:	f04f 0000 	mov.w	r0, #0
 800d0ec:	4770      	bx	lr
 800d0ee:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800d0f2:	d102      	bne.n	800d0fa <__aeabi_d2uiz+0x3a>
 800d0f4:	f04f 30ff 	mov.w	r0, #4294967295
 800d0f8:	4770      	bx	lr
 800d0fa:	f04f 0000 	mov.w	r0, #0
 800d0fe:	4770      	bx	lr

0800d100 <__aeabi_uldivmod>:
 800d100:	b953      	cbnz	r3, 800d118 <__aeabi_uldivmod+0x18>
 800d102:	b94a      	cbnz	r2, 800d118 <__aeabi_uldivmod+0x18>
 800d104:	2900      	cmp	r1, #0
 800d106:	bf08      	it	eq
 800d108:	2800      	cmpeq	r0, #0
 800d10a:	bf1c      	itt	ne
 800d10c:	f04f 31ff 	movne.w	r1, #4294967295
 800d110:	f04f 30ff 	movne.w	r0, #4294967295
 800d114:	f000 b974 	b.w	800d400 <__aeabi_idiv0>
 800d118:	f1ad 0c08 	sub.w	ip, sp, #8
 800d11c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800d120:	f000 f806 	bl	800d130 <__udivmoddi4>
 800d124:	f8dd e004 	ldr.w	lr, [sp, #4]
 800d128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800d12c:	b004      	add	sp, #16
 800d12e:	4770      	bx	lr

0800d130 <__udivmoddi4>:
 800d130:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d134:	9e08      	ldr	r6, [sp, #32]
 800d136:	4604      	mov	r4, r0
 800d138:	4688      	mov	r8, r1
 800d13a:	2b00      	cmp	r3, #0
 800d13c:	d14b      	bne.n	800d1d6 <__udivmoddi4+0xa6>
 800d13e:	428a      	cmp	r2, r1
 800d140:	4615      	mov	r5, r2
 800d142:	d967      	bls.n	800d214 <__udivmoddi4+0xe4>
 800d144:	fab2 f282 	clz	r2, r2
 800d148:	b14a      	cbz	r2, 800d15e <__udivmoddi4+0x2e>
 800d14a:	f1c2 0720 	rsb	r7, r2, #32
 800d14e:	fa01 f302 	lsl.w	r3, r1, r2
 800d152:	fa20 f707 	lsr.w	r7, r0, r7
 800d156:	4095      	lsls	r5, r2
 800d158:	ea47 0803 	orr.w	r8, r7, r3
 800d15c:	4094      	lsls	r4, r2
 800d15e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800d162:	0c23      	lsrs	r3, r4, #16
 800d164:	fbb8 f7fe 	udiv	r7, r8, lr
 800d168:	fa1f fc85 	uxth.w	ip, r5
 800d16c:	fb0e 8817 	mls	r8, lr, r7, r8
 800d170:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800d174:	fb07 f10c 	mul.w	r1, r7, ip
 800d178:	4299      	cmp	r1, r3
 800d17a:	d909      	bls.n	800d190 <__udivmoddi4+0x60>
 800d17c:	18eb      	adds	r3, r5, r3
 800d17e:	f107 30ff 	add.w	r0, r7, #4294967295
 800d182:	f080 811b 	bcs.w	800d3bc <__udivmoddi4+0x28c>
 800d186:	4299      	cmp	r1, r3
 800d188:	f240 8118 	bls.w	800d3bc <__udivmoddi4+0x28c>
 800d18c:	3f02      	subs	r7, #2
 800d18e:	442b      	add	r3, r5
 800d190:	1a5b      	subs	r3, r3, r1
 800d192:	b2a4      	uxth	r4, r4
 800d194:	fbb3 f0fe 	udiv	r0, r3, lr
 800d198:	fb0e 3310 	mls	r3, lr, r0, r3
 800d19c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800d1a0:	fb00 fc0c 	mul.w	ip, r0, ip
 800d1a4:	45a4      	cmp	ip, r4
 800d1a6:	d909      	bls.n	800d1bc <__udivmoddi4+0x8c>
 800d1a8:	192c      	adds	r4, r5, r4
 800d1aa:	f100 33ff 	add.w	r3, r0, #4294967295
 800d1ae:	f080 8107 	bcs.w	800d3c0 <__udivmoddi4+0x290>
 800d1b2:	45a4      	cmp	ip, r4
 800d1b4:	f240 8104 	bls.w	800d3c0 <__udivmoddi4+0x290>
 800d1b8:	3802      	subs	r0, #2
 800d1ba:	442c      	add	r4, r5
 800d1bc:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800d1c0:	eba4 040c 	sub.w	r4, r4, ip
 800d1c4:	2700      	movs	r7, #0
 800d1c6:	b11e      	cbz	r6, 800d1d0 <__udivmoddi4+0xa0>
 800d1c8:	40d4      	lsrs	r4, r2
 800d1ca:	2300      	movs	r3, #0
 800d1cc:	e9c6 4300 	strd	r4, r3, [r6]
 800d1d0:	4639      	mov	r1, r7
 800d1d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d1d6:	428b      	cmp	r3, r1
 800d1d8:	d909      	bls.n	800d1ee <__udivmoddi4+0xbe>
 800d1da:	2e00      	cmp	r6, #0
 800d1dc:	f000 80eb 	beq.w	800d3b6 <__udivmoddi4+0x286>
 800d1e0:	2700      	movs	r7, #0
 800d1e2:	e9c6 0100 	strd	r0, r1, [r6]
 800d1e6:	4638      	mov	r0, r7
 800d1e8:	4639      	mov	r1, r7
 800d1ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d1ee:	fab3 f783 	clz	r7, r3
 800d1f2:	2f00      	cmp	r7, #0
 800d1f4:	d147      	bne.n	800d286 <__udivmoddi4+0x156>
 800d1f6:	428b      	cmp	r3, r1
 800d1f8:	d302      	bcc.n	800d200 <__udivmoddi4+0xd0>
 800d1fa:	4282      	cmp	r2, r0
 800d1fc:	f200 80fa 	bhi.w	800d3f4 <__udivmoddi4+0x2c4>
 800d200:	1a84      	subs	r4, r0, r2
 800d202:	eb61 0303 	sbc.w	r3, r1, r3
 800d206:	2001      	movs	r0, #1
 800d208:	4698      	mov	r8, r3
 800d20a:	2e00      	cmp	r6, #0
 800d20c:	d0e0      	beq.n	800d1d0 <__udivmoddi4+0xa0>
 800d20e:	e9c6 4800 	strd	r4, r8, [r6]
 800d212:	e7dd      	b.n	800d1d0 <__udivmoddi4+0xa0>
 800d214:	b902      	cbnz	r2, 800d218 <__udivmoddi4+0xe8>
 800d216:	deff      	udf	#255	; 0xff
 800d218:	fab2 f282 	clz	r2, r2
 800d21c:	2a00      	cmp	r2, #0
 800d21e:	f040 808f 	bne.w	800d340 <__udivmoddi4+0x210>
 800d222:	1b49      	subs	r1, r1, r5
 800d224:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800d228:	fa1f f885 	uxth.w	r8, r5
 800d22c:	2701      	movs	r7, #1
 800d22e:	fbb1 fcfe 	udiv	ip, r1, lr
 800d232:	0c23      	lsrs	r3, r4, #16
 800d234:	fb0e 111c 	mls	r1, lr, ip, r1
 800d238:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800d23c:	fb08 f10c 	mul.w	r1, r8, ip
 800d240:	4299      	cmp	r1, r3
 800d242:	d907      	bls.n	800d254 <__udivmoddi4+0x124>
 800d244:	18eb      	adds	r3, r5, r3
 800d246:	f10c 30ff 	add.w	r0, ip, #4294967295
 800d24a:	d202      	bcs.n	800d252 <__udivmoddi4+0x122>
 800d24c:	4299      	cmp	r1, r3
 800d24e:	f200 80cd 	bhi.w	800d3ec <__udivmoddi4+0x2bc>
 800d252:	4684      	mov	ip, r0
 800d254:	1a59      	subs	r1, r3, r1
 800d256:	b2a3      	uxth	r3, r4
 800d258:	fbb1 f0fe 	udiv	r0, r1, lr
 800d25c:	fb0e 1410 	mls	r4, lr, r0, r1
 800d260:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800d264:	fb08 f800 	mul.w	r8, r8, r0
 800d268:	45a0      	cmp	r8, r4
 800d26a:	d907      	bls.n	800d27c <__udivmoddi4+0x14c>
 800d26c:	192c      	adds	r4, r5, r4
 800d26e:	f100 33ff 	add.w	r3, r0, #4294967295
 800d272:	d202      	bcs.n	800d27a <__udivmoddi4+0x14a>
 800d274:	45a0      	cmp	r8, r4
 800d276:	f200 80b6 	bhi.w	800d3e6 <__udivmoddi4+0x2b6>
 800d27a:	4618      	mov	r0, r3
 800d27c:	eba4 0408 	sub.w	r4, r4, r8
 800d280:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 800d284:	e79f      	b.n	800d1c6 <__udivmoddi4+0x96>
 800d286:	f1c7 0c20 	rsb	ip, r7, #32
 800d28a:	40bb      	lsls	r3, r7
 800d28c:	fa22 fe0c 	lsr.w	lr, r2, ip
 800d290:	ea4e 0e03 	orr.w	lr, lr, r3
 800d294:	fa01 f407 	lsl.w	r4, r1, r7
 800d298:	fa20 f50c 	lsr.w	r5, r0, ip
 800d29c:	fa21 f30c 	lsr.w	r3, r1, ip
 800d2a0:	ea4f 481e 	mov.w	r8, lr, lsr #16
 800d2a4:	4325      	orrs	r5, r4
 800d2a6:	fbb3 f9f8 	udiv	r9, r3, r8
 800d2aa:	0c2c      	lsrs	r4, r5, #16
 800d2ac:	fb08 3319 	mls	r3, r8, r9, r3
 800d2b0:	fa1f fa8e 	uxth.w	sl, lr
 800d2b4:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 800d2b8:	fb09 f40a 	mul.w	r4, r9, sl
 800d2bc:	429c      	cmp	r4, r3
 800d2be:	fa02 f207 	lsl.w	r2, r2, r7
 800d2c2:	fa00 f107 	lsl.w	r1, r0, r7
 800d2c6:	d90b      	bls.n	800d2e0 <__udivmoddi4+0x1b0>
 800d2c8:	eb1e 0303 	adds.w	r3, lr, r3
 800d2cc:	f109 30ff 	add.w	r0, r9, #4294967295
 800d2d0:	f080 8087 	bcs.w	800d3e2 <__udivmoddi4+0x2b2>
 800d2d4:	429c      	cmp	r4, r3
 800d2d6:	f240 8084 	bls.w	800d3e2 <__udivmoddi4+0x2b2>
 800d2da:	f1a9 0902 	sub.w	r9, r9, #2
 800d2de:	4473      	add	r3, lr
 800d2e0:	1b1b      	subs	r3, r3, r4
 800d2e2:	b2ad      	uxth	r5, r5
 800d2e4:	fbb3 f0f8 	udiv	r0, r3, r8
 800d2e8:	fb08 3310 	mls	r3, r8, r0, r3
 800d2ec:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 800d2f0:	fb00 fa0a 	mul.w	sl, r0, sl
 800d2f4:	45a2      	cmp	sl, r4
 800d2f6:	d908      	bls.n	800d30a <__udivmoddi4+0x1da>
 800d2f8:	eb1e 0404 	adds.w	r4, lr, r4
 800d2fc:	f100 33ff 	add.w	r3, r0, #4294967295
 800d300:	d26b      	bcs.n	800d3da <__udivmoddi4+0x2aa>
 800d302:	45a2      	cmp	sl, r4
 800d304:	d969      	bls.n	800d3da <__udivmoddi4+0x2aa>
 800d306:	3802      	subs	r0, #2
 800d308:	4474      	add	r4, lr
 800d30a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800d30e:	fba0 8902 	umull	r8, r9, r0, r2
 800d312:	eba4 040a 	sub.w	r4, r4, sl
 800d316:	454c      	cmp	r4, r9
 800d318:	46c2      	mov	sl, r8
 800d31a:	464b      	mov	r3, r9
 800d31c:	d354      	bcc.n	800d3c8 <__udivmoddi4+0x298>
 800d31e:	d051      	beq.n	800d3c4 <__udivmoddi4+0x294>
 800d320:	2e00      	cmp	r6, #0
 800d322:	d069      	beq.n	800d3f8 <__udivmoddi4+0x2c8>
 800d324:	ebb1 050a 	subs.w	r5, r1, sl
 800d328:	eb64 0403 	sbc.w	r4, r4, r3
 800d32c:	fa04 fc0c 	lsl.w	ip, r4, ip
 800d330:	40fd      	lsrs	r5, r7
 800d332:	40fc      	lsrs	r4, r7
 800d334:	ea4c 0505 	orr.w	r5, ip, r5
 800d338:	e9c6 5400 	strd	r5, r4, [r6]
 800d33c:	2700      	movs	r7, #0
 800d33e:	e747      	b.n	800d1d0 <__udivmoddi4+0xa0>
 800d340:	f1c2 0320 	rsb	r3, r2, #32
 800d344:	fa20 f703 	lsr.w	r7, r0, r3
 800d348:	4095      	lsls	r5, r2
 800d34a:	fa01 f002 	lsl.w	r0, r1, r2
 800d34e:	fa21 f303 	lsr.w	r3, r1, r3
 800d352:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800d356:	4338      	orrs	r0, r7
 800d358:	0c01      	lsrs	r1, r0, #16
 800d35a:	fbb3 f7fe 	udiv	r7, r3, lr
 800d35e:	fa1f f885 	uxth.w	r8, r5
 800d362:	fb0e 3317 	mls	r3, lr, r7, r3
 800d366:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800d36a:	fb07 f308 	mul.w	r3, r7, r8
 800d36e:	428b      	cmp	r3, r1
 800d370:	fa04 f402 	lsl.w	r4, r4, r2
 800d374:	d907      	bls.n	800d386 <__udivmoddi4+0x256>
 800d376:	1869      	adds	r1, r5, r1
 800d378:	f107 3cff 	add.w	ip, r7, #4294967295
 800d37c:	d22f      	bcs.n	800d3de <__udivmoddi4+0x2ae>
 800d37e:	428b      	cmp	r3, r1
 800d380:	d92d      	bls.n	800d3de <__udivmoddi4+0x2ae>
 800d382:	3f02      	subs	r7, #2
 800d384:	4429      	add	r1, r5
 800d386:	1acb      	subs	r3, r1, r3
 800d388:	b281      	uxth	r1, r0
 800d38a:	fbb3 f0fe 	udiv	r0, r3, lr
 800d38e:	fb0e 3310 	mls	r3, lr, r0, r3
 800d392:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800d396:	fb00 f308 	mul.w	r3, r0, r8
 800d39a:	428b      	cmp	r3, r1
 800d39c:	d907      	bls.n	800d3ae <__udivmoddi4+0x27e>
 800d39e:	1869      	adds	r1, r5, r1
 800d3a0:	f100 3cff 	add.w	ip, r0, #4294967295
 800d3a4:	d217      	bcs.n	800d3d6 <__udivmoddi4+0x2a6>
 800d3a6:	428b      	cmp	r3, r1
 800d3a8:	d915      	bls.n	800d3d6 <__udivmoddi4+0x2a6>
 800d3aa:	3802      	subs	r0, #2
 800d3ac:	4429      	add	r1, r5
 800d3ae:	1ac9      	subs	r1, r1, r3
 800d3b0:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 800d3b4:	e73b      	b.n	800d22e <__udivmoddi4+0xfe>
 800d3b6:	4637      	mov	r7, r6
 800d3b8:	4630      	mov	r0, r6
 800d3ba:	e709      	b.n	800d1d0 <__udivmoddi4+0xa0>
 800d3bc:	4607      	mov	r7, r0
 800d3be:	e6e7      	b.n	800d190 <__udivmoddi4+0x60>
 800d3c0:	4618      	mov	r0, r3
 800d3c2:	e6fb      	b.n	800d1bc <__udivmoddi4+0x8c>
 800d3c4:	4541      	cmp	r1, r8
 800d3c6:	d2ab      	bcs.n	800d320 <__udivmoddi4+0x1f0>
 800d3c8:	ebb8 0a02 	subs.w	sl, r8, r2
 800d3cc:	eb69 020e 	sbc.w	r2, r9, lr
 800d3d0:	3801      	subs	r0, #1
 800d3d2:	4613      	mov	r3, r2
 800d3d4:	e7a4      	b.n	800d320 <__udivmoddi4+0x1f0>
 800d3d6:	4660      	mov	r0, ip
 800d3d8:	e7e9      	b.n	800d3ae <__udivmoddi4+0x27e>
 800d3da:	4618      	mov	r0, r3
 800d3dc:	e795      	b.n	800d30a <__udivmoddi4+0x1da>
 800d3de:	4667      	mov	r7, ip
 800d3e0:	e7d1      	b.n	800d386 <__udivmoddi4+0x256>
 800d3e2:	4681      	mov	r9, r0
 800d3e4:	e77c      	b.n	800d2e0 <__udivmoddi4+0x1b0>
 800d3e6:	3802      	subs	r0, #2
 800d3e8:	442c      	add	r4, r5
 800d3ea:	e747      	b.n	800d27c <__udivmoddi4+0x14c>
 800d3ec:	f1ac 0c02 	sub.w	ip, ip, #2
 800d3f0:	442b      	add	r3, r5
 800d3f2:	e72f      	b.n	800d254 <__udivmoddi4+0x124>
 800d3f4:	4638      	mov	r0, r7
 800d3f6:	e708      	b.n	800d20a <__udivmoddi4+0xda>
 800d3f8:	4637      	mov	r7, r6
 800d3fa:	e6e9      	b.n	800d1d0 <__udivmoddi4+0xa0>
 800d3fc:	0000      	movs	r0, r0
	...

0800d400 <__aeabi_idiv0>:
 800d400:	4770      	bx	lr
 800d402:	bf00      	nop
	...

0800d410 <__core_init>:
 800d410:	4770      	bx	lr
 800d412:	bf00      	nop
	...

0800d420 <__late_init>:
 800d420:	4770      	bx	lr
 800d422:	bf00      	nop
	...

0800d430 <__default_exit>:
 800d430:	e7fe      	b.n	800d430 <__default_exit>
 800d432:	bf00      	nop
	...

0800d440 <_unhandled_exception>:
 800d440:	e7fe      	b.n	800d440 <_unhandled_exception>
 800d442:	bf00      	nop
	...

0800d450 <_idle_thread>:
 800d450:	e7fe      	b.n	800d450 <_idle_thread>
 800d452:	bf00      	nop
	...

0800d460 <chSysInit>:
 800d460:	4b20      	ldr	r3, [pc, #128]	; (800d4e4 <chSysInit+0x84>)
 800d462:	4a21      	ldr	r2, [pc, #132]	; (800d4e8 <chSysInit+0x88>)
 800d464:	4821      	ldr	r0, [pc, #132]	; (800d4ec <chSysInit+0x8c>)
 800d466:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d468:	2400      	movs	r4, #0
 800d46a:	609c      	str	r4, [r3, #8]
 800d46c:	68df      	ldr	r7, [r3, #12]
 800d46e:	4e20      	ldr	r6, [pc, #128]	; (800d4f0 <chSysInit+0x90>)
 800d470:	4d20      	ldr	r5, [pc, #128]	; (800d4f4 <chSysInit+0x94>)
 800d472:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 800d476:	4039      	ands	r1, r7
 800d478:	430a      	orrs	r2, r1
 800d47a:	60da      	str	r2, [r3, #12]
 800d47c:	68f2      	ldr	r2, [r6, #12]
 800d47e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800d482:	60f2      	str	r2, [r6, #12]
 800d484:	6802      	ldr	r2, [r0, #0]
 800d486:	2120      	movs	r1, #32
 800d488:	f042 0201 	orr.w	r2, r2, #1
 800d48c:	2610      	movs	r6, #16
 800d48e:	6002      	str	r2, [r0, #0]
 800d490:	b083      	sub	sp, #12
 800d492:	77de      	strb	r6, [r3, #31]
 800d494:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
 800d498:	f000 f902 	bl	800d6a0 <_scheduler_init>
 800d49c:	f000 f880 	bl	800d5a0 <_vt_init>
 800d4a0:	f000 fb66 	bl	800db70 <_tm_init>
 800d4a4:	f000 fe64 	bl	800e170 <_core_init>
 800d4a8:	f000 feaa 	bl	800e200 <_heap_init>
 800d4ac:	4628      	mov	r0, r5
 800d4ae:	2140      	movs	r1, #64	; 0x40
 800d4b0:	f000 fa06 	bl	800d8c0 <_thread_init>
 800d4b4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
 800d4b8:	2201      	movs	r2, #1
 800d4ba:	6198      	str	r0, [r3, #24]
 800d4bc:	7702      	strb	r2, [r0, #28]
 800d4be:	f384 8811 	msr	BASEPRI, r4
 800d4c2:	b662      	cpsie	i
 800d4c4:	699b      	ldr	r3, [r3, #24]
 800d4c6:	490c      	ldr	r1, [pc, #48]	; (800d4f8 <chSysInit+0x98>)
 800d4c8:	6199      	str	r1, [r3, #24]
 800d4ca:	f105 0050 	add.w	r0, r5, #80	; 0x50
 800d4ce:	9400      	str	r4, [sp, #0]
 800d4d0:	4b0a      	ldr	r3, [pc, #40]	; (800d4fc <chSysInit+0x9c>)
 800d4d2:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 800d4d6:	f000 fa4b 	bl	800d970 <chThdCreateStatic>
 800d4da:	4b09      	ldr	r3, [pc, #36]	; (800d500 <chSysInit+0xa0>)
 800d4dc:	6183      	str	r3, [r0, #24]
 800d4de:	b003      	add	sp, #12
 800d4e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d4e2:	bf00      	nop
 800d4e4:	e000ed00 	.word	0xe000ed00
 800d4e8:	05fa0300 	.word	0x05fa0300
 800d4ec:	e0001000 	.word	0xe0001000
 800d4f0:	e000edf0 	.word	0xe000edf0
 800d4f4:	20001a78 	.word	0x20001a78
 800d4f8:	0802d940 	.word	0x0802d940
 800d4fc:	0800d451 	.word	0x0800d451
 800d500:	0802d930 	.word	0x0802d930
	...

0800d510 <chSysHalt>:
 800d510:	b672      	cpsid	i
 800d512:	4b01      	ldr	r3, [pc, #4]	; (800d518 <chSysHalt+0x8>)
 800d514:	62d8      	str	r0, [r3, #44]	; 0x2c
 800d516:	e7fe      	b.n	800d516 <chSysHalt+0x6>
 800d518:	20001a48 	.word	0x20001a48
 800d51c:	00000000 	.word	0x00000000

0800d520 <chSysTimerHandlerI>:
 800d520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d522:	4d13      	ldr	r5, [pc, #76]	; (800d570 <chSysTimerHandlerI+0x50>)
 800d524:	69aa      	ldr	r2, [r5, #24]
 800d526:	7fd3      	ldrb	r3, [r2, #31]
 800d528:	b10b      	cbz	r3, 800d52e <chSysTimerHandlerI+0xe>
 800d52a:	3b01      	subs	r3, #1
 800d52c:	77d3      	strb	r3, [r2, #31]
 800d52e:	6a11      	ldr	r1, [r2, #32]
 800d530:	69eb      	ldr	r3, [r5, #28]
 800d532:	4e10      	ldr	r6, [pc, #64]	; (800d574 <chSysTimerHandlerI+0x54>)
 800d534:	3101      	adds	r1, #1
 800d536:	6211      	str	r1, [r2, #32]
 800d538:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800d53a:	42b3      	cmp	r3, r6
 800d53c:	f102 0201 	add.w	r2, r2, #1
 800d540:	62aa      	str	r2, [r5, #40]	; 0x28
 800d542:	d013      	beq.n	800d56c <chSysTimerHandlerI+0x4c>
 800d544:	689c      	ldr	r4, [r3, #8]
 800d546:	3c01      	subs	r4, #1
 800d548:	609c      	str	r4, [r3, #8]
 800d54a:	b97c      	cbnz	r4, 800d56c <chSysTimerHandlerI+0x4c>
 800d54c:	2720      	movs	r7, #32
 800d54e:	681a      	ldr	r2, [r3, #0]
 800d550:	68d9      	ldr	r1, [r3, #12]
 800d552:	60dc      	str	r4, [r3, #12]
 800d554:	6056      	str	r6, [r2, #4]
 800d556:	61ea      	str	r2, [r5, #28]
 800d558:	f384 8811 	msr	BASEPRI, r4
 800d55c:	6918      	ldr	r0, [r3, #16]
 800d55e:	4788      	blx	r1
 800d560:	f387 8811 	msr	BASEPRI, r7
 800d564:	69eb      	ldr	r3, [r5, #28]
 800d566:	689a      	ldr	r2, [r3, #8]
 800d568:	2a00      	cmp	r2, #0
 800d56a:	d0f0      	beq.n	800d54e <chSysTimerHandlerI+0x2e>
 800d56c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d56e:	bf00      	nop
 800d570:	20001a48 	.word	0x20001a48
 800d574:	20001a64 	.word	0x20001a64
	...

0800d580 <chSysPolledDelayX>:
 800d580:	4a03      	ldr	r2, [pc, #12]	; (800d590 <chSysPolledDelayX+0x10>)
 800d582:	6851      	ldr	r1, [r2, #4]
 800d584:	6853      	ldr	r3, [r2, #4]
 800d586:	1a5b      	subs	r3, r3, r1
 800d588:	4283      	cmp	r3, r0
 800d58a:	d3fb      	bcc.n	800d584 <chSysPolledDelayX+0x4>
 800d58c:	4770      	bx	lr
 800d58e:	bf00      	nop
 800d590:	e0001000 	.word	0xe0001000
	...

0800d5a0 <_vt_init>:
 800d5a0:	4b05      	ldr	r3, [pc, #20]	; (800d5b8 <_vt_init+0x18>)
 800d5a2:	f04f 30ff 	mov.w	r0, #4294967295
 800d5a6:	f103 021c 	add.w	r2, r3, #28
 800d5aa:	2100      	movs	r1, #0
 800d5ac:	6258      	str	r0, [r3, #36]	; 0x24
 800d5ae:	6299      	str	r1, [r3, #40]	; 0x28
 800d5b0:	61da      	str	r2, [r3, #28]
 800d5b2:	621a      	str	r2, [r3, #32]
 800d5b4:	4770      	bx	lr
 800d5b6:	bf00      	nop
 800d5b8:	20001a48 	.word	0x20001a48
 800d5bc:	00000000 	.word	0x00000000

0800d5c0 <chVTDoSetI>:
 800d5c0:	b470      	push	{r4, r5, r6}
 800d5c2:	4e0d      	ldr	r6, [pc, #52]	; (800d5f8 <chVTDoSetI+0x38>)
 800d5c4:	69f4      	ldr	r4, [r6, #28]
 800d5c6:	68a5      	ldr	r5, [r4, #8]
 800d5c8:	6103      	str	r3, [r0, #16]
 800d5ca:	42a9      	cmp	r1, r5
 800d5cc:	60c2      	str	r2, [r0, #12]
 800d5ce:	d904      	bls.n	800d5da <chVTDoSetI+0x1a>
 800d5d0:	6824      	ldr	r4, [r4, #0]
 800d5d2:	1b49      	subs	r1, r1, r5
 800d5d4:	68a5      	ldr	r5, [r4, #8]
 800d5d6:	428d      	cmp	r5, r1
 800d5d8:	d3fa      	bcc.n	800d5d0 <chVTDoSetI+0x10>
 800d5da:	6863      	ldr	r3, [r4, #4]
 800d5dc:	6043      	str	r3, [r0, #4]
 800d5de:	6004      	str	r4, [r0, #0]
 800d5e0:	6018      	str	r0, [r3, #0]
 800d5e2:	6060      	str	r0, [r4, #4]
 800d5e4:	6081      	str	r1, [r0, #8]
 800d5e6:	68a3      	ldr	r3, [r4, #8]
 800d5e8:	f04f 32ff 	mov.w	r2, #4294967295
 800d5ec:	1a59      	subs	r1, r3, r1
 800d5ee:	60a1      	str	r1, [r4, #8]
 800d5f0:	6272      	str	r2, [r6, #36]	; 0x24
 800d5f2:	bc70      	pop	{r4, r5, r6}
 800d5f4:	4770      	bx	lr
 800d5f6:	bf00      	nop
 800d5f8:	20001a48 	.word	0x20001a48
 800d5fc:	00000000 	.word	0x00000000

0800d600 <chVTDoResetI>:
 800d600:	6803      	ldr	r3, [r0, #0]
 800d602:	6882      	ldr	r2, [r0, #8]
 800d604:	6841      	ldr	r1, [r0, #4]
 800d606:	b430      	push	{r4, r5}
 800d608:	689d      	ldr	r5, [r3, #8]
 800d60a:	4c06      	ldr	r4, [pc, #24]	; (800d624 <chVTDoResetI+0x24>)
 800d60c:	442a      	add	r2, r5
 800d60e:	609a      	str	r2, [r3, #8]
 800d610:	600b      	str	r3, [r1, #0]
 800d612:	6805      	ldr	r5, [r0, #0]
 800d614:	2200      	movs	r2, #0
 800d616:	f04f 33ff 	mov.w	r3, #4294967295
 800d61a:	6069      	str	r1, [r5, #4]
 800d61c:	60c2      	str	r2, [r0, #12]
 800d61e:	6263      	str	r3, [r4, #36]	; 0x24
 800d620:	bc30      	pop	{r4, r5}
 800d622:	4770      	bx	lr
 800d624:	20001a48 	.word	0x20001a48
	...

0800d630 <wakeup>:
 800d630:	b410      	push	{r4}
 800d632:	2320      	movs	r3, #32
 800d634:	f383 8811 	msr	BASEPRI, r3
 800d638:	7f03      	ldrb	r3, [r0, #28]
 800d63a:	2b07      	cmp	r3, #7
 800d63c:	d80e      	bhi.n	800d65c <wakeup+0x2c>
 800d63e:	e8df f003 	tbb	[pc, r3]
 800d642:	0d27      	.short	0x0d27
 800d644:	0408230d 	.word	0x0408230d
 800d648:	080d      	.short	0x080d
 800d64a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800d64c:	6893      	ldr	r3, [r2, #8]
 800d64e:	3301      	adds	r3, #1
 800d650:	6093      	str	r3, [r2, #8]
 800d652:	e890 000c 	ldmia.w	r0, {r2, r3}
 800d656:	601a      	str	r2, [r3, #0]
 800d658:	6802      	ldr	r2, [r0, #0]
 800d65a:	6053      	str	r3, [r2, #4]
 800d65c:	f04f 34ff 	mov.w	r4, #4294967295
 800d660:	2200      	movs	r2, #0
 800d662:	6881      	ldr	r1, [r0, #8]
 800d664:	4b0d      	ldr	r3, [pc, #52]	; (800d69c <wakeup+0x6c>)
 800d666:	6244      	str	r4, [r0, #36]	; 0x24
 800d668:	7702      	strb	r2, [r0, #28]
 800d66a:	681b      	ldr	r3, [r3, #0]
 800d66c:	689a      	ldr	r2, [r3, #8]
 800d66e:	428a      	cmp	r2, r1
 800d670:	d2fb      	bcs.n	800d66a <wakeup+0x3a>
 800d672:	685a      	ldr	r2, [r3, #4]
 800d674:	6042      	str	r2, [r0, #4]
 800d676:	6003      	str	r3, [r0, #0]
 800d678:	2100      	movs	r1, #0
 800d67a:	6010      	str	r0, [r2, #0]
 800d67c:	6058      	str	r0, [r3, #4]
 800d67e:	f381 8811 	msr	BASEPRI, r1
 800d682:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d686:	4770      	bx	lr
 800d688:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800d68a:	2200      	movs	r2, #0
 800d68c:	601a      	str	r2, [r3, #0]
 800d68e:	e7e5      	b.n	800d65c <wakeup+0x2c>
 800d690:	2300      	movs	r3, #0
 800d692:	f383 8811 	msr	BASEPRI, r3
 800d696:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d69a:	4770      	bx	lr
 800d69c:	20001a48 	.word	0x20001a48

0800d6a0 <_scheduler_init>:
 800d6a0:	4b03      	ldr	r3, [pc, #12]	; (800d6b0 <_scheduler_init+0x10>)
 800d6a2:	2200      	movs	r2, #0
 800d6a4:	601b      	str	r3, [r3, #0]
 800d6a6:	605b      	str	r3, [r3, #4]
 800d6a8:	611b      	str	r3, [r3, #16]
 800d6aa:	615b      	str	r3, [r3, #20]
 800d6ac:	609a      	str	r2, [r3, #8]
 800d6ae:	4770      	bx	lr
 800d6b0:	20001a48 	.word	0x20001a48
	...

0800d6c0 <chSchReadyI>:
 800d6c0:	2200      	movs	r2, #0
 800d6c2:	6881      	ldr	r1, [r0, #8]
 800d6c4:	4b08      	ldr	r3, [pc, #32]	; (800d6e8 <chSchReadyI+0x28>)
 800d6c6:	b410      	push	{r4}
 800d6c8:	4604      	mov	r4, r0
 800d6ca:	7702      	strb	r2, [r0, #28]
 800d6cc:	681b      	ldr	r3, [r3, #0]
 800d6ce:	689a      	ldr	r2, [r3, #8]
 800d6d0:	428a      	cmp	r2, r1
 800d6d2:	d2fb      	bcs.n	800d6cc <chSchReadyI+0xc>
 800d6d4:	685a      	ldr	r2, [r3, #4]
 800d6d6:	6062      	str	r2, [r4, #4]
 800d6d8:	6023      	str	r3, [r4, #0]
 800d6da:	4620      	mov	r0, r4
 800d6dc:	6014      	str	r4, [r2, #0]
 800d6de:	605c      	str	r4, [r3, #4]
 800d6e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d6e4:	4770      	bx	lr
 800d6e6:	bf00      	nop
 800d6e8:	20001a48 	.word	0x20001a48
 800d6ec:	00000000 	.word	0x00000000

0800d6f0 <chSchGoSleepS>:
 800d6f0:	4b08      	ldr	r3, [pc, #32]	; (800d714 <chSchGoSleepS+0x24>)
 800d6f2:	6999      	ldr	r1, [r3, #24]
 800d6f4:	681a      	ldr	r2, [r3, #0]
 800d6f6:	b410      	push	{r4}
 800d6f8:	7708      	strb	r0, [r1, #28]
 800d6fa:	2004      	movs	r0, #4
 800d6fc:	77c8      	strb	r0, [r1, #31]
 800d6fe:	6810      	ldr	r0, [r2, #0]
 800d700:	6018      	str	r0, [r3, #0]
 800d702:	2401      	movs	r4, #1
 800d704:	6043      	str	r3, [r0, #4]
 800d706:	7714      	strb	r4, [r2, #28]
 800d708:	4610      	mov	r0, r2
 800d70a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d70e:	619a      	str	r2, [r3, #24]
 800d710:	f7fe bcfe 	b.w	800c110 <_port_switch>
 800d714:	20001a48 	.word	0x20001a48
	...

0800d720 <chSchGoSleepTimeoutS>:
 800d720:	b530      	push	{r4, r5, lr}
 800d722:	1c4b      	adds	r3, r1, #1
 800d724:	b087      	sub	sp, #28
 800d726:	d012      	beq.n	800d74e <chSchGoSleepTimeoutS+0x2e>
 800d728:	4c0c      	ldr	r4, [pc, #48]	; (800d75c <chSchGoSleepTimeoutS+0x3c>)
 800d72a:	4a0d      	ldr	r2, [pc, #52]	; (800d760 <chSchGoSleepTimeoutS+0x40>)
 800d72c:	69a3      	ldr	r3, [r4, #24]
 800d72e:	4605      	mov	r5, r0
 800d730:	a801      	add	r0, sp, #4
 800d732:	f7ff ff45 	bl	800d5c0 <chVTDoSetI>
 800d736:	4628      	mov	r0, r5
 800d738:	f7ff ffda 	bl	800d6f0 <chSchGoSleepS>
 800d73c:	9b04      	ldr	r3, [sp, #16]
 800d73e:	b113      	cbz	r3, 800d746 <chSchGoSleepTimeoutS+0x26>
 800d740:	a801      	add	r0, sp, #4
 800d742:	f7ff ff5d 	bl	800d600 <chVTDoResetI>
 800d746:	69a3      	ldr	r3, [r4, #24]
 800d748:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d74a:	b007      	add	sp, #28
 800d74c:	bd30      	pop	{r4, r5, pc}
 800d74e:	4c03      	ldr	r4, [pc, #12]	; (800d75c <chSchGoSleepTimeoutS+0x3c>)
 800d750:	f7ff ffce 	bl	800d6f0 <chSchGoSleepS>
 800d754:	69a3      	ldr	r3, [r4, #24]
 800d756:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d758:	b007      	add	sp, #28
 800d75a:	bd30      	pop	{r4, r5, pc}
 800d75c:	20001a48 	.word	0x20001a48
 800d760:	0800d631 	.word	0x0800d631
	...

0800d770 <chSchWakeupS>:
 800d770:	4b14      	ldr	r3, [pc, #80]	; (800d7c4 <chSchWakeupS+0x54>)
 800d772:	b470      	push	{r4, r5, r6}
 800d774:	4604      	mov	r4, r0
 800d776:	699d      	ldr	r5, [r3, #24]
 800d778:	6241      	str	r1, [r0, #36]	; 0x24
 800d77a:	68a8      	ldr	r0, [r5, #8]
 800d77c:	68a1      	ldr	r1, [r4, #8]
 800d77e:	4281      	cmp	r1, r0
 800d780:	f04f 0200 	mov.w	r2, #0
 800d784:	d80b      	bhi.n	800d79e <chSchWakeupS+0x2e>
 800d786:	7722      	strb	r2, [r4, #28]
 800d788:	681b      	ldr	r3, [r3, #0]
 800d78a:	689a      	ldr	r2, [r3, #8]
 800d78c:	4291      	cmp	r1, r2
 800d78e:	d9fb      	bls.n	800d788 <chSchWakeupS+0x18>
 800d790:	685a      	ldr	r2, [r3, #4]
 800d792:	6062      	str	r2, [r4, #4]
 800d794:	6023      	str	r3, [r4, #0]
 800d796:	6014      	str	r4, [r2, #0]
 800d798:	605c      	str	r4, [r3, #4]
 800d79a:	bc70      	pop	{r4, r5, r6}
 800d79c:	4770      	bx	lr
 800d79e:	772a      	strb	r2, [r5, #28]
 800d7a0:	461a      	mov	r2, r3
 800d7a2:	6812      	ldr	r2, [r2, #0]
 800d7a4:	6891      	ldr	r1, [r2, #8]
 800d7a6:	4288      	cmp	r0, r1
 800d7a8:	d9fb      	bls.n	800d7a2 <chSchWakeupS+0x32>
 800d7aa:	6850      	ldr	r0, [r2, #4]
 800d7ac:	6068      	str	r0, [r5, #4]
 800d7ae:	2601      	movs	r6, #1
 800d7b0:	602a      	str	r2, [r5, #0]
 800d7b2:	6005      	str	r5, [r0, #0]
 800d7b4:	6055      	str	r5, [r2, #4]
 800d7b6:	7726      	strb	r6, [r4, #28]
 800d7b8:	4629      	mov	r1, r5
 800d7ba:	4620      	mov	r0, r4
 800d7bc:	619c      	str	r4, [r3, #24]
 800d7be:	bc70      	pop	{r4, r5, r6}
 800d7c0:	f7fe bca6 	b.w	800c110 <_port_switch>
 800d7c4:	20001a48 	.word	0x20001a48
	...

0800d7d0 <chSchIsPreemptionRequired>:
 800d7d0:	4b08      	ldr	r3, [pc, #32]	; (800d7f4 <chSchIsPreemptionRequired+0x24>)
 800d7d2:	699a      	ldr	r2, [r3, #24]
 800d7d4:	681b      	ldr	r3, [r3, #0]
 800d7d6:	7fd1      	ldrb	r1, [r2, #31]
 800d7d8:	689b      	ldr	r3, [r3, #8]
 800d7da:	6890      	ldr	r0, [r2, #8]
 800d7dc:	b921      	cbnz	r1, 800d7e8 <chSchIsPreemptionRequired+0x18>
 800d7de:	4283      	cmp	r3, r0
 800d7e0:	bf34      	ite	cc
 800d7e2:	2000      	movcc	r0, #0
 800d7e4:	2001      	movcs	r0, #1
 800d7e6:	4770      	bx	lr
 800d7e8:	4283      	cmp	r3, r0
 800d7ea:	bf94      	ite	ls
 800d7ec:	2000      	movls	r0, #0
 800d7ee:	2001      	movhi	r0, #1
 800d7f0:	4770      	bx	lr
 800d7f2:	bf00      	nop
 800d7f4:	20001a48 	.word	0x20001a48
	...

0800d800 <chSchDoRescheduleBehind>:
 800d800:	4a0e      	ldr	r2, [pc, #56]	; (800d83c <chSchDoRescheduleBehind+0x3c>)
 800d802:	6810      	ldr	r0, [r2, #0]
 800d804:	6803      	ldr	r3, [r0, #0]
 800d806:	b470      	push	{r4, r5, r6}
 800d808:	2101      	movs	r1, #1
 800d80a:	6994      	ldr	r4, [r2, #24]
 800d80c:	605a      	str	r2, [r3, #4]
 800d80e:	2604      	movs	r6, #4
 800d810:	7701      	strb	r1, [r0, #28]
 800d812:	2500      	movs	r5, #0
 800d814:	68a1      	ldr	r1, [r4, #8]
 800d816:	6013      	str	r3, [r2, #0]
 800d818:	6190      	str	r0, [r2, #24]
 800d81a:	77e6      	strb	r6, [r4, #31]
 800d81c:	7725      	strb	r5, [r4, #28]
 800d81e:	e000      	b.n	800d822 <chSchDoRescheduleBehind+0x22>
 800d820:	681b      	ldr	r3, [r3, #0]
 800d822:	689a      	ldr	r2, [r3, #8]
 800d824:	428a      	cmp	r2, r1
 800d826:	d2fb      	bcs.n	800d820 <chSchDoRescheduleBehind+0x20>
 800d828:	685a      	ldr	r2, [r3, #4]
 800d82a:	6062      	str	r2, [r4, #4]
 800d82c:	6023      	str	r3, [r4, #0]
 800d82e:	4621      	mov	r1, r4
 800d830:	6014      	str	r4, [r2, #0]
 800d832:	605c      	str	r4, [r3, #4]
 800d834:	bc70      	pop	{r4, r5, r6}
 800d836:	f7fe bc6b 	b.w	800c110 <_port_switch>
 800d83a:	bf00      	nop
 800d83c:	20001a48 	.word	0x20001a48

0800d840 <chSchDoRescheduleAhead>:
 800d840:	4a0d      	ldr	r2, [pc, #52]	; (800d878 <chSchDoRescheduleAhead+0x38>)
 800d842:	6810      	ldr	r0, [r2, #0]
 800d844:	6803      	ldr	r3, [r0, #0]
 800d846:	b430      	push	{r4, r5}
 800d848:	2101      	movs	r1, #1
 800d84a:	6994      	ldr	r4, [r2, #24]
 800d84c:	605a      	str	r2, [r3, #4]
 800d84e:	2500      	movs	r5, #0
 800d850:	7701      	strb	r1, [r0, #28]
 800d852:	68a1      	ldr	r1, [r4, #8]
 800d854:	6013      	str	r3, [r2, #0]
 800d856:	6190      	str	r0, [r2, #24]
 800d858:	7725      	strb	r5, [r4, #28]
 800d85a:	e000      	b.n	800d85e <chSchDoRescheduleAhead+0x1e>
 800d85c:	681b      	ldr	r3, [r3, #0]
 800d85e:	689a      	ldr	r2, [r3, #8]
 800d860:	428a      	cmp	r2, r1
 800d862:	d8fb      	bhi.n	800d85c <chSchDoRescheduleAhead+0x1c>
 800d864:	685a      	ldr	r2, [r3, #4]
 800d866:	6062      	str	r2, [r4, #4]
 800d868:	6023      	str	r3, [r4, #0]
 800d86a:	4621      	mov	r1, r4
 800d86c:	6014      	str	r4, [r2, #0]
 800d86e:	605c      	str	r4, [r3, #4]
 800d870:	bc30      	pop	{r4, r5}
 800d872:	f7fe bc4d 	b.w	800c110 <_port_switch>
 800d876:	bf00      	nop
 800d878:	20001a48 	.word	0x20001a48
 800d87c:	00000000 	.word	0x00000000

0800d880 <chSchRescheduleS>:
 800d880:	4b04      	ldr	r3, [pc, #16]	; (800d894 <chSchRescheduleS+0x14>)
 800d882:	681a      	ldr	r2, [r3, #0]
 800d884:	699b      	ldr	r3, [r3, #24]
 800d886:	6892      	ldr	r2, [r2, #8]
 800d888:	689b      	ldr	r3, [r3, #8]
 800d88a:	429a      	cmp	r2, r3
 800d88c:	d800      	bhi.n	800d890 <chSchRescheduleS+0x10>
 800d88e:	4770      	bx	lr
 800d890:	f7ff bfd6 	b.w	800d840 <chSchDoRescheduleAhead>
 800d894:	20001a48 	.word	0x20001a48
	...

0800d8a0 <chSchDoReschedule>:
 800d8a0:	4b03      	ldr	r3, [pc, #12]	; (800d8b0 <chSchDoReschedule+0x10>)
 800d8a2:	699b      	ldr	r3, [r3, #24]
 800d8a4:	7fdb      	ldrb	r3, [r3, #31]
 800d8a6:	b10b      	cbz	r3, 800d8ac <chSchDoReschedule+0xc>
 800d8a8:	f7ff bfca 	b.w	800d840 <chSchDoRescheduleAhead>
 800d8ac:	f7ff bfa8 	b.w	800d800 <chSchDoRescheduleBehind>
 800d8b0:	20001a48 	.word	0x20001a48
	...

0800d8c0 <_thread_init>:
 800d8c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d8c2:	4c0f      	ldr	r4, [pc, #60]	; (800d900 <_thread_init+0x40>)
 800d8c4:	6401      	str	r1, [r0, #64]	; 0x40
 800d8c6:	6965      	ldr	r5, [r4, #20]
 800d8c8:	6081      	str	r1, [r0, #8]
 800d8ca:	2602      	movs	r6, #2
 800d8cc:	2200      	movs	r2, #0
 800d8ce:	7706      	strb	r6, [r0, #28]
 800d8d0:	f100 012c 	add.w	r1, r0, #44	; 0x2c
 800d8d4:	f04f 0e04 	mov.w	lr, #4
 800d8d8:	2701      	movs	r7, #1
 800d8da:	f100 0628 	add.w	r6, r0, #40	; 0x28
 800d8de:	6145      	str	r5, [r0, #20]
 800d8e0:	6104      	str	r4, [r0, #16]
 800d8e2:	f880 e01f 	strb.w	lr, [r0, #31]
 800d8e6:	7787      	strb	r7, [r0, #30]
 800d8e8:	7742      	strb	r2, [r0, #29]
 800d8ea:	63c2      	str	r2, [r0, #60]	; 0x3c
 800d8ec:	6382      	str	r2, [r0, #56]	; 0x38
 800d8ee:	6202      	str	r2, [r0, #32]
 800d8f0:	6182      	str	r2, [r0, #24]
 800d8f2:	6128      	str	r0, [r5, #16]
 800d8f4:	6160      	str	r0, [r4, #20]
 800d8f6:	6286      	str	r6, [r0, #40]	; 0x28
 800d8f8:	62c1      	str	r1, [r0, #44]	; 0x2c
 800d8fa:	6301      	str	r1, [r0, #48]	; 0x30
 800d8fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d8fe:	bf00      	nop
 800d900:	20001a48 	.word	0x20001a48
	...

0800d910 <chThdCreateI>:
 800d910:	3964      	subs	r1, #100	; 0x64
 800d912:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d914:	4401      	add	r1, r0
 800d916:	4e12      	ldr	r6, [pc, #72]	; (800d960 <chThdCreateI+0x50>)
 800d918:	4d12      	ldr	r5, [pc, #72]	; (800d964 <chThdCreateI+0x54>)
 800d91a:	6977      	ldr	r7, [r6, #20]
 800d91c:	60c1      	str	r1, [r0, #12]
 800d91e:	640b      	str	r3, [r1, #64]	; 0x40
 800d920:	9b05      	ldr	r3, [sp, #20]
 800d922:	644b      	str	r3, [r1, #68]	; 0x44
 800d924:	2302      	movs	r3, #2
 800d926:	660d      	str	r5, [r1, #96]	; 0x60
 800d928:	f04f 0e04 	mov.w	lr, #4
 800d92c:	6082      	str	r2, [r0, #8]
 800d92e:	6402      	str	r2, [r0, #64]	; 0x40
 800d930:	7703      	strb	r3, [r0, #28]
 800d932:	f100 022c 	add.w	r2, r0, #44	; 0x2c
 800d936:	2300      	movs	r3, #0
 800d938:	2501      	movs	r5, #1
 800d93a:	f100 0128 	add.w	r1, r0, #40	; 0x28
 800d93e:	6106      	str	r6, [r0, #16]
 800d940:	6147      	str	r7, [r0, #20]
 800d942:	f880 e01f 	strb.w	lr, [r0, #31]
 800d946:	7785      	strb	r5, [r0, #30]
 800d948:	7743      	strb	r3, [r0, #29]
 800d94a:	63c3      	str	r3, [r0, #60]	; 0x3c
 800d94c:	6383      	str	r3, [r0, #56]	; 0x38
 800d94e:	6203      	str	r3, [r0, #32]
 800d950:	6183      	str	r3, [r0, #24]
 800d952:	6138      	str	r0, [r7, #16]
 800d954:	6281      	str	r1, [r0, #40]	; 0x28
 800d956:	6170      	str	r0, [r6, #20]
 800d958:	62c2      	str	r2, [r0, #44]	; 0x2c
 800d95a:	6302      	str	r2, [r0, #48]	; 0x30
 800d95c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d95e:	bf00      	nop
 800d960:	20001a48 	.word	0x20001a48
 800d964:	0800c129 	.word	0x0800c129
	...

0800d970 <chThdCreateStatic>:
 800d970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d972:	461d      	mov	r5, r3
 800d974:	4604      	mov	r4, r0
 800d976:	2320      	movs	r3, #32
 800d978:	f383 8811 	msr	BASEPRI, r3
 800d97c:	3964      	subs	r1, #100	; 0x64
 800d97e:	4401      	add	r1, r0
 800d980:	4e13      	ldr	r6, [pc, #76]	; (800d9d0 <chThdCreateStatic+0x60>)
 800d982:	4b14      	ldr	r3, [pc, #80]	; (800d9d4 <chThdCreateStatic+0x64>)
 800d984:	6977      	ldr	r7, [r6, #20]
 800d986:	60c1      	str	r1, [r0, #12]
 800d988:	640d      	str	r5, [r1, #64]	; 0x40
 800d98a:	9d06      	ldr	r5, [sp, #24]
 800d98c:	644d      	str	r5, [r1, #68]	; 0x44
 800d98e:	660b      	str	r3, [r1, #96]	; 0x60
 800d990:	2502      	movs	r5, #2
 800d992:	2304      	movs	r3, #4
 800d994:	6082      	str	r2, [r0, #8]
 800d996:	6402      	str	r2, [r0, #64]	; 0x40
 800d998:	7705      	strb	r5, [r0, #28]
 800d99a:	77c3      	strb	r3, [r0, #31]
 800d99c:	2500      	movs	r5, #0
 800d99e:	f100 032c 	add.w	r3, r0, #44	; 0x2c
 800d9a2:	f100 0228 	add.w	r2, r0, #40	; 0x28
 800d9a6:	2101      	movs	r1, #1
 800d9a8:	7781      	strb	r1, [r0, #30]
 800d9aa:	6106      	str	r6, [r0, #16]
 800d9ac:	6147      	str	r7, [r0, #20]
 800d9ae:	7745      	strb	r5, [r0, #29]
 800d9b0:	63c5      	str	r5, [r0, #60]	; 0x3c
 800d9b2:	6385      	str	r5, [r0, #56]	; 0x38
 800d9b4:	6205      	str	r5, [r0, #32]
 800d9b6:	6185      	str	r5, [r0, #24]
 800d9b8:	4629      	mov	r1, r5
 800d9ba:	6138      	str	r0, [r7, #16]
 800d9bc:	6282      	str	r2, [r0, #40]	; 0x28
 800d9be:	62c3      	str	r3, [r0, #44]	; 0x2c
 800d9c0:	6303      	str	r3, [r0, #48]	; 0x30
 800d9c2:	6170      	str	r0, [r6, #20]
 800d9c4:	f7ff fed4 	bl	800d770 <chSchWakeupS>
 800d9c8:	f385 8811 	msr	BASEPRI, r5
 800d9cc:	4620      	mov	r0, r4
 800d9ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d9d0:	20001a48 	.word	0x20001a48
 800d9d4:	0800c129 	.word	0x0800c129
	...

0800d9e0 <chThdSleep>:
 800d9e0:	b508      	push	{r3, lr}
 800d9e2:	4601      	mov	r1, r0
 800d9e4:	2320      	movs	r3, #32
 800d9e6:	f383 8811 	msr	BASEPRI, r3
 800d9ea:	2008      	movs	r0, #8
 800d9ec:	f7ff fe98 	bl	800d720 <chSchGoSleepTimeoutS>
 800d9f0:	2300      	movs	r3, #0
 800d9f2:	f383 8811 	msr	BASEPRI, r3
 800d9f6:	bd08      	pop	{r3, pc}
	...

0800da00 <chThdExitS>:
 800da00:	b538      	push	{r3, r4, r5, lr}
 800da02:	4b0e      	ldr	r3, [pc, #56]	; (800da3c <chThdExitS+0x3c>)
 800da04:	699c      	ldr	r4, [r3, #24]
 800da06:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800da08:	6260      	str	r0, [r4, #36]	; 0x24
 800da0a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800da0e:	429d      	cmp	r5, r3
 800da10:	d007      	beq.n	800da22 <chThdExitS+0x22>
 800da12:	681a      	ldr	r2, [r3, #0]
 800da14:	62a2      	str	r2, [r4, #40]	; 0x28
 800da16:	4618      	mov	r0, r3
 800da18:	f7ff fe52 	bl	800d6c0 <chSchReadyI>
 800da1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800da1e:	42ab      	cmp	r3, r5
 800da20:	d1f7      	bne.n	800da12 <chThdExitS+0x12>
 800da22:	7f63      	ldrb	r3, [r4, #29]
 800da24:	079b      	lsls	r3, r3, #30
 800da26:	d104      	bne.n	800da32 <chThdExitS+0x32>
 800da28:	6963      	ldr	r3, [r4, #20]
 800da2a:	6922      	ldr	r2, [r4, #16]
 800da2c:	611a      	str	r2, [r3, #16]
 800da2e:	6922      	ldr	r2, [r4, #16]
 800da30:	6153      	str	r3, [r2, #20]
 800da32:	200f      	movs	r0, #15
 800da34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800da38:	f7ff be5a 	b.w	800d6f0 <chSchGoSleepS>
 800da3c:	20001a48 	.word	0x20001a48

0800da40 <chThdExit>:
 800da40:	2320      	movs	r3, #32
 800da42:	f383 8811 	msr	BASEPRI, r3
 800da46:	f7ff bfdb 	b.w	800da00 <chThdExitS>
 800da4a:	bf00      	nop
 800da4c:	0000      	movs	r0, r0
	...

0800da50 <chThdSuspendS>:
 800da50:	b510      	push	{r4, lr}
 800da52:	4c05      	ldr	r4, [pc, #20]	; (800da68 <chThdSuspendS+0x18>)
 800da54:	69a3      	ldr	r3, [r4, #24]
 800da56:	6003      	str	r3, [r0, #0]
 800da58:	4602      	mov	r2, r0
 800da5a:	625a      	str	r2, [r3, #36]	; 0x24
 800da5c:	2003      	movs	r0, #3
 800da5e:	f7ff fe47 	bl	800d6f0 <chSchGoSleepS>
 800da62:	69a3      	ldr	r3, [r4, #24]
 800da64:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800da66:	bd10      	pop	{r4, pc}
 800da68:	20001a48 	.word	0x20001a48
 800da6c:	00000000 	.word	0x00000000

0800da70 <chThdSuspendTimeoutS>:
 800da70:	4b05      	ldr	r3, [pc, #20]	; (800da88 <chThdSuspendTimeoutS+0x18>)
 800da72:	4602      	mov	r2, r0
 800da74:	699b      	ldr	r3, [r3, #24]
 800da76:	b121      	cbz	r1, 800da82 <chThdSuspendTimeoutS+0x12>
 800da78:	6003      	str	r3, [r0, #0]
 800da7a:	2003      	movs	r0, #3
 800da7c:	625a      	str	r2, [r3, #36]	; 0x24
 800da7e:	f7ff be4f 	b.w	800d720 <chSchGoSleepTimeoutS>
 800da82:	f04f 30ff 	mov.w	r0, #4294967295
 800da86:	4770      	bx	lr
 800da88:	20001a48 	.word	0x20001a48
 800da8c:	00000000 	.word	0x00000000

0800da90 <chThdResumeI>:
 800da90:	6803      	ldr	r3, [r0, #0]
 800da92:	b12b      	cbz	r3, 800daa0 <chThdResumeI+0x10>
 800da94:	2200      	movs	r2, #0
 800da96:	6002      	str	r2, [r0, #0]
 800da98:	4618      	mov	r0, r3
 800da9a:	6259      	str	r1, [r3, #36]	; 0x24
 800da9c:	f7ff be10 	b.w	800d6c0 <chSchReadyI>
 800daa0:	4770      	bx	lr
 800daa2:	bf00      	nop
	...

0800dab0 <chThdEnqueueTimeoutS>:
 800dab0:	b169      	cbz	r1, 800dace <chThdEnqueueTimeoutS+0x1e>
 800dab2:	4b08      	ldr	r3, [pc, #32]	; (800dad4 <chThdEnqueueTimeoutS+0x24>)
 800dab4:	b410      	push	{r4}
 800dab6:	4602      	mov	r2, r0
 800dab8:	6844      	ldr	r4, [r0, #4]
 800daba:	699b      	ldr	r3, [r3, #24]
 800dabc:	2004      	movs	r0, #4
 800dabe:	e883 0014 	stmia.w	r3, {r2, r4}
 800dac2:	6023      	str	r3, [r4, #0]
 800dac4:	6053      	str	r3, [r2, #4]
 800dac6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800daca:	f7ff be29 	b.w	800d720 <chSchGoSleepTimeoutS>
 800dace:	f04f 30ff 	mov.w	r0, #4294967295
 800dad2:	4770      	bx	lr
 800dad4:	20001a48 	.word	0x20001a48
	...

0800dae0 <chThdDequeueAllI>:
 800dae0:	b538      	push	{r3, r4, r5, lr}
 800dae2:	6803      	ldr	r3, [r0, #0]
 800dae4:	4298      	cmp	r0, r3
 800dae6:	d00b      	beq.n	800db00 <chThdDequeueAllI+0x20>
 800dae8:	4604      	mov	r4, r0
 800daea:	460d      	mov	r5, r1
 800daec:	681a      	ldr	r2, [r3, #0]
 800daee:	6022      	str	r2, [r4, #0]
 800daf0:	4618      	mov	r0, r3
 800daf2:	6054      	str	r4, [r2, #4]
 800daf4:	625d      	str	r5, [r3, #36]	; 0x24
 800daf6:	f7ff fde3 	bl	800d6c0 <chSchReadyI>
 800dafa:	6823      	ldr	r3, [r4, #0]
 800dafc:	429c      	cmp	r4, r3
 800dafe:	d1f5      	bne.n	800daec <chThdDequeueAllI+0xc>
 800db00:	bd38      	pop	{r3, r4, r5, pc}
 800db02:	bf00      	nop
	...

0800db10 <chTMStartMeasurementX>:
 800db10:	4b01      	ldr	r3, [pc, #4]	; (800db18 <chTMStartMeasurementX+0x8>)
 800db12:	685b      	ldr	r3, [r3, #4]
 800db14:	6083      	str	r3, [r0, #8]
 800db16:	4770      	bx	lr
 800db18:	e0001000 	.word	0xe0001000
 800db1c:	00000000 	.word	0x00000000

0800db20 <chTMStopMeasurementX>:
 800db20:	4b0f      	ldr	r3, [pc, #60]	; (800db60 <chTMStopMeasurementX+0x40>)
 800db22:	4910      	ldr	r1, [pc, #64]	; (800db64 <chTMStopMeasurementX+0x44>)
 800db24:	685a      	ldr	r2, [r3, #4]
 800db26:	6883      	ldr	r3, [r0, #8]
 800db28:	b4f0      	push	{r4, r5, r6, r7}
 800db2a:	6f8f      	ldr	r7, [r1, #120]	; 0x78
 800db2c:	68c6      	ldr	r6, [r0, #12]
 800db2e:	6841      	ldr	r1, [r0, #4]
 800db30:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 800db34:	1ad3      	subs	r3, r2, r3
 800db36:	1bdb      	subs	r3, r3, r7
 800db38:	18e4      	adds	r4, r4, r3
 800db3a:	f145 0500 	adc.w	r5, r5, #0
 800db3e:	3601      	adds	r6, #1
 800db40:	428b      	cmp	r3, r1
 800db42:	60c6      	str	r6, [r0, #12]
 800db44:	6083      	str	r3, [r0, #8]
 800db46:	e9c0 4504 	strd	r4, r5, [r0, #16]
 800db4a:	d805      	bhi.n	800db58 <chTMStopMeasurementX+0x38>
 800db4c:	6802      	ldr	r2, [r0, #0]
 800db4e:	4293      	cmp	r3, r2
 800db50:	bf38      	it	cc
 800db52:	6003      	strcc	r3, [r0, #0]
 800db54:	bcf0      	pop	{r4, r5, r6, r7}
 800db56:	4770      	bx	lr
 800db58:	6043      	str	r3, [r0, #4]
 800db5a:	bcf0      	pop	{r4, r5, r6, r7}
 800db5c:	4770      	bx	lr
 800db5e:	bf00      	nop
 800db60:	e0001000 	.word	0xe0001000
 800db64:	20001a48 	.word	0x20001a48
	...

0800db70 <_tm_init>:
 800db70:	b5d0      	push	{r4, r6, r7, lr}
 800db72:	4c0c      	ldr	r4, [pc, #48]	; (800dba4 <_tm_init+0x34>)
 800db74:	b086      	sub	sp, #24
 800db76:	2300      	movs	r3, #0
 800db78:	f04f 32ff 	mov.w	r2, #4294967295
 800db7c:	4668      	mov	r0, sp
 800db7e:	2600      	movs	r6, #0
 800db80:	2700      	movs	r7, #0
 800db82:	67a3      	str	r3, [r4, #120]	; 0x78
 800db84:	9301      	str	r3, [sp, #4]
 800db86:	9302      	str	r3, [sp, #8]
 800db88:	9303      	str	r3, [sp, #12]
 800db8a:	9200      	str	r2, [sp, #0]
 800db8c:	e9cd 6704 	strd	r6, r7, [sp, #16]
 800db90:	f7ff ffbe 	bl	800db10 <chTMStartMeasurementX>
 800db94:	4668      	mov	r0, sp
 800db96:	f7ff ffc3 	bl	800db20 <chTMStopMeasurementX>
 800db9a:	9b02      	ldr	r3, [sp, #8]
 800db9c:	67a3      	str	r3, [r4, #120]	; 0x78
 800db9e:	b006      	add	sp, #24
 800dba0:	bdd0      	pop	{r4, r6, r7, pc}
 800dba2:	bf00      	nop
 800dba4:	20001a48 	.word	0x20001a48
	...

0800dbb0 <chThdRelease>:
 800dbb0:	4601      	mov	r1, r0
 800dbb2:	2320      	movs	r3, #32
 800dbb4:	f383 8811 	msr	BASEPRI, r3
 800dbb8:	7f83      	ldrb	r3, [r0, #30]
 800dbba:	3b01      	subs	r3, #1
 800dbbc:	b2db      	uxtb	r3, r3
 800dbbe:	7783      	strb	r3, [r0, #30]
 800dbc0:	2200      	movs	r2, #0
 800dbc2:	f382 8811 	msr	BASEPRI, r2
 800dbc6:	b913      	cbnz	r3, 800dbce <chThdRelease+0x1e>
 800dbc8:	7f03      	ldrb	r3, [r0, #28]
 800dbca:	2b0f      	cmp	r3, #15
 800dbcc:	d000      	beq.n	800dbd0 <chThdRelease+0x20>
 800dbce:	4770      	bx	lr
 800dbd0:	7f43      	ldrb	r3, [r0, #29]
 800dbd2:	f003 0303 	and.w	r3, r3, #3
 800dbd6:	2b01      	cmp	r3, #1
 800dbd8:	d002      	beq.n	800dbe0 <chThdRelease+0x30>
 800dbda:	2b02      	cmp	r3, #2
 800dbdc:	d007      	beq.n	800dbee <chThdRelease+0x3e>
 800dbde:	4770      	bx	lr
 800dbe0:	6943      	ldr	r3, [r0, #20]
 800dbe2:	6902      	ldr	r2, [r0, #16]
 800dbe4:	611a      	str	r2, [r3, #16]
 800dbe6:	6902      	ldr	r2, [r0, #16]
 800dbe8:	6153      	str	r3, [r2, #20]
 800dbea:	f000 bb19 	b.w	800e220 <chHeapFree>
 800dbee:	6943      	ldr	r3, [r0, #20]
 800dbf0:	6902      	ldr	r2, [r0, #16]
 800dbf2:	611a      	str	r2, [r3, #16]
 800dbf4:	6902      	ldr	r2, [r0, #16]
 800dbf6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800dbf8:	6153      	str	r3, [r2, #20]
 800dbfa:	f000 bb89 	b.w	800e310 <chPoolFree>
 800dbfe:	bf00      	nop

0800dc00 <chRegFirstThread>:
 800dc00:	2320      	movs	r3, #32
 800dc02:	f383 8811 	msr	BASEPRI, r3
 800dc06:	4b04      	ldr	r3, [pc, #16]	; (800dc18 <chRegFirstThread+0x18>)
 800dc08:	6918      	ldr	r0, [r3, #16]
 800dc0a:	7f83      	ldrb	r3, [r0, #30]
 800dc0c:	3301      	adds	r3, #1
 800dc0e:	7783      	strb	r3, [r0, #30]
 800dc10:	2300      	movs	r3, #0
 800dc12:	f383 8811 	msr	BASEPRI, r3
 800dc16:	4770      	bx	lr
 800dc18:	20001a48 	.word	0x20001a48
 800dc1c:	00000000 	.word	0x00000000

0800dc20 <chRegNextThread>:
 800dc20:	b510      	push	{r4, lr}
 800dc22:	2320      	movs	r3, #32
 800dc24:	f383 8811 	msr	BASEPRI, r3
 800dc28:	4b07      	ldr	r3, [pc, #28]	; (800dc48 <chRegNextThread+0x28>)
 800dc2a:	6904      	ldr	r4, [r0, #16]
 800dc2c:	429c      	cmp	r4, r3
 800dc2e:	bf1d      	ittte	ne
 800dc30:	7fa3      	ldrbne	r3, [r4, #30]
 800dc32:	3301      	addne	r3, #1
 800dc34:	77a3      	strbne	r3, [r4, #30]
 800dc36:	2400      	moveq	r4, #0
 800dc38:	2300      	movs	r3, #0
 800dc3a:	f383 8811 	msr	BASEPRI, r3
 800dc3e:	f7ff ffb7 	bl	800dbb0 <chThdRelease>
 800dc42:	4620      	mov	r0, r4
 800dc44:	bd10      	pop	{r4, pc}
 800dc46:	bf00      	nop
 800dc48:	20001a48 	.word	0x20001a48
 800dc4c:	00000000 	.word	0x00000000

0800dc50 <chMtxObjectInit>:
 800dc50:	2300      	movs	r3, #0
 800dc52:	6000      	str	r0, [r0, #0]
 800dc54:	6040      	str	r0, [r0, #4]
 800dc56:	6083      	str	r3, [r0, #8]
 800dc58:	4770      	bx	lr
 800dc5a:	bf00      	nop
 800dc5c:	0000      	movs	r0, r0
	...

0800dc60 <chMtxLockS>:
 800dc60:	4b30      	ldr	r3, [pc, #192]	; (800dd24 <chMtxLockS+0xc4>)
 800dc62:	6882      	ldr	r2, [r0, #8]
 800dc64:	b570      	push	{r4, r5, r6, lr}
 800dc66:	699c      	ldr	r4, [r3, #24]
 800dc68:	2a00      	cmp	r2, #0
 800dc6a:	d055      	beq.n	800dd18 <chMtxLockS+0xb8>
 800dc6c:	68a1      	ldr	r1, [r4, #8]
 800dc6e:	6893      	ldr	r3, [r2, #8]
 800dc70:	428b      	cmp	r3, r1
 800dc72:	4605      	mov	r5, r0
 800dc74:	d206      	bcs.n	800dc84 <chMtxLockS+0x24>
 800dc76:	7f13      	ldrb	r3, [r2, #28]
 800dc78:	6091      	str	r1, [r2, #8]
 800dc7a:	2b06      	cmp	r3, #6
 800dc7c:	d033      	beq.n	800dce6 <chMtxLockS+0x86>
 800dc7e:	2b07      	cmp	r3, #7
 800dc80:	d01d      	beq.n	800dcbe <chMtxLockS+0x5e>
 800dc82:	b19b      	cbz	r3, 800dcac <chMtxLockS+0x4c>
 800dc84:	462b      	mov	r3, r5
 800dc86:	e003      	b.n	800dc90 <chMtxLockS+0x30>
 800dc88:	6899      	ldr	r1, [r3, #8]
 800dc8a:	68a2      	ldr	r2, [r4, #8]
 800dc8c:	4291      	cmp	r1, r2
 800dc8e:	d302      	bcc.n	800dc96 <chMtxLockS+0x36>
 800dc90:	681b      	ldr	r3, [r3, #0]
 800dc92:	429d      	cmp	r5, r3
 800dc94:	d1f8      	bne.n	800dc88 <chMtxLockS+0x28>
 800dc96:	685a      	ldr	r2, [r3, #4]
 800dc98:	6062      	str	r2, [r4, #4]
 800dc9a:	6023      	str	r3, [r4, #0]
 800dc9c:	6014      	str	r4, [r2, #0]
 800dc9e:	605c      	str	r4, [r3, #4]
 800dca0:	6265      	str	r5, [r4, #36]	; 0x24
 800dca2:	2006      	movs	r0, #6
 800dca4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800dca8:	f7ff bd22 	b.w	800d6f0 <chSchGoSleepS>
 800dcac:	e892 000a 	ldmia.w	r2, {r1, r3}
 800dcb0:	6019      	str	r1, [r3, #0]
 800dcb2:	6811      	ldr	r1, [r2, #0]
 800dcb4:	4610      	mov	r0, r2
 800dcb6:	604b      	str	r3, [r1, #4]
 800dcb8:	f7ff fd02 	bl	800d6c0 <chSchReadyI>
 800dcbc:	e7e2      	b.n	800dc84 <chMtxLockS+0x24>
 800dcbe:	e892 0009 	ldmia.w	r2, {r0, r3}
 800dcc2:	6018      	str	r0, [r3, #0]
 800dcc4:	6810      	ldr	r0, [r2, #0]
 800dcc6:	6043      	str	r3, [r0, #4]
 800dcc8:	6a56      	ldr	r6, [r2, #36]	; 0x24
 800dcca:	4633      	mov	r3, r6
 800dccc:	e002      	b.n	800dcd4 <chMtxLockS+0x74>
 800dcce:	6898      	ldr	r0, [r3, #8]
 800dcd0:	4288      	cmp	r0, r1
 800dcd2:	d302      	bcc.n	800dcda <chMtxLockS+0x7a>
 800dcd4:	681b      	ldr	r3, [r3, #0]
 800dcd6:	429e      	cmp	r6, r3
 800dcd8:	d1f9      	bne.n	800dcce <chMtxLockS+0x6e>
 800dcda:	6859      	ldr	r1, [r3, #4]
 800dcdc:	6051      	str	r1, [r2, #4]
 800dcde:	6013      	str	r3, [r2, #0]
 800dce0:	600a      	str	r2, [r1, #0]
 800dce2:	605a      	str	r2, [r3, #4]
 800dce4:	e7ce      	b.n	800dc84 <chMtxLockS+0x24>
 800dce6:	e892 0009 	ldmia.w	r2, {r0, r3}
 800dcea:	6018      	str	r0, [r3, #0]
 800dcec:	6810      	ldr	r0, [r2, #0]
 800dcee:	6043      	str	r3, [r0, #4]
 800dcf0:	6a56      	ldr	r6, [r2, #36]	; 0x24
 800dcf2:	4633      	mov	r3, r6
 800dcf4:	e002      	b.n	800dcfc <chMtxLockS+0x9c>
 800dcf6:	6898      	ldr	r0, [r3, #8]
 800dcf8:	4288      	cmp	r0, r1
 800dcfa:	d302      	bcc.n	800dd02 <chMtxLockS+0xa2>
 800dcfc:	681b      	ldr	r3, [r3, #0]
 800dcfe:	429e      	cmp	r6, r3
 800dd00:	d1f9      	bne.n	800dcf6 <chMtxLockS+0x96>
 800dd02:	6859      	ldr	r1, [r3, #4]
 800dd04:	6051      	str	r1, [r2, #4]
 800dd06:	6013      	str	r3, [r2, #0]
 800dd08:	600a      	str	r2, [r1, #0]
 800dd0a:	605a      	str	r2, [r3, #4]
 800dd0c:	68b2      	ldr	r2, [r6, #8]
 800dd0e:	68a1      	ldr	r1, [r4, #8]
 800dd10:	6893      	ldr	r3, [r2, #8]
 800dd12:	428b      	cmp	r3, r1
 800dd14:	d3af      	bcc.n	800dc76 <chMtxLockS+0x16>
 800dd16:	e7b5      	b.n	800dc84 <chMtxLockS+0x24>
 800dd18:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800dd1a:	60c3      	str	r3, [r0, #12]
 800dd1c:	6084      	str	r4, [r0, #8]
 800dd1e:	63e0      	str	r0, [r4, #60]	; 0x3c
 800dd20:	bd70      	pop	{r4, r5, r6, pc}
 800dd22:	bf00      	nop
 800dd24:	20001a48 	.word	0x20001a48
	...

0800dd30 <chMtxLock>:
 800dd30:	b508      	push	{r3, lr}
 800dd32:	2320      	movs	r3, #32
 800dd34:	f383 8811 	msr	BASEPRI, r3
 800dd38:	f7ff ff92 	bl	800dc60 <chMtxLockS>
 800dd3c:	2300      	movs	r3, #0
 800dd3e:	f383 8811 	msr	BASEPRI, r3
 800dd42:	bd08      	pop	{r3, pc}
	...

0800dd50 <chMtxUnlock>:
 800dd50:	4b17      	ldr	r3, [pc, #92]	; (800ddb0 <chMtxUnlock+0x60>)
 800dd52:	b570      	push	{r4, r5, r6, lr}
 800dd54:	699d      	ldr	r5, [r3, #24]
 800dd56:	2320      	movs	r3, #32
 800dd58:	f383 8811 	msr	BASEPRI, r3
 800dd5c:	6804      	ldr	r4, [r0, #0]
 800dd5e:	68c3      	ldr	r3, [r0, #12]
 800dd60:	63eb      	str	r3, [r5, #60]	; 0x3c
 800dd62:	4284      	cmp	r4, r0
 800dd64:	d01d      	beq.n	800dda2 <chMtxUnlock+0x52>
 800dd66:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800dd68:	b14b      	cbz	r3, 800dd7e <chMtxUnlock+0x2e>
 800dd6a:	681a      	ldr	r2, [r3, #0]
 800dd6c:	4293      	cmp	r3, r2
 800dd6e:	d003      	beq.n	800dd78 <chMtxUnlock+0x28>
 800dd70:	6892      	ldr	r2, [r2, #8]
 800dd72:	4291      	cmp	r1, r2
 800dd74:	bf38      	it	cc
 800dd76:	4611      	movcc	r1, r2
 800dd78:	68db      	ldr	r3, [r3, #12]
 800dd7a:	2b00      	cmp	r3, #0
 800dd7c:	d1f5      	bne.n	800dd6a <chMtxUnlock+0x1a>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	6822      	ldr	r2, [r4, #0]
 800dd82:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 800dd84:	60a9      	str	r1, [r5, #8]
 800dd86:	4620      	mov	r0, r4
 800dd88:	601a      	str	r2, [r3, #0]
 800dd8a:	6053      	str	r3, [r2, #4]
 800dd8c:	609c      	str	r4, [r3, #8]
 800dd8e:	60de      	str	r6, [r3, #12]
 800dd90:	63e3      	str	r3, [r4, #60]	; 0x3c
 800dd92:	f7ff fc95 	bl	800d6c0 <chSchReadyI>
 800dd96:	f7ff fd73 	bl	800d880 <chSchRescheduleS>
 800dd9a:	2300      	movs	r3, #0
 800dd9c:	f383 8811 	msr	BASEPRI, r3
 800dda0:	bd70      	pop	{r4, r5, r6, pc}
 800dda2:	2300      	movs	r3, #0
 800dda4:	60a3      	str	r3, [r4, #8]
 800dda6:	2300      	movs	r3, #0
 800dda8:	f383 8811 	msr	BASEPRI, r3
 800ddac:	bd70      	pop	{r4, r5, r6, pc}
 800ddae:	bf00      	nop
 800ddb0:	20001a48 	.word	0x20001a48
	...

0800ddc0 <chEvtRegisterMaskWithFlags>:
 800ddc0:	b430      	push	{r4, r5}
 800ddc2:	2420      	movs	r4, #32
 800ddc4:	f384 8811 	msr	BASEPRI, r4
 800ddc8:	4d06      	ldr	r5, [pc, #24]	; (800dde4 <chEvtRegisterMaskWithFlags+0x24>)
 800ddca:	6804      	ldr	r4, [r0, #0]
 800ddcc:	69ad      	ldr	r5, [r5, #24]
 800ddce:	600c      	str	r4, [r1, #0]
 800ddd0:	2400      	movs	r4, #0
 800ddd2:	6001      	str	r1, [r0, #0]
 800ddd4:	604d      	str	r5, [r1, #4]
 800ddd6:	608a      	str	r2, [r1, #8]
 800ddd8:	610b      	str	r3, [r1, #16]
 800ddda:	60cc      	str	r4, [r1, #12]
 800dddc:	f384 8811 	msr	BASEPRI, r4
 800dde0:	bc30      	pop	{r4, r5}
 800dde2:	4770      	bx	lr
 800dde4:	20001a48 	.word	0x20001a48
	...

0800ddf0 <chEvtUnregister>:
 800ddf0:	2320      	movs	r3, #32
 800ddf2:	f383 8811 	msr	BASEPRI, r3
 800ddf6:	4602      	mov	r2, r0
 800ddf8:	e002      	b.n	800de00 <chEvtUnregister+0x10>
 800ddfa:	428b      	cmp	r3, r1
 800ddfc:	d007      	beq.n	800de0e <chEvtUnregister+0x1e>
 800ddfe:	461a      	mov	r2, r3
 800de00:	6813      	ldr	r3, [r2, #0]
 800de02:	4298      	cmp	r0, r3
 800de04:	d1f9      	bne.n	800ddfa <chEvtUnregister+0xa>
 800de06:	2300      	movs	r3, #0
 800de08:	f383 8811 	msr	BASEPRI, r3
 800de0c:	4770      	bx	lr
 800de0e:	680b      	ldr	r3, [r1, #0]
 800de10:	6013      	str	r3, [r2, #0]
 800de12:	2300      	movs	r3, #0
 800de14:	f383 8811 	msr	BASEPRI, r3
 800de18:	4770      	bx	lr
 800de1a:	bf00      	nop
 800de1c:	0000      	movs	r0, r0
	...

0800de20 <chEvtSignalI>:
 800de20:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800de22:	7f02      	ldrb	r2, [r0, #28]
 800de24:	4319      	orrs	r1, r3
 800de26:	2a0a      	cmp	r2, #10
 800de28:	6381      	str	r1, [r0, #56]	; 0x38
 800de2a:	d009      	beq.n	800de40 <chEvtSignalI+0x20>
 800de2c:	2a0b      	cmp	r2, #11
 800de2e:	d000      	beq.n	800de32 <chEvtSignalI+0x12>
 800de30:	4770      	bx	lr
 800de32:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800de34:	438b      	bics	r3, r1
 800de36:	d1fb      	bne.n	800de30 <chEvtSignalI+0x10>
 800de38:	2300      	movs	r3, #0
 800de3a:	6243      	str	r3, [r0, #36]	; 0x24
 800de3c:	f7ff bc40 	b.w	800d6c0 <chSchReadyI>
 800de40:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800de42:	4219      	tst	r1, r3
 800de44:	d1f8      	bne.n	800de38 <chEvtSignalI+0x18>
 800de46:	4770      	bx	lr
	...

0800de50 <chEvtBroadcastFlagsI>:
 800de50:	b570      	push	{r4, r5, r6, lr}
 800de52:	6804      	ldr	r4, [r0, #0]
 800de54:	42a0      	cmp	r0, r4
 800de56:	d00f      	beq.n	800de78 <chEvtBroadcastFlagsI+0x28>
 800de58:	4606      	mov	r6, r0
 800de5a:	460d      	mov	r5, r1
 800de5c:	68e3      	ldr	r3, [r4, #12]
 800de5e:	432b      	orrs	r3, r5
 800de60:	60e3      	str	r3, [r4, #12]
 800de62:	b115      	cbz	r5, 800de6a <chEvtBroadcastFlagsI+0x1a>
 800de64:	6922      	ldr	r2, [r4, #16]
 800de66:	4213      	tst	r3, r2
 800de68:	d003      	beq.n	800de72 <chEvtBroadcastFlagsI+0x22>
 800de6a:	68a1      	ldr	r1, [r4, #8]
 800de6c:	6860      	ldr	r0, [r4, #4]
 800de6e:	f7ff ffd7 	bl	800de20 <chEvtSignalI>
 800de72:	6824      	ldr	r4, [r4, #0]
 800de74:	42a6      	cmp	r6, r4
 800de76:	d1f1      	bne.n	800de5c <chEvtBroadcastFlagsI+0xc>
 800de78:	bd70      	pop	{r4, r5, r6, pc}
 800de7a:	bf00      	nop
 800de7c:	0000      	movs	r0, r0
	...

0800de80 <chEvtSignal>:
 800de80:	b508      	push	{r3, lr}
 800de82:	2320      	movs	r3, #32
 800de84:	f383 8811 	msr	BASEPRI, r3
 800de88:	f7ff ffca 	bl	800de20 <chEvtSignalI>
 800de8c:	f7ff fcf8 	bl	800d880 <chSchRescheduleS>
 800de90:	2300      	movs	r3, #0
 800de92:	f383 8811 	msr	BASEPRI, r3
 800de96:	bd08      	pop	{r3, pc}
	...

0800dea0 <chEvtWaitAny>:
 800dea0:	b538      	push	{r3, r4, r5, lr}
 800dea2:	4b0c      	ldr	r3, [pc, #48]	; (800ded4 <chEvtWaitAny+0x34>)
 800dea4:	699d      	ldr	r5, [r3, #24]
 800dea6:	2320      	movs	r3, #32
 800dea8:	f383 8811 	msr	BASEPRI, r3
 800deac:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800deae:	ea13 0400 	ands.w	r4, r3, r0
 800deb2:	d106      	bne.n	800dec2 <chEvtWaitAny+0x22>
 800deb4:	4604      	mov	r4, r0
 800deb6:	6268      	str	r0, [r5, #36]	; 0x24
 800deb8:	200a      	movs	r0, #10
 800deba:	f7ff fc19 	bl	800d6f0 <chSchGoSleepS>
 800debe:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800dec0:	401c      	ands	r4, r3
 800dec2:	ea23 0304 	bic.w	r3, r3, r4
 800dec6:	63ab      	str	r3, [r5, #56]	; 0x38
 800dec8:	2300      	movs	r3, #0
 800deca:	f383 8811 	msr	BASEPRI, r3
 800dece:	4620      	mov	r0, r4
 800ded0:	bd38      	pop	{r3, r4, r5, pc}
 800ded2:	bf00      	nop
 800ded4:	20001a48 	.word	0x20001a48
	...

0800dee0 <chEvtWaitAnyTimeout>:
 800dee0:	4b12      	ldr	r3, [pc, #72]	; (800df2c <chEvtWaitAnyTimeout+0x4c>)
 800dee2:	b570      	push	{r4, r5, r6, lr}
 800dee4:	699e      	ldr	r6, [r3, #24]
 800dee6:	2320      	movs	r3, #32
 800dee8:	f383 8811 	msr	BASEPRI, r3
 800deec:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 800deee:	ea13 0400 	ands.w	r4, r3, r0
 800def2:	d10e      	bne.n	800df12 <chEvtWaitAnyTimeout+0x32>
 800def4:	b919      	cbnz	r1, 800defe <chEvtWaitAnyTimeout+0x1e>
 800def6:	f381 8811 	msr	BASEPRI, r1
 800defa:	4608      	mov	r0, r1
 800defc:	bd70      	pop	{r4, r5, r6, pc}
 800defe:	6270      	str	r0, [r6, #36]	; 0x24
 800df00:	4605      	mov	r5, r0
 800df02:	200a      	movs	r0, #10
 800df04:	f7ff fc0c 	bl	800d720 <chSchGoSleepTimeoutS>
 800df08:	2800      	cmp	r0, #0
 800df0a:	db0a      	blt.n	800df22 <chEvtWaitAnyTimeout+0x42>
 800df0c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 800df0e:	ea05 0403 	and.w	r4, r5, r3
 800df12:	ea23 0304 	bic.w	r3, r3, r4
 800df16:	63b3      	str	r3, [r6, #56]	; 0x38
 800df18:	2300      	movs	r3, #0
 800df1a:	f383 8811 	msr	BASEPRI, r3
 800df1e:	4620      	mov	r0, r4
 800df20:	bd70      	pop	{r4, r5, r6, pc}
 800df22:	f384 8811 	msr	BASEPRI, r4
 800df26:	4620      	mov	r0, r4
 800df28:	bd70      	pop	{r4, r5, r6, pc}
 800df2a:	bf00      	nop
 800df2c:	20001a48 	.word	0x20001a48

0800df30 <chIQObjectInit>:
 800df30:	b430      	push	{r4, r5}
 800df32:	9c02      	ldr	r4, [sp, #8]
 800df34:	6204      	str	r4, [r0, #32]
 800df36:	2500      	movs	r5, #0
 800df38:	440a      	add	r2, r1
 800df3a:	6085      	str	r5, [r0, #8]
 800df3c:	6102      	str	r2, [r0, #16]
 800df3e:	6000      	str	r0, [r0, #0]
 800df40:	6040      	str	r0, [r0, #4]
 800df42:	60c1      	str	r1, [r0, #12]
 800df44:	6181      	str	r1, [r0, #24]
 800df46:	6141      	str	r1, [r0, #20]
 800df48:	61c3      	str	r3, [r0, #28]
 800df4a:	bc30      	pop	{r4, r5}
 800df4c:	4770      	bx	lr
 800df4e:	bf00      	nop

0800df50 <chIQResetI>:
 800df50:	2100      	movs	r1, #0
 800df52:	68c2      	ldr	r2, [r0, #12]
 800df54:	6081      	str	r1, [r0, #8]
 800df56:	6182      	str	r2, [r0, #24]
 800df58:	6142      	str	r2, [r0, #20]
 800df5a:	f06f 0101 	mvn.w	r1, #1
 800df5e:	f7ff bdbf 	b.w	800dae0 <chThdDequeueAllI>
 800df62:	bf00      	nop
	...

0800df70 <chIQGetTimeout>:
 800df70:	b570      	push	{r4, r5, r6, lr}
 800df72:	2320      	movs	r3, #32
 800df74:	460e      	mov	r6, r1
 800df76:	4604      	mov	r4, r0
 800df78:	f383 8811 	msr	BASEPRI, r3
 800df7c:	69c3      	ldr	r3, [r0, #28]
 800df7e:	b12b      	cbz	r3, 800df8c <chIQGetTimeout+0x1c>
 800df80:	4798      	blx	r3
 800df82:	e003      	b.n	800df8c <chIQGetTimeout+0x1c>
 800df84:	f7ff fd94 	bl	800dab0 <chThdEnqueueTimeoutS>
 800df88:	2800      	cmp	r0, #0
 800df8a:	db15      	blt.n	800dfb8 <chIQGetTimeout+0x48>
 800df8c:	68a5      	ldr	r5, [r4, #8]
 800df8e:	4631      	mov	r1, r6
 800df90:	4620      	mov	r0, r4
 800df92:	2d00      	cmp	r5, #0
 800df94:	d0f6      	beq.n	800df84 <chIQGetTimeout+0x14>
 800df96:	69a1      	ldr	r1, [r4, #24]
 800df98:	68a3      	ldr	r3, [r4, #8]
 800df9a:	6925      	ldr	r5, [r4, #16]
 800df9c:	1c4a      	adds	r2, r1, #1
 800df9e:	3b01      	subs	r3, #1
 800dfa0:	42aa      	cmp	r2, r5
 800dfa2:	60a3      	str	r3, [r4, #8]
 800dfa4:	61a2      	str	r2, [r4, #24]
 800dfa6:	bf28      	it	cs
 800dfa8:	68e3      	ldrcs	r3, [r4, #12]
 800dfaa:	7808      	ldrb	r0, [r1, #0]
 800dfac:	bf28      	it	cs
 800dfae:	61a3      	strcs	r3, [r4, #24]
 800dfb0:	2300      	movs	r3, #0
 800dfb2:	f383 8811 	msr	BASEPRI, r3
 800dfb6:	bd70      	pop	{r4, r5, r6, pc}
 800dfb8:	f385 8811 	msr	BASEPRI, r5
 800dfbc:	bd70      	pop	{r4, r5, r6, pc}
 800dfbe:	bf00      	nop

0800dfc0 <chIQReadTimeout>:
 800dfc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dfc4:	4604      	mov	r4, r0
 800dfc6:	b083      	sub	sp, #12
 800dfc8:	4689      	mov	r9, r1
 800dfca:	4693      	mov	fp, r2
 800dfcc:	461d      	mov	r5, r3
 800dfce:	f8d0 801c 	ldr.w	r8, [r0, #28]
 800dfd2:	2720      	movs	r7, #32
 800dfd4:	f387 8811 	msr	BASEPRI, r7
 800dfd8:	2600      	movs	r6, #0
 800dfda:	9701      	str	r7, [sp, #4]
 800dfdc:	46b2      	mov	sl, r6
 800dfde:	f1b8 0f00 	cmp.w	r8, #0
 800dfe2:	d005      	beq.n	800dff0 <chIQReadTimeout+0x30>
 800dfe4:	4620      	mov	r0, r4
 800dfe6:	47c0      	blx	r8
 800dfe8:	e002      	b.n	800dff0 <chIQReadTimeout+0x30>
 800dfea:	f7ff fd61 	bl	800dab0 <chThdEnqueueTimeoutS>
 800dfee:	b9e0      	cbnz	r0, 800e02a <chIQReadTimeout+0x6a>
 800dff0:	68a7      	ldr	r7, [r4, #8]
 800dff2:	4629      	mov	r1, r5
 800dff4:	4620      	mov	r0, r4
 800dff6:	2f00      	cmp	r7, #0
 800dff8:	d0f7      	beq.n	800dfea <chIQReadTimeout+0x2a>
 800dffa:	69a2      	ldr	r2, [r4, #24]
 800dffc:	68a3      	ldr	r3, [r4, #8]
 800dffe:	1c51      	adds	r1, r2, #1
 800e000:	3b01      	subs	r3, #1
 800e002:	61a1      	str	r1, [r4, #24]
 800e004:	60a3      	str	r3, [r4, #8]
 800e006:	7813      	ldrb	r3, [r2, #0]
 800e008:	f809 3b01 	strb.w	r3, [r9], #1
 800e00c:	6923      	ldr	r3, [r4, #16]
 800e00e:	69a2      	ldr	r2, [r4, #24]
 800e010:	429a      	cmp	r2, r3
 800e012:	bf24      	itt	cs
 800e014:	68e3      	ldrcs	r3, [r4, #12]
 800e016:	61a3      	strcs	r3, [r4, #24]
 800e018:	f38a 8811 	msr	BASEPRI, sl
 800e01c:	3601      	adds	r6, #1
 800e01e:	45b3      	cmp	fp, r6
 800e020:	d005      	beq.n	800e02e <chIQReadTimeout+0x6e>
 800e022:	9b01      	ldr	r3, [sp, #4]
 800e024:	f383 8811 	msr	BASEPRI, r3
 800e028:	e7d9      	b.n	800dfde <chIQReadTimeout+0x1e>
 800e02a:	f387 8811 	msr	BASEPRI, r7
 800e02e:	4630      	mov	r0, r6
 800e030:	b003      	add	sp, #12
 800e032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e036:	bf00      	nop
	...

0800e040 <chOQObjectInit>:
 800e040:	b430      	push	{r4, r5}
 800e042:	9c02      	ldr	r4, [sp, #8]
 800e044:	6204      	str	r4, [r0, #32]
 800e046:	188d      	adds	r5, r1, r2
 800e048:	6105      	str	r5, [r0, #16]
 800e04a:	6000      	str	r0, [r0, #0]
 800e04c:	6040      	str	r0, [r0, #4]
 800e04e:	6082      	str	r2, [r0, #8]
 800e050:	60c1      	str	r1, [r0, #12]
 800e052:	6181      	str	r1, [r0, #24]
 800e054:	6141      	str	r1, [r0, #20]
 800e056:	61c3      	str	r3, [r0, #28]
 800e058:	bc30      	pop	{r4, r5}
 800e05a:	4770      	bx	lr
 800e05c:	0000      	movs	r0, r0
	...

0800e060 <chOQResetI>:
 800e060:	b410      	push	{r4}
 800e062:	6902      	ldr	r2, [r0, #16]
 800e064:	68c4      	ldr	r4, [r0, #12]
 800e066:	6184      	str	r4, [r0, #24]
 800e068:	1b12      	subs	r2, r2, r4
 800e06a:	6144      	str	r4, [r0, #20]
 800e06c:	f06f 0101 	mvn.w	r1, #1
 800e070:	6082      	str	r2, [r0, #8]
 800e072:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e076:	f7ff bd33 	b.w	800dae0 <chThdDequeueAllI>
 800e07a:	bf00      	nop
 800e07c:	0000      	movs	r0, r0
	...

0800e080 <chOQPutTimeout>:
 800e080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e082:	4604      	mov	r4, r0
 800e084:	460f      	mov	r7, r1
 800e086:	4616      	mov	r6, r2
 800e088:	2320      	movs	r3, #32
 800e08a:	f383 8811 	msr	BASEPRI, r3
 800e08e:	e003      	b.n	800e098 <chOQPutTimeout+0x18>
 800e090:	f7ff fd0e 	bl	800dab0 <chThdEnqueueTimeoutS>
 800e094:	2800      	cmp	r0, #0
 800e096:	db19      	blt.n	800e0cc <chOQPutTimeout+0x4c>
 800e098:	68a5      	ldr	r5, [r4, #8]
 800e09a:	4631      	mov	r1, r6
 800e09c:	4620      	mov	r0, r4
 800e09e:	2d00      	cmp	r5, #0
 800e0a0:	d0f6      	beq.n	800e090 <chOQPutTimeout+0x10>
 800e0a2:	6962      	ldr	r2, [r4, #20]
 800e0a4:	68a3      	ldr	r3, [r4, #8]
 800e0a6:	1c51      	adds	r1, r2, #1
 800e0a8:	3b01      	subs	r3, #1
 800e0aa:	6161      	str	r1, [r4, #20]
 800e0ac:	60a3      	str	r3, [r4, #8]
 800e0ae:	7017      	strb	r7, [r2, #0]
 800e0b0:	6923      	ldr	r3, [r4, #16]
 800e0b2:	6962      	ldr	r2, [r4, #20]
 800e0b4:	429a      	cmp	r2, r3
 800e0b6:	bf24      	itt	cs
 800e0b8:	68e3      	ldrcs	r3, [r4, #12]
 800e0ba:	6163      	strcs	r3, [r4, #20]
 800e0bc:	69e3      	ldr	r3, [r4, #28]
 800e0be:	b10b      	cbz	r3, 800e0c4 <chOQPutTimeout+0x44>
 800e0c0:	4620      	mov	r0, r4
 800e0c2:	4798      	blx	r3
 800e0c4:	2000      	movs	r0, #0
 800e0c6:	f380 8811 	msr	BASEPRI, r0
 800e0ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e0cc:	f385 8811 	msr	BASEPRI, r5
 800e0d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e0d2:	bf00      	nop
	...

0800e0e0 <chOQWriteTimeout>:
 800e0e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e0e4:	b083      	sub	sp, #12
 800e0e6:	4604      	mov	r4, r0
 800e0e8:	460d      	mov	r5, r1
 800e0ea:	4616      	mov	r6, r2
 800e0ec:	9301      	str	r3, [sp, #4]
 800e0ee:	f8d0 801c 	ldr.w	r8, [r0, #28]
 800e0f2:	f04f 0920 	mov.w	r9, #32
 800e0f6:	f389 8811 	msr	BASEPRI, r9
 800e0fa:	2700      	movs	r7, #0
 800e0fc:	46ba      	mov	sl, r7
 800e0fe:	68a3      	ldr	r3, [r4, #8]
 800e100:	f105 0b01 	add.w	fp, r5, #1
 800e104:	4620      	mov	r0, r4
 800e106:	b303      	cbz	r3, 800e14a <chOQWriteTimeout+0x6a>
 800e108:	6961      	ldr	r1, [r4, #20]
 800e10a:	68a3      	ldr	r3, [r4, #8]
 800e10c:	1c4a      	adds	r2, r1, #1
 800e10e:	3b01      	subs	r3, #1
 800e110:	6162      	str	r2, [r4, #20]
 800e112:	60a3      	str	r3, [r4, #8]
 800e114:	782b      	ldrb	r3, [r5, #0]
 800e116:	700b      	strb	r3, [r1, #0]
 800e118:	6923      	ldr	r3, [r4, #16]
 800e11a:	6961      	ldr	r1, [r4, #20]
 800e11c:	4299      	cmp	r1, r3
 800e11e:	bf24      	itt	cs
 800e120:	68e3      	ldrcs	r3, [r4, #12]
 800e122:	6163      	strcs	r3, [r4, #20]
 800e124:	f1b8 0f00 	cmp.w	r8, #0
 800e128:	d000      	beq.n	800e12c <chOQWriteTimeout+0x4c>
 800e12a:	47c0      	blx	r8
 800e12c:	f38a 8811 	msr	BASEPRI, sl
 800e130:	3e01      	subs	r6, #1
 800e132:	f107 0701 	add.w	r7, r7, #1
 800e136:	d012      	beq.n	800e15e <chOQWriteTimeout+0x7e>
 800e138:	f389 8811 	msr	BASEPRI, r9
 800e13c:	68a3      	ldr	r3, [r4, #8]
 800e13e:	465d      	mov	r5, fp
 800e140:	f105 0b01 	add.w	fp, r5, #1
 800e144:	4620      	mov	r0, r4
 800e146:	2b00      	cmp	r3, #0
 800e148:	d1de      	bne.n	800e108 <chOQWriteTimeout+0x28>
 800e14a:	9901      	ldr	r1, [sp, #4]
 800e14c:	9300      	str	r3, [sp, #0]
 800e14e:	4620      	mov	r0, r4
 800e150:	f7ff fcae 	bl	800dab0 <chThdEnqueueTimeoutS>
 800e154:	9b00      	ldr	r3, [sp, #0]
 800e156:	2800      	cmp	r0, #0
 800e158:	d0d1      	beq.n	800e0fe <chOQWriteTimeout+0x1e>
 800e15a:	f383 8811 	msr	BASEPRI, r3
 800e15e:	4638      	mov	r0, r7
 800e160:	b003      	add	sp, #12
 800e162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e166:	bf00      	nop
	...

0800e170 <_core_init>:
 800e170:	4a05      	ldr	r2, [pc, #20]	; (800e188 <_core_init+0x18>)
 800e172:	4b06      	ldr	r3, [pc, #24]	; (800e18c <_core_init+0x1c>)
 800e174:	4806      	ldr	r0, [pc, #24]	; (800e190 <_core_init+0x20>)
 800e176:	4907      	ldr	r1, [pc, #28]	; (800e194 <_core_init+0x24>)
 800e178:	f022 0207 	bic.w	r2, r2, #7
 800e17c:	f023 0307 	bic.w	r3, r3, #7
 800e180:	6002      	str	r2, [r0, #0]
 800e182:	600b      	str	r3, [r1, #0]
 800e184:	4770      	bx	lr
 800e186:	bf00      	nop
 800e188:	20011cef 	.word	0x20011cef
 800e18c:	20020000 	.word	0x20020000
 800e190:	20001ca4 	.word	0x20001ca4
 800e194:	20001ca0 	.word	0x20001ca0
	...

0800e1a0 <chCoreAlloc>:
 800e1a0:	b410      	push	{r4}
 800e1a2:	2320      	movs	r3, #32
 800e1a4:	f383 8811 	msr	BASEPRI, r3
 800e1a8:	4c09      	ldr	r4, [pc, #36]	; (800e1d0 <chCoreAlloc+0x30>)
 800e1aa:	4b0a      	ldr	r3, [pc, #40]	; (800e1d4 <chCoreAlloc+0x34>)
 800e1ac:	6822      	ldr	r2, [r4, #0]
 800e1ae:	6819      	ldr	r1, [r3, #0]
 800e1b0:	1dc3      	adds	r3, r0, #7
 800e1b2:	f023 0307 	bic.w	r3, r3, #7
 800e1b6:	1a89      	subs	r1, r1, r2
 800e1b8:	428b      	cmp	r3, r1
 800e1ba:	bf9d      	ittte	ls
 800e1bc:	189b      	addls	r3, r3, r2
 800e1be:	6023      	strls	r3, [r4, #0]
 800e1c0:	4610      	movls	r0, r2
 800e1c2:	2000      	movhi	r0, #0
 800e1c4:	2300      	movs	r3, #0
 800e1c6:	f383 8811 	msr	BASEPRI, r3
 800e1ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e1ce:	4770      	bx	lr
 800e1d0:	20001ca4 	.word	0x20001ca4
 800e1d4:	20001ca0 	.word	0x20001ca0
	...

0800e1e0 <chCoreGetStatusX>:
 800e1e0:	4a02      	ldr	r2, [pc, #8]	; (800e1ec <chCoreGetStatusX+0xc>)
 800e1e2:	4b03      	ldr	r3, [pc, #12]	; (800e1f0 <chCoreGetStatusX+0x10>)
 800e1e4:	6810      	ldr	r0, [r2, #0]
 800e1e6:	681b      	ldr	r3, [r3, #0]
 800e1e8:	1ac0      	subs	r0, r0, r3
 800e1ea:	4770      	bx	lr
 800e1ec:	20001ca0 	.word	0x20001ca0
 800e1f0:	20001ca4 	.word	0x20001ca4
	...

0800e200 <_heap_init>:
 800e200:	4b04      	ldr	r3, [pc, #16]	; (800e214 <_heap_init+0x14>)
 800e202:	4a05      	ldr	r2, [pc, #20]	; (800e218 <_heap_init+0x18>)
 800e204:	601a      	str	r2, [r3, #0]
 800e206:	f103 0010 	add.w	r0, r3, #16
 800e20a:	2200      	movs	r2, #0
 800e20c:	609a      	str	r2, [r3, #8]
 800e20e:	60da      	str	r2, [r3, #12]
 800e210:	f7ff bd1e 	b.w	800dc50 <chMtxObjectInit>
 800e214:	20001ca8 	.word	0x20001ca8
 800e218:	0800e1a1 	.word	0x0800e1a1
 800e21c:	00000000 	.word	0x00000000

0800e220 <chHeapFree>:
 800e220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e222:	f850 5c08 	ldr.w	r5, [r0, #-8]
 800e226:	f105 0710 	add.w	r7, r5, #16
 800e22a:	4606      	mov	r6, r0
 800e22c:	f1a0 0408 	sub.w	r4, r0, #8
 800e230:	3508      	adds	r5, #8
 800e232:	4638      	mov	r0, r7
 800e234:	f7ff fd7c 	bl	800dd30 <chMtxLock>
 800e238:	462b      	mov	r3, r5
 800e23a:	42ab      	cmp	r3, r5
 800e23c:	d004      	beq.n	800e248 <chHeapFree+0x28>
 800e23e:	42a3      	cmp	r3, r4
 800e240:	d302      	bcc.n	800e248 <chHeapFree+0x28>
 800e242:	681b      	ldr	r3, [r3, #0]
 800e244:	42ab      	cmp	r3, r5
 800e246:	d1fa      	bne.n	800e23e <chHeapFree+0x1e>
 800e248:	681a      	ldr	r2, [r3, #0]
 800e24a:	b11a      	cbz	r2, 800e254 <chHeapFree+0x34>
 800e24c:	4294      	cmp	r4, r2
 800e24e:	d301      	bcc.n	800e254 <chHeapFree+0x34>
 800e250:	4613      	mov	r3, r2
 800e252:	e7f2      	b.n	800e23a <chHeapFree+0x1a>
 800e254:	f846 2c08 	str.w	r2, [r6, #-8]
 800e258:	601c      	str	r4, [r3, #0]
 800e25a:	f856 1c04 	ldr.w	r1, [r6, #-4]
 800e25e:	f856 5c08 	ldr.w	r5, [r6, #-8]
 800e262:	f101 0208 	add.w	r2, r1, #8
 800e266:	18a0      	adds	r0, r4, r2
 800e268:	42a8      	cmp	r0, r5
 800e26a:	d00a      	beq.n	800e282 <chHeapFree+0x62>
 800e26c:	6859      	ldr	r1, [r3, #4]
 800e26e:	f101 0208 	add.w	r2, r1, #8
 800e272:	441a      	add	r2, r3
 800e274:	4294      	cmp	r4, r2
 800e276:	d012      	beq.n	800e29e <chHeapFree+0x7e>
 800e278:	4638      	mov	r0, r7
 800e27a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800e27e:	f7ff bd67 	b.w	800dd50 <chMtxUnlock>
 800e282:	6840      	ldr	r0, [r0, #4]
 800e284:	4401      	add	r1, r0
 800e286:	3108      	adds	r1, #8
 800e288:	f846 1c04 	str.w	r1, [r6, #-4]
 800e28c:	58a2      	ldr	r2, [r4, r2]
 800e28e:	f846 2c08 	str.w	r2, [r6, #-8]
 800e292:	6859      	ldr	r1, [r3, #4]
 800e294:	f101 0208 	add.w	r2, r1, #8
 800e298:	441a      	add	r2, r3
 800e29a:	4294      	cmp	r4, r2
 800e29c:	d1ec      	bne.n	800e278 <chHeapFree+0x58>
 800e29e:	f856 2c04 	ldr.w	r2, [r6, #-4]
 800e2a2:	440a      	add	r2, r1
 800e2a4:	3208      	adds	r2, #8
 800e2a6:	605a      	str	r2, [r3, #4]
 800e2a8:	f856 2c08 	ldr.w	r2, [r6, #-8]
 800e2ac:	601a      	str	r2, [r3, #0]
 800e2ae:	4638      	mov	r0, r7
 800e2b0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800e2b4:	f7ff bd4c 	b.w	800dd50 <chMtxUnlock>
	...

0800e2c0 <chHeapStatus>:
 800e2c0:	b570      	push	{r4, r5, r6, lr}
 800e2c2:	4c0f      	ldr	r4, [pc, #60]	; (800e300 <chHeapStatus+0x40>)
 800e2c4:	2800      	cmp	r0, #0
 800e2c6:	bf18      	it	ne
 800e2c8:	4604      	movne	r4, r0
 800e2ca:	f104 0510 	add.w	r5, r4, #16
 800e2ce:	4628      	mov	r0, r5
 800e2d0:	460e      	mov	r6, r1
 800e2d2:	f7ff fd2d 	bl	800dd30 <chMtxLock>
 800e2d6:	68a3      	ldr	r3, [r4, #8]
 800e2d8:	b173      	cbz	r3, 800e2f8 <chHeapStatus+0x38>
 800e2da:	2200      	movs	r2, #0
 800e2dc:	4614      	mov	r4, r2
 800e2de:	6858      	ldr	r0, [r3, #4]
 800e2e0:	681b      	ldr	r3, [r3, #0]
 800e2e2:	3401      	adds	r4, #1
 800e2e4:	4402      	add	r2, r0
 800e2e6:	2b00      	cmp	r3, #0
 800e2e8:	d1f9      	bne.n	800e2de <chHeapStatus+0x1e>
 800e2ea:	b106      	cbz	r6, 800e2ee <chHeapStatus+0x2e>
 800e2ec:	6032      	str	r2, [r6, #0]
 800e2ee:	4628      	mov	r0, r5
 800e2f0:	f7ff fd2e 	bl	800dd50 <chMtxUnlock>
 800e2f4:	4620      	mov	r0, r4
 800e2f6:	bd70      	pop	{r4, r5, r6, pc}
 800e2f8:	461a      	mov	r2, r3
 800e2fa:	461c      	mov	r4, r3
 800e2fc:	e7f5      	b.n	800e2ea <chHeapStatus+0x2a>
 800e2fe:	bf00      	nop
 800e300:	20001ca8 	.word	0x20001ca8
	...

0800e310 <chPoolFree>:
 800e310:	2320      	movs	r3, #32
 800e312:	f383 8811 	msr	BASEPRI, r3
 800e316:	6803      	ldr	r3, [r0, #0]
 800e318:	600b      	str	r3, [r1, #0]
 800e31a:	2300      	movs	r3, #0
 800e31c:	6001      	str	r1, [r0, #0]
 800e31e:	f383 8811 	msr	BASEPRI, r3
 800e322:	4770      	bx	lr
	...

0800e330 <SVC_Handler>:
 800e330:	4a06      	ldr	r2, [pc, #24]	; (800e34c <SVC_Handler+0x1c>)
 800e332:	6853      	ldr	r3, [r2, #4]
 800e334:	f023 0301 	bic.w	r3, r3, #1
 800e338:	6053      	str	r3, [r2, #4]
 800e33a:	f3ef 8309 	mrs	r3, PSP
 800e33e:	3368      	adds	r3, #104	; 0x68
 800e340:	f383 8809 	msr	PSP, r3
 800e344:	2300      	movs	r3, #0
 800e346:	f383 8811 	msr	BASEPRI, r3
 800e34a:	4770      	bx	lr
 800e34c:	e000ef30 	.word	0xe000ef30

0800e350 <_port_irq_epilogue>:
 800e350:	2320      	movs	r3, #32
 800e352:	f383 8811 	msr	BASEPRI, r3
 800e356:	4b12      	ldr	r3, [pc, #72]	; (800e3a0 <_port_irq_epilogue+0x50>)
 800e358:	685b      	ldr	r3, [r3, #4]
 800e35a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800e35e:	d102      	bne.n	800e366 <_port_irq_epilogue+0x16>
 800e360:	f383 8811 	msr	BASEPRI, r3
 800e364:	4770      	bx	lr
 800e366:	b510      	push	{r4, lr}
 800e368:	eef1 3a10 	vmrs	r3, fpscr
 800e36c:	f3ef 8409 	mrs	r4, PSP
 800e370:	4b0c      	ldr	r3, [pc, #48]	; (800e3a4 <_port_irq_epilogue+0x54>)
 800e372:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800e376:	68db      	ldr	r3, [r3, #12]
 800e378:	f844 3c08 	str.w	r3, [r4, #-8]
 800e37c:	f844 2c4c 	str.w	r2, [r4, #-76]
 800e380:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68
 800e384:	f383 8809 	msr	PSP, r3
 800e388:	f7ff fa22 	bl	800d7d0 <chSchIsPreemptionRequired>
 800e38c:	b118      	cbz	r0, 800e396 <_port_irq_epilogue+0x46>
 800e38e:	4b06      	ldr	r3, [pc, #24]	; (800e3a8 <_port_irq_epilogue+0x58>)
 800e390:	f844 3c50 	str.w	r3, [r4, #-80]
 800e394:	bd10      	pop	{r4, pc}
 800e396:	4b05      	ldr	r3, [pc, #20]	; (800e3ac <_port_irq_epilogue+0x5c>)
 800e398:	f844 3c50 	str.w	r3, [r4, #-80]
 800e39c:	bd10      	pop	{r4, pc}
 800e39e:	bf00      	nop
 800e3a0:	e000ed00 	.word	0xe000ed00
 800e3a4:	e000ef30 	.word	0xe000ef30
 800e3a8:	0800c139 	.word	0x0800c139
 800e3ac:	0800c13c 	.word	0x0800c13c

0800e3b0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 800e3b0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 800e3b2:	f001 f91d 	bl	800f5f0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800e3b6:	480b      	ldr	r0, [pc, #44]	; (800e3e4 <halInit+0x34>)
 800e3b8:	f001 fc7a 	bl	800fcb0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
 800e3bc:	f000 f820 	bl	800e400 <canInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 800e3c0:	f000 f8c6 	bl	800e550 <i2cInit>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
#endif
#if (HAL_USE_ICU == TRUE) || defined(__DOXYGEN__)
  icuInit();
 800e3c4:	f000 f93c 	bl	800e640 <icuInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 800e3c8:	f000 fb42 	bl	800ea50 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
 800e3cc:	f000 fb50 	bl	800ea70 <uartInit>
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 800e3d0:	f000 fb8e 	bl	800eaf0 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 800e3d4:	f000 fa2c 	bl	800e830 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800e3d8:	f003 f9f2 	bl	80117c0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 800e3dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 800e3e0:	f000 b806 	b.w	800e3f0 <stInit>
 800e3e4:	0802dad0 	.word	0x0802dad0
	...

0800e3f0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 800e3f0:	f001 b9a6 	b.w	800f740 <st_lld_init>
	...

0800e400 <canInit>:
 *
 * @init
 */
void canInit(void) {

  can_lld_init();
 800e400:	f001 bb0e 	b.w	800fa20 <can_lld_init>
	...

0800e410 <canObjectInit>:
 *
 * @param[out] canp     pointer to the @p CANDriver object
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {
 800e410:	b430      	push	{r4, r5}

  canp->state    = CAN_STOP;
  canp->config   = NULL;
 800e412:	2100      	movs	r1, #0
  canp->state    = CAN_STOP;
 800e414:	2401      	movs	r4, #1
  osalThreadQueueObjectInit(&canp->txqueue);
  osalThreadQueueObjectInit(&canp->rxqueue);
  osalEventObjectInit(&canp->rxfull_event);
 800e416:	f100 0218 	add.w	r2, r0, #24
  osalEventObjectInit(&canp->txempty_event);
 800e41a:	f100 031c 	add.w	r3, r0, #28
  osalEventObjectInit(&canp->error_event);
 800e41e:	f100 0520 	add.w	r5, r0, #32
  canp->state    = CAN_STOP;
 800e422:	7004      	strb	r4, [r0, #0]
  canp->config   = NULL;
 800e424:	6041      	str	r1, [r0, #4]
#if CAN_USE_SLEEP_MODE == TRUE
  osalEventObjectInit(&canp->sleep_event);
 800e426:	f100 0424 	add.w	r4, r0, #36	; 0x24
  osalEventObjectInit(&canp->wakeup_event);
 800e42a:	f100 0128 	add.w	r1, r0, #40	; 0x28
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 800e42e:	6182      	str	r2, [r0, #24]
 800e430:	61c3      	str	r3, [r0, #28]
  osalThreadQueueObjectInit(&canp->txqueue);
 800e432:	f100 0208 	add.w	r2, r0, #8
  osalThreadQueueObjectInit(&canp->rxqueue);
 800e436:	f100 0310 	add.w	r3, r0, #16
 800e43a:	e9c0 5408 	strd	r5, r4, [r0, #32]
 800e43e:	6281      	str	r1, [r0, #40]	; 0x28
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
  tqp->p_prev = (thread_t *)tqp;
 800e440:	e9c0 2202 	strd	r2, r2, [r0, #8]
 800e444:	e9c0 3304 	strd	r3, r3, [r0, #16]
#endif
}
 800e448:	bc30      	pop	{r4, r5}
 800e44a:	4770      	bx	lr
 800e44c:	0000      	movs	r0, r0
	...

0800e450 <canStart>:
 * @param[in] config    pointer to the @p CANConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void canStart(CANDriver *canp, const CANConfig *config) {
 800e450:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800e452:	2320      	movs	r3, #32
 800e454:	4604      	mov	r4, r0
 800e456:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 800e45a:	2302      	movs	r3, #2
 800e45c:	7003      	strb	r3, [r0, #0]
  canp->config = config;
 800e45e:	6041      	str	r1, [r0, #4]

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 800e460:	f001 faf6 	bl	800fa50 <can_lld_start>

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 800e464:	2303      	movs	r3, #3
 800e466:	7023      	strb	r3, [r4, #0]
 800e468:	2300      	movs	r3, #0
 800e46a:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e46e:	bd10      	pop	{r4, pc}

0800e470 <canStop>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @api
 */
void canStop(CANDriver *canp) {
 800e470:	b510      	push	{r4, lr}
 800e472:	2320      	movs	r3, #32
 800e474:	4604      	mov	r4, r0
 800e476:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();
  osalDbgAssert((canp->state == CAN_STOP) || (canp->state == CAN_READY),
                "invalid state");

  /* The low level driver is stopped.*/
  can_lld_stop(canp);
 800e47a:	f001 fb21 	bl	800fac0 <can_lld_stop>
  canp->state  = CAN_STOP;
 800e47e:	4620      	mov	r0, r4
 800e480:	2301      	movs	r3, #1
 800e482:	f800 3b10 	strb.w	r3, [r0], #16
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800e486:	f06f 0101 	mvn.w	r1, #1
 800e48a:	f7ff fb29 	bl	800dae0 <chThdDequeueAllI>
 800e48e:	f104 0008 	add.w	r0, r4, #8
 800e492:	f06f 0101 	mvn.w	r1, #1
 800e496:	f7ff fb23 	bl	800dae0 <chThdDequeueAllI>
  chSchRescheduleS();
 800e49a:	f7ff f9f1 	bl	800d880 <chSchRescheduleS>
 800e49e:	2300      	movs	r3, #0
 800e4a0:	f383 8811 	msr	BASEPRI, r3
     stopped in order to not have stuck threads.*/
  osalThreadDequeueAllI(&canp->rxqueue, MSG_RESET);
  osalThreadDequeueAllI(&canp->txqueue, MSG_RESET);
  osalOsRescheduleS();
  osalSysUnlock();
}
 800e4a4:	bd10      	pop	{r4, pc}
 800e4a6:	bf00      	nop
	...

0800e4b0 <canTransmit>:
 * @api
 */
msg_t canTransmit(CANDriver *canp,
                  canmbx_t mailbox,
                  const CANTxFrame *ctfp,
                  systime_t timeout) {
 800e4b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e4b4:	461f      	mov	r7, r3
 800e4b6:	4604      	mov	r4, r0
 800e4b8:	460d      	mov	r5, r1
 800e4ba:	4690      	mov	r8, r2
 800e4bc:	2320      	movs	r3, #32
 800e4be:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
                "invalid state");
  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
  /*lint -restore*/
   msg_t msg = osalThreadEnqueueTimeoutS(&canp->txqueue, timeout);
 800e4c2:	f100 0608 	add.w	r6, r0, #8
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 800e4c6:	7823      	ldrb	r3, [r4, #0]
 800e4c8:	2b04      	cmp	r3, #4
 800e4ca:	4629      	mov	r1, r5
 800e4cc:	4620      	mov	r0, r4
 800e4ce:	d002      	beq.n	800e4d6 <canTransmit+0x26>
 800e4d0:	f001 fb1e 	bl	800fb10 <can_lld_is_tx_empty>
 800e4d4:	b950      	cbnz	r0, 800e4ec <canTransmit+0x3c>
  return chThdEnqueueTimeoutS(tqp, time);
 800e4d6:	4639      	mov	r1, r7
 800e4d8:	4630      	mov	r0, r6
 800e4da:	f7ff fae9 	bl	800dab0 <chThdEnqueueTimeoutS>
    if (msg != MSG_OK) {
 800e4de:	2800      	cmp	r0, #0
 800e4e0:	d0f1      	beq.n	800e4c6 <canTransmit+0x16>
 800e4e2:	2300      	movs	r3, #0
 800e4e4:	f383 8811 	msr	BASEPRI, r3
    }
  }
  can_lld_transmit(canp, mailbox, ctfp);
  osalSysUnlock();
  return MSG_OK;
}
 800e4e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  can_lld_transmit(canp, mailbox, ctfp);
 800e4ec:	4620      	mov	r0, r4
 800e4ee:	4642      	mov	r2, r8
 800e4f0:	4629      	mov	r1, r5
 800e4f2:	f001 fb2d 	bl	800fb50 <can_lld_transmit>
 800e4f6:	2000      	movs	r0, #0
 800e4f8:	f380 8811 	msr	BASEPRI, r0
}
 800e4fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800e500 <canReceive>:
 * @api
 */
msg_t canReceive(CANDriver *canp,
                 canmbx_t mailbox,
                 CANRxFrame *crfp,
                 systime_t timeout) {
 800e500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e504:	461f      	mov	r7, r3
 800e506:	4604      	mov	r4, r0
 800e508:	460d      	mov	r5, r1
 800e50a:	4690      	mov	r8, r2
 800e50c:	2320      	movs	r3, #32
 800e50e:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
                "invalid state");
  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
  /*lint -restore*/
    msg_t msg = osalThreadEnqueueTimeoutS(&canp->rxqueue, timeout);
 800e512:	f100 0610 	add.w	r6, r0, #16
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
 800e516:	7823      	ldrb	r3, [r4, #0]
 800e518:	2b04      	cmp	r3, #4
 800e51a:	4629      	mov	r1, r5
 800e51c:	4620      	mov	r0, r4
 800e51e:	d002      	beq.n	800e526 <canReceive+0x26>
 800e520:	f001 fb4e 	bl	800fbc0 <can_lld_is_rx_nonempty>
 800e524:	b950      	cbnz	r0, 800e53c <canReceive+0x3c>
 800e526:	4639      	mov	r1, r7
 800e528:	4630      	mov	r0, r6
 800e52a:	f7ff fac1 	bl	800dab0 <chThdEnqueueTimeoutS>
    if (msg != MSG_OK) {
 800e52e:	2800      	cmp	r0, #0
 800e530:	d0f1      	beq.n	800e516 <canReceive+0x16>
 800e532:	2300      	movs	r3, #0
 800e534:	f383 8811 	msr	BASEPRI, r3
    }
  }
  can_lld_receive(canp, mailbox, crfp);
  osalSysUnlock();
  return MSG_OK;
}
 800e538:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  can_lld_receive(canp, mailbox, crfp);
 800e53c:	4620      	mov	r0, r4
 800e53e:	4642      	mov	r2, r8
 800e540:	4629      	mov	r1, r5
 800e542:	f001 fb5d 	bl	800fc00 <can_lld_receive>
 800e546:	2000      	movs	r0, #0
 800e548:	f380 8811 	msr	BASEPRI, r0
}
 800e54c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800e550 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 800e550:	f001 be2e 	b.w	80101b0 <i2c_lld_init>
	...

0800e560 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800e560:	2201      	movs	r2, #1
  i2cp->config = NULL;
 800e562:	2300      	movs	r3, #0
  i2cp->state  = I2C_STOP;
 800e564:	7002      	strb	r2, [r0, #0]
  i2cp->config = NULL;
 800e566:	6043      	str	r3, [r0, #4]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 800e568:	300c      	adds	r0, #12
 800e56a:	f7ff bb71 	b.w	800dc50 <chMtxObjectInit>
 800e56e:	bf00      	nop

0800e570 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 800e570:	b510      	push	{r4, lr}
 800e572:	2320      	movs	r3, #32
 800e574:	4604      	mov	r4, r0
 800e576:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800e57a:	6041      	str	r1, [r0, #4]
  i2c_lld_start(i2cp);
 800e57c:	f001 fe30 	bl	80101e0 <i2c_lld_start>
  i2cp->state = I2C_READY;
 800e580:	2302      	movs	r3, #2
 800e582:	7023      	strb	r3, [r4, #0]
 800e584:	2300      	movs	r3, #0
 800e586:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e58a:	bd10      	pop	{r4, pc}
 800e58c:	0000      	movs	r0, r0
	...

0800e590 <i2cStop>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cStop(I2CDriver *i2cp) {
 800e590:	b510      	push	{r4, lr}
 800e592:	2320      	movs	r3, #32
 800e594:	4604      	mov	r4, r0
 800e596:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(i2cp != NULL);
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2c_lld_stop(i2cp);
 800e59a:	f001 fed9 	bl	8010350 <i2c_lld_stop>
  i2cp->state = I2C_STOP;
 800e59e:	2301      	movs	r3, #1
 800e5a0:	7023      	strb	r3, [r4, #0]
 800e5a2:	2300      	movs	r3, #0
 800e5a4:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e5a8:	bd10      	pop	{r4, pc}
 800e5aa:	bf00      	nop
 800e5ac:	0000      	movs	r0, r0
	...

0800e5b0 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 800e5b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e5b2:	b085      	sub	sp, #20
 800e5b4:	4604      	mov	r4, r0
 800e5b6:	e9dd 670b 	ldrd	r6, r7, [sp, #44]	; 0x2c
 800e5ba:	f04f 0c20 	mov.w	ip, #32
 800e5be:	f38c 8811 	msr	BASEPRI, ip

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800e5c2:	f04f 0c03 	mov.w	ip, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800e5c6:	e9cd 6701 	strd	r6, r7, [sp, #4]
  i2cp->errors = I2C_NO_ERROR;
 800e5ca:	2500      	movs	r5, #0
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800e5cc:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800e5ce:	9600      	str	r6, [sp, #0]
  i2cp->errors = I2C_NO_ERROR;
 800e5d0:	6085      	str	r5, [r0, #8]
  i2cp->state = I2C_ACTIVE_TX;
 800e5d2:	f880 c000 	strb.w	ip, [r0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 800e5d6:	f001 ff43 	bl	8010460 <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 800e5da:	1c43      	adds	r3, r0, #1
    i2cp->state = I2C_LOCKED;
 800e5dc:	bf0c      	ite	eq
 800e5de:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 800e5e0:	2302      	movne	r3, #2
 800e5e2:	7023      	strb	r3, [r4, #0]
 800e5e4:	2300      	movs	r3, #0
 800e5e6:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return rdymsg;
}
 800e5ea:	b005      	add	sp, #20
 800e5ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e5ee:	bf00      	nop

0800e5f0 <i2cMasterReceiveTimeout>:
 */
msg_t i2cMasterReceiveTimeout(I2CDriver *i2cp,
                              i2caddr_t addr,
                              uint8_t *rxbuf,
                              size_t rxbytes,
                              systime_t timeout){
 800e5f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e5f2:	b083      	sub	sp, #12
 800e5f4:	4604      	mov	r4, r0
 800e5f6:	9f08      	ldr	r7, [sp, #32]
 800e5f8:	2520      	movs	r5, #32
 800e5fa:	f385 8811 	msr	BASEPRI, r5
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800e5fe:	2600      	movs	r6, #0
  i2cp->state = I2C_ACTIVE_RX;
 800e600:	2504      	movs	r5, #4
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
 800e602:	9700      	str	r7, [sp, #0]
  i2cp->errors = I2C_NO_ERROR;
 800e604:	6086      	str	r6, [r0, #8]
  i2cp->state = I2C_ACTIVE_RX;
 800e606:	7005      	strb	r5, [r0, #0]
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
 800e608:	f001 feea 	bl	80103e0 <i2c_lld_master_receive_timeout>
  if (rdymsg == MSG_TIMEOUT) {
 800e60c:	1c43      	adds	r3, r0, #1
    i2cp->state = I2C_LOCKED;
 800e60e:	bf0c      	ite	eq
 800e610:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 800e612:	2302      	movne	r3, #2
 800e614:	7023      	strb	r3, [r4, #0]
 800e616:	2300      	movs	r3, #0
 800e618:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return rdymsg;
}
 800e61c:	b003      	add	sp, #12
 800e61e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800e620 <i2cAcquireBus>:
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800e620:	300c      	adds	r0, #12
 800e622:	f7ff bb85 	b.w	800dd30 <chMtxLock>
 800e626:	bf00      	nop
	...

0800e630 <i2cReleaseBus>:
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800e630:	300c      	adds	r0, #12
 800e632:	f7ff bb8d 	b.w	800dd50 <chMtxUnlock>
 800e636:	bf00      	nop
	...

0800e640 <icuInit>:
 *
 * @init
 */
void icuInit(void) {

  icu_lld_init();
 800e640:	f002 bdce 	b.w	80111e0 <icu_lld_init>
	...

0800e650 <icuObjectInit>:
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {

  icup->state  = ICU_STOP;
 800e650:	2201      	movs	r2, #1
  icup->config = NULL;
 800e652:	2300      	movs	r3, #0
  icup->state  = ICU_STOP;
 800e654:	7002      	strb	r2, [r0, #0]
  icup->config = NULL;
 800e656:	6043      	str	r3, [r0, #4]
}
 800e658:	4770      	bx	lr
 800e65a:	bf00      	nop
 800e65c:	0000      	movs	r0, r0
	...

0800e660 <icuStart>:
 * @param[in] icup      pointer to the @p ICUDriver object
 * @param[in] config    pointer to the @p ICUConfig object
 *
 * @api
 */
void icuStart(ICUDriver *icup, const ICUConfig *config) {
 800e660:	b510      	push	{r4, lr}
 800e662:	2320      	movs	r3, #32
 800e664:	4604      	mov	r4, r0
 800e666:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((icup != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
                "invalid state");
  icup->config = config;
 800e66a:	6041      	str	r1, [r0, #4]
  icu_lld_start(icup);
 800e66c:	f002 fdc8 	bl	8011200 <icu_lld_start>
  icup->state = ICU_READY;
 800e670:	2302      	movs	r3, #2
 800e672:	7023      	strb	r3, [r4, #0]
 800e674:	2300      	movs	r3, #0
 800e676:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e67a:	bd10      	pop	{r4, pc}
 800e67c:	0000      	movs	r0, r0
	...

0800e680 <icuStop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStop(ICUDriver *icup) {
 800e680:	b510      	push	{r4, lr}
 800e682:	2320      	movs	r3, #32
 800e684:	4604      	mov	r4, r0
 800e686:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(icup != NULL);

  osalSysLock();
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
                "invalid state");
  icu_lld_stop(icup);
 800e68a:	f002 fe19 	bl	80112c0 <icu_lld_stop>
  icup->state = ICU_STOP;
 800e68e:	2301      	movs	r3, #1
 800e690:	7023      	strb	r3, [r4, #0]
 800e692:	2300      	movs	r3, #0
 800e694:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e698:	bd10      	pop	{r4, pc}
 800e69a:	bf00      	nop
 800e69c:	0000      	movs	r0, r0
	...

0800e6a0 <icuStartCapture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStartCapture(ICUDriver *icup) {
 800e6a0:	b510      	push	{r4, lr}
 800e6a2:	2320      	movs	r3, #32
 800e6a4:	4604      	mov	r4, r0
 800e6a6:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheck(icup != NULL);

  osalSysLock();
  osalDbgAssert(icup->state == ICU_READY, "invalid state");
  icuStartCaptureI(icup);
 800e6aa:	f002 fe29 	bl	8011300 <icu_lld_start_capture>
 800e6ae:	2303      	movs	r3, #3
 800e6b0:	7023      	strb	r3, [r4, #0]
 800e6b2:	2300      	movs	r3, #0
 800e6b4:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e6b8:	bd10      	pop	{r4, pc}
 800e6ba:	bf00      	nop
 800e6bc:	0000      	movs	r0, r0
	...

0800e6c0 <icuEnableNotifications>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuEnableNotifications(ICUDriver *icup) {
 800e6c0:	b508      	push	{r3, lr}
 800e6c2:	2320      	movs	r3, #32
 800e6c4:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(icup != NULL);

  osalSysLock();
  osalDbgAssert((icup->state == ICU_WAITING) || (icup->state == ICU_ACTIVE),
                "invalid state");
  icuEnableNotificationsI(icup);
 800e6c8:	f002 fe2a 	bl	8011320 <icu_lld_enable_notifications>
 800e6cc:	2300      	movs	r3, #0
 800e6ce:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e6d2:	bd08      	pop	{r3, pc}
	...

0800e6e0 <onotify>:
/**
 * @brief   Notification of data inserted into the output queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void onotify(io_queue_t *qp) {
 800e6e0:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = qGetLink(qp);
 800e6e2:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800e6e4:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e6e8:	6813      	ldr	r3, [r2, #0]
 800e6ea:	7819      	ldrb	r1, [r3, #0]
 800e6ec:	2904      	cmp	r1, #4
 800e6ee:	d000      	beq.n	800e6f2 <onotify+0x12>

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
    }
  }
}
 800e6f0:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800e6f2:	7a21      	ldrb	r1, [r4, #8]
 800e6f4:	2902      	cmp	r1, #2
 800e6f6:	d1fb      	bne.n	800e6f0 <onotify+0x10>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800e6f8:	7911      	ldrb	r1, [r2, #4]
 800e6fa:	891a      	ldrh	r2, [r3, #8]
 800e6fc:	2301      	movs	r3, #1
 800e6fe:	408b      	lsls	r3, r1
 800e700:	401a      	ands	r2, r3
 800e702:	d1f5      	bne.n	800e6f0 <onotify+0x10>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800e704:	e9d4 030f 	ldrd	r0, r3, [r4, #60]	; 0x3c
 800e708:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800e70a:	1a1b      	subs	r3, r3, r0
    if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800e70c:	1a5b      	subs	r3, r3, r1
 800e70e:	d0ef      	beq.n	800e6f0 <onotify+0x10>
 800e710:	f382 8811 	msr	BASEPRI, r2
      usbPrepareQueuedTransmit(sdup->config->usbp,
 800e714:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e718:	7911      	ldrb	r1, [r2, #4]
 800e71a:	6810      	ldr	r0, [r2, #0]
 800e71c:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800e720:	f000 fa4e 	bl	800ebc0 <usbPrepareQueuedTransmit>
 800e724:	2320      	movs	r3, #32
 800e726:	f383 8811 	msr	BASEPRI, r3
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800e72a:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
}
 800e72e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800e732:	7919      	ldrb	r1, [r3, #4]
 800e734:	6818      	ldr	r0, [r3, #0]
 800e736:	f000 ba6b 	b.w	800ec10 <usbStartTransmitI>
 800e73a:	bf00      	nop
 800e73c:	0000      	movs	r0, r0
	...

0800e740 <inotify>:
static void inotify(io_queue_t *qp) {
 800e740:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = qGetLink(qp);
 800e742:	6a04      	ldr	r4, [r0, #32]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800e744:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e748:	6813      	ldr	r3, [r2, #0]
 800e74a:	7819      	ldrb	r1, [r3, #0]
 800e74c:	2904      	cmp	r1, #4
 800e74e:	d000      	beq.n	800e752 <inotify+0x12>
}
 800e750:	bd38      	pop	{r3, r4, r5, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800e752:	7a21      	ldrb	r1, [r4, #8]
 800e754:	2902      	cmp	r1, #2
 800e756:	d1fb      	bne.n	800e750 <inotify+0x10>
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e758:	7950      	ldrb	r0, [r2, #5]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800e75a:	8959      	ldrh	r1, [r3, #10]
 800e75c:	2201      	movs	r2, #1
 800e75e:	4082      	lsls	r2, r0
 800e760:	400a      	ands	r2, r1
 800e762:	d1f5      	bne.n	800e750 <inotify+0x10>
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 800e764:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800e768:	69a1      	ldr	r1, [r4, #24]
 800e76a:	69e0      	ldr	r0, [r4, #28]
 800e76c:	68db      	ldr	r3, [r3, #12]
 800e76e:	6965      	ldr	r5, [r4, #20]
 800e770:	8a5b      	ldrh	r3, [r3, #18]
 800e772:	1a41      	subs	r1, r0, r1
 800e774:	1b49      	subs	r1, r1, r5
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800e776:	428b      	cmp	r3, r1
 800e778:	d8ea      	bhi.n	800e750 <inotify+0x10>
 800e77a:	f382 8811 	msr	BASEPRI, r2
      n = (n / maxsize) * maxsize;
 800e77e:	fbb1 f1f3 	udiv	r1, r1, r3
      usbPrepareQueuedReceive(sdup->config->usbp,
 800e782:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800e786:	fb03 f301 	mul.w	r3, r3, r1
 800e78a:	6810      	ldr	r0, [r2, #0]
 800e78c:	7951      	ldrb	r1, [r2, #5]
 800e78e:	f104 020c 	add.w	r2, r4, #12
 800e792:	f000 fa05 	bl	800eba0 <usbPrepareQueuedReceive>
 800e796:	2320      	movs	r3, #32
 800e798:	f383 8811 	msr	BASEPRI, r3
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800e79c:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800e7a0:	7959      	ldrb	r1, [r3, #5]
 800e7a2:	6818      	ldr	r0, [r3, #0]
}
 800e7a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 800e7a8:	f000 ba1a 	b.w	800ebe0 <usbStartReceiveI>
 800e7ac:	0000      	movs	r0, r0
	...

0800e7b0 <readt>:
  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, timeout);
 800e7b0:	300c      	adds	r0, #12
 800e7b2:	f7ff bc05 	b.w	800dfc0 <chIQReadTimeout>
 800e7b6:	bf00      	nop
	...

0800e7c0 <read>:
  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
 800e7c0:	300c      	adds	r0, #12
 800e7c2:	f04f 33ff 	mov.w	r3, #4294967295
 800e7c6:	f7ff bbfb 	b.w	800dfc0 <chIQReadTimeout>
 800e7ca:	bf00      	nop
 800e7cc:	0000      	movs	r0, r0
	...

0800e7d0 <writet>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
 800e7d0:	3030      	adds	r0, #48	; 0x30
 800e7d2:	f7ff bc85 	b.w	800e0e0 <chOQWriteTimeout>
 800e7d6:	bf00      	nop
	...

0800e7e0 <write>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
 800e7e0:	3030      	adds	r0, #48	; 0x30
 800e7e2:	f04f 33ff 	mov.w	r3, #4294967295
 800e7e6:	f7ff bc7b 	b.w	800e0e0 <chOQWriteTimeout>
 800e7ea:	bf00      	nop
 800e7ec:	0000      	movs	r0, r0
	...

0800e7f0 <gett>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
 800e7f0:	300c      	adds	r0, #12
 800e7f2:	f7ff bbbd 	b.w	800df70 <chIQGetTimeout>
 800e7f6:	bf00      	nop
	...

0800e800 <get>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
 800e800:	300c      	adds	r0, #12
 800e802:	f04f 31ff 	mov.w	r1, #4294967295
 800e806:	f7ff bbb3 	b.w	800df70 <chIQGetTimeout>
 800e80a:	bf00      	nop
 800e80c:	0000      	movs	r0, r0
	...

0800e810 <putt>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
 800e810:	3030      	adds	r0, #48	; 0x30
 800e812:	f7ff bc35 	b.w	800e080 <chOQPutTimeout>
 800e816:	bf00      	nop
	...

0800e820 <put>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
 800e820:	3030      	adds	r0, #48	; 0x30
 800e822:	f04f 32ff 	mov.w	r2, #4294967295
 800e826:	f7ff bc2b 	b.w	800e080 <chOQPutTimeout>
 800e82a:	bf00      	nop
 800e82c:	0000      	movs	r0, r0
	...

0800e830 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 800e830:	4770      	bx	lr
 800e832:	bf00      	nop
	...

0800e840 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800e840:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
 800e842:	4603      	mov	r3, r0
 800e844:	4a0e      	ldr	r2, [pc, #56]	; (800e880 <sduObjectInit+0x40>)
 800e846:	f843 2b04 	str.w	r2, [r3], #4
void sduObjectInit(SerialUSBDriver *sdup) {
 800e84a:	b082      	sub	sp, #8
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800e84c:	2201      	movs	r2, #1
void sduObjectInit(SerialUSBDriver *sdup) {
 800e84e:	4604      	mov	r4, r0
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800e850:	9000      	str	r0, [sp, #0]
 800e852:	f100 0154 	add.w	r1, r0, #84	; 0x54
 800e856:	6043      	str	r3, [r0, #4]
  sdup->state = SDU_STOP;
 800e858:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800e85a:	4b0a      	ldr	r3, [pc, #40]	; (800e884 <sduObjectInit+0x44>)
 800e85c:	300c      	adds	r0, #12
 800e85e:	f44f 7280 	mov.w	r2, #256	; 0x100
 800e862:	f7ff fb65 	bl	800df30 <chIQObjectInit>
  oqObjectInit(&sdup->oqueue, sdup->ob, SERIAL_USB_BUFFERS_SIZE, onotify, sdup);
 800e866:	9400      	str	r4, [sp, #0]
 800e868:	f504 71aa 	add.w	r1, r4, #340	; 0x154
 800e86c:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800e870:	4b05      	ldr	r3, [pc, #20]	; (800e888 <sduObjectInit+0x48>)
 800e872:	f44f 7280 	mov.w	r2, #256	; 0x100
 800e876:	f7ff fbe3 	bl	800e040 <chOQObjectInit>
}
 800e87a:	b002      	add	sp, #8
 800e87c:	bd10      	pop	{r4, pc}
 800e87e:	bf00      	nop
 800e880:	0802d960 	.word	0x0802d960
 800e884:	0800e741 	.word	0x0800e741
 800e888:	0800e6e1 	.word	0x0800e6e1
 800e88c:	00000000 	.word	0x00000000

0800e890 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 800e890:	680b      	ldr	r3, [r1, #0]
 800e892:	2220      	movs	r2, #32
 800e894:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800e898:	790a      	ldrb	r2, [r1, #4]
 800e89a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800e89e:	6190      	str	r0, [r2, #24]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800e8a0:	794a      	ldrb	r2, [r1, #5]
 800e8a2:	3209      	adds	r2, #9
 800e8a4:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 800e8a8:	798a      	ldrb	r2, [r1, #6]
 800e8aa:	b112      	cbz	r2, 800e8b2 <sduStart+0x22>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800e8ac:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e8b0:	6198      	str	r0, [r3, #24]
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 800e8b2:	2302      	movs	r3, #2
 800e8b4:	7203      	strb	r3, [r0, #8]
  sdup->config = config;
 800e8b6:	f8c0 1254 	str.w	r1, [r0, #596]	; 0x254
 800e8ba:	2300      	movs	r3, #0
 800e8bc:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800e8c0:	4770      	bx	lr
 800e8c2:	bf00      	nop
	...

0800e8d0 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800e8d0:	b570      	push	{r4, r5, r6, lr}
  USBDriver *usbp = sdup->config->usbp;
 800e8d2:	f8d0 3254 	ldr.w	r3, [r0, #596]	; 0x254

  iqResetI(&sdup->iqueue);
 800e8d6:	f100 060c 	add.w	r6, r0, #12
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800e8da:	4604      	mov	r4, r0
  iqResetI(&sdup->iqueue);
 800e8dc:	4630      	mov	r0, r6
  USBDriver *usbp = sdup->config->usbp;
 800e8de:	681d      	ldr	r5, [r3, #0]
  iqResetI(&sdup->iqueue);
 800e8e0:	f7ff fb36 	bl	800df50 <chIQResetI>
  oqResetI(&sdup->oqueue);
 800e8e4:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800e8e8:	f7ff fbba 	bl	800e060 <chOQResetI>
  chEvtBroadcastFlagsI(esp, flags);
 800e8ec:	1d20      	adds	r0, r4, #4
 800e8ee:	2101      	movs	r1, #1
 800e8f0:	f7ff faae 	bl	800de50 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800e8f4:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800e8f8:	7959      	ldrb	r1, [r3, #5]
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800e8fa:	eb05 0381 	add.w	r3, r5, r1, lsl #2
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800e8fe:	4628      	mov	r0, r5
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 800e900:	68db      	ldr	r3, [r3, #12]
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800e902:	4632      	mov	r2, r6
 800e904:	8a5b      	ldrh	r3, [r3, #18]
 800e906:	f000 f94b 	bl	800eba0 <usbPrepareQueuedReceive>
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800e90a:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800e90e:	4628      	mov	r0, r5
 800e910:	7959      	ldrb	r1, [r3, #5]
}
 800e912:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800e916:	f000 b963 	b.w	800ebe0 <usbStartReceiveI>
 800e91a:	bf00      	nop
 800e91c:	0000      	movs	r0, r0
	...

0800e920 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 800e920:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 800e924:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800e928:	2b20      	cmp	r3, #32
 800e92a:	d001      	beq.n	800e930 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800e92c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800e92e:	4770      	bx	lr
    switch (usbp->setup[1]) {
 800e930:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 800e934:	2b20      	cmp	r3, #32
 800e936:	d3f9      	bcc.n	800e92c <sduRequestsHook+0xc>
 800e938:	2b21      	cmp	r3, #33	; 0x21
 800e93a:	d807      	bhi.n	800e94c <sduRequestsHook+0x2c>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800e93c:	4b07      	ldr	r3, [pc, #28]	; (800e95c <sduRequestsHook+0x3c>)
 800e93e:	6383      	str	r3, [r0, #56]	; 0x38
 800e940:	2207      	movs	r2, #7
 800e942:	2300      	movs	r3, #0
 800e944:	e9c0 230f 	strd	r2, r3, [r0, #60]	; 0x3c
      return true;
 800e948:	2001      	movs	r0, #1
 800e94a:	4770      	bx	lr
    switch (usbp->setup[1]) {
 800e94c:	2b22      	cmp	r3, #34	; 0x22
 800e94e:	d1ed      	bne.n	800e92c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800e950:	2300      	movs	r3, #0
 800e952:	e9c0 330e 	strd	r3, r3, [r0, #56]	; 0x38
 800e956:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800e958:	2001      	movs	r0, #1
 800e95a:	4770      	bx	lr
 800e95c:	20001000 	.word	0x20001000

0800e960 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800e960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800e962:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 800e966:	699c      	ldr	r4, [r3, #24]

  if (sdup == NULL) {
 800e968:	b34c      	cbz	r4, 800e9be <sduDataTransmitted+0x5e>
 800e96a:	460e      	mov	r6, r1
 800e96c:	4605      	mov	r5, r0
 800e96e:	2720      	movs	r7, #32
 800e970:	f387 8811 	msr	BASEPRI, r7
 800e974:	2108      	movs	r1, #8
 800e976:	1d20      	adds	r0, r4, #4
 800e978:	f7ff fa6a 	bl	800de50 <chEvtBroadcastFlagsI>
  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800e97c:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
 800e980:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800e982:	1a5b      	subs	r3, r3, r1

  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800e984:	1a9b      	subs	r3, r3, r2
 800e986:	d11b      	bne.n	800e9c0 <sduDataTransmitted+0x60>
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800e988:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 800e98c:	68db      	ldr	r3, [r3, #12]
 800e98e:	695a      	ldr	r2, [r3, #20]
 800e990:	6852      	ldr	r2, [r2, #4]
 800e992:	b18a      	cbz	r2, 800e9b8 <sduDataTransmitted+0x58>
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800e994:	8a1b      	ldrh	r3, [r3, #16]
 800e996:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800e998:	4013      	ands	r3, r2
 800e99a:	d10d      	bne.n	800e9b8 <sduDataTransmitted+0x58>
 800e99c:	f383 8811 	msr	BASEPRI, r3
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
 800e9a0:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800e9a4:	4631      	mov	r1, r6
 800e9a6:	4628      	mov	r0, r5
 800e9a8:	f000 f90a 	bl	800ebc0 <usbPrepareQueuedTransmit>
 800e9ac:	f387 8811 	msr	BASEPRI, r7

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
 800e9b0:	4631      	mov	r1, r6
 800e9b2:	4628      	mov	r0, r5
 800e9b4:	f000 f92c 	bl	800ec10 <usbStartTransmitI>
 800e9b8:	2300      	movs	r3, #0
 800e9ba:	f383 8811 	msr	BASEPRI, r3
  }
  /*lint -restore*/

  osalSysUnlockFromISR();
}
 800e9be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e9c0:	2200      	movs	r2, #0
 800e9c2:	f382 8811 	msr	BASEPRI, r2
 800e9c6:	e7eb      	b.n	800e9a0 <sduDataTransmitted+0x40>
	...

0800e9d0 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800e9d0:	f101 0309 	add.w	r3, r1, #9
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800e9d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800e9d8:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]

  if (sdup == NULL) {
 800e9dc:	b1bc      	cbz	r4, 800ea0e <sduDataReceived+0x3e>
 800e9de:	4607      	mov	r7, r0
 800e9e0:	460e      	mov	r6, r1
 800e9e2:	f04f 0820 	mov.w	r8, #32
 800e9e6:	f388 8811 	msr	BASEPRI, r8
 800e9ea:	2104      	movs	r1, #4
 800e9ec:	1860      	adds	r0, r4, r1
 800e9ee:	f7ff fa2f 	bl	800de50 <chEvtBroadcastFlagsI>
  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Writes to the input queue can only happen when there is enough space
     to hold at least one packet.*/
  maxsize = usbp->epc[ep]->out_maxsize;
 800e9f2:	eb07 0386 	add.w	r3, r7, r6, lsl #2
  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 800e9f6:	69e5      	ldr	r5, [r4, #28]
 800e9f8:	68d9      	ldr	r1, [r3, #12]
 800e9fa:	69a2      	ldr	r2, [r4, #24]
 800e9fc:	6963      	ldr	r3, [r4, #20]
 800e9fe:	8a49      	ldrh	r1, [r1, #18]
 800ea00:	1aaa      	subs	r2, r5, r2
 800ea02:	1ad2      	subs	r2, r2, r3
  if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 800ea04:	4291      	cmp	r1, r2
 800ea06:	d904      	bls.n	800ea12 <sduDataReceived+0x42>
 800ea08:	2300      	movs	r3, #0
 800ea0a:	f383 8811 	msr	BASEPRI, r3

    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, ep);
  }
  osalSysUnlockFromISR();
}
 800ea0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ea12:	2300      	movs	r3, #0
 800ea14:	f383 8811 	msr	BASEPRI, r3
    n = (n / maxsize) * maxsize;
 800ea18:	fbb2 f3f1 	udiv	r3, r2, r1
    usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
 800ea1c:	4638      	mov	r0, r7
 800ea1e:	fb01 f303 	mul.w	r3, r1, r3
 800ea22:	f104 020c 	add.w	r2, r4, #12
 800ea26:	4631      	mov	r1, r6
 800ea28:	f000 f8ba 	bl	800eba0 <usbPrepareQueuedReceive>
 800ea2c:	f388 8811 	msr	BASEPRI, r8
    (void) usbStartReceiveI(usbp, ep);
 800ea30:	4631      	mov	r1, r6
 800ea32:	4638      	mov	r0, r7
 800ea34:	f000 f8d4 	bl	800ebe0 <usbStartReceiveI>
 800ea38:	e7e6      	b.n	800ea08 <sduDataReceived+0x38>
 800ea3a:	bf00      	nop
 800ea3c:	0000      	movs	r0, r0
	...

0800ea40 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 800ea40:	4770      	bx	lr
 800ea42:	bf00      	nop
	...

0800ea50 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
 800ea50:	f002 bb4e 	b.w	80110f0 <spi_lld_init>
	...

0800ea60 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 800ea60:	2201      	movs	r2, #1
  spip->config = NULL;
 800ea62:	2300      	movs	r3, #0
  spip->state = SPI_STOP;
 800ea64:	7002      	strb	r2, [r0, #0]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800ea66:	e9c0 3301 	strd	r3, r3, [r0, #4]
  chMtxObjectInit(mp);
 800ea6a:	300c      	adds	r0, #12
 800ea6c:	f7ff b8f0 	b.w	800dc50 <chMtxObjectInit>

0800ea70 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
 800ea70:	f002 bd6e 	b.w	8011550 <uart_lld_init>
	...

0800ea80 <uartObjectInit>:
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state   = UART_STOP;
  uartp->txstate = UART_TX_IDLE;
 800ea80:	2300      	movs	r3, #0
  uartp->state   = UART_STOP;
 800ea82:	2201      	movs	r2, #1
 800ea84:	7002      	strb	r2, [r0, #0]
  uartp->txstate = UART_TX_IDLE;
 800ea86:	7043      	strb	r3, [r0, #1]
  uartp->rxstate = UART_RX_IDLE;
 800ea88:	7083      	strb	r3, [r0, #2]
  uartp->config  = NULL;
 800ea8a:	6043      	str	r3, [r0, #4]
  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
 800ea8c:	4770      	bx	lr
 800ea8e:	bf00      	nop

0800ea90 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
 800ea90:	b510      	push	{r4, lr}
 800ea92:	2320      	movs	r3, #32
 800ea94:	4604      	mov	r4, r0
 800ea96:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
 800ea9a:	6041      	str	r1, [r0, #4]
  uart_lld_start(uartp);
 800ea9c:	f002 fd80 	bl	80115a0 <uart_lld_start>
  uartp->state = UART_READY;
 800eaa0:	2302      	movs	r3, #2
 800eaa2:	7023      	strb	r3, [r4, #0]
 800eaa4:	2300      	movs	r3, #0
 800eaa6:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800eaaa:	bd10      	pop	{r4, pc}
 800eaac:	0000      	movs	r0, r0
	...

0800eab0 <uartStop>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @api
 */
void uartStop(UARTDriver *uartp) {
 800eab0:	b510      	push	{r4, lr}
 800eab2:	2320      	movs	r3, #32
 800eab4:	4604      	mov	r4, r0
 800eab6:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uart_lld_stop(uartp);
 800eaba:	f002 fe19 	bl	80116f0 <uart_lld_stop>
  uartp->state = UART_STOP;
  uartp->txstate = UART_TX_IDLE;
 800eabe:	2300      	movs	r3, #0
  uartp->state = UART_STOP;
 800eac0:	2201      	movs	r2, #1
 800eac2:	7022      	strb	r2, [r4, #0]
  uartp->txstate = UART_TX_IDLE;
 800eac4:	7063      	strb	r3, [r4, #1]
  uartp->rxstate = UART_RX_IDLE;
 800eac6:	70a3      	strb	r3, [r4, #2]
 800eac8:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800eacc:	bd10      	pop	{r4, pc}
 800eace:	bf00      	nop

0800ead0 <uartStartSend>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void uartStartSend(UARTDriver *uartp, size_t n, const void *txbuf) {
 800ead0:	b510      	push	{r4, lr}
 800ead2:	2320      	movs	r3, #32
 800ead4:	4604      	mov	r4, r0
 800ead6:	f383 8811 	msr	BASEPRI, r3
             
  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");

  uart_lld_start_send(uartp, n, txbuf);
 800eada:	f002 fe39 	bl	8011750 <uart_lld_start_send>
  uartp->txstate = UART_TX_ACTIVE;
 800eade:	2301      	movs	r3, #1
 800eae0:	7063      	strb	r3, [r4, #1]
 800eae2:	2300      	movs	r3, #0
 800eae4:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800eae8:	bd10      	pop	{r4, pc}
 800eaea:	bf00      	nop
 800eaec:	0000      	movs	r0, r0
	...

0800eaf0 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 800eaf0:	f001 bf06 	b.w	8010900 <usb_lld_init>
	...

0800eb00 <usbObjectInit>:
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800eb00:	2300      	movs	r3, #0
  usbp->state        = USB_STOP;
 800eb02:	2201      	movs	r2, #1
 800eb04:	7002      	strb	r2, [r0, #0]
    usbp->in_params[i]  = NULL;
 800eb06:	61c3      	str	r3, [r0, #28]
    usbp->out_params[i] = NULL;
 800eb08:	6283      	str	r3, [r0, #40]	; 0x28
    usbp->in_params[i]  = NULL;
 800eb0a:	6203      	str	r3, [r0, #32]
    usbp->out_params[i] = NULL;
 800eb0c:	62c3      	str	r3, [r0, #44]	; 0x2c
    usbp->in_params[i]  = NULL;
 800eb0e:	6243      	str	r3, [r0, #36]	; 0x24
    usbp->out_params[i] = NULL;
 800eb10:	6303      	str	r3, [r0, #48]	; 0x30
  usbp->config       = NULL;
 800eb12:	e9c0 3301 	strd	r3, r3, [r0, #4]
  }
  usbp->transmitting = 0;
  usbp->receiving    = 0;
}
 800eb16:	4770      	bx	lr
	...

0800eb20 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800eb20:	b538      	push	{r3, r4, r5, lr}
 800eb22:	4604      	mov	r4, r0
 800eb24:	2320      	movs	r3, #32
 800eb26:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800eb2a:	2500      	movs	r5, #0
  usbp->config = config;
 800eb2c:	6041      	str	r1, [r0, #4]
    usbp->epc[i] = NULL;
 800eb2e:	e9c0 5503 	strd	r5, r5, [r0, #12]
 800eb32:	e9c0 5505 	strd	r5, r5, [r0, #20]
  }
  usb_lld_start(usbp);
 800eb36:	f001 fefb 	bl	8010930 <usb_lld_start>
  usbp->state = USB_READY;
 800eb3a:	2302      	movs	r3, #2
 800eb3c:	7023      	strb	r3, [r4, #0]
 800eb3e:	f385 8811 	msr	BASEPRI, r5
  osalSysUnlock();
}
 800eb42:	bd38      	pop	{r3, r4, r5, pc}
	...

0800eb50 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 800eb50:	b510      	push	{r4, lr}
 800eb52:	2320      	movs	r3, #32
 800eb54:	4604      	mov	r4, r0
 800eb56:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE),
                "invalid state");
  usb_lld_stop(usbp);
 800eb5a:	f001 ff61 	bl	8010a20 <usb_lld_stop>
  usbp->state = USB_STOP;
 800eb5e:	2301      	movs	r3, #1
 800eb60:	7023      	strb	r3, [r4, #0]
 800eb62:	2300      	movs	r3, #0
 800eb64:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800eb68:	bd10      	pop	{r4, pc}
 800eb6a:	bf00      	nop
 800eb6c:	0000      	movs	r0, r0
	...

0800eb70 <usbInitEndpointI>:
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 800eb70:	6953      	ldr	r3, [r2, #20]
                      const USBEndpointConfig *epcp) {
 800eb72:	b410      	push	{r4}
  if (epcp->in_state != NULL) {
 800eb74:	b12b      	cbz	r3, 800eb82 <usbInitEndpointI+0x12>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800eb76:	2400      	movs	r4, #0
 800eb78:	601c      	str	r4, [r3, #0]
 800eb7a:	605c      	str	r4, [r3, #4]
 800eb7c:	609c      	str	r4, [r3, #8]
 800eb7e:	60dc      	str	r4, [r3, #12]
 800eb80:	611c      	str	r4, [r3, #16]
  }
  if (epcp->out_state != NULL) {
 800eb82:	6993      	ldr	r3, [r2, #24]
 800eb84:	b12b      	cbz	r3, 800eb92 <usbInitEndpointI+0x22>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800eb86:	2400      	movs	r4, #0
 800eb88:	601c      	str	r4, [r3, #0]
 800eb8a:	605c      	str	r4, [r3, #4]
 800eb8c:	609c      	str	r4, [r3, #8]
 800eb8e:	60dc      	str	r4, [r3, #12]
 800eb90:	611c      	str	r4, [r3, #16]
  }

  usbp->epc[ep] = epcp;
 800eb92:	eb00 0381 	add.w	r3, r0, r1, lsl #2

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
}
 800eb96:	f85d 4b04 	ldr.w	r4, [sp], #4
  usbp->epc[ep] = epcp;
 800eb9a:	60da      	str	r2, [r3, #12]
  usb_lld_init_endpoint(usbp, ep);
 800eb9c:	f001 bfd8 	b.w	8010b50 <usb_lld_init_endpoint>

0800eba0 <usbPrepareQueuedReceive>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
 800eba0:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800eba2:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  osp->rxqueued           = true;
 800eba6:	2501      	movs	r5, #1
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800eba8:	68e4      	ldr	r4, [r4, #12]
 800ebaa:	69a4      	ldr	r4, [r4, #24]
  osp->mode.queue.rxqueue = iqp;
 800ebac:	60e2      	str	r2, [r4, #12]
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800ebae:	2200      	movs	r2, #0
  osp->rxsize             = n;
 800ebb0:	6063      	str	r3, [r4, #4]
  osp->rxqueued           = true;
 800ebb2:	7025      	strb	r5, [r4, #0]
  osp->rxcnt              = 0;
 800ebb4:	60a2      	str	r2, [r4, #8]

  usb_lld_prepare_receive(usbp, ep);
}
 800ebb6:	bc30      	pop	{r4, r5}
  usb_lld_prepare_receive(usbp, ep);
 800ebb8:	f002 b8b2 	b.w	8010d20 <usb_lld_prepare_receive>
 800ebbc:	0000      	movs	r0, r0
	...

0800ebc0 <usbPrepareQueuedTransmit>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
 800ebc0:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800ebc2:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  isp->txqueued           = true;
 800ebc6:	2501      	movs	r5, #1
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800ebc8:	68e4      	ldr	r4, [r4, #12]
 800ebca:	6964      	ldr	r4, [r4, #20]
  isp->mode.queue.txqueue = oqp;
 800ebcc:	60e2      	str	r2, [r4, #12]
  isp->txsize             = n;
  isp->txcnt              = 0;
 800ebce:	2200      	movs	r2, #0
  isp->txsize             = n;
 800ebd0:	6063      	str	r3, [r4, #4]
  isp->txqueued           = true;
 800ebd2:	7025      	strb	r5, [r4, #0]
  isp->txcnt              = 0;
 800ebd4:	60a2      	str	r2, [r4, #8]

  usb_lld_prepare_transmit(usbp, ep);
}
 800ebd6:	bc30      	pop	{r4, r5}
  usb_lld_prepare_transmit(usbp, ep);
 800ebd8:	f002 b912 	b.w	8010e00 <usb_lld_prepare_transmit>
 800ebdc:	0000      	movs	r0, r0
	...

0800ebe0 <usbStartReceiveI>:
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800ebe0:	2201      	movs	r2, #1
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 800ebe2:	b570      	push	{r4, r5, r6, lr}
  if (usbGetReceiveStatusI(usbp, ep)) {
 800ebe4:	fa02 f301 	lsl.w	r3, r2, r1
 800ebe8:	8944      	ldrh	r4, [r0, #10]
 800ebea:	b29b      	uxth	r3, r3
 800ebec:	ea14 0603 	ands.w	r6, r4, r3
 800ebf0:	d001      	beq.n	800ebf6 <usbStartReceiveI+0x16>
    return true;
 800ebf2:	4610      	mov	r0, r2
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 800ebf4:	bd70      	pop	{r4, r5, r6, pc}
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800ebf6:	4323      	orrs	r3, r4
 800ebf8:	8143      	strh	r3, [r0, #10]
  usb_lld_start_out(usbp, ep);
 800ebfa:	f002 fa11 	bl	8011020 <usb_lld_start_out>
  return false;
 800ebfe:	4630      	mov	r0, r6
}
 800ec00:	bd70      	pop	{r4, r5, r6, pc}
 800ec02:	bf00      	nop
	...

0800ec10 <usbStartTransmitI>:
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 800ec10:	2201      	movs	r2, #1
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 800ec12:	b570      	push	{r4, r5, r6, lr}
  if (usbGetTransmitStatusI(usbp, ep)) {
 800ec14:	fa02 f301 	lsl.w	r3, r2, r1
 800ec18:	8904      	ldrh	r4, [r0, #8]
 800ec1a:	b29b      	uxth	r3, r3
 800ec1c:	ea14 0603 	ands.w	r6, r4, r3
 800ec20:	d001      	beq.n	800ec26 <usbStartTransmitI+0x16>
    return true;
 800ec22:	4610      	mov	r0, r2
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 800ec24:	bd70      	pop	{r4, r5, r6, pc}
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800ec26:	4323      	orrs	r3, r4
 800ec28:	8103      	strh	r3, [r0, #8]
  usb_lld_start_in(usbp, ep);
 800ec2a:	f002 fa09 	bl	8011040 <usb_lld_start_in>
  return false;
 800ec2e:	4630      	mov	r0, r6
}
 800ec30:	bd70      	pop	{r4, r5, r6, pc}
 800ec32:	bf00      	nop
	...

0800ec40 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 800ec40:	2200      	movs	r2, #0
  usbp->state         = USB_READY;
 800ec42:	2102      	movs	r1, #2
 800ec44:	7001      	strb	r1, [r0, #0]
  usbp->status        = 0;
 800ec46:	64c2      	str	r2, [r0, #76]	; 0x4c
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;
 800ec48:	e9c0 2202 	strd	r2, r2, [r0, #8]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800ec4c:	e9c0 2204 	strd	r2, r2, [r0, #16]
 800ec50:	6182      	str	r2, [r0, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800ec52:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 800ec56:	f001 bf0b 	b.w	8010a70 <usb_lld_reset>
 800ec5a:	bf00      	nop
 800ec5c:	0000      	movs	r0, r0
	...

0800ec60 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800ec60:	b570      	push	{r4, r5, r6, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800ec62:	2300      	movs	r3, #0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800ec64:	4604      	mov	r4, r0
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800ec66:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  usbReadSetup(usbp, ep, usbp->setup);
 800ec6a:	f100 0244 	add.w	r2, r0, #68	; 0x44
 800ec6e:	f002 f847 	bl	8010d00 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800ec72:	6863      	ldr	r3, [r4, #4]
 800ec74:	689b      	ldr	r3, [r3, #8]
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	d033      	beq.n	800ece2 <_usb_ep0setup+0x82>
      !(usbp->config->requests_hook_cb(usbp))) {
 800ec7a:	4620      	mov	r0, r4
 800ec7c:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800ec7e:	b380      	cbz	r0, 800ece2 <_usb_ep0setup+0x82>
 800ec80:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800ec82:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  hw |= (uint16_t)*p << 8U;
 800ec86:	f894 004b 	ldrb.w	r0, [r4, #75]	; 0x4b
 800ec8a:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 800ec8e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 800ec92:	428a      	cmp	r2, r1
 800ec94:	bf2c      	ite	cs
 800ec96:	460a      	movcs	r2, r1
    usbp->ep0n = max;
 800ec98:	63e2      	strcc	r2, [r4, #60]	; 0x3c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800ec9a:	0618      	lsls	r0, r3, #24
 800ec9c:	68e1      	ldr	r1, [r4, #12]
 800ec9e:	f100 8099 	bmi.w	800edd4 <_usb_ep0setup+0x174>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800eca2:	2a00      	cmp	r2, #0
 800eca4:	d07b      	beq.n	800ed9e <_usb_ep0setup+0x13e>
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800eca6:	698b      	ldr	r3, [r1, #24]
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 800eca8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  osp->rxqueued           = false;
 800ecaa:	2100      	movs	r1, #0
      usbp->ep0state = USB_EP0_RX;
 800ecac:	2504      	movs	r5, #4
 800ecae:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
  osp->mode.linear.rxbuf  = buf;
 800ecb2:	60d8      	str	r0, [r3, #12]
  osp->rxsize             = n;
 800ecb4:	605a      	str	r2, [r3, #4]
  osp->rxqueued           = false;
 800ecb6:	7019      	strb	r1, [r3, #0]
  osp->rxcnt              = 0;
 800ecb8:	6099      	str	r1, [r3, #8]
  usb_lld_prepare_receive(usbp, ep);
 800ecba:	4620      	mov	r0, r4
 800ecbc:	f002 f830 	bl	8010d20 <usb_lld_prepare_receive>
 800ecc0:	2320      	movs	r3, #32
 800ecc2:	f383 8811 	msr	BASEPRI, r3
  if (usbGetReceiveStatusI(usbp, ep)) {
 800ecc6:	8963      	ldrh	r3, [r4, #10]
 800ecc8:	f013 0101 	ands.w	r1, r3, #1
 800eccc:	d105      	bne.n	800ecda <_usb_ep0setup+0x7a>
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800ecce:	f043 0301 	orr.w	r3, r3, #1
 800ecd2:	8163      	strh	r3, [r4, #10]
  usb_lld_start_out(usbp, ep);
 800ecd4:	4620      	mov	r0, r4
 800ecd6:	f002 f9a3 	bl	8011020 <usb_lld_start_out>
 800ecda:	2300      	movs	r3, #0
 800ecdc:	f383 8811 	msr	BASEPRI, r3
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 800ece0:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800ece2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800ece6:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 800ecea:	4618      	mov	r0, r3
 800ecec:	d011      	beq.n	800ed12 <_usb_ep0setup+0xb2>
      usb_lld_stall_in(usbp, 0);
 800ecee:	2100      	movs	r1, #0
 800ecf0:	4620      	mov	r0, r4
 800ecf2:	f002 f9cd 	bl	8011090 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800ecf6:	2100      	movs	r1, #0
 800ecf8:	4620      	mov	r0, r4
 800ecfa:	f002 f9b9 	bl	8011070 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800ecfe:	6863      	ldr	r3, [r4, #4]
 800ed00:	681b      	ldr	r3, [r3, #0]
 800ed02:	b113      	cbz	r3, 800ed0a <_usb_ep0setup+0xaa>
 800ed04:	2105      	movs	r1, #5
 800ed06:	4620      	mov	r0, r4
 800ed08:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800ed0a:	2306      	movs	r3, #6
 800ed0c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800ed10:	bd70      	pop	{r4, r5, r6, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
 800ed12:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800ed16:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800ed1a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800ed1e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800ed22:	f000 8114 	beq.w	800ef4e <_usb_ep0setup+0x2ee>
 800ed26:	d917      	bls.n	800ed58 <_usb_ep0setup+0xf8>
 800ed28:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
 800ed2c:	f000 80f6 	beq.w	800ef1c <_usb_ep0setup+0x2bc>
 800ed30:	f240 8099 	bls.w	800ee66 <_usb_ep0setup+0x206>
 800ed34:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
 800ed38:	d073      	beq.n	800ee22 <_usb_ep0setup+0x1c2>
 800ed3a:	f640 4102 	movw	r1, #3074	; 0xc02
 800ed3e:	428a      	cmp	r2, r1
 800ed40:	f000 80d2 	beq.w	800eee8 <_usb_ep0setup+0x288>
 800ed44:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800ed48:	d1d1      	bne.n	800ecee <_usb_ep0setup+0x8e>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800ed4a:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 800ed4e:	2101      	movs	r1, #1
 800ed50:	6425      	str	r5, [r4, #64]	; 0x40
 800ed52:	e9c4 210e 	strd	r2, r1, [r4, #56]	; 0x38
 800ed56:	e796      	b.n	800ec86 <_usb_ep0setup+0x26>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800ed58:	2a02      	cmp	r2, #2
 800ed5a:	f000 80ab 	beq.w	800eeb4 <_usb_ep0setup+0x254>
 800ed5e:	f240 80a1 	bls.w	800eea4 <_usb_ep0setup+0x244>
 800ed62:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800ed66:	d06f      	beq.n	800ee48 <_usb_ep0setup+0x1e8>
 800ed68:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 800ed6c:	d1bf      	bne.n	800ecee <_usb_ep0setup+0x8e>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800ed6e:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800ed72:	2b00      	cmp	r3, #0
 800ed74:	d1bb      	bne.n	800ecee <_usb_ep0setup+0x8e>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800ed76:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 800ed7a:	f013 010f 	ands.w	r1, r3, #15
 800ed7e:	d007      	beq.n	800ed90 <_usb_ep0setup+0x130>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ed80:	061e      	lsls	r6, r3, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800ed82:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ed84:	f100 80fb 	bmi.w	800ef7e <_usb_ep0setup+0x31e>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 800ed88:	f002 f992 	bl	80110b0 <usb_lld_clear_out>
 800ed8c:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800ed90:	2300      	movs	r3, #0
 800ed92:	e9c4 330e 	strd	r3, r3, [r4, #56]	; 0x38
 800ed96:	6423      	str	r3, [r4, #64]	; 0x40
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800ed98:	0603      	lsls	r3, r0, #24
 800ed9a:	68e1      	ldr	r1, [r4, #12]
 800ed9c:	d436      	bmi.n	800ee0c <_usb_ep0setup+0x1ac>
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800ed9e:	694a      	ldr	r2, [r1, #20]
  isp->txqueued           = false;
 800eda0:	2300      	movs	r3, #0
      usbp->ep0state = USB_EP0_SENDING_STS;
 800eda2:	2105      	movs	r1, #5
 800eda4:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  usb_lld_prepare_transmit(usbp, ep);
 800eda8:	4620      	mov	r0, r4
 800edaa:	4619      	mov	r1, r3
  isp->txqueued           = false;
 800edac:	7013      	strb	r3, [r2, #0]
  isp->mode.linear.txbuf  = buf;
 800edae:	60d3      	str	r3, [r2, #12]
  isp->txcnt              = 0;
 800edb0:	e9c2 3301 	strd	r3, r3, [r2, #4]
  usb_lld_prepare_transmit(usbp, ep);
 800edb4:	f002 f824 	bl	8010e00 <usb_lld_prepare_transmit>
 800edb8:	2320      	movs	r3, #32
 800edba:	f383 8811 	msr	BASEPRI, r3
  if (usbGetTransmitStatusI(usbp, ep)) {
 800edbe:	8923      	ldrh	r3, [r4, #8]
 800edc0:	f013 0101 	ands.w	r1, r3, #1
 800edc4:	d189      	bne.n	800ecda <_usb_ep0setup+0x7a>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800edc6:	f043 0301 	orr.w	r3, r3, #1
 800edca:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 800edcc:	4620      	mov	r0, r4
 800edce:	f002 f937 	bl	8011040 <usb_lld_start_in>
 800edd2:	e782      	b.n	800ecda <_usb_ep0setup+0x7a>
    if (usbp->ep0n != 0U) {
 800edd4:	b1d2      	cbz	r2, 800ee0c <_usb_ep0setup+0x1ac>
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800edd6:	694b      	ldr	r3, [r1, #20]
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800edd8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  isp->txqueued           = false;
 800edda:	2100      	movs	r1, #0
      usbp->ep0state = USB_EP0_TX;
 800eddc:	2501      	movs	r5, #1
 800edde:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
  isp->mode.linear.txbuf  = buf;
 800ede2:	60d8      	str	r0, [r3, #12]
  isp->txsize             = n;
 800ede4:	605a      	str	r2, [r3, #4]
  isp->txqueued           = false;
 800ede6:	7019      	strb	r1, [r3, #0]
  isp->txcnt              = 0;
 800ede8:	6099      	str	r1, [r3, #8]
  usb_lld_prepare_transmit(usbp, ep);
 800edea:	4620      	mov	r0, r4
 800edec:	f002 f808 	bl	8010e00 <usb_lld_prepare_transmit>
 800edf0:	2320      	movs	r3, #32
 800edf2:	f383 8811 	msr	BASEPRI, r3
  if (usbGetTransmitStatusI(usbp, ep)) {
 800edf6:	8923      	ldrh	r3, [r4, #8]
 800edf8:	ea13 0105 	ands.w	r1, r3, r5
 800edfc:	f47f af6d 	bne.w	800ecda <_usb_ep0setup+0x7a>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800ee00:	432b      	orrs	r3, r5
 800ee02:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 800ee04:	4620      	mov	r0, r4
 800ee06:	f002 f91b 	bl	8011040 <usb_lld_start_in>
 800ee0a:	e766      	b.n	800ecda <_usb_ep0setup+0x7a>
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800ee0c:	698a      	ldr	r2, [r1, #24]
  osp->rxqueued           = false;
 800ee0e:	2300      	movs	r3, #0
      usbp->ep0state = USB_EP0_WAITING_STS;
 800ee10:	2103      	movs	r1, #3
 800ee12:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  usb_lld_prepare_receive(usbp, ep);
 800ee16:	4619      	mov	r1, r3
  osp->rxqueued           = false;
 800ee18:	7013      	strb	r3, [r2, #0]
  osp->mode.linear.rxbuf  = buf;
 800ee1a:	60d3      	str	r3, [r2, #12]
  osp->rxcnt              = 0;
 800ee1c:	e9c2 3301 	strd	r3, r3, [r2, #4]
 800ee20:	e74b      	b.n	800ecba <_usb_ep0setup+0x5a>
    usbp->configuration = usbp->setup[2];
 800ee22:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800ee26:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 800ee2a:	2b00      	cmp	r3, #0
 800ee2c:	f040 809e 	bne.w	800ef6c <_usb_ep0setup+0x30c>
      usbp->state = USB_SELECTED;
 800ee30:	2303      	movs	r3, #3
 800ee32:	7023      	strb	r3, [r4, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800ee34:	6863      	ldr	r3, [r4, #4]
 800ee36:	681b      	ldr	r3, [r3, #0]
 800ee38:	2b00      	cmp	r3, #0
 800ee3a:	d0a9      	beq.n	800ed90 <_usb_ep0setup+0x130>
 800ee3c:	4620      	mov	r0, r4
 800ee3e:	2102      	movs	r1, #2
 800ee40:	4798      	blx	r3
 800ee42:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800ee46:	e7a3      	b.n	800ed90 <_usb_ep0setup+0x130>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800ee48:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800ee4c:	2b01      	cmp	r3, #1
 800ee4e:	f47f af4e 	bne.w	800ecee <_usb_ep0setup+0x8e>
      usbp->status &= ~2U;
 800ee52:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800ee56:	63a5      	str	r5, [r4, #56]	; 0x38
      usbp->status &= ~2U;
 800ee58:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800ee5c:	e9c4 550f 	strd	r5, r5, [r4, #60]	; 0x3c
      usbp->status &= ~2U;
 800ee60:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800ee64:	e798      	b.n	800ed98 <_usb_ep0setup+0x138>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800ee66:	f240 3302 	movw	r3, #770	; 0x302
 800ee6a:	429a      	cmp	r2, r3
 800ee6c:	d043      	beq.n	800eef6 <_usb_ep0setup+0x296>
 800ee6e:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800ee72:	f47f af3c 	bne.w	800ecee <_usb_ep0setup+0x8e>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800ee76:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 800ee7a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800ee7e:	d187      	bne.n	800ed90 <_usb_ep0setup+0x130>
  usbp->address = usbp->setup[2];
 800ee80:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800ee84:	f884 304e 	strb.w	r3, [r4, #78]	; 0x4e
  usb_lld_set_address(usbp);
 800ee88:	4620      	mov	r0, r4
 800ee8a:	f001 fe51 	bl	8010b30 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 800ee8e:	6863      	ldr	r3, [r4, #4]
 800ee90:	681b      	ldr	r3, [r3, #0]
 800ee92:	b113      	cbz	r3, 800ee9a <_usb_ep0setup+0x23a>
 800ee94:	2101      	movs	r1, #1
 800ee96:	4620      	mov	r0, r4
 800ee98:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800ee9a:	2303      	movs	r3, #3
 800ee9c:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800eea0:	7023      	strb	r3, [r4, #0]
 800eea2:	e775      	b.n	800ed90 <_usb_ep0setup+0x130>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800eea4:	b9ea      	cbnz	r2, 800eee2 <_usb_ep0setup+0x282>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800eea6:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 800eeaa:	2102      	movs	r1, #2
 800eeac:	6422      	str	r2, [r4, #64]	; 0x40
 800eeae:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
 800eeb2:	e6e8      	b.n	800ec86 <_usb_ep0setup+0x26>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800eeb4:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 800eeb8:	f003 010f 	and.w	r1, r3, #15
 800eebc:	061b      	lsls	r3, r3, #24
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800eebe:	4620      	mov	r0, r4
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800eec0:	d457      	bmi.n	800ef72 <_usb_ep0setup+0x312>
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800eec2:	f001 fefd 	bl	8010cc0 <usb_lld_get_status_out>
 800eec6:	2801      	cmp	r0, #1
 800eec8:	d057      	beq.n	800ef7a <_usb_ep0setup+0x31a>
 800eeca:	2802      	cmp	r0, #2
 800eecc:	f47f af0f 	bne.w	800ecee <_usb_ep0setup+0x8e>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800eed0:	4b30      	ldr	r3, [pc, #192]	; (800ef94 <_usb_ep0setup+0x334>)
 800eed2:	63a3      	str	r3, [r4, #56]	; 0x38
 800eed4:	2102      	movs	r1, #2
 800eed6:	2300      	movs	r3, #0
 800eed8:	e9c4 130f 	strd	r1, r3, [r4, #60]	; 0x3c
 800eedc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800eee0:	e6d1      	b.n	800ec86 <_usb_ep0setup+0x26>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800eee2:	2a01      	cmp	r2, #1
 800eee4:	f47f af03 	bne.w	800ecee <_usb_ep0setup+0x8e>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800eee8:	4a2b      	ldr	r2, [pc, #172]	; (800ef98 <_usb_ep0setup+0x338>)
 800eeea:	63a2      	str	r2, [r4, #56]	; 0x38
 800eeec:	2102      	movs	r1, #2
 800eeee:	2200      	movs	r2, #0
 800eef0:	e9c4 120f 	strd	r1, r2, [r4, #60]	; 0x3c
 800eef4:	e6c7      	b.n	800ec86 <_usb_ep0setup+0x26>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800eef6:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800eefa:	2b00      	cmp	r3, #0
 800eefc:	f47f aef7 	bne.w	800ecee <_usb_ep0setup+0x8e>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800ef00:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 800ef04:	f013 010f 	ands.w	r1, r3, #15
 800ef08:	f43f af42 	beq.w	800ed90 <_usb_ep0setup+0x130>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ef0c:	061d      	lsls	r5, r3, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800ef0e:	4620      	mov	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ef10:	d43a      	bmi.n	800ef88 <_usb_ep0setup+0x328>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800ef12:	f002 f8ad 	bl	8011070 <usb_lld_stall_out>
 800ef16:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800ef1a:	e739      	b.n	800ed90 <_usb_ep0setup+0x130>
  hw |= (uint16_t)*p << 8U;
 800ef1c:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800ef20:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 800ef22:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800ef26:	684e      	ldr	r6, [r1, #4]
 800ef28:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800ef2c:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 800ef30:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800ef34:	4620      	mov	r0, r4
 800ef36:	47b0      	blx	r6
    if (dp == NULL) {
 800ef38:	2800      	cmp	r0, #0
 800ef3a:	f43f aed8 	beq.w	800ecee <_usb_ep0setup+0x8e>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800ef3e:	e9d0 1300 	ldrd	r1, r3, [r0]
 800ef42:	6425      	str	r5, [r4, #64]	; 0x40
 800ef44:	e9c4 310e 	strd	r3, r1, [r4, #56]	; 0x38
 800ef48:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800ef4c:	e69b      	b.n	800ec86 <_usb_ep0setup+0x26>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800ef4e:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800ef52:	2b01      	cmp	r3, #1
 800ef54:	f47f aecb 	bne.w	800ecee <_usb_ep0setup+0x8e>
      usbp->status |= 2U;
 800ef58:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800ef5c:	63a5      	str	r5, [r4, #56]	; 0x38
      usbp->status |= 2U;
 800ef5e:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800ef62:	e9c4 550f 	strd	r5, r5, [r4, #60]	; 0x3c
      usbp->status |= 2U;
 800ef66:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800ef6a:	e715      	b.n	800ed98 <_usb_ep0setup+0x138>
      usbp->state = USB_ACTIVE;
 800ef6c:	2304      	movs	r3, #4
 800ef6e:	7023      	strb	r3, [r4, #0]
 800ef70:	e760      	b.n	800ee34 <_usb_ep0setup+0x1d4>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800ef72:	f001 feb5 	bl	8010ce0 <usb_lld_get_status_in>
 800ef76:	2801      	cmp	r0, #1
 800ef78:	d1a7      	bne.n	800eeca <_usb_ep0setup+0x26a>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800ef7a:	4b08      	ldr	r3, [pc, #32]	; (800ef9c <_usb_ep0setup+0x33c>)
 800ef7c:	e7a9      	b.n	800eed2 <_usb_ep0setup+0x272>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800ef7e:	f002 f8a7 	bl	80110d0 <usb_lld_clear_in>
 800ef82:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800ef86:	e703      	b.n	800ed90 <_usb_ep0setup+0x130>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800ef88:	f002 f882 	bl	8011090 <usb_lld_stall_in>
 800ef8c:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 800ef90:	e6fe      	b.n	800ed90 <_usb_ep0setup+0x130>
 800ef92:	bf00      	nop
 800ef94:	0802d980 	.word	0x0802d980
 800ef98:	0802d9a0 	.word	0x0802d9a0
 800ef9c:	0802d990 	.word	0x0802d990

0800efa0 <_usb_ep0in>:
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800efa0:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800efa4:	b510      	push	{r4, lr}
 800efa6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 800efa8:	2b06      	cmp	r3, #6
 800efaa:	d823      	bhi.n	800eff4 <_usb_ep0in+0x54>
 800efac:	e8df f003 	tbb	[pc, r3]
 800efb0:	58042a58 	.word	0x58042a58
 800efb4:	2358      	.short	0x2358
 800efb6:	58          	.byte	0x58
 800efb7:	00          	.byte	0x00
 800efb8:	68c3      	ldr	r3, [r0, #12]
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800efba:	699a      	ldr	r2, [r3, #24]
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800efbc:	2103      	movs	r1, #3
  osp->rxqueued           = false;
 800efbe:	2300      	movs	r3, #0
    usbp->ep0state = USB_EP0_WAITING_STS;
 800efc0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  usb_lld_prepare_receive(usbp, ep);
 800efc4:	4620      	mov	r0, r4
 800efc6:	4619      	mov	r1, r3
  osp->rxqueued           = false;
 800efc8:	7013      	strb	r3, [r2, #0]
  osp->mode.linear.rxbuf  = buf;
 800efca:	60d3      	str	r3, [r2, #12]
  osp->rxcnt              = 0;
 800efcc:	e9c2 3301 	strd	r3, r3, [r2, #4]
  usb_lld_prepare_receive(usbp, ep);
 800efd0:	f001 fea6 	bl	8010d20 <usb_lld_prepare_receive>
 800efd4:	2320      	movs	r3, #32
 800efd6:	f383 8811 	msr	BASEPRI, r3
  if (usbGetReceiveStatusI(usbp, ep)) {
 800efda:	8963      	ldrh	r3, [r4, #10]
 800efdc:	f013 0101 	ands.w	r1, r3, #1
 800efe0:	d105      	bne.n	800efee <_usb_ep0in+0x4e>
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800efe2:	f043 0301 	orr.w	r3, r3, #1
 800efe6:	8163      	strh	r3, [r4, #10]
  usb_lld_start_out(usbp, ep);
 800efe8:	4620      	mov	r0, r4
 800efea:	f002 f819 	bl	8011020 <usb_lld_start_out>
 800efee:	2300      	movs	r3, #0
 800eff0:	f383 8811 	msr	BASEPRI, r3
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800eff4:	bd10      	pop	{r4, pc}
    if (usbp->ep0endcb != NULL) {
 800eff6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800eff8:	b103      	cbz	r3, 800effc <_usb_ep0in+0x5c>
      usbp->ep0endcb(usbp);
 800effa:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800effc:	2300      	movs	r3, #0
 800effe:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800f002:	bd10      	pop	{r4, pc}
  hw |= (uint16_t)*p << 8U;
 800f004:	f890 004b 	ldrb.w	r0, [r0, #75]	; 0x4b
 800f008:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
    if ((usbp->ep0n < max) &&
 800f00c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800f00e:	68e3      	ldr	r3, [r4, #12]
    max = (size_t)get_hword(&usbp->setup[6]);
 800f010:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    if ((usbp->ep0n < max) &&
 800f014:	4291      	cmp	r1, r2
 800f016:	d2d0      	bcs.n	800efba <_usb_ep0in+0x1a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800f018:	8a18      	ldrh	r0, [r3, #16]
 800f01a:	fbb1 f2f0 	udiv	r2, r1, r0
 800f01e:	fb00 1212 	mls	r2, r0, r2, r1
    if ((usbp->ep0n < max) &&
 800f022:	2a00      	cmp	r2, #0
 800f024:	d1c9      	bne.n	800efba <_usb_ep0in+0x1a>
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800f026:	695b      	ldr	r3, [r3, #20]
  usb_lld_prepare_transmit(usbp, ep);
 800f028:	4611      	mov	r1, r2
  isp->txqueued           = false;
 800f02a:	701a      	strb	r2, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800f02c:	60da      	str	r2, [r3, #12]
  isp->txcnt              = 0;
 800f02e:	e9c3 2201 	strd	r2, r2, [r3, #4]
  usb_lld_prepare_transmit(usbp, ep);
 800f032:	4620      	mov	r0, r4
 800f034:	f001 fee4 	bl	8010e00 <usb_lld_prepare_transmit>
 800f038:	2320      	movs	r3, #32
 800f03a:	f383 8811 	msr	BASEPRI, r3
  if (usbGetTransmitStatusI(usbp, ep)) {
 800f03e:	8923      	ldrh	r3, [r4, #8]
 800f040:	f013 0101 	ands.w	r1, r3, #1
 800f044:	d105      	bne.n	800f052 <_usb_ep0in+0xb2>
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800f046:	f043 0301 	orr.w	r3, r3, #1
 800f04a:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 800f04c:	4620      	mov	r0, r4
 800f04e:	f001 fff7 	bl	8011040 <usb_lld_start_in>
 800f052:	2300      	movs	r3, #0
 800f054:	f383 8811 	msr	BASEPRI, r3
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800f058:	2302      	movs	r3, #2
 800f05a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800f05e:	bd10      	pop	{r4, pc}
    usb_lld_stall_in(usbp, 0);
 800f060:	2100      	movs	r1, #0
 800f062:	f002 f815 	bl	8011090 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800f066:	2100      	movs	r1, #0
 800f068:	4620      	mov	r0, r4
 800f06a:	f002 f801 	bl	8011070 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800f06e:	6863      	ldr	r3, [r4, #4]
 800f070:	681b      	ldr	r3, [r3, #0]
 800f072:	b113      	cbz	r3, 800f07a <_usb_ep0in+0xda>
 800f074:	2105      	movs	r1, #5
 800f076:	4620      	mov	r0, r4
 800f078:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800f07a:	2306      	movs	r3, #6
 800f07c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800f080:	bd10      	pop	{r4, pc}
 800f082:	bf00      	nop
	...

0800f090 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 800f090:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 800f094:	2a06      	cmp	r2, #6
 800f096:	d814      	bhi.n	800f0c2 <_usb_ep0out+0x32>
 800f098:	2301      	movs	r3, #1
 800f09a:	4093      	lsls	r3, r2
 800f09c:	f013 0f67 	tst.w	r3, #103	; 0x67
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 800f0a0:	b510      	push	{r4, lr}
 800f0a2:	4604      	mov	r4, r0
 800f0a4:	d127      	bne.n	800f0f6 <_usb_ep0out+0x66>
 800f0a6:	f013 0208 	ands.w	r2, r3, #8
 800f0aa:	d00b      	beq.n	800f0c4 <_usb_ep0out+0x34>
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 800f0ac:	68c3      	ldr	r3, [r0, #12]
 800f0ae:	699b      	ldr	r3, [r3, #24]
 800f0b0:	689b      	ldr	r3, [r3, #8]
 800f0b2:	b92b      	cbnz	r3, 800f0c0 <_usb_ep0out+0x30>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800f0b4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800f0b6:	b103      	cbz	r3, 800f0ba <_usb_ep0out+0x2a>
      usbp->ep0endcb(usbp);
 800f0b8:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800f0ba:	2300      	movs	r3, #0
 800f0bc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800f0c0:	bd10      	pop	{r4, pc}
 800f0c2:	4770      	bx	lr
 800f0c4:	06db      	lsls	r3, r3, #27
 800f0c6:	d5fb      	bpl.n	800f0c0 <_usb_ep0out+0x30>
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800f0c8:	68c3      	ldr	r3, [r0, #12]
 800f0ca:	695b      	ldr	r3, [r3, #20]
    usbp->ep0state = USB_EP0_SENDING_STS;
 800f0cc:	2105      	movs	r1, #5
 800f0ce:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34
  isp->txqueued           = false;
 800f0d2:	701a      	strb	r2, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 800f0d4:	60da      	str	r2, [r3, #12]
  isp->txcnt              = 0;
 800f0d6:	e9c3 2201 	strd	r2, r2, [r3, #4]
  usb_lld_prepare_transmit(usbp, ep);
 800f0da:	4611      	mov	r1, r2
 800f0dc:	f001 fe90 	bl	8010e00 <usb_lld_prepare_transmit>
 800f0e0:	2320      	movs	r3, #32
 800f0e2:	f383 8811 	msr	BASEPRI, r3
  if (usbGetTransmitStatusI(usbp, ep)) {
 800f0e6:	8923      	ldrh	r3, [r4, #8]
 800f0e8:	f013 0101 	ands.w	r1, r3, #1
 800f0ec:	d014      	beq.n	800f118 <_usb_ep0out+0x88>
 800f0ee:	2300      	movs	r3, #0
 800f0f0:	f383 8811 	msr	BASEPRI, r3
}
 800f0f4:	bd10      	pop	{r4, pc}
    usb_lld_stall_in(usbp, 0);
 800f0f6:	2100      	movs	r1, #0
 800f0f8:	f001 ffca 	bl	8011090 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800f0fc:	2100      	movs	r1, #0
 800f0fe:	4620      	mov	r0, r4
 800f100:	f001 ffb6 	bl	8011070 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800f104:	6863      	ldr	r3, [r4, #4]
 800f106:	681b      	ldr	r3, [r3, #0]
 800f108:	b113      	cbz	r3, 800f110 <_usb_ep0out+0x80>
 800f10a:	2105      	movs	r1, #5
 800f10c:	4620      	mov	r0, r4
 800f10e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 800f110:	2306      	movs	r3, #6
 800f112:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800f116:	bd10      	pop	{r4, pc}
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800f118:	f043 0301 	orr.w	r3, r3, #1
 800f11c:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 800f11e:	4620      	mov	r0, r4
 800f120:	f001 ff8e 	bl	8011040 <usb_lld_start_in>
 800f124:	e7e3      	b.n	800f0ee <_usb_ep0out+0x5e>
 800f126:	bf00      	nop
	...

0800f130 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800f130:	0943      	lsrs	r3, r0, #5
void nvicEnableVector(uint32_t n, uint32_t prio) {
 800f132:	b410      	push	{r4}
 800f134:	009b      	lsls	r3, r3, #2
  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800f136:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800f13a:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 800f13e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800f142:	0109      	lsls	r1, r1, #4
 800f144:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800f148:	f000 001f 	and.w	r0, r0, #31
 800f14c:	2201      	movs	r2, #1
  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800f14e:	b2c9      	uxtb	r1, r1
 800f150:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 800f154:	fa02 f000 	lsl.w	r0, r2, r0
 800f158:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
}
 800f15c:	f85d 4b04 	ldr.w	r4, [sp], #4
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 800f160:	6018      	str	r0, [r3, #0]
}
 800f162:	4770      	bx	lr
	...

0800f170 <nvicDisableVector>:
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5] = 1 << (n & 0x1F);
 800f170:	4908      	ldr	r1, [pc, #32]	; (800f194 <nvicDisableVector+0x24>)
 800f172:	0943      	lsrs	r3, r0, #5
void nvicDisableVector(uint32_t n) {
 800f174:	b410      	push	{r4}
  NVIC->ICER[n >> 5] = 1 << (n & 0x1F);
 800f176:	3320      	adds	r3, #32
 800f178:	f000 041f 	and.w	r4, r0, #31
 800f17c:	2201      	movs	r2, #1
  NVIC->IP[n]        = 0;
 800f17e:	4408      	add	r0, r1
  NVIC->ICER[n >> 5] = 1 << (n & 0x1F);
 800f180:	40a2      	lsls	r2, r4
  NVIC->IP[n]        = 0;
 800f182:	2400      	movs	r4, #0
  NVIC->ICER[n >> 5] = 1 << (n & 0x1F);
 800f184:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->IP[n]        = 0;
 800f188:	f880 4300 	strb.w	r4, [r0, #768]	; 0x300
}
 800f18c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f190:	4770      	bx	lr
 800f192:	bf00      	nop
 800f194:	e000e100 	.word	0xe000e100
	...

0800f1a0 <nvicSetSystemHandlerPriority>:
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler <= 12);

  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 800f1a0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800f1a4:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
 800f1a8:	0109      	lsls	r1, r1, #4
 800f1aa:	b2c9      	uxtb	r1, r1
 800f1ac:	7601      	strb	r1, [r0, #24]
}
 800f1ae:	4770      	bx	lr

0800f1b0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 800f1b0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800f1b2:	4b07      	ldr	r3, [pc, #28]	; (800f1d0 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 800f1b4:	4a07      	ldr	r2, [pc, #28]	; (800f1d4 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800f1b6:	6819      	ldr	r1, [r3, #0]
 800f1b8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 800f1bc:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800f1be:	6813      	ldr	r3, [r2, #0]
 800f1c0:	b10b      	cbz	r3, 800f1c6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800f1c2:	6850      	ldr	r0, [r2, #4]
 800f1c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800f1c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800f1ca:	f7ff b8c1 	b.w	800e350 <_port_irq_epilogue>
 800f1ce:	bf00      	nop
 800f1d0:	40026000 	.word	0x40026000
 800f1d4:	20001cc8 	.word	0x20001cc8
	...

0800f1e0 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f1e0:	4b08      	ldr	r3, [pc, #32]	; (800f204 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 800f1e2:	4809      	ldr	r0, [pc, #36]	; (800f208 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f1e4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[1].dma_func)
 800f1e6:	6882      	ldr	r2, [r0, #8]
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f1e8:	0989      	lsrs	r1, r1, #6
 800f1ea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector70) {
 800f1ee:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6;
 800f1f0:	018c      	lsls	r4, r1, #6
 800f1f2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800f1f4:	b10a      	cbz	r2, 800f1fa <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 800f1f6:	68c0      	ldr	r0, [r0, #12]
 800f1f8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f1fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f1fe:	f7ff b8a7 	b.w	800e350 <_port_irq_epilogue>
 800f202:	bf00      	nop
 800f204:	40026000 	.word	0x40026000
 800f208:	20001cc8 	.word	0x20001cc8
 800f20c:	00000000 	.word	0x00000000

0800f210 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f210:	4b08      	ldr	r3, [pc, #32]	; (800f234 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 800f212:	4809      	ldr	r0, [pc, #36]	; (800f238 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f214:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[2].dma_func)
 800f216:	6902      	ldr	r2, [r0, #16]
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f218:	0c09      	lsrs	r1, r1, #16
 800f21a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector74) {
 800f21e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16;
 800f220:	040c      	lsls	r4, r1, #16
 800f222:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800f224:	b10a      	cbz	r2, 800f22a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800f226:	6940      	ldr	r0, [r0, #20]
 800f228:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f22a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f22e:	f7ff b88f 	b.w	800e350 <_port_irq_epilogue>
 800f232:	bf00      	nop
 800f234:	40026000 	.word	0x40026000
 800f238:	20001cc8 	.word	0x20001cc8
 800f23c:	00000000 	.word	0x00000000

0800f240 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f240:	4b08      	ldr	r3, [pc, #32]	; (800f264 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 800f242:	4809      	ldr	r0, [pc, #36]	; (800f268 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f244:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[3].dma_func)
 800f246:	6982      	ldr	r2, [r0, #24]
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f248:	0d89      	lsrs	r1, r1, #22
 800f24a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector78) {
 800f24e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22;
 800f250:	058c      	lsls	r4, r1, #22
 800f252:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 800f254:	b10a      	cbz	r2, 800f25a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800f256:	69c0      	ldr	r0, [r0, #28]
 800f258:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f25a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f25e:	f7ff b877 	b.w	800e350 <_port_irq_epilogue>
 800f262:	bf00      	nop
 800f264:	40026000 	.word	0x40026000
 800f268:	20001cc8 	.word	0x20001cc8
 800f26c:	00000000 	.word	0x00000000

0800f270 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 800f270:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f272:	4b07      	ldr	r3, [pc, #28]	; (800f290 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 800f274:	4807      	ldr	r0, [pc, #28]	; (800f294 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f276:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[4].dma_func)
 800f278:	6a02      	ldr	r2, [r0, #32]
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f27a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 800f27e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 800f280:	b10a      	cbz	r2, 800f286 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800f282:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800f284:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f286:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800f28a:	f7ff b861 	b.w	800e350 <_port_irq_epilogue>
 800f28e:	bf00      	nop
 800f290:	40026000 	.word	0x40026000
 800f294:	20001cc8 	.word	0x20001cc8
	...

0800f2a0 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f2a0:	4b08      	ldr	r3, [pc, #32]	; (800f2c4 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 800f2a2:	4809      	ldr	r0, [pc, #36]	; (800f2c8 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f2a4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[5].dma_func)
 800f2a6:	6a82      	ldr	r2, [r0, #40]	; 0x28
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f2a8:	0989      	lsrs	r1, r1, #6
 800f2aa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector80) {
 800f2ae:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6;
 800f2b0:	018c      	lsls	r4, r1, #6
 800f2b2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800f2b4:	b10a      	cbz	r2, 800f2ba <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800f2b6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800f2b8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f2ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f2be:	f7ff b847 	b.w	800e350 <_port_irq_epilogue>
 800f2c2:	bf00      	nop
 800f2c4:	40026000 	.word	0x40026000
 800f2c8:	20001cc8 	.word	0x20001cc8
 800f2cc:	00000000 	.word	0x00000000

0800f2d0 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f2d0:	4b08      	ldr	r3, [pc, #32]	; (800f2f4 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 800f2d2:	4809      	ldr	r0, [pc, #36]	; (800f2f8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f2d4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[6].dma_func)
 800f2d6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f2d8:	0c09      	lsrs	r1, r1, #16
 800f2da:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector84) {
 800f2de:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16;
 800f2e0:	040c      	lsls	r4, r1, #16
 800f2e2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800f2e4:	b10a      	cbz	r2, 800f2ea <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800f2e6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800f2e8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f2ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f2ee:	f7ff b82f 	b.w	800e350 <_port_irq_epilogue>
 800f2f2:	bf00      	nop
 800f2f4:	40026000 	.word	0x40026000
 800f2f8:	20001cc8 	.word	0x20001cc8
 800f2fc:	00000000 	.word	0x00000000

0800f300 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f300:	4b08      	ldr	r3, [pc, #32]	; (800f324 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 800f302:	4809      	ldr	r0, [pc, #36]	; (800f328 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f304:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
 800f306:	6b82      	ldr	r2, [r0, #56]	; 0x38
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f308:	0d89      	lsrs	r1, r1, #22
 800f30a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(VectorFC) {
 800f30e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22;
 800f310:	058c      	lsls	r4, r1, #22
 800f312:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800f314:	b10a      	cbz	r2, 800f31a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800f316:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 800f318:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f31a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f31e:	f7ff b817 	b.w	800e350 <_port_irq_epilogue>
 800f322:	bf00      	nop
 800f324:	40026000 	.word	0x40026000
 800f328:	20001cc8 	.word	0x20001cc8
 800f32c:	00000000 	.word	0x00000000

0800f330 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 800f330:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800f332:	4b07      	ldr	r3, [pc, #28]	; (800f350 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 800f334:	4807      	ldr	r0, [pc, #28]	; (800f354 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800f336:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[8].dma_func)
 800f338:	6c02      	ldr	r2, [r0, #64]	; 0x40
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800f33a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 800f33e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800f340:	b10a      	cbz	r2, 800f346 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800f342:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800f344:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f346:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800f34a:	f7ff b801 	b.w	800e350 <_port_irq_epilogue>
 800f34e:	bf00      	nop
 800f350:	40026400 	.word	0x40026400
 800f354:	20001cc8 	.word	0x20001cc8
	...

0800f360 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f360:	4b08      	ldr	r3, [pc, #32]	; (800f384 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 800f362:	4809      	ldr	r0, [pc, #36]	; (800f388 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f364:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[9].dma_func)
 800f366:	6c82      	ldr	r2, [r0, #72]	; 0x48
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 800f368:	0989      	lsrs	r1, r1, #6
 800f36a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector124) {
 800f36e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6;
 800f370:	018c      	lsls	r4, r1, #6
 800f372:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800f374:	b10a      	cbz	r2, 800f37a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 800f376:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800f378:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f37a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f37e:	f7fe bfe7 	b.w	800e350 <_port_irq_epilogue>
 800f382:	bf00      	nop
 800f384:	40026400 	.word	0x40026400
 800f388:	20001cc8 	.word	0x20001cc8
 800f38c:	00000000 	.word	0x00000000

0800f390 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f390:	4b08      	ldr	r3, [pc, #32]	; (800f3b4 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 800f392:	4809      	ldr	r0, [pc, #36]	; (800f3b8 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f394:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[10].dma_func)
 800f396:	6d02      	ldr	r2, [r0, #80]	; 0x50
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 800f398:	0c09      	lsrs	r1, r1, #16
 800f39a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector128) {
 800f39e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16;
 800f3a0:	040c      	lsls	r4, r1, #16
 800f3a2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 800f3a4:	b10a      	cbz	r2, 800f3aa <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 800f3a6:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800f3a8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f3aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f3ae:	f7fe bfcf 	b.w	800e350 <_port_irq_epilogue>
 800f3b2:	bf00      	nop
 800f3b4:	40026400 	.word	0x40026400
 800f3b8:	20001cc8 	.word	0x20001cc8
 800f3bc:	00000000 	.word	0x00000000

0800f3c0 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f3c0:	4b08      	ldr	r3, [pc, #32]	; (800f3e4 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 800f3c2:	4809      	ldr	r0, [pc, #36]	; (800f3e8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f3c4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[11].dma_func)
 800f3c6:	6d82      	ldr	r2, [r0, #88]	; 0x58
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 800f3c8:	0d89      	lsrs	r1, r1, #22
 800f3ca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector12C) {
 800f3ce:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22;
 800f3d0:	058c      	lsls	r4, r1, #22
 800f3d2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 800f3d4:	b10a      	cbz	r2, 800f3da <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 800f3d6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800f3d8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f3da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f3de:	f7fe bfb7 	b.w	800e350 <_port_irq_epilogue>
 800f3e2:	bf00      	nop
 800f3e4:	40026400 	.word	0x40026400
 800f3e8:	20001cc8 	.word	0x20001cc8
 800f3ec:	00000000 	.word	0x00000000

0800f3f0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 800f3f0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f3f2:	4b07      	ldr	r3, [pc, #28]	; (800f410 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 800f3f4:	4807      	ldr	r0, [pc, #28]	; (800f414 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f3f6:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[12].dma_func)
 800f3f8:	6e02      	ldr	r2, [r0, #96]	; 0x60
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 800f3fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 800f3fe:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 800f400:	b10a      	cbz	r2, 800f406 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 800f402:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800f404:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f406:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800f40a:	f7fe bfa1 	b.w	800e350 <_port_irq_epilogue>
 800f40e:	bf00      	nop
 800f410:	40026400 	.word	0x40026400
 800f414:	20001cc8 	.word	0x20001cc8
	...

0800f420 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f420:	4b08      	ldr	r3, [pc, #32]	; (800f444 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 800f422:	4809      	ldr	r0, [pc, #36]	; (800f448 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f424:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[13].dma_func)
 800f426:	6e82      	ldr	r2, [r0, #104]	; 0x68
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 800f428:	0989      	lsrs	r1, r1, #6
 800f42a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector150) {
 800f42e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6;
 800f430:	018c      	lsls	r4, r1, #6
 800f432:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 800f434:	b10a      	cbz	r2, 800f43a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 800f436:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 800f438:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f43a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f43e:	f7fe bf87 	b.w	800e350 <_port_irq_epilogue>
 800f442:	bf00      	nop
 800f444:	40026400 	.word	0x40026400
 800f448:	20001cc8 	.word	0x20001cc8
 800f44c:	00000000 	.word	0x00000000

0800f450 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f450:	4b08      	ldr	r3, [pc, #32]	; (800f474 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 800f452:	4809      	ldr	r0, [pc, #36]	; (800f478 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f454:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[14].dma_func)
 800f456:	6f02      	ldr	r2, [r0, #112]	; 0x70
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 800f458:	0c09      	lsrs	r1, r1, #16
 800f45a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector154) {
 800f45e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16;
 800f460:	040c      	lsls	r4, r1, #16
 800f462:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 800f464:	b10a      	cbz	r2, 800f46a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800f466:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800f468:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f46a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f46e:	f7fe bf6f 	b.w	800e350 <_port_irq_epilogue>
 800f472:	bf00      	nop
 800f474:	40026400 	.word	0x40026400
 800f478:	20001cc8 	.word	0x20001cc8
 800f47c:	00000000 	.word	0x00000000

0800f480 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f480:	4b08      	ldr	r3, [pc, #32]	; (800f4a4 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 800f482:	4809      	ldr	r0, [pc, #36]	; (800f4a8 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f484:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[15].dma_func)
 800f486:	6f82      	ldr	r2, [r0, #120]	; 0x78
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 800f488:	0d89      	lsrs	r1, r1, #22
 800f48a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(Vector158) {
 800f48e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22;
 800f490:	058c      	lsls	r4, r1, #22
 800f492:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 800f494:	b10a      	cbz	r2, 800f49a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 800f496:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800f498:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800f49a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f49e:	f7fe bf57 	b.w	800e350 <_port_irq_epilogue>
 800f4a2:	bf00      	nop
 800f4a4:	40026400 	.word	0x40026400
 800f4a8:	20001cc8 	.word	0x20001cc8
 800f4ac:	00000000 	.word	0x00000000

0800f4b0 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 800f4b0:	490e      	ldr	r1, [pc, #56]	; (800f4ec <dmaInit+0x3c>)
 800f4b2:	4a0f      	ldr	r2, [pc, #60]	; (800f4f0 <dmaInit+0x40>)
 800f4b4:	480f      	ldr	r0, [pc, #60]	; (800f4f4 <dmaInit+0x44>)
 800f4b6:	2300      	movs	r3, #0
void dmaInit(void) {
 800f4b8:	b410      	push	{r4}
  dma_streams_mask = 0;
 800f4ba:	600b      	str	r3, [r1, #0]
 800f4bc:	4c0e      	ldr	r4, [pc, #56]	; (800f4f8 <dmaInit+0x48>)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 800f4be:	4619      	mov	r1, r3
 800f4c0:	e001      	b.n	800f4c6 <dmaInit+0x16>
 800f4c2:	f852 0c0c 	ldr.w	r0, [r2, #-12]
 800f4c6:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 800f4c8:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800f4cc:	3301      	adds	r3, #1
 800f4ce:	2b10      	cmp	r3, #16
 800f4d0:	f102 020c 	add.w	r2, r2, #12
 800f4d4:	d1f5      	bne.n	800f4c2 <dmaInit+0x12>
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 800f4d6:	4909      	ldr	r1, [pc, #36]	; (800f4fc <dmaInit+0x4c>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 800f4d8:	4a09      	ldr	r2, [pc, #36]	; (800f500 <dmaInit+0x50>)
  DMA2->HIFCR = 0xFFFFFFFF;
}
 800f4da:	f85d 4b04 	ldr.w	r4, [sp], #4
  DMA1->LIFCR = 0xFFFFFFFF;
 800f4de:	f04f 33ff 	mov.w	r3, #4294967295
 800f4e2:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
 800f4e4:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 800f4e6:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 800f4e8:	60d3      	str	r3, [r2, #12]
}
 800f4ea:	4770      	bx	lr
 800f4ec:	20001d48 	.word	0x20001d48
 800f4f0:	0802d9bc 	.word	0x0802d9bc
 800f4f4:	40026010 	.word	0x40026010
 800f4f8:	20001cc8 	.word	0x20001cc8
 800f4fc:	40026000 	.word	0x40026000
 800f500:	40026400 	.word	0x40026400
	...

0800f510 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 800f510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 800f512:	4f20      	ldr	r7, [pc, #128]	; (800f594 <dmaStreamAllocate+0x84>)
 800f514:	7a46      	ldrb	r6, [r0, #9]
 800f516:	f8d7 c000 	ldr.w	ip, [r7]
 800f51a:	2401      	movs	r4, #1
 800f51c:	fa04 f506 	lsl.w	r5, r4, r6
 800f520:	ea15 0f0c 	tst.w	r5, ip
 800f524:	d133      	bne.n	800f58e <dmaStreamAllocate+0x7e>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800f526:	4c1c      	ldr	r4, [pc, #112]	; (800f598 <dmaStreamAllocate+0x88>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 800f528:	ea45 050c 	orr.w	r5, r5, ip
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800f52c:	eb04 0cc6 	add.w	ip, r4, r6, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800f530:	f015 0fff 	tst.w	r5, #255	; 0xff
  dma_streams_mask |= (1 << dmastp->selfindex);
 800f534:	603d      	str	r5, [r7, #0]
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800f536:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800f53a:	f8cc 3004 	str.w	r3, [ip, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800f53e:	d004      	beq.n	800f54a <dmaStreamAllocate+0x3a>
    rccEnableDMA1(FALSE);
 800f540:	4c16      	ldr	r4, [pc, #88]	; (800f59c <dmaStreamAllocate+0x8c>)
 800f542:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800f544:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800f548:	6323      	str	r3, [r4, #48]	; 0x30
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 800f54a:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800f54e:	d116      	bne.n	800f57e <dmaStreamAllocate+0x6e>
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800f550:	6805      	ldr	r5, [r0, #0]
 800f552:	682b      	ldr	r3, [r5, #0]
 800f554:	f023 031f 	bic.w	r3, r3, #31
 800f558:	602b      	str	r3, [r5, #0]
 800f55a:	682c      	ldr	r4, [r5, #0]
 800f55c:	f014 0401 	ands.w	r4, r4, #1
 800f560:	d1fb      	bne.n	800f55a <dmaStreamAllocate+0x4a>
 800f562:	7a07      	ldrb	r7, [r0, #8]
 800f564:	6846      	ldr	r6, [r0, #4]
 800f566:	233d      	movs	r3, #61	; 0x3d
 800f568:	40bb      	lsls	r3, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800f56a:	2721      	movs	r7, #33	; 0x21
  dmaStreamDisable(dmastp);
 800f56c:	6033      	str	r3, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800f56e:	602c      	str	r4, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800f570:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 800f572:	b152      	cbz	r2, 800f58a <dmaStreamAllocate+0x7a>
    nvicEnableVector(dmastp->vector, priority);
 800f574:	7a80      	ldrb	r0, [r0, #10]
 800f576:	f7ff fddb 	bl	800f130 <nvicEnableVector>

  return FALSE;
 800f57a:	4620      	mov	r0, r4
}
 800f57c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    rccEnableDMA2(FALSE);
 800f57e:	4c07      	ldr	r4, [pc, #28]	; (800f59c <dmaStreamAllocate+0x8c>)
 800f580:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800f582:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800f586:	6323      	str	r3, [r4, #48]	; 0x30
 800f588:	e7e2      	b.n	800f550 <dmaStreamAllocate+0x40>
  return FALSE;
 800f58a:	4610      	mov	r0, r2
}
 800f58c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return TRUE;
 800f58e:	4620      	mov	r0, r4
}
 800f590:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f592:	bf00      	nop
 800f594:	20001d48 	.word	0x20001d48
 800f598:	20001cc8 	.word	0x20001cc8
 800f59c:	40023800 	.word	0x40023800

0800f5a0 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 800f5a0:	b510      	push	{r4, lr}
 800f5a2:	4604      	mov	r4, r0
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 800f5a4:	7a80      	ldrb	r0, [r0, #10]
 800f5a6:	f7ff fde3 	bl	800f170 <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1 << dmastp->selfindex);
 800f5aa:	490c      	ldr	r1, [pc, #48]	; (800f5dc <dmaStreamRelease+0x3c>)
 800f5ac:	7a60      	ldrb	r0, [r4, #9]
 800f5ae:	680b      	ldr	r3, [r1, #0]
 800f5b0:	2201      	movs	r2, #1
 800f5b2:	4082      	lsls	r2, r0
 800f5b4:	ea23 0302 	bic.w	r3, r3, r2

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0)
 800f5b8:	f013 0fff 	tst.w	r3, #255	; 0xff
  dma_streams_mask &= ~(1 << dmastp->selfindex);
 800f5bc:	600b      	str	r3, [r1, #0]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0)
 800f5be:	d104      	bne.n	800f5ca <dmaStreamRelease+0x2a>
    rccDisableDMA1(FALSE);
 800f5c0:	4907      	ldr	r1, [pc, #28]	; (800f5e0 <dmaStreamRelease+0x40>)
 800f5c2:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 800f5c4:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800f5c8:	630a      	str	r2, [r1, #48]	; 0x30
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0)
 800f5ca:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 800f5ce:	d104      	bne.n	800f5da <dmaStreamRelease+0x3a>
    rccDisableDMA2(FALSE);
 800f5d0:	4a03      	ldr	r2, [pc, #12]	; (800f5e0 <dmaStreamRelease+0x40>)
 800f5d2:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800f5d4:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800f5d8:	6313      	str	r3, [r2, #48]	; 0x30
}
 800f5da:	bd10      	pop	{r4, pc}
 800f5dc:	20001d48 	.word	0x20001d48
 800f5e0:	40023800 	.word	0x40023800
	...

0800f5f0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 800f5f0:	4b17      	ldr	r3, [pc, #92]	; (800f650 <hal_lld_init+0x60>)
 800f5f2:	f04f 31ff 	mov.w	r1, #4294967295
 800f5f6:	691a      	ldr	r2, [r3, #16]
 800f5f8:	2200      	movs	r2, #0
void hal_lld_init(void) {
 800f5fa:	b410      	push	{r4}
  rccResetAHB1(~0);
 800f5fc:	6119      	str	r1, [r3, #16]
 800f5fe:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 800f600:	6958      	ldr	r0, [r3, #20]
 800f602:	6159      	str	r1, [r3, #20]
 800f604:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800f606:	6a18      	ldr	r0, [r3, #32]
  PWR->CR |= PWR_CR_DBP;
 800f608:	4c12      	ldr	r4, [pc, #72]	; (800f654 <hal_lld_init+0x64>)
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800f60a:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 800f60e:	6218      	str	r0, [r3, #32]
 800f610:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 800f612:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800f614:	6259      	str	r1, [r3, #36]	; 0x24
 800f616:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800f618:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800f61a:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800f61e:	6419      	str	r1, [r3, #64]	; 0x40
  PWR->CR |= PWR_CR_DBP;
 800f620:	6821      	ldr	r1, [r4, #0]
 800f622:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800f626:	6021      	str	r1, [r4, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800f628:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800f62a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 800f62e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800f632:	d003      	beq.n	800f63c <hal_lld_init+0x4c>
    RCC->BDCR = RCC_BDCR_BDRST;
 800f634:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800f638:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800f63a:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 800f63c:	4a05      	ldr	r2, [pc, #20]	; (800f654 <hal_lld_init+0x64>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800f63e:	f85d 4b04 	ldr.w	r4, [sp], #4
  PWR->CSR &= ~PWR_CSR_BRE;
 800f642:	6853      	ldr	r3, [r2, #4]
 800f644:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800f648:	6053      	str	r3, [r2, #4]
  dmaInit();
 800f64a:	f7ff bf31 	b.w	800f4b0 <dmaInit>
 800f64e:	bf00      	nop
 800f650:	40023800 	.word	0x40023800
 800f654:	40007000 	.word	0x40007000
	...

0800f660 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800f660:	4b2a      	ldr	r3, [pc, #168]	; (800f70c <stm32_clock_init+0xac>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800f662:	4a2b      	ldr	r2, [pc, #172]	; (800f710 <stm32_clock_init+0xb0>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800f664:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  PWR->CR = STM32_VOS;
 800f668:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800f66c:	6418      	str	r0, [r3, #64]	; 0x40
  PWR->CR = STM32_VOS;
 800f66e:	6011      	str	r1, [r2, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800f670:	681a      	ldr	r2, [r3, #0]
 800f672:	f042 0201 	orr.w	r2, r2, #1
 800f676:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800f678:	681a      	ldr	r2, [r3, #0]
 800f67a:	0792      	lsls	r2, r2, #30
 800f67c:	d5fc      	bpl.n	800f678 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800f67e:	6899      	ldr	r1, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800f680:	4a22      	ldr	r2, [pc, #136]	; (800f70c <stm32_clock_init+0xac>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800f682:	f021 0103 	bic.w	r1, r1, #3
 800f686:	6099      	str	r1, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800f688:	6899      	ldr	r1, [r3, #8]
 800f68a:	6099      	str	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800f68c:	6893      	ldr	r3, [r2, #8]
 800f68e:	f013 030c 	ands.w	r3, r3, #12
 800f692:	d1fb      	bne.n	800f68c <stm32_clock_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800f694:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800f696:	491d      	ldr	r1, [pc, #116]	; (800f70c <stm32_clock_init+0xac>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800f698:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 800f69c:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800f69e:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON;
 800f6a0:	6813      	ldr	r3, [r2, #0]
 800f6a2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800f6a6:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800f6a8:	680b      	ldr	r3, [r1, #0]
 800f6aa:	0398      	lsls	r0, r3, #14
 800f6ac:	d5fc      	bpl.n	800f6a8 <stm32_clock_init+0x48>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800f6ae:	6f4b      	ldr	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800f6b0:	4a16      	ldr	r2, [pc, #88]	; (800f70c <stm32_clock_init+0xac>)
  RCC->CSR |= RCC_CSR_LSION;
 800f6b2:	f043 0301 	orr.w	r3, r3, #1
 800f6b6:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800f6b8:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800f6ba:	0799      	lsls	r1, r3, #30
 800f6bc:	d5fc      	bpl.n	800f6b8 <stm32_clock_init+0x58>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800f6be:	4b15      	ldr	r3, [pc, #84]	; (800f714 <stm32_clock_init+0xb4>)
 800f6c0:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800f6c2:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800f6c4:	4912      	ldr	r1, [pc, #72]	; (800f710 <stm32_clock_init+0xb0>)
  RCC->CR |= RCC_CR_PLLON;
 800f6c6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800f6ca:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800f6cc:	684b      	ldr	r3, [r1, #4]
 800f6ce:	045a      	lsls	r2, r3, #17
 800f6d0:	d5fc      	bpl.n	800f6cc <stm32_clock_init+0x6c>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800f6d2:	490e      	ldr	r1, [pc, #56]	; (800f70c <stm32_clock_init+0xac>)
 800f6d4:	680b      	ldr	r3, [r1, #0]
 800f6d6:	019b      	lsls	r3, r3, #6
 800f6d8:	d5fc      	bpl.n	800f6d4 <stm32_clock_init+0x74>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800f6da:	4b0f      	ldr	r3, [pc, #60]	; (800f718 <stm32_clock_init+0xb8>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800f6dc:	4a0f      	ldr	r2, [pc, #60]	; (800f71c <stm32_clock_init+0xbc>)
 800f6de:	608a      	str	r2, [r1, #8]
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800f6e0:	f240 7205 	movw	r2, #1797	; 0x705
 800f6e4:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800f6e6:	688b      	ldr	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800f6e8:	4a08      	ldr	r2, [pc, #32]	; (800f70c <stm32_clock_init+0xac>)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800f6ea:	f043 0302 	orr.w	r3, r3, #2
 800f6ee:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800f6f0:	6893      	ldr	r3, [r2, #8]
 800f6f2:	f003 030c 	and.w	r3, r3, #12
 800f6f6:	2b08      	cmp	r3, #8
 800f6f8:	d1fa      	bne.n	800f6f0 <stm32_clock_init+0x90>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800f6fa:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800f6fc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800f700:	6453      	str	r3, [r2, #68]	; 0x44
 800f702:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800f704:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800f708:	6653      	str	r3, [r2, #100]	; 0x64
}
 800f70a:	4770      	bx	lr
 800f70c:	40023800 	.word	0x40023800
 800f710:	40007000 	.word	0x40007000
 800f714:	07405408 	.word	0x07405408
 800f718:	40023c00 	.word	0x40023c00
 800f71c:	38089400 	.word	0x38089400

0800f720 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 800f720:	b508      	push	{r3, lr}
 800f722:	2320      	movs	r3, #32
 800f724:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 800f728:	f7fd fefa 	bl	800d520 <chSysTimerHandlerI>
 800f72c:	2300      	movs	r3, #0
 800f72e:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800f732:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800f736:	f7fe be0b 	b.w	800e350 <_port_irq_epilogue>
 800f73a:	bf00      	nop
 800f73c:	0000      	movs	r0, r0
	...

0800f740 <st_lld_init>:
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800f740:	4b05      	ldr	r3, [pc, #20]	; (800f758 <st_lld_init+0x18>)
 800f742:	f244 119f 	movw	r1, #16799	; 0x419f
  SysTick->VAL = 0;
 800f746:	2000      	movs	r0, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800f748:	2207      	movs	r2, #7
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800f74a:	6059      	str	r1, [r3, #4]
  SysTick->VAL = 0;
 800f74c:	6098      	str	r0, [r3, #8]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800f74e:	2108      	movs	r1, #8
 800f750:	200b      	movs	r0, #11
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 800f752:	601a      	str	r2, [r3, #0]
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800f754:	f7ff bd24 	b.w	800f1a0 <nvicSetSystemHandlerPriority>
 800f758:	e000e010 	.word	0xe000e010
 800f75c:	00000000 	.word	0x00000000

0800f760 <can_lld_set_filters>:
 *
 * @notapi
 */
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {
 800f760:	b4f0      	push	{r4, r5, r6, r7}

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800f762:	4d44      	ldr	r5, [pc, #272]	; (800f874 <can_lld_set_filters+0x114>)

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800f764:	4c44      	ldr	r4, [pc, #272]	; (800f878 <can_lld_set_filters+0x118>)
  rccEnableCAN1(FALSE);
 800f766:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800f768:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800f76c:	642b      	str	r3, [r5, #64]	; 0x40
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 800f76e:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 800f772:	0c1b      	lsrs	r3, r3, #16
 800f774:	041b      	lsls	r3, r3, #16
 800f776:	f043 0301 	orr.w	r3, r3, #1
 800f77a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800f77e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
  if (num > 0) {
 800f782:	2900      	cmp	r1, #0
 800f784:	d05b      	beq.n	800f83e <can_lld_set_filters+0xde>
    uint32_t i, fmask;

    /* All filters cleared.*/
    CAN1->FA1R = 0;
 800f786:	2300      	movs	r3, #0
 800f788:	f8c4 321c 	str.w	r3, [r4, #540]	; 0x21c
    CAN1->FM1R = 0;
    CAN1->FS1R = 0;
    CAN1->FFA1R = 0;
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f78c:	4618      	mov	r0, r3
    CAN1->FM1R = 0;
 800f78e:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    CAN1->FS1R = 0;
 800f792:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
    CAN1->FFA1R = 0;
 800f796:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
      CAN1->sFilterRegister[i].FR1 = 0;
 800f79a:	461c      	mov	r4, r3
 800f79c:	00c3      	lsls	r3, r0, #3
 800f79e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f7a2:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f7a6:	3001      	adds	r0, #1
 800f7a8:	281c      	cmp	r0, #28
      CAN1->sFilterRegister[i].FR1 = 0;
 800f7aa:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[i].FR2 = 0;
 800f7ae:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
    for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
 800f7b2:	d1f3      	bne.n	800f79c <can_lld_set_filters+0x3c>

    /* Scanning the filters array.*/
    for (i = 0; i < num; i++) {
      fmask = 1 << cfp->filter;
      if (cfp->mode)
        CAN1->FM1R |= fmask;
 800f7b4:	4d30      	ldr	r5, [pc, #192]	; (800f878 <can_lld_set_filters+0x118>)
    for (i = 0; i < num; i++) {
 800f7b6:	2600      	movs	r6, #0
      fmask = 1 << cfp->filter;
 800f7b8:	2701      	movs	r7, #1
 800f7ba:	6810      	ldr	r0, [r2, #0]
      if (cfp->mode)
 800f7bc:	7914      	ldrb	r4, [r2, #4]
 800f7be:	00c3      	lsls	r3, r0, #3
 800f7c0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f7c4:	f014 0f01 	tst.w	r4, #1
 800f7c8:	f503 43c8 	add.w	r3, r3, #25600	; 0x6400
    for (i = 0; i < num; i++) {
 800f7cc:	f106 0601 	add.w	r6, r6, #1
      fmask = 1 << cfp->filter;
 800f7d0:	fa07 f000 	lsl.w	r0, r7, r0
      if (cfp->mode)
 800f7d4:	d005      	beq.n	800f7e2 <can_lld_set_filters+0x82>
        CAN1->FM1R |= fmask;
 800f7d6:	f8d5 c204 	ldr.w	ip, [r5, #516]	; 0x204
 800f7da:	ea4c 0c00 	orr.w	ip, ip, r0
 800f7de:	f8c5 c204 	str.w	ip, [r5, #516]	; 0x204
      if (cfp->scale)
 800f7e2:	f014 0f02 	tst.w	r4, #2
 800f7e6:	d005      	beq.n	800f7f4 <can_lld_set_filters+0x94>
        CAN1->FS1R |= fmask;
 800f7e8:	f8d5 c20c 	ldr.w	ip, [r5, #524]	; 0x20c
 800f7ec:	ea4c 0c00 	orr.w	ip, ip, r0
 800f7f0:	f8c5 c20c 	str.w	ip, [r5, #524]	; 0x20c
      if (cfp->assignment)
 800f7f4:	0764      	lsls	r4, r4, #29
 800f7f6:	d504      	bpl.n	800f802 <can_lld_set_filters+0xa2>
        CAN1->FFA1R |= fmask;
 800f7f8:	f8d5 4214 	ldr.w	r4, [r5, #532]	; 0x214
 800f7fc:	4304      	orrs	r4, r0
 800f7fe:	f8c5 4214 	str.w	r4, [r5, #532]	; 0x214
      CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
 800f802:	6894      	ldr	r4, [r2, #8]
 800f804:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
      CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
 800f808:	68d4      	ldr	r4, [r2, #12]
 800f80a:	f8c3 4244 	str.w	r4, [r3, #580]	; 0x244
      CAN1->FA1R |= fmask;
 800f80e:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
    for (i = 0; i < num; i++) {
 800f812:	42b1      	cmp	r1, r6
      CAN1->FA1R |= fmask;
 800f814:	ea40 0003 	orr.w	r0, r0, r3
      cfp++;
 800f818:	f102 0210 	add.w	r2, r2, #16
      CAN1->FA1R |= fmask;
 800f81c:	f8c5 021c 	str.w	r0, [r5, #540]	; 0x21c
    for (i = 0; i < num; i++) {
 800f820:	d1cb      	bne.n	800f7ba <can_lld_set_filters+0x5a>
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800f822:	4915      	ldr	r1, [pc, #84]	; (800f878 <can_lld_set_filters+0x118>)

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800f824:	4a13      	ldr	r2, [pc, #76]	; (800f874 <can_lld_set_filters+0x114>)
  CAN1->FMR &= ~CAN_FMR_FINIT;
 800f826:	f8d1 3200 	ldr.w	r3, [r1, #512]	; 0x200
 800f82a:	f023 0301 	bic.w	r3, r3, #1
 800f82e:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
  rccDisableCAN1(FALSE);
 800f832:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f834:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800f838:	6413      	str	r3, [r2, #64]	; 0x40
}
 800f83a:	bcf0      	pop	{r4, r5, r6, r7}
 800f83c:	4770      	bx	lr
 800f83e:	00c2      	lsls	r2, r0, #3
 800f840:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    CAN1->FS1R = 1 | (1 << can2sb);
 800f844:	2301      	movs	r3, #1
 800f846:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
 800f84a:	4083      	lsls	r3, r0
 800f84c:	f043 0301 	orr.w	r3, r3, #1
    CAN1->sFilterRegister[0].FR1 = 0;
 800f850:	f8c4 1240 	str.w	r1, [r4, #576]	; 0x240
    CAN1->sFilterRegister[0].FR2 = 0;
 800f854:	f8c4 1244 	str.w	r1, [r4, #580]	; 0x244
    CAN1->sFilterRegister[can2sb].FR1 = 0;
 800f858:	f8c2 1240 	str.w	r1, [r2, #576]	; 0x240
    CAN1->sFilterRegister[can2sb].FR2 = 0;
 800f85c:	f8c2 1244 	str.w	r1, [r2, #580]	; 0x244
    CAN1->FM1R = 0;
 800f860:	f8c4 1204 	str.w	r1, [r4, #516]	; 0x204
    CAN1->FFA1R = 0;
 800f864:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
    CAN1->FS1R = 1 | (1 << can2sb);
 800f868:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
    CAN1->FA1R = 1 | (1 << can2sb);
 800f86c:	f8c4 321c 	str.w	r3, [r4, #540]	; 0x21c
 800f870:	e7d7      	b.n	800f822 <can_lld_set_filters+0xc2>
 800f872:	bf00      	nop
 800f874:	40023800 	.word	0x40023800
 800f878:	40006400 	.word	0x40006400
 800f87c:	00000000 	.word	0x00000000

0800f880 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 800f880:	b510      	push	{r4, lr}
  canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
 800f882:	4c0c      	ldr	r4, [pc, #48]	; (800f8b4 <Vector8C+0x34>)
 800f884:	490c      	ldr	r1, [pc, #48]	; (800f8b8 <Vector8C+0x38>)
 800f886:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800f888:	2320      	movs	r3, #32
 800f88a:	6091      	str	r1, [r2, #8]
 800f88c:	f383 8811 	msr	BASEPRI, r3
  chThdDequeueAllI(tqp, msg);
 800f890:	2100      	movs	r1, #0
 800f892:	f104 0008 	add.w	r0, r4, #8
 800f896:	f7fe f923 	bl	800dae0 <chThdDequeueAllI>
  chEvtBroadcastFlagsI(esp, flags);
 800f89a:	f104 001c 	add.w	r0, r4, #28
 800f89e:	2101      	movs	r1, #1
 800f8a0:	f7fe fad6 	bl	800de50 <chEvtBroadcastFlagsI>
 800f8a4:	2300      	movs	r3, #0
 800f8a6:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f8aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800f8ae:	f7fe bd4f 	b.w	800e350 <_port_irq_epilogue>
 800f8b2:	bf00      	nop
 800f8b4:	20001d4c 	.word	0x20001d4c
 800f8b8:	00010101 	.word	0x00010101
 800f8bc:	00000000 	.word	0x00000000

0800f8c0 <Vector90>:
/*
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 800f8c0:	b538      	push	{r3, r4, r5, lr}
  rf0r = canp->can->RF0R;
 800f8c2:	4c16      	ldr	r4, [pc, #88]	; (800f91c <Vector90+0x5c>)
 800f8c4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f8c6:	68dd      	ldr	r5, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 800f8c8:	07aa      	lsls	r2, r5, #30
 800f8ca:	d111      	bne.n	800f8f0 <Vector90+0x30>
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 800f8cc:	06eb      	lsls	r3, r5, #27
 800f8ce:	d50b      	bpl.n	800f8e8 <Vector90+0x28>
    canp->can->RF0R = CAN_RF0R_FOVR0;
 800f8d0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f8d2:	2110      	movs	r1, #16
 800f8d4:	60d9      	str	r1, [r3, #12]
 800f8d6:	2320      	movs	r3, #32
 800f8d8:	f383 8811 	msr	BASEPRI, r3
 800f8dc:	4810      	ldr	r0, [pc, #64]	; (800f920 <Vector90+0x60>)
 800f8de:	f7fe fab7 	bl	800de50 <chEvtBroadcastFlagsI>
 800f8e2:	2300      	movs	r3, #0
 800f8e4:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f8e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800f8ec:	f7fe bd30 	b.w	800e350 <_port_irq_epilogue>
    canp->can->IER &= ~CAN_IER_FMPIE0;
 800f8f0:	695a      	ldr	r2, [r3, #20]
 800f8f2:	f022 0202 	bic.w	r2, r2, #2
 800f8f6:	615a      	str	r2, [r3, #20]
 800f8f8:	2320      	movs	r3, #32
 800f8fa:	f383 8811 	msr	BASEPRI, r3
  chThdDequeueAllI(tqp, msg);
 800f8fe:	2100      	movs	r1, #0
 800f900:	f104 0010 	add.w	r0, r4, #16
 800f904:	f7fe f8ec 	bl	800dae0 <chThdDequeueAllI>
  chEvtBroadcastFlagsI(esp, flags);
 800f908:	f104 0018 	add.w	r0, r4, #24
 800f90c:	2101      	movs	r1, #1
 800f90e:	f7fe fa9f 	bl	800de50 <chEvtBroadcastFlagsI>
 800f912:	2300      	movs	r3, #0
 800f914:	f383 8811 	msr	BASEPRI, r3
 800f918:	e7d8      	b.n	800f8cc <Vector90+0xc>
 800f91a:	bf00      	nop
 800f91c:	20001d4c 	.word	0x20001d4c
 800f920:	20001d6c 	.word	0x20001d6c
	...

0800f930 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 800f930:	b538      	push	{r3, r4, r5, lr}
  rf1r = canp->can->RF1R;
 800f932:	4c16      	ldr	r4, [pc, #88]	; (800f98c <Vector94+0x5c>)
 800f934:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f936:	691d      	ldr	r5, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 800f938:	07aa      	lsls	r2, r5, #30
 800f93a:	d111      	bne.n	800f960 <Vector94+0x30>
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 800f93c:	06eb      	lsls	r3, r5, #27
 800f93e:	d50b      	bpl.n	800f958 <Vector94+0x28>
    canp->can->RF1R = CAN_RF1R_FOVR1;
 800f940:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800f942:	2110      	movs	r1, #16
 800f944:	6119      	str	r1, [r3, #16]
 800f946:	2320      	movs	r3, #32
 800f948:	f383 8811 	msr	BASEPRI, r3
 800f94c:	4810      	ldr	r0, [pc, #64]	; (800f990 <Vector94+0x60>)
 800f94e:	f7fe fa7f 	bl	800de50 <chEvtBroadcastFlagsI>
 800f952:	2300      	movs	r3, #0
 800f954:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f958:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800f95c:	f7fe bcf8 	b.w	800e350 <_port_irq_epilogue>
    canp->can->IER &= ~CAN_IER_FMPIE1;
 800f960:	695a      	ldr	r2, [r3, #20]
 800f962:	f022 0210 	bic.w	r2, r2, #16
 800f966:	615a      	str	r2, [r3, #20]
 800f968:	2320      	movs	r3, #32
 800f96a:	f383 8811 	msr	BASEPRI, r3
  chThdDequeueAllI(tqp, msg);
 800f96e:	2100      	movs	r1, #0
 800f970:	f104 0010 	add.w	r0, r4, #16
 800f974:	f7fe f8b4 	bl	800dae0 <chThdDequeueAllI>
  chEvtBroadcastFlagsI(esp, flags);
 800f978:	f104 0018 	add.w	r0, r4, #24
 800f97c:	2102      	movs	r1, #2
 800f97e:	f7fe fa67 	bl	800de50 <chEvtBroadcastFlagsI>
 800f982:	2300      	movs	r3, #0
 800f984:	f383 8811 	msr	BASEPRI, r3
 800f988:	e7d8      	b.n	800f93c <Vector94+0xc>
 800f98a:	bf00      	nop
 800f98c:	20001d4c 	.word	0x20001d4c
 800f990:	20001d6c 	.word	0x20001d6c
	...

0800f9a0 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 800f9a0:	b538      	push	{r3, r4, r5, lr}
  msr = canp->can->MSR;
 800f9a2:	4d1b      	ldr	r5, [pc, #108]	; (800fa10 <Vector98+0x70>)
 800f9a4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800f9a6:	685c      	ldr	r4, [r3, #4]
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
 800f9a8:	221c      	movs	r2, #28
 800f9aa:	605a      	str	r2, [r3, #4]
  if (msr & CAN_MSR_WKUI) {
 800f9ac:	0722      	lsls	r2, r4, #28
 800f9ae:	d41d      	bmi.n	800f9ec <Vector98+0x4c>
  if (msr & CAN_MSR_ERRI) {
 800f9b0:	0763      	lsls	r3, r4, #29
 800f9b2:	d517      	bpl.n	800f9e4 <Vector98+0x44>
    uint32_t esr = canp->can->ESR;
 800f9b4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800f9b6:	6993      	ldr	r3, [r2, #24]
    canp->can->ESR &= ~CAN_ESR_LEC;
 800f9b8:	6991      	ldr	r1, [r2, #24]
 800f9ba:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 800f9be:	6191      	str	r1, [r2, #24]
    if ((esr & CAN_ESR_LEC) > 0)
 800f9c0:	f013 0f70 	tst.w	r3, #112	; 0x70
    flags = (eventflags_t)(esr & 7);
 800f9c4:	f003 0107 	and.w	r1, r3, #7
      flags |= CAN_FRAMING_ERROR;
 800f9c8:	bf18      	it	ne
 800f9ca:	f041 0108 	orrne.w	r1, r1, #8
 800f9ce:	2220      	movs	r2, #32
 800f9d0:	f382 8811 	msr	BASEPRI, r2
 800f9d4:	480f      	ldr	r0, [pc, #60]	; (800fa14 <Vector98+0x74>)
 800f9d6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800f9da:	f7fe fa39 	bl	800de50 <chEvtBroadcastFlagsI>
 800f9de:	2300      	movs	r3, #0
 800f9e0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
}
 800f9e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800f9e8:	f7fe bcb2 	b.w	800e350 <_port_irq_epilogue>
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f9ec:	681a      	ldr	r2, [r3, #0]
    canp->state = CAN_READY;
 800f9ee:	4628      	mov	r0, r5
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f9f0:	f022 0202 	bic.w	r2, r2, #2
    canp->state = CAN_READY;
 800f9f4:	2103      	movs	r1, #3
 800f9f6:	f800 1b28 	strb.w	r1, [r0], #40
 800f9fa:	2120      	movs	r1, #32
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800f9fc:	601a      	str	r2, [r3, #0]
 800f9fe:	f381 8811 	msr	BASEPRI, r1
 800fa02:	2100      	movs	r1, #0
 800fa04:	f7fe fa24 	bl	800de50 <chEvtBroadcastFlagsI>
 800fa08:	2300      	movs	r3, #0
 800fa0a:	f383 8811 	msr	BASEPRI, r3
 800fa0e:	e7cf      	b.n	800f9b0 <Vector98+0x10>
 800fa10:	20001d4c 	.word	0x20001d4c
 800fa14:	20001d6c 	.word	0x20001d6c
	...

0800fa20 <can_lld_init>:
/**
 * @brief   Low level CAN driver initialization.
 *
 * @notapi
 */
void can_lld_init(void) {
 800fa20:	b510      	push	{r4, lr}

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
 800fa22:	4c06      	ldr	r4, [pc, #24]	; (800fa3c <can_lld_init+0x1c>)
 800fa24:	4620      	mov	r0, r4
 800fa26:	f7fe fcf3 	bl	800e410 <canObjectInit>
  CAND2.can = CAN2;
#endif

  /* Filters initialization.*/
#if STM32_HAS_CAN2
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800fa2a:	2200      	movs	r2, #0
  CAND1.can = CAN1;
 800fa2c:	4b04      	ldr	r3, [pc, #16]	; (800fa40 <can_lld_init+0x20>)
 800fa2e:	62e3      	str	r3, [r4, #44]	; 0x2c
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800fa30:	4611      	mov	r1, r2
 800fa32:	200e      	movs	r0, #14
#else
  can_lld_set_filters(STM32_CAN_MAX_FILTERS, 0, NULL);
#endif
}
 800fa34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
 800fa38:	f7ff be92 	b.w	800f760 <can_lld_set_filters>
 800fa3c:	20001d4c 	.word	0x20001d4c
 800fa40:	40006400 	.word	0x40006400
	...

0800fa50 <can_lld_start>:
 */
void can_lld_start(CANDriver *canp) {

  /* Clock activation.*/
#if STM32_CAN_USE_CAN1
  if (&CAND1 == canp) {
 800fa50:	4b18      	ldr	r3, [pc, #96]	; (800fab4 <can_lld_start+0x64>)
 800fa52:	4298      	cmp	r0, r3
void can_lld_start(CANDriver *canp) {
 800fa54:	b510      	push	{r4, lr}
 800fa56:	4604      	mov	r4, r0
  if (&CAND1 == canp) {
 800fa58:	d015      	beq.n	800fa86 <can_lld_start+0x36>
    rccEnableCAN2(FALSE);
  }
#endif

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
 800fa5a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800fa5c:	2201      	movs	r2, #1
 800fa5e:	601a      	str	r2, [r3, #0]
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
 800fa60:	685a      	ldr	r2, [r3, #4]
 800fa62:	07d1      	lsls	r1, r2, #31
 800fa64:	d407      	bmi.n	800fa76 <can_lld_start+0x26>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800fa66:	2101      	movs	r1, #1
 800fa68:	2008      	movs	r0, #8
 800fa6a:	f7fd fe59 	bl	800d720 <chSchGoSleepTimeoutS>
 800fa6e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800fa70:	685a      	ldr	r2, [r3, #4]
 800fa72:	07d2      	lsls	r2, r2, #31
 800fa74:	d5f7      	bpl.n	800fa66 <can_lld_start+0x16>
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 800fa76:	6862      	ldr	r2, [r4, #4]
  canp->can->MCR = canp->config->mcr;

  /* Interrupt sources initialization.*/
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 800fa78:	490f      	ldr	r1, [pc, #60]	; (800fab8 <can_lld_start+0x68>)
  canp->can->MCR = canp->config->mcr;
 800fa7a:	e9d2 2000 	ldrd	r2, r0, [r2]
  canp->can->BTR = canp->config->btr;
 800fa7e:	61d8      	str	r0, [r3, #28]
  canp->can->MCR = canp->config->mcr;
 800fa80:	601a      	str	r2, [r3, #0]
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 800fa82:	6159      	str	r1, [r3, #20]
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
}
 800fa84:	bd10      	pop	{r4, pc}
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800fa86:	210b      	movs	r1, #11
 800fa88:	2013      	movs	r0, #19
 800fa8a:	f7ff fb51 	bl	800f130 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800fa8e:	210b      	movs	r1, #11
 800fa90:	2014      	movs	r0, #20
 800fa92:	f7ff fb4d 	bl	800f130 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800fa96:	210b      	movs	r1, #11
 800fa98:	2015      	movs	r0, #21
 800fa9a:	f7ff fb49 	bl	800f130 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 800fa9e:	210b      	movs	r1, #11
 800faa0:	2016      	movs	r0, #22
 800faa2:	f7ff fb45 	bl	800f130 <nvicEnableVector>
    rccEnableCAN1(FALSE);
 800faa6:	4a05      	ldr	r2, [pc, #20]	; (800fabc <can_lld_start+0x6c>)
 800faa8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800faaa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800faae:	6413      	str	r3, [r2, #64]	; 0x40
 800fab0:	e7d3      	b.n	800fa5a <can_lld_start+0xa>
 800fab2:	bf00      	nop
 800fab4:	20001d4c 	.word	0x20001d4c
 800fab8:	00018f5b 	.word	0x00018f5b
 800fabc:	40023800 	.word	0x40023800

0800fac0 <can_lld_stop>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
void can_lld_stop(CANDriver *canp) {
 800fac0:	b508      	push	{r3, lr}

  /* If in ready state then disables the CAN peripheral.*/
  if (canp->state == CAN_READY) {
 800fac2:	7803      	ldrb	r3, [r0, #0]
 800fac4:	2b03      	cmp	r3, #3
 800fac6:	d000      	beq.n	800faca <can_lld_stop+0xa>
#endif
      rccDisableCAN2(FALSE);
    }
#endif
  }
}
 800fac8:	bd08      	pop	{r3, pc}
    if (&CAND1 == canp) {
 800faca:	4b0d      	ldr	r3, [pc, #52]	; (800fb00 <can_lld_stop+0x40>)
 800facc:	4298      	cmp	r0, r3
 800face:	d1fb      	bne.n	800fac8 <can_lld_stop+0x8>
      CAN1->MCR = 0x00010002;                   /* Register reset value.    */
 800fad0:	4b0c      	ldr	r3, [pc, #48]	; (800fb04 <can_lld_stop+0x44>)
 800fad2:	4a0d      	ldr	r2, [pc, #52]	; (800fb08 <can_lld_stop+0x48>)
 800fad4:	601a      	str	r2, [r3, #0]
      CAN1->IER = 0x00000000;                   /* All sources disabled.    */
 800fad6:	2200      	movs	r2, #0
 800fad8:	615a      	str	r2, [r3, #20]
      nvicDisableVector(STM32_CAN1_TX_NUMBER);
 800fada:	2013      	movs	r0, #19
 800fadc:	f7ff fb48 	bl	800f170 <nvicDisableVector>
      nvicDisableVector(STM32_CAN1_RX0_NUMBER);
 800fae0:	2014      	movs	r0, #20
 800fae2:	f7ff fb45 	bl	800f170 <nvicDisableVector>
      nvicDisableVector(STM32_CAN1_RX1_NUMBER);
 800fae6:	2015      	movs	r0, #21
 800fae8:	f7ff fb42 	bl	800f170 <nvicDisableVector>
      nvicDisableVector(STM32_CAN1_SCE_NUMBER);
 800faec:	2016      	movs	r0, #22
 800faee:	f7ff fb3f 	bl	800f170 <nvicDisableVector>
      rccDisableCAN1(FALSE);
 800faf2:	4a06      	ldr	r2, [pc, #24]	; (800fb0c <can_lld_stop+0x4c>)
 800faf4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800faf6:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800fafa:	6413      	str	r3, [r2, #64]	; 0x40
}
 800fafc:	bd08      	pop	{r3, pc}
 800fafe:	bf00      	nop
 800fb00:	20001d4c 	.word	0x20001d4c
 800fb04:	40006400 	.word	0x40006400
 800fb08:	00010002 	.word	0x00010002
 800fb0c:	40023800 	.word	0x40023800

0800fb10 <can_lld_is_tx_empty>:
 *
 * @notapi
 */
bool can_lld_is_tx_empty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
 800fb10:	2903      	cmp	r1, #3
 800fb12:	d81a      	bhi.n	800fb4a <can_lld_is_tx_empty+0x3a>
 800fb14:	e8df f001 	tbb	[pc, r1]
 800fb18:	02070c11 	.word	0x02070c11
  case 1:
    return (canp->can->TSR & CAN_TSR_TME0) != 0;
  case 2:
    return (canp->can->TSR & CAN_TSR_TME1) != 0;
  case 3:
    return (canp->can->TSR & CAN_TSR_TME2) != 0;
 800fb1c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fb1e:	6898      	ldr	r0, [r3, #8]
 800fb20:	f3c0 7000 	ubfx	r0, r0, #28, #1
 800fb24:	4770      	bx	lr
    return (canp->can->TSR & CAN_TSR_TME1) != 0;
 800fb26:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fb28:	6898      	ldr	r0, [r3, #8]
 800fb2a:	f3c0 60c0 	ubfx	r0, r0, #27, #1
 800fb2e:	4770      	bx	lr
    return (canp->can->TSR & CAN_TSR_TME0) != 0;
 800fb30:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fb32:	6898      	ldr	r0, [r3, #8]
 800fb34:	f3c0 6080 	ubfx	r0, r0, #26, #1
 800fb38:	4770      	bx	lr
    return (canp->can->TSR & CAN_TSR_TME) != 0;
 800fb3a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fb3c:	689b      	ldr	r3, [r3, #8]
 800fb3e:	f013 5fe0 	tst.w	r3, #469762048	; 0x1c000000
 800fb42:	bf14      	ite	ne
 800fb44:	2001      	movne	r0, #1
 800fb46:	2000      	moveq	r0, #0
 800fb48:	4770      	bx	lr
  default:
    return FALSE;
 800fb4a:	2000      	movs	r0, #0
  }
}
 800fb4c:	4770      	bx	lr
 800fb4e:	bf00      	nop

0800fb50 <can_lld_transmit>:
                      const CANTxFrame *ctfp) {
  uint32_t tir;
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
 800fb50:	2903      	cmp	r1, #3
 800fb52:	d834      	bhi.n	800fbbe <can_lld_transmit+0x6e>
 800fb54:	e8df f001 	tbb	[pc, r1]
 800fb58:	021f2b23 	.word	0x021f2b23
    break;
  case 2:
    tmbp = &canp->can->sTxMailBox[1];
    break;
  case 3:
    tmbp = &canp->can->sTxMailBox[2];
 800fb5c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800fb5e:	f501 71d0 	add.w	r1, r1, #416	; 0x1a0
 800fb62:	7810      	ldrb	r0, [r2, #0]
                      const CANTxFrame *ctfp) {
 800fb64:	b410      	push	{r4}
 800fb66:	f3c0 1300 	ubfx	r3, r0, #4, #1
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 800fb6a:	0684      	lsls	r4, r0, #26
 800fb6c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fb70:	d521      	bpl.n	800fbb6 <can_lld_transmit+0x66>
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
 800fb72:	6854      	ldr	r4, [r2, #4]
 800fb74:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
 800fb78:	f043 0304 	orr.w	r3, r3, #4
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
  tmbp->TDLR = ctfp->data32[0];
  tmbp->TDHR = ctfp->data32[1];
 800fb7c:	e9d2 4202 	ldrd	r4, r2, [r2, #8]
  tmbp->TDTR = ctfp->DLC;
 800fb80:	f000 000f 	and.w	r0, r0, #15
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 800fb84:	f043 0301 	orr.w	r3, r3, #1
  tmbp->TDTR = ctfp->DLC;
 800fb88:	6048      	str	r0, [r1, #4]
  tmbp->TDLR = ctfp->data32[0];
 800fb8a:	608c      	str	r4, [r1, #8]
  tmbp->TDHR = ctfp->data32[1];
 800fb8c:	60ca      	str	r2, [r1, #12]
}
 800fb8e:	f85d 4b04 	ldr.w	r4, [sp], #4
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 800fb92:	600b      	str	r3, [r1, #0]
}
 800fb94:	4770      	bx	lr
    tmbp = &canp->can->sTxMailBox[1];
 800fb96:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800fb98:	f501 71c8 	add.w	r1, r1, #400	; 0x190
    break;
 800fb9c:	e7e1      	b.n	800fb62 <can_lld_transmit+0x12>
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 800fb9e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800fba0:	688b      	ldr	r3, [r1, #8]
 800fba2:	f3c3 6301 	ubfx	r3, r3, #24, #2
 800fba6:	3318      	adds	r3, #24
 800fba8:	eb01 1103 	add.w	r1, r1, r3, lsl #4
    break;
 800fbac:	e7d9      	b.n	800fb62 <can_lld_transmit+0x12>
    tmbp = &canp->can->sTxMailBox[0];
 800fbae:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800fbb0:	f501 71c0 	add.w	r1, r1, #384	; 0x180
    break;
 800fbb4:	e7d5      	b.n	800fb62 <can_lld_transmit+0x12>
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
 800fbb6:	8894      	ldrh	r4, [r2, #4]
 800fbb8:	ea43 5344 	orr.w	r3, r3, r4, lsl #21
 800fbbc:	e7de      	b.n	800fb7c <can_lld_transmit+0x2c>
 800fbbe:	4770      	bx	lr

0800fbc0 <can_lld_is_rx_nonempty>:
 *
 * @notapi
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
 800fbc0:	2901      	cmp	r1, #1
 800fbc2:	d011      	beq.n	800fbe8 <can_lld_is_rx_nonempty+0x28>
 800fbc4:	d30a      	bcc.n	800fbdc <can_lld_is_rx_nonempty+0x1c>
 800fbc6:	2902      	cmp	r1, #2
 800fbc8:	d106      	bne.n	800fbd8 <can_lld_is_rx_nonempty+0x18>
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
            (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
  case 1:
    return (canp->can->RF0R & CAN_RF0R_FMP0) != 0;
  case 2:
    return (canp->can->RF1R & CAN_RF1R_FMP1) != 0;
 800fbca:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fbcc:	6918      	ldr	r0, [r3, #16]
 800fbce:	f010 0003 	ands.w	r0, r0, #3
 800fbd2:	bf18      	it	ne
 800fbd4:	2001      	movne	r0, #1
 800fbd6:	4770      	bx	lr
  default:
    return FALSE;
 800fbd8:	2000      	movs	r0, #0
  }
}
 800fbda:	4770      	bx	lr
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 800fbdc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fbde:	68da      	ldr	r2, [r3, #12]
 800fbe0:	0792      	lsls	r2, r2, #30
 800fbe2:	d0f3      	beq.n	800fbcc <can_lld_is_rx_nonempty+0xc>
 800fbe4:	2001      	movs	r0, #1
 800fbe6:	4770      	bx	lr
    return (canp->can->RF0R & CAN_RF0R_FMP0) != 0;
 800fbe8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fbea:	68d8      	ldr	r0, [r3, #12]
 800fbec:	f010 0003 	ands.w	r0, r0, #3
 800fbf0:	bf18      	it	ne
 800fbf2:	2001      	movne	r0, #1
 800fbf4:	4770      	bx	lr
 800fbf6:	bf00      	nop
	...

0800fc00 <can_lld_receive>:
 *
 * @notapi
 */
void can_lld_receive(CANDriver *canp,
                     canmbx_t mailbox,
                     CANRxFrame *crfp) {
 800fc00:	b430      	push	{r4, r5}
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
 800fc02:	2900      	cmp	r1, #0
 800fc04:	d12f      	bne.n	800fc66 <can_lld_receive+0x66>
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
 800fc06:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fc08:	68d9      	ldr	r1, [r3, #12]
 800fc0a:	0788      	lsls	r0, r1, #30
 800fc0c:	d044      	beq.n	800fc98 <can_lld_receive+0x98>
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 800fc0e:	f8d3 01b0 	ldr.w	r0, [r3, #432]	; 0x1b0
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 800fc12:	f8d3 11b4 	ldr.w	r1, [r3, #436]	; 0x1b4
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 800fc16:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 800fc1a:	f8d3 51bc 	ldr.w	r5, [r3, #444]	; 0x1bc
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 800fc1e:	60d4      	str	r4, [r2, #12]

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 800fc20:	2420      	movs	r4, #32
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 800fc22:	6115      	str	r5, [r2, #16]
    canp->can->RF0R = CAN_RF0R_RFOM0;
 800fc24:	60dc      	str	r4, [r3, #12]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 800fc26:	68dc      	ldr	r4, [r3, #12]
 800fc28:	07a5      	lsls	r5, r4, #30
 800fc2a:	d103      	bne.n	800fc34 <can_lld_receive+0x34>
      canp->can->IER |= CAN_IER_FMPIE0;
 800fc2c:	695c      	ldr	r4, [r3, #20]
 800fc2e:	f044 0402 	orr.w	r4, r4, #2
 800fc32:	615c      	str	r4, [r3, #20]
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 800fc34:	7913      	ldrb	r3, [r2, #4]
 800fc36:	0844      	lsrs	r4, r0, #1
 800fc38:	f364 1304 	bfi	r3, r4, #4, #1
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
 800fc3c:	0884      	lsrs	r4, r0, #2
 800fc3e:	f364 1345 	bfi	r3, r4, #5, #1
 800fc42:	7113      	strb	r3, [r2, #4]
  if (crfp->IDE)
 800fc44:	069b      	lsls	r3, r3, #26
 800fc46:	d52b      	bpl.n	800fca0 <can_lld_receive+0xa0>
    crfp->EID = rir >> 3;
 800fc48:	6893      	ldr	r3, [r2, #8]
 800fc4a:	08c0      	lsrs	r0, r0, #3
 800fc4c:	f360 031c 	bfi	r3, r0, #0, #29
 800fc50:	6093      	str	r3, [r2, #8]
  else
    crfp->SID = rir >> 21;
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 800fc52:	7913      	ldrb	r3, [r2, #4]
  crfp->FMI = (uint8_t)(rdtr >> 8);
 800fc54:	0a08      	lsrs	r0, r1, #8
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 800fc56:	f361 0303 	bfi	r3, r1, #0, #4
  crfp->TIME = (uint16_t)(rdtr >> 16);
 800fc5a:	0c09      	lsrs	r1, r1, #16
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 800fc5c:	7113      	strb	r3, [r2, #4]
  crfp->FMI = (uint8_t)(rdtr >> 8);
 800fc5e:	7010      	strb	r0, [r2, #0]
  crfp->TIME = (uint16_t)(rdtr >> 16);
 800fc60:	8051      	strh	r1, [r2, #2]
}
 800fc62:	bc30      	pop	{r4, r5}
 800fc64:	4770      	bx	lr
  switch (mailbox) {
 800fc66:	2901      	cmp	r1, #1
 800fc68:	d020      	beq.n	800fcac <can_lld_receive+0xac>
 800fc6a:	2902      	cmp	r1, #2
 800fc6c:	d1f9      	bne.n	800fc62 <can_lld_receive+0x62>
 800fc6e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    rir  = canp->can->sFIFOMailBox[1].RIR;
 800fc70:	f8d3 01c0 	ldr.w	r0, [r3, #448]	; 0x1c0
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 800fc74:	f8d3 11c4 	ldr.w	r1, [r3, #452]	; 0x1c4
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 800fc78:	f8d3 41c8 	ldr.w	r4, [r3, #456]	; 0x1c8
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 800fc7c:	f8d3 51cc 	ldr.w	r5, [r3, #460]	; 0x1cc
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 800fc80:	60d4      	str	r4, [r2, #12]
    canp->can->RF1R = CAN_RF1R_RFOM1;
 800fc82:	2420      	movs	r4, #32
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 800fc84:	6115      	str	r5, [r2, #16]
    canp->can->RF1R = CAN_RF1R_RFOM1;
 800fc86:	611c      	str	r4, [r3, #16]
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 800fc88:	691c      	ldr	r4, [r3, #16]
 800fc8a:	07a4      	lsls	r4, r4, #30
 800fc8c:	d1d2      	bne.n	800fc34 <can_lld_receive+0x34>
      canp->can->IER |= CAN_IER_FMPIE1;
 800fc8e:	695c      	ldr	r4, [r3, #20]
 800fc90:	f044 0410 	orr.w	r4, r4, #16
 800fc94:	615c      	str	r4, [r3, #20]
 800fc96:	e7cd      	b.n	800fc34 <can_lld_receive+0x34>
    else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
 800fc98:	6919      	ldr	r1, [r3, #16]
 800fc9a:	0789      	lsls	r1, r1, #30
 800fc9c:	d1e8      	bne.n	800fc70 <can_lld_receive+0x70>
 800fc9e:	e7e0      	b.n	800fc62 <can_lld_receive+0x62>
    crfp->SID = rir >> 21;
 800fca0:	8913      	ldrh	r3, [r2, #8]
 800fca2:	0d40      	lsrs	r0, r0, #21
 800fca4:	f360 030a 	bfi	r3, r0, #0, #11
 800fca8:	8113      	strh	r3, [r2, #8]
 800fcaa:	e7d2      	b.n	800fc52 <can_lld_receive+0x52>
 800fcac:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800fcae:	e7ae      	b.n	800fc0e <can_lld_receive+0xe>

0800fcb0 <_pal_lld_init>:
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800fcb0:	4968      	ldr	r1, [pc, #416]	; (800fe54 <_pal_lld_init+0x1a4>)
  gpiop->OTYPER  = config->otyper;
 800fcb2:	4a69      	ldr	r2, [pc, #420]	; (800fe58 <_pal_lld_init+0x1a8>)
 800fcb4:	4b69      	ldr	r3, [pc, #420]	; (800fe5c <_pal_lld_init+0x1ac>)
void _pal_lld_init(const PALConfig *config) {
 800fcb6:	b470      	push	{r4, r5, r6}
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800fcb8:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800fcba:	f240 16ff 	movw	r6, #511	; 0x1ff
 800fcbe:	4335      	orrs	r5, r6
 800fcc0:	630d      	str	r5, [r1, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800fcc2:	6d0c      	ldr	r4, [r1, #80]	; 0x50
 800fcc4:	4334      	orrs	r4, r6
 800fcc6:	650c      	str	r4, [r1, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 800fcc8:	6841      	ldr	r1, [r0, #4]
 800fcca:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fccc:	6881      	ldr	r1, [r0, #8]
 800fcce:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800fcd0:	68c1      	ldr	r1, [r0, #12]
 800fcd2:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 800fcd4:	6901      	ldr	r1, [r0, #16]
 800fcd6:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800fcd8:	6941      	ldr	r1, [r0, #20]
 800fcda:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800fcdc:	6981      	ldr	r1, [r0, #24]
 800fcde:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fce0:	6801      	ldr	r1, [r0, #0]
 800fce2:	6011      	str	r1, [r2, #0]
  gpiop->OTYPER  = config->otyper;
 800fce4:	6a02      	ldr	r2, [r0, #32]
 800fce6:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fce8:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800fcea:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800fcec:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800fcee:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800fcf0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800fcf2:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800fcf4:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800fcf6:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800fcf8:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800fcfa:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fcfc:	69c2      	ldr	r2, [r0, #28]
 800fcfe:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 800fd00:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800fd02:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 800fd06:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800fd08:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 800fd0c:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800fd0e:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 800fd12:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800fd14:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 800fd18:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 800fd1a:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800fd1e:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800fd20:	f8c3 2424 	str.w	r2, [r3, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 800fd24:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800fd26:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
 800fd2a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800fd2e:	6d82      	ldr	r2, [r0, #88]	; 0x58
 800fd30:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fd32:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800fd34:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800fd36:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800fd38:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800fd3a:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800fd3c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800fd3e:	6e82      	ldr	r2, [r0, #104]	; 0x68
 800fd40:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800fd42:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800fd44:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fd46:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800fd48:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 800fd4a:	6f42      	ldr	r2, [r0, #116]	; 0x74
 800fd4c:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 800fd50:	6f82      	ldr	r2, [r0, #120]	; 0x78
 800fd52:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 800fd56:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 800fd58:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 800fd5c:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 800fd60:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 800fd64:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 800fd68:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800fd6c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800fd70:	f8c3 2424 	str.w	r2, [r3, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 800fd74:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800fd76:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
 800fd7a:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 800fd7e:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 800fd82:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 800fd86:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 800fd8a:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 800fd8e:	f8c3 280c 	str.w	r2, [r3, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 800fd92:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800fd96:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 800fd9a:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
 800fd9e:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 800fda2:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 800fda6:	f8c3 2824 	str.w	r2, [r3, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800fdaa:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 800fdae:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  gpiop->OTYPER  = config->otyper;
 800fdb2:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 800fdb6:	f8d0 20ac 	ldr.w	r2, [r0, #172]	; 0xac
 800fdba:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800fdbc:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 800fdc0:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800fdc2:	f8d0 20b4 	ldr.w	r2, [r0, #180]	; 0xb4
 800fdc6:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800fdc8:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
 800fdcc:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800fdce:	f8d0 20bc 	ldr.w	r2, [r0, #188]	; 0xbc
 800fdd2:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800fdd4:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 800fdd8:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800fdda:	f8d0 20a8 	ldr.w	r2, [r0, #168]	; 0xa8
 800fdde:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 800fde0:	f8d0 20c8 	ldr.w	r2, [r0, #200]	; 0xc8
 800fde4:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 800fde8:	f8d0 20cc 	ldr.w	r2, [r0, #204]	; 0xcc
 800fdec:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 800fdf0:	f8d0 20d0 	ldr.w	r2, [r0, #208]	; 0xd0
 800fdf4:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 800fdf8:	f8d0 20d4 	ldr.w	r2, [r0, #212]	; 0xd4
 800fdfc:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 800fe00:	f8d0 20d8 	ldr.w	r2, [r0, #216]	; 0xd8
 800fe04:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800fe08:	f8d0 20dc 	ldr.w	r2, [r0, #220]	; 0xdc
 800fe0c:	f8c3 2424 	str.w	r2, [r3, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 800fe10:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
 800fe14:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
 800fe18:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 800fe1c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 800fe20:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 800fe24:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 800fe28:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 800fe2c:	f8c3 280c 	str.w	r2, [r3, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 800fe30:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 800fe34:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 800fe38:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800fe3c:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 800fe40:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 800fe44:	f8c3 2824 	str.w	r2, [r3, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800fe48:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800fe4c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  initgpio(GPIOH, &config->PHData);
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
#endif
}
 800fe50:	bc70      	pop	{r4, r5, r6}
 800fe52:	4770      	bx	lr
 800fe54:	40023800 	.word	0x40023800
 800fe58:	40020000 	.word	0x40020000
 800fe5c:	40020400 	.word	0x40020400

0800fe60 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800fe60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800fe64:	f002 0c03 	and.w	ip, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800fe68:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800fe6c:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 800fe70:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 800fe74:	2400      	movs	r4, #0
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800fe76:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 800fe7a:	f04f 0e0f 	mov.w	lr, #15
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800fe7e:	f04f 0901 	mov.w	r9, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800fe82:	f04f 0803 	mov.w	r8, #3
 800fe86:	e030      	b.n	800feea <_pal_lld_setgroupmode+0x8a>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800fe88:	f8d0 b020 	ldr.w	fp, [r0, #32]
 800fe8c:	ea0b 0a0a 	and.w	sl, fp, sl
 800fe90:	ea4a 0303 	orr.w	r3, sl, r3
 800fe94:	6203      	str	r3, [r0, #32]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800fe96:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 800fe98:	fa09 fa04 	lsl.w	sl, r9, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800fe9c:	ea23 030a 	bic.w	r3, r3, sl
 800fea0:	433b      	orrs	r3, r7
 800fea2:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 800fea4:	0063      	lsls	r3, r4, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800fea6:	f8d0 a008 	ldr.w	sl, [r0, #8]
      m2 = 3 << (bit * 2);
 800feaa:	fa08 f303 	lsl.w	r3, r8, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800feae:	43db      	mvns	r3, r3
 800feb0:	ea0a 0a03 	and.w	sl, sl, r3
 800feb4:	ea4a 0a06 	orr.w	sl, sl, r6
 800feb8:	f8c0 a008 	str.w	sl, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800febc:	f8d0 a00c 	ldr.w	sl, [r0, #12]
 800fec0:	ea03 0a0a 	and.w	sl, r3, sl
 800fec4:	ea4a 0a05 	orr.w	sl, sl, r5
 800fec8:	f8c0 a00c 	str.w	sl, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 800fecc:	f8d0 a000 	ldr.w	sl, [r0]
 800fed0:	ea03 030a 	and.w	r3, r3, sl
 800fed4:	ea43 030c 	orr.w	r3, r3, ip
 800fed8:	6003      	str	r3, [r0, #0]
    }
    mask >>= 1;
    if (!mask)
 800feda:	0849      	lsrs	r1, r1, #1
 800fedc:	d01b      	beq.n	800ff16 <_pal_lld_setgroupmode+0xb6>
      return;
    otyper <<= 1;
 800fede:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 800fee0:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 800fee2:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 800fee4:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    bit++;
 800fee8:	3401      	adds	r4, #1
      altrmask = altr << ((bit & 7) * 4);
 800feea:	f004 0307 	and.w	r3, r4, #7
 800feee:	009b      	lsls	r3, r3, #2
      m4 = 15 << ((bit & 7) * 4);
 800fef0:	fa0e fa03 	lsl.w	sl, lr, r3
    if ((mask & 1) != 0) {
 800fef4:	f011 0f01 	tst.w	r1, #1
      altrmask = altr << ((bit & 7) * 4);
 800fef8:	fa02 f303 	lsl.w	r3, r2, r3
 800fefc:	ea6f 0a0a 	mvn.w	sl, sl
    if ((mask & 1) != 0) {
 800ff00:	d0eb      	beq.n	800feda <_pal_lld_setgroupmode+0x7a>
      if (bit < 8)
 800ff02:	2c07      	cmp	r4, #7
 800ff04:	d9c0      	bls.n	800fe88 <_pal_lld_setgroupmode+0x28>
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 800ff06:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 800ff0a:	ea0b 0a0a 	and.w	sl, fp, sl
 800ff0e:	ea4a 0303 	orr.w	r3, sl, r3
 800ff12:	6243      	str	r3, [r0, #36]	; 0x24
 800ff14:	e7bf      	b.n	800fe96 <_pal_lld_setgroupmode+0x36>
  }
}
 800ff16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ff1a:	bf00      	nop
 800ff1c:	0000      	movs	r0, r0
	...

0800ff20 <i2c_lld_serve_tx_end_irq>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800ff20:	f011 0f0c 	tst.w	r1, #12
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800ff24:	b538      	push	{r3, r4, r5, lr}
 800ff26:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;
 800ff28:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800ff2a:	d112      	bne.n	800ff52 <i2c_lld_serve_tx_end_irq+0x32>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 800ff2c:	6b29      	ldr	r1, [r5, #48]	; 0x30
 800ff2e:	680a      	ldr	r2, [r1, #0]
 800ff30:	6813      	ldr	r3, [r2, #0]
 800ff32:	f023 031f 	bic.w	r3, r3, #31
 800ff36:	6013      	str	r3, [r2, #0]
 800ff38:	6813      	ldr	r3, [r2, #0]
 800ff3a:	07db      	lsls	r3, r3, #31
 800ff3c:	d4fc      	bmi.n	800ff38 <i2c_lld_serve_tx_end_irq+0x18>
 800ff3e:	7a08      	ldrb	r0, [r1, #8]
 800ff40:	684a      	ldr	r2, [r1, #4]
 800ff42:	233d      	movs	r3, #61	; 0x3d
 800ff44:	4083      	lsls	r3, r0
 800ff46:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800ff48:	6863      	ldr	r3, [r4, #4]
 800ff4a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ff4e:	6063      	str	r3, [r4, #4]
}
 800ff50:	bd38      	pop	{r3, r4, r5, pc}
  chSysHalt(reason);
 800ff52:	4802      	ldr	r0, [pc, #8]	; (800ff5c <i2c_lld_serve_tx_end_irq+0x3c>)
 800ff54:	f7fd fadc 	bl	800d510 <chSysHalt>
 800ff58:	e7e8      	b.n	800ff2c <i2c_lld_serve_tx_end_irq+0xc>
 800ff5a:	bf00      	nop
 800ff5c:	0802da70 	.word	0x0802da70

0800ff60 <i2c_lld_serve_rx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800ff60:	f011 0f0c 	tst.w	r1, #12
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800ff64:	b570      	push	{r4, r5, r6, lr}
 800ff66:	4606      	mov	r6, r0
  I2C_TypeDef *dp = i2cp->i2c;
 800ff68:	6b45      	ldr	r5, [r0, #52]	; 0x34
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800ff6a:	d125      	bne.n	800ffb8 <i2c_lld_serve_rx_end_irq+0x58>
  dmaStreamDisable(i2cp->dmarx);
 800ff6c:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800ff6e:	6813      	ldr	r3, [r2, #0]
 800ff70:	6819      	ldr	r1, [r3, #0]
 800ff72:	f021 011f 	bic.w	r1, r1, #31
 800ff76:	6019      	str	r1, [r3, #0]
 800ff78:	681c      	ldr	r4, [r3, #0]
 800ff7a:	f014 0401 	ands.w	r4, r4, #1
 800ff7e:	d1fb      	bne.n	800ff78 <i2c_lld_serve_rx_end_irq+0x18>
 800ff80:	7a11      	ldrb	r1, [r2, #8]
 800ff82:	6852      	ldr	r2, [r2, #4]
 800ff84:	233d      	movs	r3, #61	; 0x3d
 800ff86:	408b      	lsls	r3, r1
 800ff88:	6013      	str	r3, [r2, #0]
  dp->CR2 &= ~I2C_CR2_LAST;
 800ff8a:	686b      	ldr	r3, [r5, #4]
 800ff8c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800ff90:	606b      	str	r3, [r5, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 800ff92:	682b      	ldr	r3, [r5, #0]
 800ff94:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ff98:	602b      	str	r3, [r5, #0]
  dp->CR1 |= I2C_CR1_STOP;
 800ff9a:	682b      	ldr	r3, [r5, #0]
 800ff9c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ffa0:	602b      	str	r3, [r5, #0]
 800ffa2:	2320      	movs	r3, #32
 800ffa4:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 800ffa8:	f106 001c 	add.w	r0, r6, #28
 800ffac:	4621      	mov	r1, r4
 800ffae:	f7fd fd6f 	bl	800da90 <chThdResumeI>
 800ffb2:	f384 8811 	msr	BASEPRI, r4
}
 800ffb6:	bd70      	pop	{r4, r5, r6, pc}
  chSysHalt(reason);
 800ffb8:	4801      	ldr	r0, [pc, #4]	; (800ffc0 <i2c_lld_serve_rx_end_irq+0x60>)
 800ffba:	f7fd faa9 	bl	800d510 <chSysHalt>
 800ffbe:	e7d5      	b.n	800ff6c <i2c_lld_serve_rx_end_irq+0xc>
 800ffc0:	0802da70 	.word	0x0802da70
	...

0800ffd0 <VectorBC>:
  I2C_TypeDef *dp = i2cp->i2c;
 800ffd0:	4839      	ldr	r0, [pc, #228]	; (80100b8 <VectorBC+0xe8>)
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800ffd2:	4a3a      	ldr	r2, [pc, #232]	; (80100bc <VectorBC+0xec>)
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 800ffd4:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800ffd6:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t regSR2 = dp->SR2;
 800ffd8:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 800ffda:	6965      	ldr	r5, [r4, #20]
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800ffdc:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800ffe0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ffe4:	4293      	cmp	r3, r2
 800ffe6:	d050      	beq.n	801008a <VectorBC+0xba>
 800ffe8:	d822      	bhi.n	8010030 <VectorBC+0x60>
 800ffea:	3a07      	subs	r2, #7
 800ffec:	4293      	cmp	r3, r2
 800ffee:	d040      	beq.n	8010072 <VectorBC+0xa2>
 800fff0:	3201      	adds	r2, #1
 800fff2:	4293      	cmp	r3, r2
 800fff4:	d114      	bne.n	8010020 <VectorBC+0x50>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fff6:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800fff8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800fffa:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 800fffe:	681b      	ldr	r3, [r3, #0]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8010000:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8010002:	681a      	ldr	r2, [r3, #0]
 8010004:	f042 0201 	orr.w	r2, r2, #1
 8010008:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 801000a:	6862      	ldr	r2, [r4, #4]
 801000c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8010010:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8010012:	685b      	ldr	r3, [r3, #4]
 8010014:	2b01      	cmp	r3, #1
 8010016:	d803      	bhi.n	8010020 <VectorBC+0x50>
      dp->CR1 &= ~I2C_CR1_ACK;
 8010018:	6823      	ldr	r3, [r4, #0]
 801001a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801001e:	6023      	str	r3, [r4, #0]
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8010020:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 8010024:	bf18      	it	ne
 8010026:	69a3      	ldrne	r3, [r4, #24]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
}
 8010028:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 801002c:	f7fe b990 	b.w	800e350 <_port_irq_epilogue>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8010030:	4a23      	ldr	r2, [pc, #140]	; (80100c0 <VectorBC+0xf0>)
 8010032:	4293      	cmp	r3, r2
 8010034:	d012      	beq.n	801005c <VectorBC+0x8c>
 8010036:	3202      	adds	r2, #2
 8010038:	4293      	cmp	r3, r2
 801003a:	d1f1      	bne.n	8010020 <VectorBC+0x50>
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 801003c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 801003e:	681b      	ldr	r3, [r3, #0]
 8010040:	685e      	ldr	r6, [r3, #4]
 8010042:	b33e      	cbz	r6, 8010094 <VectorBC+0xc4>
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8010044:	6823      	ldr	r3, [r4, #0]
      i2cp->addr |= 0x01;
 8010046:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8010048:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
      i2cp->addr |= 0x01;
 801004c:	f042 0201 	orr.w	r2, r2, #1
 8010050:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8010052:	6023      	str	r3, [r4, #0]
}
 8010054:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8010058:	f7fe b97a 	b.w	800e350 <_port_irq_epilogue>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 801005c:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 801005e:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8010060:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8010064:	6812      	ldr	r2, [r2, #0]
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8010066:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8010068:	6813      	ldr	r3, [r2, #0]
 801006a:	f043 0301 	orr.w	r3, r3, #1
 801006e:	6013      	str	r3, [r2, #0]
 8010070:	e7d6      	b.n	8010020 <VectorBC+0x50>
    if ((i2cp->addr >> 8) > 0) { 
 8010072:	8c03      	ldrh	r3, [r0, #32]
 8010074:	0a1a      	lsrs	r2, r3, #8
 8010076:	d00b      	beq.n	8010090 <VectorBC+0xc0>
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8010078:	f003 0301 	and.w	r3, r3, #1
 801007c:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8010080:	f002 0206 	and.w	r2, r2, #6
 8010084:	4313      	orrs	r3, r2
 8010086:	6123      	str	r3, [r4, #16]
 8010088:	e7ca      	b.n	8010020 <VectorBC+0x50>
    dp->DR = (0xFF & (i2cp->addr >> 1));
 801008a:	8c03      	ldrh	r3, [r0, #32]
 801008c:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8010090:	6123      	str	r3, [r4, #16]
 8010092:	e7c5      	b.n	8010020 <VectorBC+0x50>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8010094:	6863      	ldr	r3, [r4, #4]
 8010096:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801009a:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 801009c:	6823      	ldr	r3, [r4, #0]
 801009e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80100a2:	6023      	str	r3, [r4, #0]
 80100a4:	2320      	movs	r3, #32
 80100a6:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 80100aa:	301c      	adds	r0, #28
 80100ac:	4631      	mov	r1, r6
 80100ae:	f7fd fcef 	bl	800da90 <chThdResumeI>
 80100b2:	f386 8811 	msr	BASEPRI, r6
 80100b6:	e7b3      	b.n	8010020 <VectorBC+0x50>
 80100b8:	20001d7c 	.word	0x20001d7c
 80100bc:	00030008 	.word	0x00030008
 80100c0:	00070082 	.word	0x00070082
	...

080100d0 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 80100d0:	4834      	ldr	r0, [pc, #208]	; (80101a4 <VectorC0+0xd4>)
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80100d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dmaStreamDisable(i2cp->dmatx);
 80100d4:	e9d0 750c 	ldrd	r7, r5, [r0, #48]	; 0x30
  uint16_t sr = I2CD1.i2c->SR1;
 80100d8:	696c      	ldr	r4, [r5, #20]
  dmaStreamDisable(i2cp->dmatx);
 80100da:	683a      	ldr	r2, [r7, #0]

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80100dc:	f404 435f 	and.w	r3, r4, #57088	; 0xdf00
 80100e0:	43db      	mvns	r3, r3
 80100e2:	616b      	str	r3, [r5, #20]
  dmaStreamDisable(i2cp->dmatx);
 80100e4:	6813      	ldr	r3, [r2, #0]
 80100e6:	f023 031f 	bic.w	r3, r3, #31
 80100ea:	6013      	str	r3, [r2, #0]
  uint16_t sr = I2CD1.i2c->SR1;
 80100ec:	b2a1      	uxth	r1, r4
  dmaStreamDisable(i2cp->dmatx);
 80100ee:	6813      	ldr	r3, [r2, #0]
 80100f0:	07db      	lsls	r3, r3, #31
 80100f2:	d4fc      	bmi.n	80100ee <VectorC0+0x1e>
 80100f4:	7a3a      	ldrb	r2, [r7, #8]
  dmaStreamDisable(i2cp->dmarx);
 80100f6:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  dmaStreamDisable(i2cp->dmatx);
 80100f8:	687f      	ldr	r7, [r7, #4]
 80100fa:	233d      	movs	r3, #61	; 0x3d
 80100fc:	4093      	lsls	r3, r2
  dmaStreamDisable(i2cp->dmarx);
 80100fe:	6832      	ldr	r2, [r6, #0]
  dmaStreamDisable(i2cp->dmatx);
 8010100:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 8010102:	6813      	ldr	r3, [r2, #0]
 8010104:	f023 031f 	bic.w	r3, r3, #31
 8010108:	6013      	str	r3, [r2, #0]
 801010a:	6813      	ldr	r3, [r2, #0]
 801010c:	07df      	lsls	r7, r3, #31
 801010e:	d4fc      	bmi.n	801010a <VectorC0+0x3a>
 8010110:	7a37      	ldrb	r7, [r6, #8]
 8010112:	6872      	ldr	r2, [r6, #4]
 8010114:	233d      	movs	r3, #61	; 0x3d
 8010116:	40bb      	lsls	r3, r7
 8010118:	6013      	str	r3, [r2, #0]
  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 801011a:	f411 7380 	ands.w	r3, r1, #256	; 0x100
    i2cp->errors |= I2C_BUS_ERROR;
 801011e:	bf18      	it	ne
 8010120:	2301      	movne	r3, #1
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8010122:	058a      	lsls	r2, r1, #22
    i2cp->errors |= I2C_BUS_ERROR;
 8010124:	6083      	str	r3, [r0, #8]
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8010126:	bf44      	itt	mi
 8010128:	f043 0302 	orrmi.w	r3, r3, #2
 801012c:	6083      	strmi	r3, [r0, #8]
  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 801012e:	054f      	lsls	r7, r1, #21
 8010130:	d50a      	bpl.n	8010148 <VectorC0+0x78>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8010132:	686a      	ldr	r2, [r5, #4]
 8010134:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8010138:	606a      	str	r2, [r5, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 801013a:	682a      	ldr	r2, [r5, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 801013c:	f043 0304 	orr.w	r3, r3, #4
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8010140:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8010144:	602a      	str	r2, [r5, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8010146:	6083      	str	r3, [r0, #8]
  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8010148:	050e      	lsls	r6, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 801014a:	bf44      	itt	mi
 801014c:	f043 0308 	orrmi.w	r3, r3, #8
 8010150:	6083      	strmi	r3, [r0, #8]
  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8010152:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 8010154:	bf44      	itt	mi
 8010156:	f043 0320 	orrmi.w	r3, r3, #32
 801015a:	6083      	strmi	r3, [r0, #8]
  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 801015c:	04ca      	lsls	r2, r1, #19
 801015e:	b224      	sxth	r4, r4
 8010160:	d513      	bpl.n	801018a <VectorC0+0xba>
    i2cp->errors |= I2C_PEC_ERROR;
 8010162:	f043 0310 	orr.w	r3, r3, #16
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8010166:	2c00      	cmp	r4, #0
    i2cp->errors |= I2C_PEC_ERROR;
 8010168:	6083      	str	r3, [r0, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 801016a:	db16      	blt.n	801019a <VectorC0+0xca>
 801016c:	2320      	movs	r3, #32
 801016e:	f383 8811 	msr	BASEPRI, r3
 8010172:	f06f 0101 	mvn.w	r1, #1
 8010176:	480c      	ldr	r0, [pc, #48]	; (80101a8 <VectorC0+0xd8>)
 8010178:	f7fd fc8a 	bl	800da90 <chThdResumeI>
 801017c:	2300      	movs	r3, #0
 801017e:	f383 8811 	msr	BASEPRI, r3
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
}
 8010182:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 8010186:	f7fe b8e3 	b.w	800e350 <_port_irq_epilogue>
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 801018a:	2c00      	cmp	r4, #0
 801018c:	db05      	blt.n	801019a <VectorC0+0xca>
  if (i2cp->errors != I2C_NO_ERROR)
 801018e:	2b00      	cmp	r3, #0
 8010190:	d1ec      	bne.n	801016c <VectorC0+0x9c>
}
 8010192:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 8010196:	f7fe b8db 	b.w	800e350 <_port_irq_epilogue>
    i2cp->errors |= I2C_SMB_ALERT;
 801019a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801019e:	6083      	str	r3, [r0, #8]
 80101a0:	e7e4      	b.n	801016c <VectorC0+0x9c>
 80101a2:	bf00      	nop
 80101a4:	20001d7c 	.word	0x20001d7c
 80101a8:	20001d98 	.word	0x20001d98
 80101ac:	00000000 	.word	0x00000000

080101b0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 80101b0:	b510      	push	{r4, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 80101b2:	4c07      	ldr	r4, [pc, #28]	; (80101d0 <i2c_lld_init+0x20>)
 80101b4:	4620      	mov	r0, r4
 80101b6:	f7fe f9d3 	bl	800e560 <i2cObjectInit>
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 80101ba:	4b06      	ldr	r3, [pc, #24]	; (80101d4 <i2c_lld_init+0x24>)
  I2CD1.i2c    = I2C1;
 80101bc:	4a06      	ldr	r2, [pc, #24]	; (80101d8 <i2c_lld_init+0x28>)
 80101be:	6362      	str	r2, [r4, #52]	; 0x34
  I2CD1.thread = NULL;
 80101c0:	2100      	movs	r1, #0
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 80101c2:	f103 0248 	add.w	r2, r3, #72	; 0x48
  I2CD1.thread = NULL;
 80101c6:	61e1      	str	r1, [r4, #28]
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 80101c8:	e9c4 320b 	strd	r3, r2, [r4, #44]	; 0x2c
  I2CD3.thread = NULL;
  I2CD3.i2c    = I2C3;
  I2CD3.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C3_RX_DMA_STREAM);
  I2CD3.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C3_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C3 */
}
 80101cc:	bd10      	pop	{r4, pc}
 80101ce:	bf00      	nop
 80101d0:	20001d7c 	.word	0x20001d7c
 80101d4:	0802d9b0 	.word	0x0802d9b0
 80101d8:	40005400 	.word	0x40005400
 80101dc:	00000000 	.word	0x00000000

080101e0 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 80101e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80101e2:	7803      	ldrb	r3, [r0, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 80101e4:	6b45      	ldr	r5, [r0, #52]	; 0x34
  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80101e6:	f240 4256 	movw	r2, #1110	; 0x456
 80101ea:	6282      	str	r2, [r0, #40]	; 0x28
  if (i2cp->state == I2C_STOP) {
 80101ec:	2b01      	cmp	r3, #1
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80101ee:	f240 4216 	movw	r2, #1046	; 0x416
void i2c_lld_start(I2CDriver *i2cp) {
 80101f2:	4604      	mov	r4, r0
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80101f4:	6242      	str	r2, [r0, #36]	; 0x24
  if (i2cp->state == I2C_STOP) {
 80101f6:	d03c      	beq.n	8010272 <i2c_lld_start+0x92>
  I2C_TypeDef *dp = i2cp->i2c;
 80101f8:	462b      	mov	r3, r5
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80101fa:	e9d4 120b 	ldrd	r1, r2, [r4, #44]	; 0x2c
 80101fe:	6860      	ldr	r0, [r4, #4]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8010200:	680f      	ldr	r7, [r1, #0]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8010202:	f8d2 c000 	ldr.w	ip, [r2]
  int32_t clock_speed = i2cp->config->clock_speed;
 8010206:	6841      	ldr	r1, [r0, #4]
  if (clock_speed <= 100000) {
 8010208:	4e46      	ldr	r6, [pc, #280]	; (8010324 <i2c_lld_start+0x144>)
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 801020a:	f105 0210 	add.w	r2, r5, #16
 801020e:	60ba      	str	r2, [r7, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8010210:	f44f 6410 	mov.w	r4, #2304	; 0x900
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8010214:	f8cc 2008 	str.w	r2, [ip, #8]
  dp->CR1 = I2C_CR1_SWRST;
 8010218:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  dp->CR1 = 0;
 801021c:	2200      	movs	r2, #0
  dp->CR1 = I2C_CR1_SWRST;
 801021e:	602f      	str	r7, [r5, #0]
  dp->CR1 = 0;
 8010220:	602a      	str	r2, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8010222:	606c      	str	r4, [r5, #4]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8010224:	685c      	ldr	r4, [r3, #4]
 8010226:	f64f 77c0 	movw	r7, #65472	; 0xffc0
 801022a:	403c      	ands	r4, r7
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 801022c:	7a07      	ldrb	r7, [r0, #8]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 801022e:	605c      	str	r4, [r3, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8010230:	685c      	ldr	r4, [r3, #4]
  if (clock_speed <= 100000) {
 8010232:	42b1      	cmp	r1, r6
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8010234:	f044 042a 	orr.w	r4, r4, #42	; 0x2a
 8010238:	605c      	str	r4, [r3, #4]
  if (clock_speed <= 100000) {
 801023a:	dd49      	ble.n	80102d0 <i2c_lld_start+0xf0>
  else if (clock_speed <= 400000) {
 801023c:	4c3a      	ldr	r4, [pc, #232]	; (8010328 <i2c_lld_start+0x148>)
 801023e:	42a1      	cmp	r1, r4
 8010240:	dc07      	bgt.n	8010252 <i2c_lld_start+0x72>
    if (duty == FAST_DUTY_CYCLE_2) {
 8010242:	2f02      	cmp	r7, #2
 8010244:	d056      	beq.n	80102f4 <i2c_lld_start+0x114>
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 8010246:	2f03      	cmp	r7, #3
 8010248:	d05f      	beq.n	801030a <i2c_lld_start+0x12a>
 801024a:	f648 72ff 	movw	r2, #36863	; 0x8fff
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 801024e:	210d      	movs	r1, #13
 8010250:	6219      	str	r1, [r3, #32]
  dp->CCR = regCCR;
 8010252:	61da      	str	r2, [r3, #28]
  switch (opmode) {
 8010254:	7801      	ldrb	r1, [r0, #0]
  regCR1 = dp->CR1;
 8010256:	681a      	ldr	r2, [r3, #0]
  switch (opmode) {
 8010258:	2902      	cmp	r1, #2
  regCR1 = dp->CR1;
 801025a:	b292      	uxth	r2, r2
  switch (opmode) {
 801025c:	d044      	beq.n	80102e8 <i2c_lld_start+0x108>
 801025e:	2903      	cmp	r1, #3
 8010260:	d03f      	beq.n	80102e2 <i2c_lld_start+0x102>
 8010262:	2901      	cmp	r1, #1
 8010264:	d030      	beq.n	80102c8 <i2c_lld_start+0xe8>
  dp->CR1 = regCR1;
 8010266:	601a      	str	r2, [r3, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8010268:	682b      	ldr	r3, [r5, #0]
 801026a:	f043 0301 	orr.w	r3, r3, #1
 801026e:	602b      	str	r3, [r5, #0]
}
 8010270:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (&I2CD1 == i2cp) {
 8010272:	4b2e      	ldr	r3, [pc, #184]	; (801032c <i2c_lld_start+0x14c>)
 8010274:	4298      	cmp	r0, r3
 8010276:	d1bf      	bne.n	80101f8 <i2c_lld_start+0x18>
      rccResetI2C1();
 8010278:	4e2d      	ldr	r6, [pc, #180]	; (8010330 <i2c_lld_start+0x150>)
      b = dmaStreamAllocate(i2cp->dmarx,
 801027a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
      rccResetI2C1();
 801027c:	6a33      	ldr	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 801027e:	4a2d      	ldr	r2, [pc, #180]	; (8010334 <i2c_lld_start+0x154>)
      rccResetI2C1();
 8010280:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8010284:	2100      	movs	r1, #0
 8010286:	6233      	str	r3, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 8010288:	4623      	mov	r3, r4
      rccResetI2C1();
 801028a:	6231      	str	r1, [r6, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 801028c:	2105      	movs	r1, #5
 801028e:	f7ff f93f 	bl	800f510 <dmaStreamAllocate>
      b = dmaStreamAllocate(i2cp->dmatx,
 8010292:	4a29      	ldr	r2, [pc, #164]	; (8010338 <i2c_lld_start+0x158>)
 8010294:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8010296:	4623      	mov	r3, r4
 8010298:	2105      	movs	r1, #5
 801029a:	f7ff f939 	bl	800f510 <dmaStreamAllocate>
      rccEnableI2C1(FALSE);
 801029e:	6c33      	ldr	r3, [r6, #64]	; 0x40
 80102a0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80102a4:	6433      	str	r3, [r6, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 80102a6:	2105      	movs	r1, #5
 80102a8:	201f      	movs	r0, #31
 80102aa:	f7fe ff41 	bl	800f130 <nvicEnableVector>
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 80102ae:	2105      	movs	r1, #5
 80102b0:	2020      	movs	r0, #32
 80102b2:	f7fe ff3d 	bl	800f130 <nvicEnableVector>
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80102b6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80102b8:	4820      	ldr	r0, [pc, #128]	; (801033c <i2c_lld_start+0x15c>)
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80102ba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80102bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80102be:	4301      	orrs	r1, r0
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80102c0:	4302      	orrs	r2, r0
 80102c2:	e9c4 1209 	strd	r1, r2, [r4, #36]	; 0x24
 80102c6:	e798      	b.n	80101fa <i2c_lld_start+0x1a>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80102c8:	f022 020a 	bic.w	r2, r2, #10
 80102cc:	b292      	uxth	r2, r2
 80102ce:	e7ca      	b.n	8010266 <i2c_lld_start+0x86>
    dp->TRISE = I2C_CLK_FREQ + 1;
 80102d0:	242b      	movs	r4, #43	; 0x2b
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 80102d2:	0049      	lsls	r1, r1, #1
 80102d4:	4a1a      	ldr	r2, [pc, #104]	; (8010340 <i2c_lld_start+0x160>)
    dp->TRISE = I2C_CLK_FREQ + 1;
 80102d6:	621c      	str	r4, [r3, #32]
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 80102d8:	fbb2 f2f1 	udiv	r2, r2, r1
 80102dc:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80102e0:	e7b7      	b.n	8010252 <i2c_lld_start+0x72>
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80102e2:	f042 020a 	orr.w	r2, r2, #10
 80102e6:	e7be      	b.n	8010266 <i2c_lld_start+0x86>
 80102e8:	f022 0208 	bic.w	r2, r2, #8
 80102ec:	b292      	uxth	r2, r2
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 80102ee:	f042 0202 	orr.w	r2, r2, #2
 80102f2:	e7b8      	b.n	8010266 <i2c_lld_start+0x86>
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 80102f4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80102f8:	4a11      	ldr	r2, [pc, #68]	; (8010340 <i2c_lld_start+0x160>)
 80102fa:	fbb2 f2f1 	udiv	r2, r2, r1
 80102fe:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8010302:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8010306:	b292      	uxth	r2, r2
 8010308:	e7a1      	b.n	801024e <i2c_lld_start+0x6e>
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 801030a:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 801030e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8010312:	4a0b      	ldr	r2, [pc, #44]	; (8010340 <i2c_lld_start+0x160>)
 8010314:	fbb2 f2f1 	udiv	r2, r2, r1
 8010318:	ea6f 4282 	mvn.w	r2, r2, lsl #18
 801031c:	ea6f 4292 	mvn.w	r2, r2, lsr #18
 8010320:	b292      	uxth	r2, r2
 8010322:	e794      	b.n	801024e <i2c_lld_start+0x6e>
 8010324:	000186a0 	.word	0x000186a0
 8010328:	00061a80 	.word	0x00061a80
 801032c:	20001d7c 	.word	0x20001d7c
 8010330:	40023800 	.word	0x40023800
 8010334:	0800ff61 	.word	0x0800ff61
 8010338:	0800ff21 	.word	0x0800ff21
 801033c:	02030000 	.word	0x02030000
 8010340:	0280de80 	.word	0x0280de80
	...

08010350 <i2c_lld_stop>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {
 8010350:	b538      	push	{r3, r4, r5, lr}

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8010352:	7803      	ldrb	r3, [r0, #0]
 8010354:	2b01      	cmp	r3, #1
 8010356:	d02d      	beq.n	80103b4 <i2c_lld_stop+0x64>
  I2C_TypeDef *dp = i2cp->i2c;
 8010358:	e9d0 130c 	ldrd	r1, r3, [r0, #48]	; 0x30
  dp->CR1 = 0;
 801035c:	2400      	movs	r4, #0
  dmaStreamDisable(i2cp->dmatx);
 801035e:	680a      	ldr	r2, [r1, #0]
  dp->CR1 = I2C_CR1_SWRST;
 8010360:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 8010364:	601d      	str	r5, [r3, #0]
  dp->CR1 = 0;
 8010366:	601c      	str	r4, [r3, #0]
  dp->CR2 = 0;
 8010368:	605c      	str	r4, [r3, #4]
  dp->SR1 = 0;
 801036a:	615c      	str	r4, [r3, #20]
  dmaStreamDisable(i2cp->dmatx);
 801036c:	6813      	ldr	r3, [r2, #0]
 801036e:	f023 031f 	bic.w	r3, r3, #31
 8010372:	6013      	str	r3, [r2, #0]
 8010374:	6813      	ldr	r3, [r2, #0]
 8010376:	07dc      	lsls	r4, r3, #31
 8010378:	d4fc      	bmi.n	8010374 <i2c_lld_stop+0x24>
 801037a:	7a0a      	ldrb	r2, [r1, #8]
  dmaStreamDisable(i2cp->dmarx);
 801037c:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  dmaStreamDisable(i2cp->dmatx);
 801037e:	684c      	ldr	r4, [r1, #4]
 8010380:	233d      	movs	r3, #61	; 0x3d
 8010382:	4093      	lsls	r3, r2
  dmaStreamDisable(i2cp->dmarx);
 8010384:	682a      	ldr	r2, [r5, #0]
  dmaStreamDisable(i2cp->dmatx);
 8010386:	6023      	str	r3, [r4, #0]
  dmaStreamDisable(i2cp->dmarx);
 8010388:	6813      	ldr	r3, [r2, #0]
 801038a:	f023 031f 	bic.w	r3, r3, #31
 801038e:	6013      	str	r3, [r2, #0]
 8010390:	6813      	ldr	r3, [r2, #0]
 8010392:	07db      	lsls	r3, r3, #31
 8010394:	d4fc      	bmi.n	8010390 <i2c_lld_stop+0x40>
 8010396:	4604      	mov	r4, r0
 8010398:	7a28      	ldrb	r0, [r5, #8]
 801039a:	686a      	ldr	r2, [r5, #4]
 801039c:	233d      	movs	r3, #61	; 0x3d
 801039e:	4083      	lsls	r3, r0
 80103a0:	6013      	str	r3, [r2, #0]

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 80103a2:	4608      	mov	r0, r1
 80103a4:	f7ff f8fc 	bl	800f5a0 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 80103a8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80103aa:	f7ff f8f9 	bl	800f5a0 <dmaStreamRelease>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 80103ae:	4b08      	ldr	r3, [pc, #32]	; (80103d0 <i2c_lld_stop+0x80>)
 80103b0:	429c      	cmp	r4, r3
 80103b2:	d000      	beq.n	80103b6 <i2c_lld_stop+0x66>
      nvicDisableVector(I2C3_ER_IRQn);
      rccDisableI2C3(FALSE);
    }
#endif
  }
}
 80103b4:	bd38      	pop	{r3, r4, r5, pc}
      nvicDisableVector(I2C1_EV_IRQn);
 80103b6:	201f      	movs	r0, #31
 80103b8:	f7fe feda 	bl	800f170 <nvicDisableVector>
      nvicDisableVector(I2C1_ER_IRQn);
 80103bc:	2020      	movs	r0, #32
 80103be:	f7fe fed7 	bl	800f170 <nvicDisableVector>
      rccDisableI2C1(FALSE);
 80103c2:	4a04      	ldr	r2, [pc, #16]	; (80103d4 <i2c_lld_stop+0x84>)
 80103c4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80103c6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80103ca:	6413      	str	r3, [r2, #64]	; 0x40
}
 80103cc:	bd38      	pop	{r3, r4, r5, pc}
 80103ce:	bf00      	nop
 80103d0:	20001d7c 	.word	0x20001d7c
 80103d4:	40023800 	.word	0x40023800
	...

080103e0 <i2c_lld_master_receive_timeout>:

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 1 -> receive.*/
  i2cp->addr = (addr << 1) | 0x01;
 80103e0:	0049      	lsls	r1, r1, #1
                                     systime_t timeout) {
 80103e2:	b4f0      	push	{r4, r5, r6, r7}
  i2cp->addr = (addr << 1) | 0x01;
 80103e4:	f041 0101 	orr.w	r1, r1, #1
  i2cp->errors = I2C_NO_ERROR;
 80103e8:	2500      	movs	r5, #0
  i2cp->addr = (addr << 1) | 0x01;
 80103ea:	8401      	strh	r1, [r0, #32]
  I2C_TypeDef *dp = i2cp->i2c;
 80103ec:	6b44      	ldr	r4, [r0, #52]	; 0x34
  i2cp->errors = I2C_NO_ERROR;
 80103ee:	6085      	str	r5, [r0, #8]
                                     systime_t timeout) {
 80103f0:	f8dd c010 	ldr.w	ip, [sp, #16]
 80103f4:	f385 8811 	msr	BASEPRI, r5

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80103f8:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 80103fa:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80103fc:	6837      	ldr	r7, [r6, #0]
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 80103fe:	4e14      	ldr	r6, [pc, #80]	; (8010450 <i2c_lld_master_receive_timeout+0x70>)
 8010400:	6039      	str	r1, [r7, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8010402:	60fa      	str	r2, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8010404:	607b      	str	r3, [r7, #4]
 8010406:	462a      	mov	r2, r5
 8010408:	6ab7      	ldr	r7, [r6, #40]	; 0x28
 801040a:	2520      	movs	r5, #32
 801040c:	e001      	b.n	8010412 <i2c_lld_master_receive_timeout+0x32>
 801040e:	f382 8811 	msr	BASEPRI, r2
 8010412:	f385 8811 	msr	BASEPRI, r5
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8010416:	69a3      	ldr	r3, [r4, #24]
 8010418:	0799      	lsls	r1, r3, #30
 801041a:	d402      	bmi.n	8010422 <i2c_lld_master_receive_timeout+0x42>
 801041c:	6823      	ldr	r3, [r4, #0]
 801041e:	059b      	lsls	r3, r3, #22
 8010420:	d508      	bpl.n	8010434 <i2c_lld_master_receive_timeout+0x54>
 8010422:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
 8010424:	1bdb      	subs	r3, r3, r7
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8010426:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 801042a:	d3f0      	bcc.n	801040e <i2c_lld_master_receive_timeout+0x2e>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 801042c:	f04f 30ff 	mov.w	r0, #4294967295
 8010430:	bcf0      	pop	{r4, r5, r6, r7}
 8010432:	4770      	bx	lr
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8010434:	6863      	ldr	r3, [r4, #4]
 8010436:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801043a:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 801043c:	6823      	ldr	r3, [r4, #0]
 801043e:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 8010442:	6023      	str	r3, [r4, #0]
  return chThdSuspendTimeoutS(trp, timeout);
 8010444:	4661      	mov	r1, ip
 8010446:	301c      	adds	r0, #28
}
 8010448:	bcf0      	pop	{r4, r5, r6, r7}
 801044a:	f7fd bb11 	b.w	800da70 <chThdSuspendTimeoutS>
 801044e:	bf00      	nop
 8010450:	20001a48 	.word	0x20001a48
	...

08010460 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8010460:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8010464:	0049      	lsls	r1, r1, #1
  i2cp->errors = I2C_NO_ERROR;
 8010466:	2500      	movs	r5, #0
                                      systime_t timeout) {
 8010468:	4616      	mov	r6, r2
  i2cp->addr = (addr << 1);
 801046a:	8401      	strh	r1, [r0, #32]
                                      systime_t timeout) {
 801046c:	469e      	mov	lr, r3
  I2C_TypeDef *dp = i2cp->i2c;
 801046e:	6b44      	ldr	r4, [r0, #52]	; 0x34
  i2cp->errors = I2C_NO_ERROR;
 8010470:	6085      	str	r5, [r0, #8]
                                      systime_t timeout) {
 8010472:	e9dd 2807 	ldrd	r2, r8, [sp, #28]
 8010476:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801047a:	f385 8811 	msr	BASEPRI, r5
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 801047e:	e9d0 710b 	ldrd	r7, r1, [r0, #44]	; 0x2c
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8010482:	6809      	ldr	r1, [r1, #0]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010484:	683f      	ldr	r7, [r7, #0]
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8010486:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8010488:	600b      	str	r3, [r1, #0]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 801048a:	f8d0 9024 	ldr.w	r9, [r0, #36]	; 0x24
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 801048e:	60ce      	str	r6, [r1, #12]
  return ch.vtlist.vt_systime;
 8010490:	4e16      	ldr	r6, [pc, #88]	; (80104ec <i2c_lld_master_transmit_timeout+0x8c>)
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8010492:	f8c1 e004 	str.w	lr, [r1, #4]
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8010496:	f8c7 9000 	str.w	r9, [r7]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 801049a:	60fa      	str	r2, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 801049c:	f8c7 8004 	str.w	r8, [r7, #4]
 80104a0:	462a      	mov	r2, r5
 80104a2:	6ab7      	ldr	r7, [r6, #40]	; 0x28
 80104a4:	2520      	movs	r5, #32
 80104a6:	e001      	b.n	80104ac <i2c_lld_master_transmit_timeout+0x4c>
 80104a8:	f382 8811 	msr	BASEPRI, r2
 80104ac:	f385 8811 	msr	BASEPRI, r5
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 80104b0:	69a3      	ldr	r3, [r4, #24]
 80104b2:	0799      	lsls	r1, r3, #30
 80104b4:	d402      	bmi.n	80104bc <i2c_lld_master_transmit_timeout+0x5c>
 80104b6:	6823      	ldr	r3, [r4, #0]
 80104b8:	059b      	lsls	r3, r3, #22
 80104ba:	d508      	bpl.n	80104ce <i2c_lld_master_transmit_timeout+0x6e>
 80104bc:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  return (bool)((time - start) < (end - start));
 80104be:	1bdb      	subs	r3, r3, r7
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 80104c0:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80104c4:	d3f0      	bcc.n	80104a8 <i2c_lld_master_transmit_timeout+0x48>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 80104c6:	f04f 30ff 	mov.w	r0, #4294967295
 80104ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80104ce:	6863      	ldr	r3, [r4, #4]
 80104d0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80104d4:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START;
 80104d6:	6823      	ldr	r3, [r4, #0]
 80104d8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80104dc:	6023      	str	r3, [r4, #0]
 80104de:	4661      	mov	r1, ip
 80104e0:	301c      	adds	r0, #28
}
 80104e2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80104e6:	f7fd bac3 	b.w	800da70 <chThdSuspendTimeoutS>
 80104ea:	bf00      	nop
 80104ec:	20001a48 	.word	0x20001a48

080104f0 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 80104f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80104f4:	4bb8      	ldr	r3, [pc, #736]	; (80107d8 <usb_lld_pump+0x2e8>)
 80104f6:	49b9      	ldr	r1, [pc, #740]	; (80107dc <usb_lld_pump+0x2ec>)
 80104f8:	699a      	ldr	r2, [r3, #24]
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 80104fa:	6d05      	ldr	r5, [r0, #80]	; 0x50
 80104fc:	6191      	str	r1, [r2, #24]
void usb_lld_pump(void *p) {
 80104fe:	b087      	sub	sp, #28
 8010500:	2320      	movs	r3, #32
 8010502:	f383 8811 	msr	BASEPRI, r3
 8010506:	9300      	str	r3, [sp, #0]
 8010508:	f100 0360 	add.w	r3, r0, #96	; 0x60
 801050c:	46a9      	mov	r9, r5
 801050e:	9305      	str	r3, [sp, #20]
 8010510:	4605      	mov	r5, r0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8010512:	782b      	ldrb	r3, [r5, #0]
 8010514:	2b01      	cmp	r3, #1
 8010516:	d005      	beq.n	8010524 <usb_lld_pump+0x34>
 8010518:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 801051a:	b963      	cbnz	r3, 8010536 <usb_lld_pump+0x46>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 801051c:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8010520:	06db      	lsls	r3, r3, #27
 8010522:	d408      	bmi.n	8010536 <usb_lld_pump+0x46>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8010524:	f8d9 3018 	ldr.w	r3, [r9, #24]
  return chThdSuspendS(trp);
 8010528:	9805      	ldr	r0, [sp, #20]
 801052a:	f043 0310 	orr.w	r3, r3, #16
 801052e:	f8c9 3018 	str.w	r3, [r9, #24]
 8010532:	f7fd fa8d 	bl	800da50 <chThdSuspendS>
 8010536:	2300      	movs	r3, #0
 8010538:	f383 8811 	msr	BASEPRI, r3
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 801053c:	469a      	mov	sl, r3

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 801053e:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8010542:	f013 0310 	ands.w	r3, r3, #16
 8010546:	d058      	beq.n	80105fa <usb_lld_pump+0x10a>
  sts = usbp->otg->GRXSTSP;
 8010548:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 801054a:	6a13      	ldr	r3, [r2, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 801054c:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
 8010550:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8010554:	d024      	beq.n	80105a0 <usb_lld_pump+0xb0>
 8010556:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 801055a:	d1f0      	bne.n	801053e <usb_lld_pump+0x4e>
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 801055c:	f003 010f 	and.w	r1, r3, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8010560:	eb05 0181 	add.w	r1, r5, r1, lsl #2
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8010564:	f3c3 130a 	ubfx	r3, r3, #4, #11
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8010568:	68c9      	ldr	r1, [r1, #12]
  n = (n + 3) / 4;
 801056a:	3303      	adds	r3, #3
  while (n) {
 801056c:	089b      	lsrs	r3, r3, #2
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 801056e:	6a0c      	ldr	r4, [r1, #32]
  while (n) {
 8010570:	d0e5      	beq.n	801053e <usb_lld_pump+0x4e>
 8010572:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  max = (max + 3) / 4;
 8010576:	2102      	movs	r1, #2
    uint32_t w = *fifop;
 8010578:	6816      	ldr	r6, [r2, #0]
 801057a:	1e58      	subs	r0, r3, #1
    if (max) {
 801057c:	b149      	cbz	r1, 8010592 <usb_lld_pump+0xa2>
      max--;
 801057e:	4603      	mov	r3, r0
      *((PACKED_VAR uint32_t *)buf) = w;
 8010580:	f844 6b04 	str.w	r6, [r4], #4
      max--;
 8010584:	3901      	subs	r1, #1
  while (n) {
 8010586:	2b00      	cmp	r3, #0
 8010588:	d0d9      	beq.n	801053e <usb_lld_pump+0x4e>
    uint32_t w = *fifop;
 801058a:	6816      	ldr	r6, [r2, #0]
 801058c:	1e58      	subs	r0, r3, #1
    if (max) {
 801058e:	2900      	cmp	r1, #0
 8010590:	d1f5      	bne.n	801057e <usb_lld_pump+0x8e>
  while (n) {
 8010592:	2800      	cmp	r0, #0
 8010594:	d0d3      	beq.n	801053e <usb_lld_pump+0x4e>
 8010596:	3b02      	subs	r3, #2
    uint32_t w = *fifop;
 8010598:	6810      	ldr	r0, [r2, #0]
  while (n) {
 801059a:	2b00      	cmp	r3, #0
 801059c:	d1f5      	bne.n	801058a <usb_lld_pump+0x9a>
 801059e:	e7ce      	b.n	801053e <usb_lld_pump+0x4e>
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80105a0:	f003 060f 	and.w	r6, r3, #15
 80105a4:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80105a8:	f3c3 140a 	ubfx	r4, r3, #4, #11
    if (usbp->epc[ep]->out_state->rxqueued) {
 80105ac:	68f3      	ldr	r3, [r6, #12]
 80105ae:	699f      	ldr	r7, [r3, #24]
 80105b0:	783b      	ldrb	r3, [r7, #0]
 80105b2:	68f8      	ldr	r0, [r7, #12]
 80105b4:	2b00      	cmp	r3, #0
 80105b6:	d13b      	bne.n	8010630 <usb_lld_pump+0x140>
                              usbp->epc[ep]->out_state->rxcnt);
 80105b8:	e9d7 1c01 	ldrd	r1, ip, [r7, #4]
  max = (max + 3) / 4;
 80105bc:	1cce      	adds	r6, r1, #3
  n = (n + 3) / 4;
 80105be:	1ce1      	adds	r1, r4, #3
  max = (max + 3) / 4;
 80105c0:	eba6 060c 	sub.w	r6, r6, ip
  while (n) {
 80105c4:	0889      	lsrs	r1, r1, #2
  max = (max + 3) / 4;
 80105c6:	ea4f 0696 	mov.w	r6, r6, lsr #2
  while (n) {
 80105ca:	d00d      	beq.n	80105e8 <usb_lld_pump+0xf8>
 80105cc:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80105d0:	4686      	mov	lr, r0
 80105d2:	4690      	mov	r8, r2
    uint32_t w = *fifop;
 80105d4:	f8d8 2000 	ldr.w	r2, [r8]
 80105d8:	1e4b      	subs	r3, r1, #1
    if (max) {
 80105da:	b30e      	cbz	r6, 8010620 <usb_lld_pump+0x130>
      max--;
 80105dc:	4619      	mov	r1, r3
      *((PACKED_VAR uint32_t *)buf) = w;
 80105de:	f84e 2b04 	str.w	r2, [lr], #4
      max--;
 80105e2:	3e01      	subs	r6, #1
  while (n) {
 80105e4:	2900      	cmp	r1, #0
 80105e6:	d1f5      	bne.n	80105d4 <usb_lld_pump+0xe4>
      usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
 80105e8:	4420      	add	r0, r4
 80105ea:	60f8      	str	r0, [r7, #12]
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80105ec:	f8d9 3014 	ldr.w	r3, [r9, #20]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80105f0:	4464      	add	r4, ip
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80105f2:	f013 0310 	ands.w	r3, r3, #16
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80105f6:	60bc      	str	r4, [r7, #8]
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80105f8:	d1a6      	bne.n	8010548 <usb_lld_pump+0x58>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80105fa:	2601      	movs	r6, #1
      if (usbp->txpending & epmask) {
 80105fc:	6dea      	ldr	r2, [r5, #92]	; 0x5c
      epmask = (1 << ep);
 80105fe:	fa06 f60a 	lsl.w	r6, r6, sl
      if (usbp->txpending & epmask) {
 8010602:	4216      	tst	r6, r2
 8010604:	d150      	bne.n	80106a8 <usb_lld_pump+0x1b8>
 8010606:	f10a 0301 	add.w	r3, sl, #1
 801060a:	9302      	str	r3, [sp, #8]
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 801060c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 801060e:	f89d a008 	ldrb.w	sl, [sp, #8]
 8010612:	689b      	ldr	r3, [r3, #8]
 8010614:	459a      	cmp	sl, r3
 8010616:	d992      	bls.n	801053e <usb_lld_pump+0x4e>
 8010618:	9b00      	ldr	r3, [sp, #0]
 801061a:	f383 8811 	msr	BASEPRI, r3
 801061e:	e778      	b.n	8010512 <usb_lld_pump+0x22>
  while (n) {
 8010620:	2b00      	cmp	r3, #0
 8010622:	d0e1      	beq.n	80105e8 <usb_lld_pump+0xf8>
 8010624:	3902      	subs	r1, #2
    uint32_t w = *fifop;
 8010626:	f8d8 3000 	ldr.w	r3, [r8]
  while (n) {
 801062a:	2900      	cmp	r1, #0
 801062c:	d1d2      	bne.n	80105d4 <usb_lld_pump+0xe4>
 801062e:	e7db      	b.n	80105e8 <usb_lld_pump+0xf8>
  while (ntogo > 0) {
 8010630:	b33c      	cbz	r4, 8010682 <usb_lld_pump+0x192>
 8010632:	6941      	ldr	r1, [r0, #20]
 8010634:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8010638:	46a4      	mov	ip, r4
    if (nw > 0) {
 801063a:	f1bc 0f03 	cmp.w	ip, #3
 801063e:	d907      	bls.n	8010650 <usb_lld_pump+0x160>
      if (iqp->q_wrptr >= iqp->q_top) {
 8010640:	6903      	ldr	r3, [r0, #16]
 8010642:	428b      	cmp	r3, r1
 8010644:	d804      	bhi.n	8010650 <usb_lld_pump+0x160>
        iqp->q_wrptr = iqp->q_buffer;
 8010646:	68c1      	ldr	r1, [r0, #12]
 8010648:	6141      	str	r1, [r0, #20]
    if (nw > 0) {
 801064a:	f1bc 0f03 	cmp.w	ip, #3
 801064e:	d8f7      	bhi.n	8010640 <usb_lld_pump+0x150>
    w = *fifop;
 8010650:	f8d2 e000 	ldr.w	lr, [r2]
 8010654:	2300      	movs	r3, #0
      *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
 8010656:	fa2e f703 	lsr.w	r7, lr, r3
 801065a:	f101 0801 	add.w	r8, r1, #1
 801065e:	f8c0 8014 	str.w	r8, [r0, #20]
 8010662:	700f      	strb	r7, [r1, #0]
      if (iqp->q_wrptr >= iqp->q_top)
 8010664:	e9d0 1704 	ldrd	r1, r7, [r0, #16]
 8010668:	428f      	cmp	r7, r1
        iqp->q_wrptr = iqp->q_buffer;
 801066a:	bf24      	itt	cs
 801066c:	68c1      	ldrcs	r1, [r0, #12]
 801066e:	6141      	strcs	r1, [r0, #20]
    while ((ntogo > 0) && (i < 4)) {
 8010670:	f1bc 0c01 	subs.w	ip, ip, #1
 8010674:	f103 0308 	add.w	r3, r3, #8
 8010678:	d003      	beq.n	8010682 <usb_lld_pump+0x192>
 801067a:	2b20      	cmp	r3, #32
 801067c:	6941      	ldr	r1, [r0, #20]
 801067e:	d1ea      	bne.n	8010656 <usb_lld_pump+0x166>
 8010680:	e7db      	b.n	801063a <usb_lld_pump+0x14a>
 8010682:	9b00      	ldr	r3, [sp, #0]
 8010684:	f383 8811 	msr	BASEPRI, r3
  iqp->q_counter += n;
 8010688:	6883      	ldr	r3, [r0, #8]
 801068a:	4423      	add	r3, r4
 801068c:	6083      	str	r3, [r0, #8]
  chThdDequeueAllI(tqp, msg);
 801068e:	2100      	movs	r1, #0
 8010690:	f7fd fa26 	bl	800dae0 <chThdDequeueAllI>
  chSchRescheduleS();
 8010694:	f7fd f8f4 	bl	800d880 <chSchRescheduleS>
 8010698:	2300      	movs	r3, #0
 801069a:	f383 8811 	msr	BASEPRI, r3
 801069e:	68f3      	ldr	r3, [r6, #12]
 80106a0:	699f      	ldr	r7, [r3, #24]
 80106a2:	f8d7 c008 	ldr.w	ip, [r7, #8]
 80106a6:	e7a1      	b.n	80105ec <usb_lld_pump+0xfc>
 80106a8:	9a00      	ldr	r2, [sp, #0]
 80106aa:	f382 8811 	msr	BASEPRI, r2
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80106ae:	f8d9 1008 	ldr.w	r1, [r9, #8]
        usbp->txpending &= ~epmask;
 80106b2:	6dea      	ldr	r2, [r5, #92]	; 0x5c
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80106b4:	f021 0101 	bic.w	r1, r1, #1
        usbp->txpending &= ~epmask;
 80106b8:	ea22 0206 	bic.w	r2, r2, r6
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80106bc:	f8c9 1008 	str.w	r1, [r9, #8]
        usbp->txpending &= ~epmask;
 80106c0:	65ea      	str	r2, [r5, #92]	; 0x5c
 80106c2:	f383 8811 	msr	BASEPRI, r3
 80106c6:	eb05 038a 	add.w	r3, r5, sl, lsl #2
 80106ca:	461f      	mov	r7, r3
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80106cc:	68d9      	ldr	r1, [r3, #12]
 80106ce:	694a      	ldr	r2, [r1, #20]
 80106d0:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
 80106d4:	4298      	cmp	r0, r3
 80106d6:	f080 80b6 	bcs.w	8010846 <usb_lld_pump+0x356>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80106da:	f8d5 e050 	ldr.w	lr, [r5, #80]	; 0x50
    if (n > usbp->epc[ep]->in_maxsize)
 80106de:	8a0c      	ldrh	r4, [r1, #16]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80106e0:	ea4f 184a 	mov.w	r8, sl, lsl #5
 80106e4:	eb0e 0c08 	add.w	ip, lr, r8
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80106e8:	1a1b      	subs	r3, r3, r0
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80106ea:	f8dc 0918 	ldr.w	r0, [ip, #2328]	; 0x918
 80106ee:	429c      	cmp	r4, r3
 80106f0:	bf28      	it	cs
 80106f2:	461c      	movcs	r4, r3
 80106f4:	b283      	uxth	r3, r0
 80106f6:	ebb4 0f83 	cmp.w	r4, r3, lsl #2
 80106fa:	f200 80b1 	bhi.w	8010860 <usb_lld_pump+0x370>
 80106fe:	f10a 0301 	add.w	r3, sl, #1
 8010702:	9302      	str	r3, [sp, #8]
 8010704:	031b      	lsls	r3, r3, #12
 8010706:	e9cd 9603 	strd	r9, r6, [sp, #12]
 801070a:	9301      	str	r3, [sp, #4]
 801070c:	46b9      	mov	r9, r7
 801070e:	9e01      	ldr	r6, [sp, #4]
    if (usbp->epc[ep]->in_state->txqueued) {
 8010710:	7813      	ldrb	r3, [r2, #0]
 8010712:	68d0      	ldr	r0, [r2, #12]
 8010714:	44b6      	add	lr, r6
 8010716:	2b00      	cmp	r3, #0
 8010718:	d07e      	beq.n	8010818 <usb_lld_pump+0x328>
  while (ntogo > 0) {
 801071a:	b1fc      	cbz	r4, 801075c <usb_lld_pump+0x26c>
 801071c:	f8d0 b010 	ldr.w	fp, [r0, #16]
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 8010720:	4622      	mov	r2, r4
    if (nw > 0) {
 8010722:	0897      	lsrs	r7, r2, #2
 8010724:	6983      	ldr	r3, [r0, #24]
 8010726:	d05e      	beq.n	80107e6 <usb_lld_pump+0x2f6>
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 8010728:	ebbb 0103 	subs.w	r1, fp, r3
 801072c:	bf48      	it	mi
 801072e:	3103      	addmi	r1, #3
 8010730:	108e      	asrs	r6, r1, #2
      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
 8010732:	42be      	cmp	r6, r7
 8010734:	bf28      	it	cs
 8010736:	463e      	movcs	r6, r7
 8010738:	00b1      	lsls	r1, r6, #2
 801073a:	1a52      	subs	r2, r2, r1
  while (n > 0) {
 801073c:	2e00      	cmp	r6, #0
 801073e:	d07c      	beq.n	801083a <usb_lld_pump+0x34a>
 8010740:	4419      	add	r1, r3
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8010742:	f853 6b04 	ldr.w	r6, [r3], #4
 8010746:	f8ce 6000 	str.w	r6, [lr]
  while (n > 0) {
 801074a:	428b      	cmp	r3, r1
 801074c:	d1f9      	bne.n	8010742 <usb_lld_pump+0x252>
      if (oqp->q_rdptr >= oqp->q_top) {
 801074e:	4559      	cmp	r1, fp
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
 8010750:	6181      	str	r1, [r0, #24]
      if (oqp->q_rdptr >= oqp->q_top) {
 8010752:	d345      	bcc.n	80107e0 <usb_lld_pump+0x2f0>
        oqp->q_rdptr = oqp->q_buffer;
 8010754:	68c3      	ldr	r3, [r0, #12]
 8010756:	6183      	str	r3, [r0, #24]
  while (ntogo > 0) {
 8010758:	2a00      	cmp	r2, #0
 801075a:	d1e2      	bne.n	8010722 <usb_lld_pump+0x232>
 801075c:	9b00      	ldr	r3, [sp, #0]
 801075e:	f383 8811 	msr	BASEPRI, r3
  oqp->q_counter += n;
 8010762:	6883      	ldr	r3, [r0, #8]
 8010764:	4423      	add	r3, r4
 8010766:	6083      	str	r3, [r0, #8]
  chThdDequeueAllI(tqp, msg);
 8010768:	2100      	movs	r1, #0
 801076a:	f7fd f9b9 	bl	800dae0 <chThdDequeueAllI>
  chSchRescheduleS();
 801076e:	f7fd f887 	bl	800d880 <chSchRescheduleS>
 8010772:	2300      	movs	r3, #0
 8010774:	f383 8811 	msr	BASEPRI, r3
 8010778:	f8d9 100c 	ldr.w	r1, [r9, #12]
    usbp->epc[ep]->in_state->txcnt += n;
 801077c:	694a      	ldr	r2, [r1, #20]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 801077e:	e9d2 0301 	ldrd	r0, r3, [r2, #4]
    usbp->epc[ep]->in_state->txcnt += n;
 8010782:	441c      	add	r4, r3
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8010784:	42a0      	cmp	r0, r4
    usbp->epc[ep]->in_state->txcnt += n;
 8010786:	6094      	str	r4, [r2, #8]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8010788:	d959      	bls.n	801083e <usb_lld_pump+0x34e>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 801078a:	f8d5 e050 	ldr.w	lr, [r5, #80]	; 0x50
    if (n > usbp->epc[ep]->in_maxsize)
 801078e:	f8b1 c010 	ldrh.w	ip, [r1, #16]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8010792:	eb0e 0a08 	add.w	sl, lr, r8
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8010796:	1b04      	subs	r4, r0, r4
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8010798:	f8da 3918 	ldr.w	r3, [sl, #2328]	; 0x918
 801079c:	4564      	cmp	r4, ip
 801079e:	bf28      	it	cs
 80107a0:	4664      	movcs	r4, ip
 80107a2:	b29b      	uxth	r3, r3
 80107a4:	ebb4 0f83 	cmp.w	r4, r3, lsl #2
 80107a8:	d9b1      	bls.n	801070e <usb_lld_pump+0x21e>
 80107aa:	e9dd 9603 	ldrd	r9, r6, [sp, #12]
      return FALSE;
 80107ae:	2200      	movs	r2, #0
 80107b0:	9b00      	ldr	r3, [sp, #0]
 80107b2:	f383 8811 	msr	BASEPRI, r3
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80107b6:	f8d9 3008 	ldr.w	r3, [r9, #8]
 80107ba:	f043 0301 	orr.w	r3, r3, #1
 80107be:	f8c9 3008 	str.w	r3, [r9, #8]
        if (!done)
 80107c2:	b922      	cbnz	r2, 80107ce <usb_lld_pump+0x2de>
          otgp->DIEPEMPMSK |= epmask;
 80107c4:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
 80107c8:	431e      	orrs	r6, r3
 80107ca:	f8c9 6834 	str.w	r6, [r9, #2100]	; 0x834
 80107ce:	2300      	movs	r3, #0
 80107d0:	f383 8811 	msr	BASEPRI, r3
 80107d4:	e71a      	b.n	801060c <usb_lld_pump+0x11c>
 80107d6:	bf00      	nop
 80107d8:	20001a48 	.word	0x20001a48
 80107dc:	0802dac0 	.word	0x0802dac0
    if (ntogo <= 0)
 80107e0:	2a00      	cmp	r2, #0
 80107e2:	d0bb      	beq.n	801075c <usb_lld_pump+0x26c>
 80107e4:	460b      	mov	r3, r1
 80107e6:	2100      	movs	r1, #0
 80107e8:	460e      	mov	r6, r1
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 80107ea:	1c5f      	adds	r7, r3, #1
 80107ec:	6187      	str	r7, [r0, #24]
 80107ee:	781b      	ldrb	r3, [r3, #0]
      if (oqp->q_rdptr >= oqp->q_top)
 80107f0:	455f      	cmp	r7, fp
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 80107f2:	fa03 f301 	lsl.w	r3, r3, r1
 80107f6:	ea46 0603 	orr.w	r6, r6, r3
        oqp->q_rdptr = oqp->q_buffer;
 80107fa:	bf24      	itt	cs
 80107fc:	68c3      	ldrcs	r3, [r0, #12]
 80107fe:	6183      	strcs	r3, [r0, #24]
    while ((ntogo > 0) && (i < 4)) {
 8010800:	3a01      	subs	r2, #1
 8010802:	d004      	beq.n	801080e <usb_lld_pump+0x31e>
 8010804:	2918      	cmp	r1, #24
 8010806:	d002      	beq.n	801080e <usb_lld_pump+0x31e>
 8010808:	3108      	adds	r1, #8
 801080a:	6983      	ldr	r3, [r0, #24]
 801080c:	e7ed      	b.n	80107ea <usb_lld_pump+0x2fa>
    *fifop = w;
 801080e:	f8ce 6000 	str.w	r6, [lr]
  while (ntogo > 0) {
 8010812:	2a00      	cmp	r2, #0
 8010814:	d185      	bne.n	8010722 <usb_lld_pump+0x232>
 8010816:	e7a1      	b.n	801075c <usb_lld_pump+0x26c>
  otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
 8010818:	1ce3      	adds	r3, r4, #3
  while (n > 0) {
 801081a:	089b      	lsrs	r3, r3, #2
 801081c:	d00a      	beq.n	8010834 <usb_lld_pump+0x344>
 801081e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 8010822:	4603      	mov	r3, r0
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8010824:	f853 6b04 	ldr.w	r6, [r3], #4
 8010828:	f8ce 6000 	str.w	r6, [lr]
  while (n > 0) {
 801082c:	428b      	cmp	r3, r1
 801082e:	d1f9      	bne.n	8010824 <usb_lld_pump+0x334>
 8010830:	f8d9 100c 	ldr.w	r1, [r9, #12]
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
 8010834:	4420      	add	r0, r4
 8010836:	60d0      	str	r0, [r2, #12]
 8010838:	e7a0      	b.n	801077c <usb_lld_pump+0x28c>
  while (n > 0) {
 801083a:	4619      	mov	r1, r3
 801083c:	e787      	b.n	801074e <usb_lld_pump+0x25e>
 801083e:	e9dd 9603 	ldrd	r9, r6, [sp, #12]
      return TRUE;
 8010842:	2201      	movs	r2, #1
 8010844:	e7b4      	b.n	80107b0 <usb_lld_pump+0x2c0>
 8010846:	9b00      	ldr	r3, [sp, #0]
 8010848:	f383 8811 	msr	BASEPRI, r3
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 801084c:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8010850:	f10a 0201 	add.w	r2, sl, #1
 8010854:	f043 0301 	orr.w	r3, r3, #1
 8010858:	9202      	str	r2, [sp, #8]
 801085a:	f8c9 3008 	str.w	r3, [r9, #8]
 801085e:	e7b6      	b.n	80107ce <usb_lld_pump+0x2de>
 8010860:	9b00      	ldr	r3, [sp, #0]
 8010862:	f383 8811 	msr	BASEPRI, r3
 8010866:	f8d9 3008 	ldr.w	r3, [r9, #8]
 801086a:	f10a 0201 	add.w	r2, sl, #1
 801086e:	f043 0301 	orr.w	r3, r3, #1
 8010872:	9202      	str	r2, [sp, #8]
 8010874:	f8c9 3008 	str.w	r3, [r9, #8]
 8010878:	e7a4      	b.n	80107c4 <usb_lld_pump+0x2d4>
 801087a:	bf00      	nop
 801087c:	0000      	movs	r0, r0
	...

08010880 <otg_disable_ep.isra.0>:
static void otg_disable_ep(USBDriver *usbp) {
 8010880:	688b      	ldr	r3, [r1, #8]
 8010882:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8010884:	2400      	movs	r4, #0
 8010886:	f103 0c01 	add.w	ip, r3, #1
      otgp->ie[i].DIEPCTL = 0;
 801088a:	4625      	mov	r5, r4
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 801088c:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8010890:	f04f 36ff 	mov.w	r6, #4294967295
 8010894:	e014      	b.n	80108c0 <otg_disable_ep.isra.0+0x40>
      otgp->ie[i].DIEPCTL = 0;
 8010896:	f8c2 5900 	str.w	r5, [r2, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 801089a:	18c1      	adds	r1, r0, r3
 801089c:	f8c1 5910 	str.w	r5, [r1, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80108a0:	f8c1 6908 	str.w	r6, [r1, #2312]	; 0x908
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
 80108a4:	f8d2 7b00 	ldr.w	r7, [r2, #2816]	; 0xb00
 80108a8:	2f00      	cmp	r7, #0
 80108aa:	db17      	blt.n	80108dc <otg_disable_ep.isra.0+0x5c>
      otgp->oe[i].DOEPCTL = 0;
 80108ac:	f8c2 5b00 	str.w	r5, [r2, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 80108b0:	4403      	add	r3, r0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80108b2:	3401      	adds	r4, #1
 80108b4:	4564      	cmp	r4, ip
    otgp->oe[i].DOEPTSIZ = 0;
 80108b6:	f8c3 5b10 	str.w	r5, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80108ba:	f8c3 6b08 	str.w	r6, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80108be:	d014      	beq.n	80108ea <otg_disable_ep.isra.0+0x6a>
 80108c0:	0163      	lsls	r3, r4, #5
 80108c2:	18c2      	adds	r2, r0, r3
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
 80108c4:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 80108c8:	2900      	cmp	r1, #0
 80108ca:	dae4      	bge.n	8010896 <otg_disable_ep.isra.0+0x16>
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 80108cc:	f8c2 e900 	str.w	lr, [r2, #2304]	; 0x900
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
 80108d0:	4617      	mov	r7, r2
 80108d2:	f8d7 1908 	ldr.w	r1, [r7, #2312]	; 0x908
 80108d6:	0789      	lsls	r1, r1, #30
 80108d8:	d5fb      	bpl.n	80108d2 <otg_disable_ep.isra.0+0x52>
 80108da:	e7de      	b.n	801089a <otg_disable_ep.isra.0+0x1a>
      otgp->oe[i].DOEPCTL = DOEPCTL_EPDIS;
 80108dc:	f8c2 eb00 	str.w	lr, [r2, #2816]	; 0xb00
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
 80108e0:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
 80108e4:	06d2      	lsls	r2, r2, #27
 80108e6:	d5fb      	bpl.n	80108e0 <otg_disable_ep.isra.0+0x60>
 80108e8:	e7e2      	b.n	80108b0 <otg_disable_ep.isra.0+0x30>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80108ea:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80108ee:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 80108f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08010900 <usb_lld_init>:
void usb_lld_init(void) {
 8010900:	b510      	push	{r4, lr}
  usbObjectInit(&USBD1);
 8010902:	4c06      	ldr	r4, [pc, #24]	; (801091c <usb_lld_init+0x1c>)
 8010904:	4620      	mov	r0, r4
 8010906:	f7fe f8fb 	bl	800eb00 <usbObjectInit>
  USBD1.otg       = OTG_FS;
 801090a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
 801090e:	4a04      	ldr	r2, [pc, #16]	; (8010920 <usb_lld_init+0x20>)
  USBD1.otg       = OTG_FS;
 8010910:	6523      	str	r3, [r4, #80]	; 0x50
  USBD1.wait      = NULL;
 8010912:	2300      	movs	r3, #0
  USBD1.otgparams = &fsparams;
 8010914:	6562      	str	r2, [r4, #84]	; 0x54
  USBD1.tr = NULL;
 8010916:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 801091a:	bd10      	pop	{r4, pc}
 801091c:	20001db8 	.word	0x20001db8
 8010920:	0802dab0 	.word	0x0802dab0
	...

08010930 <usb_lld_start>:
  if (usbp->state == USB_STOP) {
 8010930:	7803      	ldrb	r3, [r0, #0]
 8010932:	2b01      	cmp	r3, #1
 8010934:	d000      	beq.n	8010938 <usb_lld_start+0x8>
 8010936:	4770      	bx	lr
void usb_lld_start(USBDriver *usbp) {
 8010938:	b570      	push	{r4, r5, r6, lr}
    if (&USBD1 == usbp) {
 801093a:	4b31      	ldr	r3, [pc, #196]	; (8010a00 <usb_lld_start+0xd0>)
  stm32_otg_t *otgp = usbp->otg;
 801093c:	6d06      	ldr	r6, [r0, #80]	; 0x50
    if (&USBD1 == usbp) {
 801093e:	4298      	cmp	r0, r3
void usb_lld_start(USBDriver *usbp) {
 8010940:	b082      	sub	sp, #8
 8010942:	4605      	mov	r5, r0
    if (&USBD1 == usbp) {
 8010944:	d03b      	beq.n	80109be <usb_lld_start+0x8e>
  stm32_otg_t *otgp = usbp->otg;
 8010946:	4634      	mov	r4, r6
    usbp->txpending = 0;
 8010948:	2300      	movs	r3, #0
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 801094a:	4a2e      	ldr	r2, [pc, #184]	; (8010a04 <usb_lld_start+0xd4>)
    usbp->txpending = 0;
 801094c:	65eb      	str	r3, [r5, #92]	; 0x5c
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 801094e:	492e      	ldr	r1, [pc, #184]	; (8010a08 <usb_lld_start+0xd8>)
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 8010950:	60f2      	str	r2, [r6, #12]
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 8010952:	f44f 1234 	mov.w	r2, #2949120	; 0x2d0000
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8010956:	f8c6 1800 	str.w	r1, [r6, #2048]	; 0x800
  chSysPolledDelayX(cycles);
 801095a:	2020      	movs	r0, #32
    otgp->PCGCCTL = 0;
 801095c:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
 8010960:	63b2      	str	r2, [r6, #56]	; 0x38
 8010962:	f7fc fe0d 	bl	800d580 <chSysPolledDelayX>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8010966:	2301      	movs	r3, #1
 8010968:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 801096a:	6923      	ldr	r3, [r4, #16]
 801096c:	07db      	lsls	r3, r3, #31
 801096e:	d4fc      	bmi.n	801096a <usb_lld_start+0x3a>
 8010970:	200c      	movs	r0, #12
 8010972:	f7fc fe05 	bl	800d580 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8010976:	6923      	ldr	r3, [r4, #16]
 8010978:	2b00      	cmp	r3, #0
 801097a:	dafc      	bge.n	8010976 <usb_lld_start+0x46>
    otgp->GAHBCFG = 0;
 801097c:	2400      	movs	r4, #0
 801097e:	60b4      	str	r4, [r6, #8]
    otg_disable_ep(usbp);
 8010980:	e9d5 0114 	ldrd	r0, r1, [r5, #80]	; 0x50
 8010984:	f7ff ff7c 	bl	8010880 <otg_disable_ep.isra.0>
    if (usbp->config->sof_cb == NULL)
 8010988:	686b      	ldr	r3, [r5, #4]
    otgp->DIEPMSK  = 0;
 801098a:	f8c6 4810 	str.w	r4, [r6, #2064]	; 0x810
    if (usbp->config->sof_cb == NULL)
 801098e:	68db      	ldr	r3, [r3, #12]
    otgp->DOEPMSK  = 0;
 8010990:	f8c6 4814 	str.w	r4, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8010994:	f8c6 481c 	str.w	r4, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8010998:	b16b      	cbz	r3, 80109b6 <usb_lld_start+0x86>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 801099a:	f243 0308 	movw	r3, #12296	; 0x3008
 801099e:	61b3      	str	r3, [r6, #24]
    if (usbp->tr == NULL) {
 80109a0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
 80109a2:	f04f 32ff 	mov.w	r2, #4294967295
 80109a6:	6172      	str	r2, [r6, #20]
    if (usbp->tr == NULL) {
 80109a8:	b1d3      	cbz	r3, 80109e0 <usb_lld_start+0xb0>
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80109aa:	68b3      	ldr	r3, [r6, #8]
 80109ac:	f043 0301 	orr.w	r3, r3, #1
 80109b0:	60b3      	str	r3, [r6, #8]
}
 80109b2:	b002      	add	sp, #8
 80109b4:	bd70      	pop	{r4, r5, r6, pc}
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 80109b6:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80109ba:	61b3      	str	r3, [r6, #24]
 80109bc:	e7f0      	b.n	80109a0 <usb_lld_start+0x70>
      rccEnableOTG_FS(FALSE);
 80109be:	4b13      	ldr	r3, [pc, #76]	; (8010a0c <usb_lld_start+0xdc>)
 80109c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80109c2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80109c6:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 80109c8:	695a      	ldr	r2, [r3, #20]
 80109ca:	2000      	movs	r0, #0
 80109cc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80109d0:	615a      	str	r2, [r3, #20]
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 80109d2:	210e      	movs	r1, #14
      rccResetOTG_FS();
 80109d4:	6158      	str	r0, [r3, #20]
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 80109d6:	2043      	movs	r0, #67	; 0x43
 80109d8:	f7fe fbaa 	bl	800f130 <nvicEnableVector>
 80109dc:	6d2c      	ldr	r4, [r5, #80]	; 0x50
 80109de:	e7b3      	b.n	8010948 <usb_lld_start+0x18>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 80109e0:	4b0b      	ldr	r3, [pc, #44]	; (8010a10 <usb_lld_start+0xe0>)
 80109e2:	9500      	str	r5, [sp, #0]
 80109e4:	2202      	movs	r2, #2
 80109e6:	f44f 7106 	mov.w	r1, #536	; 0x218
 80109ea:	f105 0068 	add.w	r0, r5, #104	; 0x68
 80109ee:	f7fc ff8f 	bl	800d910 <chThdCreateI>
 80109f2:	6668      	str	r0, [r5, #100]	; 0x64
  return chSchReadyI(tp);
 80109f4:	f7fc fe64 	bl	800d6c0 <chSchReadyI>
      chSchRescheduleS();
 80109f8:	f7fc ff42 	bl	800d880 <chSchRescheduleS>
 80109fc:	e7d5      	b.n	80109aa <usb_lld_start+0x7a>
 80109fe:	bf00      	nop
 8010a00:	20001db8 	.word	0x20001db8
 8010a04:	40001440 	.word	0x40001440
 8010a08:	02200003 	.word	0x02200003
 8010a0c:	40023800 	.word	0x40023800
 8010a10:	080104f1 	.word	0x080104f1
	...

08010a20 <usb_lld_stop>:
void usb_lld_stop(USBDriver *usbp) {
 8010a20:	b538      	push	{r3, r4, r5, lr}
  if (usbp->state != USB_STOP) {
 8010a22:	7803      	ldrb	r3, [r0, #0]
 8010a24:	2b01      	cmp	r3, #1
 8010a26:	d00e      	beq.n	8010a46 <usb_lld_stop+0x26>
    otg_disable_ep(usbp);
 8010a28:	e9d0 5114 	ldrd	r5, r1, [r0, #80]	; 0x50
 8010a2c:	4604      	mov	r4, r0
 8010a2e:	4628      	mov	r0, r5
 8010a30:	f7ff ff26 	bl	8010880 <otg_disable_ep.isra.0>
    if (&USBD1 == usbp) {
 8010a34:	4a09      	ldr	r2, [pc, #36]	; (8010a5c <usb_lld_stop+0x3c>)
    usbp->txpending = 0;
 8010a36:	2300      	movs	r3, #0
    if (&USBD1 == usbp) {
 8010a38:	4294      	cmp	r4, r2
    usbp->txpending = 0;
 8010a3a:	65e3      	str	r3, [r4, #92]	; 0x5c
    otgp->DAINTMSK   = 0;
 8010a3c:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
    otgp->GAHBCFG    = 0;
 8010a40:	60ab      	str	r3, [r5, #8]
    otgp->GCCFG      = 0;
 8010a42:	63ab      	str	r3, [r5, #56]	; 0x38
    if (&USBD1 == usbp) {
 8010a44:	d000      	beq.n	8010a48 <usb_lld_stop+0x28>
}
 8010a46:	bd38      	pop	{r3, r4, r5, pc}
      nvicDisableVector(STM32_OTG1_NUMBER);
 8010a48:	2043      	movs	r0, #67	; 0x43
 8010a4a:	f7fe fb91 	bl	800f170 <nvicDisableVector>
      rccDisableOTG_FS(FALSE);
 8010a4e:	4a04      	ldr	r2, [pc, #16]	; (8010a60 <usb_lld_stop+0x40>)
 8010a50:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8010a52:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8010a56:	6353      	str	r3, [r2, #52]	; 0x34
}
 8010a58:	bd38      	pop	{r3, r4, r5, pc}
 8010a5a:	bf00      	nop
 8010a5c:	20001db8 	.word	0x20001db8
 8010a60:	40023800 	.word	0x40023800
	...

08010a70 <usb_lld_reset>:
void usb_lld_reset(USBDriver *usbp) {
 8010a70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010a72:	6d05      	ldr	r5, [r0, #80]	; 0x50
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010a74:	2320      	movs	r3, #32
void usb_lld_reset(USBDriver *usbp) {
 8010a76:	4606      	mov	r6, r0
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010a78:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8010a7a:	692c      	ldr	r4, [r5, #16]
 8010a7c:	f014 0420 	ands.w	r4, r4, #32
 8010a80:	d1fb      	bne.n	8010a7a <usb_lld_reset+0xa>
 8010a82:	200c      	movs	r0, #12
 8010a84:	f7fc fd7c 	bl	800d580 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8010a88:	6d77      	ldr	r7, [r6, #84]	; 0x54
 8010a8a:	68ba      	ldr	r2, [r7, #8]
 8010a8c:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8010a8e:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8010a92:	1c54      	adds	r4, r2, #1
    otgp->ie[i].DIEPINT = 0xFF;
 8010a94:	21ff      	movs	r1, #255	; 0xff
 8010a96:	eb05 1243 	add.w	r2, r5, r3, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8010a9a:	3301      	adds	r3, #1
 8010a9c:	429c      	cmp	r4, r3
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8010a9e:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8010aa2:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 8010aa6:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 8010aaa:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8010aae:	d1f2      	bne.n	8010a96 <usb_lld_reset+0x26>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8010ab0:	683b      	ldr	r3, [r7, #0]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8010ab2:	f04f 1201 	mov.w	r2, #65537	; 0x10001
  otgp->DAINT = 0xFFFFFFFF;
 8010ab6:	f04f 31ff 	mov.w	r1, #4294967295
 8010aba:	f8c5 1818 	str.w	r1, [r5, #2072]	; 0x818
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8010abe:	f8c5 281c 	str.w	r2, [r5, #2076]	; 0x81c
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8010ac2:	65b3      	str	r3, [r6, #88]	; 0x58
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8010ac4:	683b      	ldr	r3, [r7, #0]
 8010ac6:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8010ac8:	626b      	str	r3, [r5, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8010aca:	2310      	movs	r3, #16
 8010acc:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8010ace:	6914      	ldr	r4, [r2, #16]
 8010ad0:	f014 0410 	ands.w	r4, r4, #16
 8010ad4:	d1fb      	bne.n	8010ace <usb_lld_reset+0x5e>
 8010ad6:	200c      	movs	r0, #12
 8010ad8:	f7fc fd52 	bl	800d580 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8010adc:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8010ae0:	4a10      	ldr	r2, [pc, #64]	; (8010b24 <usb_lld_reset+0xb4>)
  usbp->epc[0] = &ep0config;
 8010ae2:	4911      	ldr	r1, [pc, #68]	; (8010b28 <usb_lld_reset+0xb8>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8010ae4:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8010ae8:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8010aec:	69ab      	ldr	r3, [r5, #24]
 8010aee:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8010af2:	f043 0310 	orr.w	r3, r3, #16
 8010af6:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8010af8:	2309      	movs	r3, #9
 8010afa:	f8c5 3810 	str.w	r3, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8010afe:	f8c5 3814 	str.w	r3, [r5, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 8010b02:	60f1      	str	r1, [r6, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8010b04:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8010b08:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8010b0c:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8010b10:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
  next = usbp->pmnext;
 8010b14:	6db3      	ldr	r3, [r6, #88]	; 0x58
  usbp->pmnext += size;
 8010b16:	f103 0210 	add.w	r2, r3, #16
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8010b1a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  usbp->pmnext += size;
 8010b1e:	65b2      	str	r2, [r6, #88]	; 0x58
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8010b20:	62ab      	str	r3, [r5, #40]	; 0x28
}
 8010b22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010b24:	10008040 	.word	0x10008040
 8010b28:	0802da80 	.word	0x0802da80
 8010b2c:	00000000 	.word	0x00000000

08010b30 <usb_lld_set_address>:
  stm32_otg_t *otgp = usbp->otg;
 8010b30:	6d02      	ldr	r2, [r0, #80]	; 0x50
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8010b32:	f890 104e 	ldrb.w	r1, [r0, #78]	; 0x4e
 8010b36:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 8010b3a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8010b3e:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8010b42:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
}
 8010b46:	4770      	bx	lr
	...

08010b50 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8010b50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010b54:	fa0f f881 	sxth.w	r8, r1
 8010b58:	eb00 0788 	add.w	r7, r0, r8, lsl #2
 8010b5c:	460d      	mov	r5, r1
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8010b5e:	68fb      	ldr	r3, [r7, #12]
 8010b60:	681a      	ldr	r2, [r3, #0]
 8010b62:	f002 0203 	and.w	r2, r2, #3
 8010b66:	2a02      	cmp	r2, #2
 8010b68:	f000 8097 	beq.w	8010c9a <usb_lld_init_endpoint+0x14a>
 8010b6c:	2a03      	cmp	r2, #3
 8010b6e:	f000 8091 	beq.w	8010c94 <usb_lld_init_endpoint+0x144>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8010b72:	4c4b      	ldr	r4, [pc, #300]	; (8010ca0 <usb_lld_init_endpoint+0x150>)
 8010b74:	494b      	ldr	r1, [pc, #300]	; (8010ca4 <usb_lld_init_endpoint+0x154>)
 8010b76:	2a01      	cmp	r2, #1
 8010b78:	bf0c      	ite	eq
 8010b7a:	46a1      	moveq	r9, r4
 8010b7c:	4689      	movne	r9, r1
  stm32_otg_t *otgp = usbp->otg;
 8010b7e:	6d04      	ldr	r4, [r0, #80]	; 0x50
  if (usbp->epc[ep]->out_cb != NULL) {
 8010b80:	68de      	ldr	r6, [r3, #12]
  otgp->oe[ep].DOEPTSIZ = 0;
 8010b82:	0169      	lsls	r1, r5, #5
 8010b84:	1862      	adds	r2, r4, r1
 8010b86:	f04f 0c00 	mov.w	ip, #0
 8010b8a:	f8c2 cb10 	str.w	ip, [r2, #2832]	; 0xb10
 8010b8e:	f105 0210 	add.w	r2, r5, #16
 8010b92:	f04f 0c01 	mov.w	ip, #1
 8010b96:	fa0c f202 	lsl.w	r2, ip, r2
  if (usbp->epc[ep]->out_cb != NULL) {
 8010b9a:	2e00      	cmp	r6, #0
 8010b9c:	d04b      	beq.n	8010c36 <usb_lld_init_endpoint+0xe6>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8010b9e:	f8b3 c012 	ldrh.w	ip, [r3, #18]
 8010ba2:	f105 0658 	add.w	r6, r5, #88	; 0x58
 8010ba6:	0176      	lsls	r6, r6, #5
 8010ba8:	ea4c 0c09 	orr.w	ip, ip, r9
 8010bac:	f844 c006 	str.w	ip, [r4, r6]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8010bb0:	f8d4 681c 	ldr.w	r6, [r4, #2076]	; 0x81c
 8010bb4:	4332      	orrs	r2, r6
 8010bb6:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 8010bba:	1866      	adds	r6, r4, r1
  if (usbp->epc[ep]->in_cb != NULL) {
 8010bbc:	f8d3 c008 	ldr.w	ip, [r3, #8]
  otgp->ie[ep].DIEPTSIZ = 0;
 8010bc0:	2200      	movs	r2, #0
 8010bc2:	01a9      	lsls	r1, r5, #6
 8010bc4:	f8c6 2910 	str.w	r2, [r6, #2320]	; 0x910
 8010bc8:	f041 0120 	orr.w	r1, r1, #32
 8010bcc:	1e6a      	subs	r2, r5, #1
  if (usbp->epc[ep]->in_cb != NULL) {
 8010bce:	f1bc 0f00 	cmp.w	ip, #0
 8010bd2:	d03f      	beq.n	8010c54 <usb_lld_init_endpoint+0x104>
    if (usbp->epc[ep]->in_multiplier > 1)
 8010bd4:	f8b3 c01c 	ldrh.w	ip, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8010bd8:	8a1e      	ldrh	r6, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8010bda:	f1bc 0f01 	cmp.w	ip, #1
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8010bde:	ea4f 0396 	mov.w	r3, r6, lsr #2
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010be2:	f102 0240 	add.w	r2, r2, #64	; 0x40
  next = usbp->pmnext;
 8010be6:	6d86      	ldr	r6, [r0, #88]	; 0x58
      fsize *= usbp->epc[ep]->in_multiplier;
 8010be8:	bf88      	it	hi
 8010bea:	fb0c f303 	mulhi.w	r3, ip, r3
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010bee:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  usbp->pmnext += size;
 8010bf2:	eb03 0c06 	add.w	ip, r3, r6
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010bf6:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
  usbp->pmnext += size;
 8010bfa:	f8c0 c058 	str.w	ip, [r0, #88]	; 0x58
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8010bfe:	6053      	str	r3, [r2, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010c00:	6121      	str	r1, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8010c02:	6923      	ldr	r3, [r4, #16]
 8010c04:	069a      	lsls	r2, r3, #26
 8010c06:	d4fc      	bmi.n	8010c02 <usb_lld_init_endpoint+0xb2>
 8010c08:	200c      	movs	r0, #12
 8010c0a:	f7fc fcb9 	bl	800d580 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8010c0e:	68fb      	ldr	r3, [r7, #12]
 8010c10:	8a1a      	ldrh	r2, [r3, #16]
    otgp->ie[ep].DIEPCTL = ctl |
 8010c12:	f105 0348 	add.w	r3, r5, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 8010c16:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 8010c1a:	015b      	lsls	r3, r3, #5
                           DIEPCTL_TXFNUM(ep) |
 8010c1c:	ea42 0209 	orr.w	r2, r2, r9
    otgp->ie[ep].DIEPCTL = ctl |
 8010c20:	50e2      	str	r2, [r4, r3]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8010c22:	2101      	movs	r1, #1
 8010c24:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 8010c28:	fa01 f505 	lsl.w	r5, r1, r5
 8010c2c:	431d      	orrs	r5, r3
 8010c2e:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
}
 8010c32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010c36:	eb04 1c48 	add.w	ip, r4, r8, lsl #5
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8010c3a:	f8dc 6b00 	ldr.w	r6, [ip, #2816]	; 0xb00
 8010c3e:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
 8010c42:	f8cc 6b00 	str.w	r6, [ip, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8010c46:	f8d4 681c 	ldr.w	r6, [r4, #2076]	; 0x81c
 8010c4a:	ea26 0202 	bic.w	r2, r6, r2
 8010c4e:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
 8010c52:	e7b2      	b.n	8010bba <usb_lld_init_endpoint+0x6a>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8010c54:	f105 033f 	add.w	r3, r5, #63	; 0x3f
 8010c58:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8010c5c:	4a12      	ldr	r2, [pc, #72]	; (8010ca8 <usb_lld_init_endpoint+0x158>)
 8010c5e:	605a      	str	r2, [r3, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8010c60:	6121      	str	r1, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8010c62:	6923      	ldr	r3, [r4, #16]
 8010c64:	069b      	lsls	r3, r3, #26
 8010c66:	d4fc      	bmi.n	8010c62 <usb_lld_init_endpoint+0x112>
 8010c68:	eb04 1848 	add.w	r8, r4, r8, lsl #5
 8010c6c:	200c      	movs	r0, #12
 8010c6e:	f7fc fc87 	bl	800d580 <chSysPolledDelayX>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8010c72:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
 8010c76:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8010c7a:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8010c7e:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 8010c82:	2101      	movs	r1, #1
 8010c84:	fa01 f505 	lsl.w	r5, r1, r5
 8010c88:	ea23 0505 	bic.w	r5, r3, r5
 8010c8c:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
}
 8010c90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8010c94:	f8df 9014 	ldr.w	r9, [pc, #20]	; 8010cac <usb_lld_init_endpoint+0x15c>
    break;
 8010c98:	e771      	b.n	8010b7e <usb_lld_init_endpoint+0x2e>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8010c9a:	f8df 9014 	ldr.w	r9, [pc, #20]	; 8010cb0 <usb_lld_init_endpoint+0x160>
    break;
 8010c9e:	e76e      	b.n	8010b7e <usb_lld_init_endpoint+0x2e>
 8010ca0:	10048000 	.word	0x10048000
 8010ca4:	10008000 	.word	0x10008000
 8010ca8:	02000400 	.word	0x02000400
 8010cac:	100c8000 	.word	0x100c8000
 8010cb0:	10088000 	.word	0x10088000
	...

08010cc0 <usb_lld_get_status_out>:
  ctl = usbp->otg->oe[ep].DOEPCTL;
 8010cc0:	3158      	adds	r1, #88	; 0x58
 8010cc2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010cc4:	0149      	lsls	r1, r1, #5
 8010cc6:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8010cc8:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8010ccc:	d004      	beq.n	8010cd8 <usb_lld_get_status_out+0x18>
  if (ctl & DOEPCTL_STALL)
 8010cce:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  return EP_STATUS_ACTIVE;
 8010cd2:	bf14      	ite	ne
 8010cd4:	2001      	movne	r0, #1
 8010cd6:	2002      	moveq	r0, #2
}
 8010cd8:	4770      	bx	lr
 8010cda:	bf00      	nop
 8010cdc:	0000      	movs	r0, r0
	...

08010ce0 <usb_lld_get_status_in>:
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8010ce0:	3148      	adds	r1, #72	; 0x48
 8010ce2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8010ce4:	0149      	lsls	r1, r1, #5
 8010ce6:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 8010ce8:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8010cec:	d004      	beq.n	8010cf8 <usb_lld_get_status_in+0x18>
  if (ctl & DIEPCTL_STALL)
 8010cee:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  return EP_STATUS_ACTIVE;
 8010cf2:	bf14      	ite	ne
 8010cf4:	2001      	movne	r0, #1
 8010cf6:	2002      	moveq	r0, #2
}
 8010cf8:	4770      	bx	lr
 8010cfa:	bf00      	nop
 8010cfc:	0000      	movs	r0, r0
	...

08010d00 <usb_lld_read_setup>:
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8010d00:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8010d04:	68cb      	ldr	r3, [r1, #12]
 8010d06:	6a1b      	ldr	r3, [r3, #32]
 8010d08:	6819      	ldr	r1, [r3, #0]
 8010d0a:	685b      	ldr	r3, [r3, #4]
 8010d0c:	6053      	str	r3, [r2, #4]
 8010d0e:	6011      	str	r1, [r2, #0]
}
 8010d10:	4770      	bx	lr
 8010d12:	bf00      	nop
	...

08010d20 <usb_lld_prepare_receive>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8010d20:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 8010d24:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8010d26:	68de      	ldr	r6, [r3, #12]
 8010d28:	69b5      	ldr	r5, [r6, #24]
  osp->totsize = osp->rxsize;
 8010d2a:	686a      	ldr	r2, [r5, #4]
 8010d2c:	612a      	str	r2, [r5, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 8010d2e:	b929      	cbnz	r1, 8010d3c <usb_lld_prepare_receive+0x1c>
 8010d30:	2a40      	cmp	r2, #64	; 0x40
 8010d32:	d903      	bls.n	8010d3c <usb_lld_prepare_receive+0x1c>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8010d34:	2240      	movs	r2, #64	; 0x40
 8010d36:	4c09      	ldr	r4, [pc, #36]	; (8010d5c <usb_lld_prepare_receive+0x3c>)
 8010d38:	606a      	str	r2, [r5, #4]
 8010d3a:	e001      	b.n	8010d40 <usb_lld_prepare_receive+0x20>
 8010d3c:	f042 44c0 	orr.w	r4, r2, #1610612736	; 0x60000000
  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8010d40:	8a75      	ldrh	r5, [r6, #18]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010d42:	6d00      	ldr	r0, [r0, #80]	; 0x50
  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8010d44:	1e6b      	subs	r3, r5, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010d46:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8010d4a:	4413      	add	r3, r2
 8010d4c:	fbb3 f3f5 	udiv	r3, r3, r5
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8010d50:	ea44 43c3 	orr.w	r3, r4, r3, lsl #19
 8010d54:	f8c1 3b10 	str.w	r3, [r1, #2832]	; 0xb10
}
 8010d58:	bc70      	pop	{r4, r5, r6}
 8010d5a:	4770      	bx	lr
 8010d5c:	60000040 	.word	0x60000040

08010d60 <otg_epout_handler.constprop.7>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8010d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010d64:	4e24      	ldr	r6, [pc, #144]	; (8010df8 <otg_epout_handler.constprop.7+0x98>)
 8010d66:	6d37      	ldr	r7, [r6, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8010d68:	eb07 1340 	add.w	r3, r7, r0, lsl #5
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8010d6c:	4605      	mov	r5, r0
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8010d6e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 8010d72:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8010d76:	0720      	lsls	r0, r4, #28
 8010d78:	d50a      	bpl.n	8010d90 <otg_epout_handler.constprop.7+0x30>
 8010d7a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8010d7e:	0719      	lsls	r1, r3, #28
 8010d80:	d506      	bpl.n	8010d90 <otg_epout_handler.constprop.7+0x30>
    _usb_isr_invoke_setup_cb(usbp, ep);
 8010d82:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8010d86:	4629      	mov	r1, r5
 8010d88:	68db      	ldr	r3, [r3, #12]
 8010d8a:	4630      	mov	r0, r6
 8010d8c:	685b      	ldr	r3, [r3, #4]
 8010d8e:	4798      	blx	r3
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8010d90:	07e2      	lsls	r2, r4, #31
 8010d92:	d52e      	bpl.n	8010df2 <otg_epout_handler.constprop.7+0x92>
 8010d94:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8010d98:	07db      	lsls	r3, r3, #31
 8010d9a:	d52a      	bpl.n	8010df2 <otg_epout_handler.constprop.7+0x92>
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8010d9c:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8010da0:	68d9      	ldr	r1, [r3, #12]
 8010da2:	698b      	ldr	r3, [r1, #24]
    if (osp->rxsize < osp->totsize) {
 8010da4:	6858      	ldr	r0, [r3, #4]
 8010da6:	691a      	ldr	r2, [r3, #16]
 8010da8:	4290      	cmp	r0, r2
 8010daa:	d30c      	bcc.n	8010dc6 <otg_epout_handler.constprop.7+0x66>
      _usb_isr_invoke_out_cb(usbp, ep);
 8010dac:	8973      	ldrh	r3, [r6, #10]
 8010dae:	68cc      	ldr	r4, [r1, #12]
 8010db0:	4811      	ldr	r0, [pc, #68]	; (8010df8 <otg_epout_handler.constprop.7+0x98>)
 8010db2:	2201      	movs	r2, #1
 8010db4:	40aa      	lsls	r2, r5
 8010db6:	ea23 0302 	bic.w	r3, r3, r2
 8010dba:	8173      	strh	r3, [r6, #10]
 8010dbc:	4629      	mov	r1, r5
 8010dbe:	4623      	mov	r3, r4
}
 8010dc0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      _usb_isr_invoke_out_cb(usbp, ep);
 8010dc4:	4718      	bx	r3
      osp->rxsize = osp->totsize - osp->rxsize;
 8010dc6:	1a12      	subs	r2, r2, r0
      osp->rxcnt  = 0;
 8010dc8:	2400      	movs	r4, #0
 8010dca:	e9c3 2401 	strd	r2, r4, [r3, #4]
      usb_lld_prepare_receive(usbp, ep);
 8010dce:	4629      	mov	r1, r5
 8010dd0:	4809      	ldr	r0, [pc, #36]	; (8010df8 <otg_epout_handler.constprop.7+0x98>)
 8010dd2:	f7ff ffa5 	bl	8010d20 <usb_lld_prepare_receive>
 8010dd6:	2320      	movs	r3, #32
 8010dd8:	f383 8811 	msr	BASEPRI, r3
 8010ddc:	6d33      	ldr	r3, [r6, #80]	; 0x50
 8010dde:	eb03 1545 	add.w	r5, r3, r5, lsl #5
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8010de2:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8010de6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8010dea:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
 8010dee:	f384 8811 	msr	BASEPRI, r4
}
 8010df2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010df6:	bf00      	nop
 8010df8:	20001db8 	.word	0x20001db8
 8010dfc:	00000000 	.word	0x00000000

08010e00 <usb_lld_prepare_transmit>:
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010e00:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8010e04:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010e06:	68dc      	ldr	r4, [r3, #12]
 8010e08:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8010e0a:	6960      	ldr	r0, [r4, #20]
  isp->totsize = isp->txsize;
 8010e0c:	6843      	ldr	r3, [r0, #4]
 8010e0e:	6103      	str	r3, [r0, #16]
  if (isp->txsize == 0) {
 8010e10:	b19b      	cbz	r3, 8010e3a <usb_lld_prepare_transmit+0x3a>
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8010e12:	b169      	cbz	r1, 8010e30 <usb_lld_prepare_transmit+0x30>
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8010e14:	8a20      	ldrh	r0, [r4, #16]
}
 8010e16:	f85d 4b04 	ldr.w	r4, [sp], #4
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8010e1a:	eb02 1241 	add.w	r2, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8010e1e:	1e41      	subs	r1, r0, #1
 8010e20:	4419      	add	r1, r3
 8010e22:	fbb1 f1f0 	udiv	r1, r1, r0
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8010e26:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
 8010e2a:	f8c2 3910 	str.w	r3, [r2, #2320]	; 0x910
}
 8010e2e:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8010e30:	2b40      	cmp	r3, #64	; 0x40
      isp->txsize = EP0_MAX_INSIZE;
 8010e32:	bf84      	itt	hi
 8010e34:	2340      	movhi	r3, #64	; 0x40
 8010e36:	6043      	strhi	r3, [r0, #4]
 8010e38:	e7ec      	b.n	8010e14 <usb_lld_prepare_transmit+0x14>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8010e3a:	eb02 1241 	add.w	r2, r2, r1, lsl #5
 8010e3e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8010e42:	f8c2 3910 	str.w	r3, [r2, #2320]	; 0x910
}
 8010e46:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010e4a:	4770      	bx	lr
 8010e4c:	0000      	movs	r0, r0
	...

08010e50 <otg_epin_handler.constprop.8>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8010e50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010e54:	4e30      	ldr	r6, [pc, #192]	; (8010f18 <otg_epin_handler.constprop.8+0xc8>)
 8010e56:	6d35      	ldr	r5, [r6, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8010e58:	eb05 1340 	add.w	r3, r5, r0, lsl #5
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8010e5c:	4607      	mov	r7, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8010e5e:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 8010e62:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8010e66:	07e1      	lsls	r1, r4, #31
 8010e68:	d516      	bpl.n	8010e98 <otg_epin_handler.constprop.8+0x48>
 8010e6a:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 8010e6e:	07da      	lsls	r2, r3, #31
 8010e70:	d512      	bpl.n	8010e98 <otg_epin_handler.constprop.8+0x48>
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8010e72:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 8010e76:	68d9      	ldr	r1, [r3, #12]
 8010e78:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 8010e7a:	6858      	ldr	r0, [r3, #4]
 8010e7c:	691a      	ldr	r2, [r3, #16]
 8010e7e:	4290      	cmp	r0, r2
 8010e80:	d32a      	bcc.n	8010ed8 <otg_epin_handler.constprop.8+0x88>
      _usb_isr_invoke_in_cb(usbp, ep);
 8010e82:	8933      	ldrh	r3, [r6, #8]
 8010e84:	f8d1 8008 	ldr.w	r8, [r1, #8]
 8010e88:	2201      	movs	r2, #1
 8010e8a:	40ba      	lsls	r2, r7
 8010e8c:	ea23 0302 	bic.w	r3, r3, r2
 8010e90:	8133      	strh	r3, [r6, #8]
 8010e92:	4639      	mov	r1, r7
 8010e94:	4630      	mov	r0, r6
 8010e96:	47c0      	blx	r8
  if ((epint & DIEPINT_TXFE) &&
 8010e98:	0623      	lsls	r3, r4, #24
 8010e9a:	d506      	bpl.n	8010eaa <otg_epin_handler.constprop.8+0x5a>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8010e9c:	2301      	movs	r3, #1
 8010e9e:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
 8010ea2:	fa03 f707 	lsl.w	r7, r3, r7
  if ((epint & DIEPINT_TXFE) &&
 8010ea6:	4217      	tst	r7, r2
 8010ea8:	d101      	bne.n	8010eae <otg_epin_handler.constprop.8+0x5e>
}
 8010eaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010eae:	2320      	movs	r3, #32
 8010eb0:	f383 8811 	msr	BASEPRI, r3
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8010eb4:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
    usbp->txpending |= (1 << ep);
 8010eb8:	6df3      	ldr	r3, [r6, #92]	; 0x5c
  chThdResumeI(trp, msg);
 8010eba:	4818      	ldr	r0, [pc, #96]	; (8010f1c <otg_epin_handler.constprop.8+0xcc>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8010ebc:	ea22 0207 	bic.w	r2, r2, r7
 8010ec0:	f8c5 2834 	str.w	r2, [r5, #2100]	; 0x834
    usbp->txpending |= (1 << ep);
 8010ec4:	431f      	orrs	r7, r3
 8010ec6:	2100      	movs	r1, #0
 8010ec8:	65f7      	str	r7, [r6, #92]	; 0x5c
 8010eca:	f7fc fde1 	bl	800da90 <chThdResumeI>
 8010ece:	2300      	movs	r3, #0
 8010ed0:	f383 8811 	msr	BASEPRI, r3
}
 8010ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      isp->txsize = isp->totsize - isp->txsize;
 8010ed8:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 8010eda:	f04f 0800 	mov.w	r8, #0
 8010ede:	e9c3 2801 	strd	r2, r8, [r3, #4]
      usb_lld_prepare_transmit(usbp, ep);
 8010ee2:	4639      	mov	r1, r7
 8010ee4:	4630      	mov	r0, r6
 8010ee6:	f7ff ff8b 	bl	8010e00 <usb_lld_prepare_transmit>
 8010eea:	2320      	movs	r3, #32
 8010eec:	f383 8811 	msr	BASEPRI, r3
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010ef0:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8010ef2:	eb02 1047 	add.w	r0, r2, r7, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010ef6:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8010ef8:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 8010efc:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8010f00:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8010f04:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 8010f08:	40bb      	lsls	r3, r7
 8010f0a:	430b      	orrs	r3, r1
 8010f0c:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
 8010f10:	f388 8811 	msr	BASEPRI, r8
 8010f14:	e7c0      	b.n	8010e98 <otg_epin_handler.constprop.8+0x48>
 8010f16:	bf00      	nop
 8010f18:	20001db8 	.word	0x20001db8
 8010f1c:	20001e18 	.word	0x20001e18

08010f20 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8010f20:	b570      	push	{r4, r5, r6, lr}
  stm32_otg_t *otgp = usbp->otg;
 8010f22:	4d3a      	ldr	r5, [pc, #232]	; (801100c <Vector14C+0xec>)
 8010f24:	6d2e      	ldr	r6, [r5, #80]	; 0x50
  sts  = otgp->GINTSTS;
 8010f26:	6974      	ldr	r4, [r6, #20]
  sts &= otgp->GINTMSK;
 8010f28:	69b3      	ldr	r3, [r6, #24]
 8010f2a:	401c      	ands	r4, r3
  if (sts & GINTSTS_USBRST) {
 8010f2c:	04e1      	lsls	r1, r4, #19
  otgp->GINTSTS = sts;
 8010f2e:	6174      	str	r4, [r6, #20]
  if (sts & GINTSTS_USBRST) {
 8010f30:	d426      	bmi.n	8010f80 <Vector14C+0x60>
  if (sts & GINTSTS_ENUMDNE) {
 8010f32:	04a2      	lsls	r2, r4, #18
    (void)otgp->DSTS;
 8010f34:	bf48      	it	mi
 8010f36:	f8d6 3808 	ldrmi.w	r3, [r6, #2056]	; 0x808
  if (sts & GINTSTS_SOF) {
 8010f3a:	0723      	lsls	r3, r4, #28
 8010f3c:	d504      	bpl.n	8010f48 <Vector14C+0x28>
    _usb_isr_invoke_sof_cb(usbp);
 8010f3e:	686b      	ldr	r3, [r5, #4]
 8010f40:	68db      	ldr	r3, [r3, #12]
 8010f42:	b10b      	cbz	r3, 8010f48 <Vector14C+0x28>
 8010f44:	4831      	ldr	r0, [pc, #196]	; (801100c <Vector14C+0xec>)
 8010f46:	4798      	blx	r3
  if (sts & GINTSTS_RXFLVL) {
 8010f48:	06e5      	lsls	r5, r4, #27
 8010f4a:	d424      	bmi.n	8010f96 <Vector14C+0x76>
  if (sts & GINTSTS_IEPINT) {
 8010f4c:	0360      	lsls	r0, r4, #13
  src = otgp->DAINT;
 8010f4e:	f8d6 5818 	ldr.w	r5, [r6, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 8010f52:	d507      	bpl.n	8010f64 <Vector14C+0x44>
    if (src & (1 << 0))
 8010f54:	07e9      	lsls	r1, r5, #31
 8010f56:	d44f      	bmi.n	8010ff8 <Vector14C+0xd8>
    if (src & (1 << 1))
 8010f58:	07aa      	lsls	r2, r5, #30
 8010f5a:	d442      	bmi.n	8010fe2 <Vector14C+0xc2>
    if (src & (1 << 2))
 8010f5c:	076b      	lsls	r3, r5, #29
 8010f5e:	d445      	bmi.n	8010fec <Vector14C+0xcc>
    if (src & (1 << 3))
 8010f60:	072e      	lsls	r6, r5, #28
 8010f62:	d44f      	bmi.n	8011004 <Vector14C+0xe4>
  if (sts & GINTSTS_OEPINT) {
 8010f64:	0324      	lsls	r4, r4, #12
 8010f66:	d507      	bpl.n	8010f78 <Vector14C+0x58>
    if (src & (1 << 16))
 8010f68:	03e8      	lsls	r0, r5, #15
 8010f6a:	d42a      	bmi.n	8010fc2 <Vector14C+0xa2>
    if (src & (1 << 17))
 8010f6c:	03a9      	lsls	r1, r5, #14
 8010f6e:	d42d      	bmi.n	8010fcc <Vector14C+0xac>
    if (src & (1 << 18))
 8010f70:	036a      	lsls	r2, r5, #13
 8010f72:	d430      	bmi.n	8010fd6 <Vector14C+0xb6>
    if (src & (1 << 19))
 8010f74:	032b      	lsls	r3, r5, #12
 8010f76:	d41d      	bmi.n	8010fb4 <Vector14C+0x94>
}
 8010f78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8010f7c:	f7fd b9e8 	b.w	800e350 <_port_irq_epilogue>
    _usb_reset(usbp);
 8010f80:	4628      	mov	r0, r5
 8010f82:	f7fd fe5d 	bl	800ec40 <_usb_reset>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8010f86:	686b      	ldr	r3, [r5, #4]
 8010f88:	681b      	ldr	r3, [r3, #0]
 8010f8a:	2b00      	cmp	r3, #0
 8010f8c:	d0d1      	beq.n	8010f32 <Vector14C+0x12>
 8010f8e:	2100      	movs	r1, #0
 8010f90:	4628      	mov	r0, r5
 8010f92:	4798      	blx	r3
 8010f94:	e7cd      	b.n	8010f32 <Vector14C+0x12>
 8010f96:	2320      	movs	r3, #32
 8010f98:	f383 8811 	msr	BASEPRI, r3
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8010f9c:	69b3      	ldr	r3, [r6, #24]
 8010f9e:	481c      	ldr	r0, [pc, #112]	; (8011010 <Vector14C+0xf0>)
 8010fa0:	f023 0310 	bic.w	r3, r3, #16
 8010fa4:	61b3      	str	r3, [r6, #24]
 8010fa6:	2100      	movs	r1, #0
 8010fa8:	f7fc fd72 	bl	800da90 <chThdResumeI>
 8010fac:	2300      	movs	r3, #0
 8010fae:	f383 8811 	msr	BASEPRI, r3
 8010fb2:	e7cb      	b.n	8010f4c <Vector14C+0x2c>
      otg_epout_handler(usbp, 3);
 8010fb4:	2003      	movs	r0, #3
 8010fb6:	f7ff fed3 	bl	8010d60 <otg_epout_handler.constprop.7>
}
 8010fba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8010fbe:	f7fd b9c7 	b.w	800e350 <_port_irq_epilogue>
      otg_epout_handler(usbp, 0);
 8010fc2:	2000      	movs	r0, #0
 8010fc4:	f7ff fecc 	bl	8010d60 <otg_epout_handler.constprop.7>
    if (src & (1 << 17))
 8010fc8:	03a9      	lsls	r1, r5, #14
 8010fca:	d5d1      	bpl.n	8010f70 <Vector14C+0x50>
      otg_epout_handler(usbp, 1);
 8010fcc:	2001      	movs	r0, #1
 8010fce:	f7ff fec7 	bl	8010d60 <otg_epout_handler.constprop.7>
    if (src & (1 << 18))
 8010fd2:	036a      	lsls	r2, r5, #13
 8010fd4:	d5ce      	bpl.n	8010f74 <Vector14C+0x54>
      otg_epout_handler(usbp, 2);
 8010fd6:	2002      	movs	r0, #2
 8010fd8:	f7ff fec2 	bl	8010d60 <otg_epout_handler.constprop.7>
    if (src & (1 << 19))
 8010fdc:	032b      	lsls	r3, r5, #12
 8010fde:	d5cb      	bpl.n	8010f78 <Vector14C+0x58>
 8010fe0:	e7e8      	b.n	8010fb4 <Vector14C+0x94>
      otg_epin_handler(usbp, 1);
 8010fe2:	2001      	movs	r0, #1
 8010fe4:	f7ff ff34 	bl	8010e50 <otg_epin_handler.constprop.8>
    if (src & (1 << 2))
 8010fe8:	076b      	lsls	r3, r5, #29
 8010fea:	d5b9      	bpl.n	8010f60 <Vector14C+0x40>
      otg_epin_handler(usbp, 2);
 8010fec:	2002      	movs	r0, #2
 8010fee:	f7ff ff2f 	bl	8010e50 <otg_epin_handler.constprop.8>
    if (src & (1 << 3))
 8010ff2:	072e      	lsls	r6, r5, #28
 8010ff4:	d5b6      	bpl.n	8010f64 <Vector14C+0x44>
 8010ff6:	e005      	b.n	8011004 <Vector14C+0xe4>
      otg_epin_handler(usbp, 0);
 8010ff8:	2000      	movs	r0, #0
 8010ffa:	f7ff ff29 	bl	8010e50 <otg_epin_handler.constprop.8>
    if (src & (1 << 1))
 8010ffe:	07aa      	lsls	r2, r5, #30
 8011000:	d5ac      	bpl.n	8010f5c <Vector14C+0x3c>
 8011002:	e7ee      	b.n	8010fe2 <Vector14C+0xc2>
      otg_epin_handler(usbp, 3);
 8011004:	2003      	movs	r0, #3
 8011006:	f7ff ff23 	bl	8010e50 <otg_epin_handler.constprop.8>
 801100a:	e7ab      	b.n	8010f64 <Vector14C+0x44>
 801100c:	20001db8 	.word	0x20001db8
 8011010:	20001e18 	.word	0x20001e18
	...

08011020 <usb_lld_start_out>:
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8011020:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8011022:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8011026:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 801102a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 801102e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8011032:	4770      	bx	lr
	...

08011040 <usb_lld_start_in>:
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8011040:	6d02      	ldr	r2, [r0, #80]	; 0x50
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8011042:	b410      	push	{r4}
 8011044:	eb02 1441 	add.w	r4, r2, r1, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8011048:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 801104a:	f8d4 0900 	ldr.w	r0, [r4, #2304]	; 0x900
 801104e:	f040 4004 	orr.w	r0, r0, #2214592512	; 0x84000000
 8011052:	f8c4 0900 	str.w	r0, [r4, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8011056:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
}
 801105a:	f85d 4b04 	ldr.w	r4, [sp], #4
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 801105e:	fa03 f101 	lsl.w	r1, r3, r1
 8011062:	4301      	orrs	r1, r0
 8011064:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 8011068:	4770      	bx	lr
 801106a:	bf00      	nop
 801106c:	0000      	movs	r0, r0
	...

08011070 <usb_lld_stall_out>:
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8011070:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8011072:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8011076:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 801107a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 801107e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8011082:	4770      	bx	lr
	...

08011090 <usb_lld_stall_in>:
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8011090:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8011092:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8011096:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 801109a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 801109e:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 80110a2:	4770      	bx	lr
	...

080110b0 <usb_lld_clear_out>:
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 80110b0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80110b2:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80110b6:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80110ba:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80110be:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 80110c2:	4770      	bx	lr
	...

080110d0 <usb_lld_clear_in>:
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 80110d0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80110d2:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80110d6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 80110da:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80110de:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
}
 80110e2:	4770      	bx	lr
	...

080110f0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 80110f0:	b510      	push	{r4, lr}

  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 80110f2:	4c0a      	ldr	r4, [pc, #40]	; (801111c <spi_lld_init+0x2c>)
  dummytx = 0xFFFF;
 80110f4:	4b0a      	ldr	r3, [pc, #40]	; (8011120 <spi_lld_init+0x30>)
 80110f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  spiObjectInit(&SPID1);
 80110fa:	4620      	mov	r0, r4
  dummytx = 0xFFFF;
 80110fc:	801a      	strh	r2, [r3, #0]
  spiObjectInit(&SPID1);
 80110fe:	f7fd fcaf 	bl	800ea60 <spiObjectInit>
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8011102:	4b08      	ldr	r3, [pc, #32]	; (8011124 <spi_lld_init+0x34>)
  SPID1.spi       = SPI1;
 8011104:	4808      	ldr	r0, [pc, #32]	; (8011128 <spi_lld_init+0x38>)
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8011106:	4909      	ldr	r1, [pc, #36]	; (801112c <spi_lld_init+0x3c>)
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8011108:	4a09      	ldr	r2, [pc, #36]	; (8011130 <spi_lld_init+0x40>)
  SPID1.spi       = SPI1;
 801110a:	61e0      	str	r0, [r4, #28]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 801110c:	f103 0024 	add.w	r0, r3, #36	; 0x24
 8011110:	e9c4 3008 	strd	r3, r0, [r4, #32]
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8011114:	e9c4 120a 	strd	r1, r2, [r4, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 8011118:	bd10      	pop	{r4, pc}
 801111a:	bf00      	nop
 801111c:	20002054 	.word	0x20002054
 8011120:	20002084 	.word	0x20002084
 8011124:	0802da10 	.word	0x0802da10
 8011128:	40013000 	.word	0x40013000
 801112c:	06010016 	.word	0x06010016
 8011130:	06010046 	.word	0x06010046
	...

08011140 <VectorB4>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8011140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  sr  = icup->tim->SR;
 8011142:	4d26      	ldr	r5, [pc, #152]	; (80111dc <VectorB4+0x9c>)
 8011144:	68eb      	ldr	r3, [r5, #12]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8011146:	6869      	ldr	r1, [r5, #4]
  sr  = icup->tim->SR;
 8011148:	691c      	ldr	r4, [r3, #16]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 801114a:	68da      	ldr	r2, [r3, #12]
  if (icup->config->channel == ICU_CHANNEL_1) {
 801114c:	7d08      	ldrb	r0, [r1, #20]
 801114e:	4014      	ands	r4, r2
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8011150:	b2e2      	uxtb	r2, r4
  icup->tim->SR = ~sr;
 8011152:	43d2      	mvns	r2, r2
 8011154:	611a      	str	r2, [r3, #16]
 8011156:	f004 0602 	and.w	r6, r4, #2
  if (icup->config->channel == ICU_CHANNEL_1) {
 801115a:	b988      	cbnz	r0, 8011180 <VectorB4+0x40>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 801115c:	0762      	lsls	r2, r4, #29
 801115e:	d530      	bpl.n	80111c2 <VectorB4+0x82>
      _icu_isr_invoke_width_cb(icup);
 8011160:	782b      	ldrb	r3, [r5, #0]
 8011162:	2b04      	cmp	r3, #4
 8011164:	d029      	beq.n	80111ba <VectorB4+0x7a>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 8011166:	b99e      	cbnz	r6, 8011190 <VectorB4+0x50>
  if ((sr & STM32_TIM_SR_UIF) != 0)
 8011168:	07e3      	lsls	r3, r4, #31
 801116a:	d505      	bpl.n	8011178 <VectorB4+0x38>
    _icu_isr_invoke_overflow_cb(icup);
 801116c:	686b      	ldr	r3, [r5, #4]
 801116e:	481b      	ldr	r0, [pc, #108]	; (80111dc <VectorB4+0x9c>)
 8011170:	691b      	ldr	r3, [r3, #16]
 8011172:	4798      	blx	r3
 8011174:	2303      	movs	r3, #3
 8011176:	702b      	strb	r3, [r5, #0]
  OSAL_IRQ_PROLOGUE();

  icu_lld_serve_interrupt(&ICUD3);

  OSAL_IRQ_EPILOGUE();
}
 8011178:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 801117c:	f7fd b8e8 	b.w	800e350 <_port_irq_epilogue>
 8011180:	f004 0704 	and.w	r7, r4, #4
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 8011184:	b15e      	cbz	r6, 801119e <VectorB4+0x5e>
      _icu_isr_invoke_width_cb(icup);
 8011186:	782b      	ldrb	r3, [r5, #0]
 8011188:	2b04      	cmp	r3, #4
 801118a:	d004      	beq.n	8011196 <VectorB4+0x56>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 801118c:	2f00      	cmp	r7, #0
 801118e:	d0eb      	beq.n	8011168 <VectorB4+0x28>
      _icu_isr_invoke_period_cb(icup);
 8011190:	2304      	movs	r3, #4
 8011192:	702b      	strb	r3, [r5, #0]
 8011194:	e7e8      	b.n	8011168 <VectorB4+0x28>
      _icu_isr_invoke_width_cb(icup);
 8011196:	688b      	ldr	r3, [r1, #8]
 8011198:	b1e3      	cbz	r3, 80111d4 <VectorB4+0x94>
 801119a:	4628      	mov	r0, r5
 801119c:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 801119e:	2f00      	cmp	r7, #0
 80111a0:	d0e2      	beq.n	8011168 <VectorB4+0x28>
      _icu_isr_invoke_period_cb(icup);
 80111a2:	782b      	ldrb	r3, [r5, #0]
 80111a4:	2b04      	cmp	r3, #4
 80111a6:	d1f3      	bne.n	8011190 <VectorB4+0x50>
 80111a8:	6869      	ldr	r1, [r5, #4]
 80111aa:	68cb      	ldr	r3, [r1, #12]
 80111ac:	2b00      	cmp	r3, #0
 80111ae:	d0ef      	beq.n	8011190 <VectorB4+0x50>
 80111b0:	480a      	ldr	r0, [pc, #40]	; (80111dc <VectorB4+0x9c>)
 80111b2:	4798      	blx	r3
 80111b4:	2304      	movs	r3, #4
 80111b6:	702b      	strb	r3, [r5, #0]
 80111b8:	e7d6      	b.n	8011168 <VectorB4+0x28>
      _icu_isr_invoke_width_cb(icup);
 80111ba:	688b      	ldr	r3, [r1, #8]
 80111bc:	b13b      	cbz	r3, 80111ce <VectorB4+0x8e>
 80111be:	4628      	mov	r0, r5
 80111c0:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80111c2:	2e00      	cmp	r6, #0
 80111c4:	d0d0      	beq.n	8011168 <VectorB4+0x28>
      _icu_isr_invoke_period_cb(icup);
 80111c6:	782b      	ldrb	r3, [r5, #0]
 80111c8:	2b04      	cmp	r3, #4
 80111ca:	d1e1      	bne.n	8011190 <VectorB4+0x50>
 80111cc:	e7ec      	b.n	80111a8 <VectorB4+0x68>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80111ce:	2e00      	cmp	r6, #0
 80111d0:	d0ca      	beq.n	8011168 <VectorB4+0x28>
 80111d2:	e7ea      	b.n	80111aa <VectorB4+0x6a>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80111d4:	2f00      	cmp	r7, #0
 80111d6:	d0c7      	beq.n	8011168 <VectorB4+0x28>
 80111d8:	e7e7      	b.n	80111aa <VectorB4+0x6a>
 80111da:	bf00      	nop
 80111dc:	20002088 	.word	0x20002088

080111e0 <icu_lld_init>:
/**
 * @brief   Low level ICU driver initialization.
 *
 * @notapi
 */
void icu_lld_init(void) {
 80111e0:	b510      	push	{r4, lr}
  ICUD2.tim = STM32_TIM2;
#endif

#if STM32_ICU_USE_TIM3
  /* Driver initialization.*/
  icuObjectInit(&ICUD3);
 80111e2:	4c03      	ldr	r4, [pc, #12]	; (80111f0 <icu_lld_init+0x10>)
 80111e4:	4620      	mov	r0, r4
 80111e6:	f7fd fa33 	bl	800e650 <icuObjectInit>
  ICUD3.tim = STM32_TIM3;
 80111ea:	4b02      	ldr	r3, [pc, #8]	; (80111f4 <icu_lld_init+0x14>)
 80111ec:	60e3      	str	r3, [r4, #12]
#if STM32_ICU_USE_TIM9
  /* Driver initialization.*/
  icuObjectInit(&ICUD9);
  ICUD9.tim = STM32_TIM9;
#endif
}
 80111ee:	bd10      	pop	{r4, pc}
 80111f0:	20002088 	.word	0x20002088
 80111f4:	40000400 	.word	0x40000400
	...

08011200 <icu_lld_start>:

  osalDbgAssert((icup->config->channel == ICU_CHANNEL_1) ||
                (icup->config->channel == ICU_CHANNEL_2),
                "invalid input");

  if (icup->state == ICU_STOP) {
 8011200:	7803      	ldrb	r3, [r0, #0]
 8011202:	2b01      	cmp	r3, #1
void icu_lld_start(ICUDriver *icup) {
 8011204:	b570      	push	{r4, r5, r6, lr}
 8011206:	4604      	mov	r4, r0
  if (icup->state == ICU_STOP) {
 8011208:	d03a      	beq.n	8011280 <icu_lld_start+0x80>
    }
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    icup->tim->CR1    = 0;                  /* Timer disabled.              */
 801120a:	68c3      	ldr	r3, [r0, #12]
 801120c:	2200      	movs	r2, #0
 801120e:	601a      	str	r2, [r3, #0]
    icup->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8011210:	635a      	str	r2, [r3, #52]	; 0x34
    icup->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8011212:	639a      	str	r2, [r3, #56]	; 0x38
    icup->tim->CNT    = 0;                  /* Counter reset to zero.       */
 8011214:	625a      	str	r2, [r3, #36]	; 0x24

  /* Timer configuration.*/
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
                    ~STM32_TIM_DIER_IRQ_MASK;
  psc = (icup->clock / icup->config->frequency) - 1;
 8011216:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 801121a:	6988      	ldr	r0, [r1, #24]
                ((psc + 1) * icup->config->frequency) == icup->clock,
                "invalid frequency");
  icup->tim->PSC  = psc;
  icup->tim->ARR  = 0xFFFF;

  if (icup->config->channel == ICU_CHANNEL_1) {
 801121c:	7d0d      	ldrb	r5, [r1, #20]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 801121e:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 8011222:	2600      	movs	r6, #0
 8011224:	611e      	str	r6, [r3, #16]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 8011226:	60d8      	str	r0, [r3, #12]
  psc = (icup->clock / icup->config->frequency) - 1;
 8011228:	6848      	ldr	r0, [r1, #4]
 801122a:	fbb2 f2f0 	udiv	r2, r2, r0
  icup->tim->ARR  = 0xFFFF;
 801122e:	f64f 70ff 	movw	r0, #65535	; 0xffff
  psc = (icup->clock / icup->config->frequency) - 1;
 8011232:	3a01      	subs	r2, #1
  icup->tim->PSC  = psc;
 8011234:	629a      	str	r2, [r3, #40]	; 0x28
 8011236:	780a      	ldrb	r2, [r1, #0]
  icup->tim->ARR  = 0xFFFF;
 8011238:	62d8      	str	r0, [r3, #44]	; 0x2c
  if (icup->config->channel == ICU_CHANNEL_1) {
 801123a:	b96d      	cbnz	r5, 8011258 <icu_lld_start+0x58>
    /* Selected input 1.
       CCMR1_CC1S = 01 = CH1 Input on TI1.
       CCMR1_CC2S = 10 = CH2 Input on TI1.*/
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 801123c:	f240 2001 	movw	r0, #513	; 0x201

    /* SMCR_TS  = 101, input is TI1FP1.
       SMCR_SMS = 100, reset on rising edge.*/
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 8011240:	2154      	movs	r1, #84	; 0x54
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 8011242:	6198      	str	r0, [r3, #24]
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 8011244:	6099      	str	r1, [r3, #8]

    /* The CCER settings depend on the selected trigger mode.
       ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
       ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8011246:	b1c2      	cbz	r2, 801127a <icu_lld_start+0x7a>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
                        STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;
    else
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 8011248:	2213      	movs	r2, #19
 801124a:	621a      	str	r2, [r3, #32]
                        STM32_TIM_CCER_CC2E;

    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[1];
 801124c:	f103 0238 	add.w	r2, r3, #56	; 0x38
    icup->pccrp = &icup->tim->CCR[0];
 8011250:	3334      	adds	r3, #52	; 0x34
 8011252:	e9c4 2304 	strd	r2, r3, [r4, #16]
    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[0];
    icup->pccrp = &icup->tim->CCR[1];
  }
}
 8011256:	bd70      	pop	{r4, r5, r6, pc}
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 8011258:	f44f 7081 	mov.w	r0, #258	; 0x102
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 801125c:	2164      	movs	r1, #100	; 0x64
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 801125e:	6198      	str	r0, [r3, #24]
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 8011260:	6099      	str	r1, [r3, #8]
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 8011262:	b13a      	cbz	r2, 8011274 <icu_lld_start+0x74>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 8011264:	2231      	movs	r2, #49	; 0x31
 8011266:	621a      	str	r2, [r3, #32]
    icup->wccrp = &icup->tim->CCR[0];
 8011268:	f103 0234 	add.w	r2, r3, #52	; 0x34
    icup->pccrp = &icup->tim->CCR[1];
 801126c:	3338      	adds	r3, #56	; 0x38
 801126e:	e9c4 2304 	strd	r2, r3, [r4, #16]
}
 8011272:	bd70      	pop	{r4, r5, r6, pc}
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 8011274:	2213      	movs	r2, #19
 8011276:	621a      	str	r2, [r3, #32]
 8011278:	e7f6      	b.n	8011268 <icu_lld_start+0x68>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 801127a:	2231      	movs	r2, #49	; 0x31
 801127c:	621a      	str	r2, [r3, #32]
 801127e:	e7e5      	b.n	801124c <icu_lld_start+0x4c>
    if (&ICUD3 == icup) {
 8011280:	4b0b      	ldr	r3, [pc, #44]	; (80112b0 <icu_lld_start+0xb0>)
 8011282:	4298      	cmp	r0, r3
 8011284:	d001      	beq.n	801128a <icu_lld_start+0x8a>
 8011286:	68e3      	ldr	r3, [r4, #12]
 8011288:	e7c5      	b.n	8011216 <icu_lld_start+0x16>
      rccEnableTIM3(FALSE);
 801128a:	4b0a      	ldr	r3, [pc, #40]	; (80112b4 <icu_lld_start+0xb4>)
 801128c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801128e:	f042 0202 	orr.w	r2, r2, #2
 8011292:	641a      	str	r2, [r3, #64]	; 0x40
      rccResetTIM3();
 8011294:	6a1a      	ldr	r2, [r3, #32]
 8011296:	2000      	movs	r0, #0
 8011298:	f042 0202 	orr.w	r2, r2, #2
 801129c:	621a      	str	r2, [r3, #32]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_ICU_TIM3_IRQ_PRIORITY);
 801129e:	2107      	movs	r1, #7
      rccResetTIM3();
 80112a0:	6218      	str	r0, [r3, #32]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_ICU_TIM3_IRQ_PRIORITY);
 80112a2:	201d      	movs	r0, #29
 80112a4:	f7fd ff44 	bl	800f130 <nvicEnableVector>
      icup->clock = STM32_TIMCLK1;
 80112a8:	4b03      	ldr	r3, [pc, #12]	; (80112b8 <icu_lld_start+0xb8>)
 80112aa:	60a3      	str	r3, [r4, #8]
 80112ac:	e7eb      	b.n	8011286 <icu_lld_start+0x86>
 80112ae:	bf00      	nop
 80112b0:	20002088 	.word	0x20002088
 80112b4:	40023800 	.word	0x40023800
 80112b8:	0501bd00 	.word	0x0501bd00
 80112bc:	00000000 	.word	0x00000000

080112c0 <icu_lld_stop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_stop(ICUDriver *icup) {
 80112c0:	b508      	push	{r3, lr}

  if (icup->state == ICU_READY) {
 80112c2:	7803      	ldrb	r3, [r0, #0]
 80112c4:	2b02      	cmp	r3, #2
 80112c6:	d000      	beq.n	80112ca <icu_lld_stop+0xa>
      nvicDisableVector(STM32_TIM9_NUMBER);
      rccDisableTIM9(FALSE);
    }
#endif
  }
}
 80112c8:	bd08      	pop	{r3, pc}
    if (&ICUD3 == icup) {
 80112ca:	4908      	ldr	r1, [pc, #32]	; (80112ec <icu_lld_stop+0x2c>)
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 80112cc:	68c3      	ldr	r3, [r0, #12]
 80112ce:	2200      	movs	r2, #0
    if (&ICUD3 == icup) {
 80112d0:	4288      	cmp	r0, r1
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 80112d2:	601a      	str	r2, [r3, #0]
    icup->tim->DIER = 0;                    /* All IRQs disabled.           */
 80112d4:	60da      	str	r2, [r3, #12]
    icup->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 80112d6:	611a      	str	r2, [r3, #16]
    if (&ICUD3 == icup) {
 80112d8:	d1f6      	bne.n	80112c8 <icu_lld_stop+0x8>
      nvicDisableVector(STM32_TIM3_NUMBER);
 80112da:	201d      	movs	r0, #29
 80112dc:	f7fd ff48 	bl	800f170 <nvicDisableVector>
      rccDisableTIM3(FALSE);
 80112e0:	4a03      	ldr	r2, [pc, #12]	; (80112f0 <icu_lld_stop+0x30>)
 80112e2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80112e4:	f023 0302 	bic.w	r3, r3, #2
 80112e8:	6413      	str	r3, [r2, #64]	; 0x40
}
 80112ea:	bd08      	pop	{r3, pc}
 80112ec:	20002088 	.word	0x20002088
 80112f0:	40023800 	.word	0x40023800
	...

08011300 <icu_lld_start_capture>:
 * @notapi
 */
void icu_lld_start_capture(ICUDriver *icup) {

  /* Triggering an UG and clearing the IRQ status.*/
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8011300:	68c3      	ldr	r3, [r0, #12]
 8011302:	695a      	ldr	r2, [r3, #20]
  icup->tim->SR = 0;
 8011304:	2000      	movs	r0, #0
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8011306:	f042 0201 	orr.w	r2, r2, #1

  /* Timer is started.*/
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 801130a:	2105      	movs	r1, #5
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 801130c:	615a      	str	r2, [r3, #20]
  icup->tim->SR = 0;
 801130e:	6118      	str	r0, [r3, #16]
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 8011310:	6019      	str	r1, [r3, #0]
}
 8011312:	4770      	bx	lr
	...

08011320 <icu_lld_enable_notifications>:
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icu_lld_enable_notifications(ICUDriver *icup) {
  uint32_t dier = icup->tim->DIER;
 8011320:	68c2      	ldr	r2, [r0, #12]
 8011322:	68d3      	ldr	r3, [r2, #12]
void icu_lld_enable_notifications(ICUDriver *icup) {
 8011324:	b410      	push	{r4}

  /* If interrupts were already enabled then the operation is skipped.
     This is done in order to avoid clearing the SR and risk losing
     pending interrupts.*/
  if ((dier & STM32_TIM_DIER_IRQ_MASK) == 0) {
 8011326:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 801132a:	d10c      	bne.n	8011346 <icu_lld_enable_notifications+0x26>
    /* Previously triggered IRQs are ignored, status cleared.*/
    icup->tim->SR = 0;

    if (icup->config->channel == ICU_CHANNEL_1) {
 801132c:	6841      	ldr	r1, [r0, #4]
    icup->tim->SR = 0;
 801132e:	6114      	str	r4, [r2, #16]
    if (icup->config->channel == ICU_CHANNEL_1) {
 8011330:	7d0c      	ldrb	r4, [r1, #20]
 8011332:	6888      	ldr	r0, [r1, #8]
 8011334:	b954      	cbnz	r4, 801134c <icu_lld_enable_notifications+0x2c>
      /* Enabling periodic callback on CC1.*/
      dier |= STM32_TIM_DIER_CC1IE;

      /* Optionally enabling width callback on CC2.*/
      if (icup->config->width_cb != NULL)
 8011336:	b170      	cbz	r0, 8011356 <icu_lld_enable_notifications+0x36>
      /* Enabling periodic callback on CC2.*/
      dier |= STM32_TIM_DIER_CC2IE;

      /* Optionally enabling width callback on CC1.*/
      if (icup->config->width_cb != NULL)
        dier |= STM32_TIM_DIER_CC1IE;
 8011338:	f043 0306 	orr.w	r3, r3, #6
    }

    /* If an overflow callback is defined then also the overflow callback
       is enabled.*/
    if (icup->config->overflow_cb != NULL)
 801133c:	6909      	ldr	r1, [r1, #16]
 801133e:	b109      	cbz	r1, 8011344 <icu_lld_enable_notifications+0x24>
      dier |= STM32_TIM_DIER_UIE;
 8011340:	f043 0301 	orr.w	r3, r3, #1

    /* One single atomic write.*/
    icup->tim->DIER = dier;
 8011344:	60d3      	str	r3, [r2, #12]
  }
}
 8011346:	f85d 4b04 	ldr.w	r4, [sp], #4
 801134a:	4770      	bx	lr
      if (icup->config->width_cb != NULL)
 801134c:	2800      	cmp	r0, #0
 801134e:	d1f3      	bne.n	8011338 <icu_lld_enable_notifications+0x18>
      dier |= STM32_TIM_DIER_CC2IE;
 8011350:	f043 0304 	orr.w	r3, r3, #4
 8011354:	e7f2      	b.n	801133c <icu_lld_enable_notifications+0x1c>
      dier |= STM32_TIM_DIER_CC1IE;
 8011356:	f043 0302 	orr.w	r3, r3, #2
 801135a:	e7ef      	b.n	801133c <icu_lld_enable_notifications+0x1c>
 801135c:	0000      	movs	r0, r0
	...

08011360 <usart_stop>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8011360:	6901      	ldr	r1, [r0, #16]
 8011362:	680a      	ldr	r2, [r1, #0]
 8011364:	6813      	ldr	r3, [r2, #0]
 8011366:	f023 031f 	bic.w	r3, r3, #31
static void usart_stop(UARTDriver *uartp) {
 801136a:	b430      	push	{r4, r5}
  dmaStreamDisable(uartp->dmarx);
 801136c:	6013      	str	r3, [r2, #0]
 801136e:	6813      	ldr	r3, [r2, #0]
 8011370:	07db      	lsls	r3, r3, #31
 8011372:	d4fc      	bmi.n	801136e <usart_stop+0xe>
 8011374:	7a0d      	ldrb	r5, [r1, #8]
  dmaStreamDisable(uartp->dmatx);
 8011376:	6944      	ldr	r4, [r0, #20]
  dmaStreamDisable(uartp->dmarx);
 8011378:	6849      	ldr	r1, [r1, #4]
  dmaStreamDisable(uartp->dmatx);
 801137a:	6822      	ldr	r2, [r4, #0]
  dmaStreamDisable(uartp->dmarx);
 801137c:	233d      	movs	r3, #61	; 0x3d
 801137e:	40ab      	lsls	r3, r5
 8011380:	600b      	str	r3, [r1, #0]
  dmaStreamDisable(uartp->dmatx);
 8011382:	6813      	ldr	r3, [r2, #0]
 8011384:	f023 031f 	bic.w	r3, r3, #31
 8011388:	6013      	str	r3, [r2, #0]
 801138a:	6813      	ldr	r3, [r2, #0]
 801138c:	f013 0301 	ands.w	r3, r3, #1
 8011390:	d1fb      	bne.n	801138a <usart_stop+0x2a>
 8011392:	7a25      	ldrb	r5, [r4, #8]
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8011394:	6882      	ldr	r2, [r0, #8]
  dmaStreamDisable(uartp->dmatx);
 8011396:	6860      	ldr	r0, [r4, #4]
 8011398:	213d      	movs	r1, #61	; 0x3d
 801139a:	40a9      	lsls	r1, r5
 801139c:	6001      	str	r1, [r0, #0]
  uartp->usart->CR2 = 0;
  uartp->usart->CR3 = 0;
}
 801139e:	bc30      	pop	{r4, r5}
  uartp->usart->CR1 = 0;
 80113a0:	60d3      	str	r3, [r2, #12]
  uartp->usart->CR2 = 0;
 80113a2:	6113      	str	r3, [r2, #16]
  uartp->usart->CR3 = 0;
 80113a4:	6153      	str	r3, [r2, #20]
}
 80113a6:	4770      	bx	lr
	...

080113b0 <serve_usart_irq>:
/**
 * @brief   USART common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {
 80113b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
 80113b4:	6884      	ldr	r4, [r0, #8]
  uint32_t cr1 = u->CR1;
 80113b6:	68e7      	ldr	r7, [r4, #12]

  sr = u->SR;   /* SR reset step 1.*/
 80113b8:	6826      	ldr	r6, [r4, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80113ba:	6862      	ldr	r2, [r4, #4]

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
 80113bc:	f240 130f 	movw	r3, #271	; 0x10f
 80113c0:	421e      	tst	r6, r3
static void serve_usart_irq(UARTDriver *uartp) {
 80113c2:	4605      	mov	r5, r0
  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
 80113c4:	d01d      	beq.n	8011402 <serve_usart_irq+0x52>
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
    if (uartp->config->rxerr_cb != NULL)
 80113c6:	6843      	ldr	r3, [r0, #4]
 80113c8:	691a      	ldr	r2, [r3, #16]
    u->SR = ~USART_SR_LBD;
 80113ca:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80113ce:	6023      	str	r3, [r4, #0]
    if (uartp->config->rxerr_cb != NULL)
 80113d0:	b1ba      	cbz	r2, 8011402 <serve_usart_irq+0x52>
  sr = u->SR;   /* SR reset step 1.*/
 80113d2:	b2b3      	uxth	r3, r6
    sts |= UART_OVERRUN_ERROR;
 80113d4:	f013 0f08 	tst.w	r3, #8
 80113d8:	bf0c      	ite	eq
 80113da:	2100      	moveq	r1, #0
 80113dc:	2110      	movne	r1, #16
  if (sr & USART_SR_PE)
 80113de:	07d8      	lsls	r0, r3, #31
    sts |= UART_PARITY_ERROR;
 80113e0:	bf48      	it	mi
 80113e2:	f041 0104 	orrmi.w	r1, r1, #4
  if (sr & USART_SR_FE)
 80113e6:	0798      	lsls	r0, r3, #30
    sts |= UART_FRAMING_ERROR;
 80113e8:	bf48      	it	mi
 80113ea:	f041 0108 	orrmi.w	r1, r1, #8
  if (sr & USART_SR_NE)
 80113ee:	0758      	lsls	r0, r3, #29
    sts |= UART_NOISE_ERROR;
 80113f0:	bf48      	it	mi
 80113f2:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_LBD)
 80113f6:	05d8      	lsls	r0, r3, #23
    sts |= UART_BREAK_DETECTED;
 80113f8:	bf48      	it	mi
 80113fa:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
      uartp->config->rxerr_cb(uartp, translate_errors(sr));
 80113fe:	4628      	mov	r0, r5
 8011400:	4790      	blx	r2
  }

  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {
 8011402:	0672      	lsls	r2, r6, #25
 8011404:	d50e      	bpl.n	8011424 <serve_usart_irq+0x74>
 8011406:	067b      	lsls	r3, r7, #25
 8011408:	d50c      	bpl.n	8011424 <serve_usart_irq+0x74>
    /* TC interrupt cleared and disabled.*/
    u->SR = ~USART_SR_TC;
    u->CR1 = cr1 & ~USART_CR1_TCIE;

    /* End of transmission, a callback is generated.*/
    if (uartp->config->txend2_cb != NULL)
 801140a:	686b      	ldr	r3, [r5, #4]
 801140c:	685b      	ldr	r3, [r3, #4]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 801140e:	f027 0740 	bic.w	r7, r7, #64	; 0x40
    u->SR = ~USART_SR_TC;
 8011412:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8011416:	6022      	str	r2, [r4, #0]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8011418:	60e7      	str	r7, [r4, #12]
    if (uartp->config->txend2_cb != NULL)
 801141a:	b11b      	cbz	r3, 8011424 <serve_usart_irq+0x74>
      uartp->config->txend2_cb(uartp);
 801141c:	4628      	mov	r0, r5
  }
}
 801141e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      uartp->config->txend2_cb(uartp);
 8011422:	4718      	bx	r3
}
 8011424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08011430 <uart_lld_serve_tx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8011430:	f011 0f0c 	tst.w	r1, #12
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8011434:	b538      	push	{r3, r4, r5, lr}
 8011436:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8011438:	d11b      	bne.n	8011472 <uart_lld_serve_tx_end_irq+0x42>
  dmaStreamDisable(uartp->dmatx);
 801143a:	6961      	ldr	r1, [r4, #20]
 801143c:	680a      	ldr	r2, [r1, #0]
 801143e:	6813      	ldr	r3, [r2, #0]
 8011440:	f023 031f 	bic.w	r3, r3, #31
 8011444:	6013      	str	r3, [r2, #0]
 8011446:	6813      	ldr	r3, [r2, #0]
 8011448:	07db      	lsls	r3, r3, #31
 801144a:	d4fc      	bmi.n	8011446 <uart_lld_serve_tx_end_irq+0x16>
  if (uartp->config->txend1_cb != NULL)
 801144c:	6863      	ldr	r3, [r4, #4]
  dmaStreamDisable(uartp->dmatx);
 801144e:	7a0d      	ldrb	r5, [r1, #8]
 8011450:	6848      	ldr	r0, [r1, #4]
  if (uartp->config->txend1_cb != NULL)
 8011452:	681a      	ldr	r2, [r3, #0]
  dmaStreamDisable(uartp->dmatx);
 8011454:	233d      	movs	r3, #61	; 0x3d
 8011456:	40ab      	lsls	r3, r5
  uartp->txstate = UART_TX_COMPLETE;
 8011458:	2102      	movs	r1, #2
  dmaStreamDisable(uartp->dmatx);
 801145a:	6003      	str	r3, [r0, #0]
  uartp->txstate = UART_TX_COMPLETE;
 801145c:	7061      	strb	r1, [r4, #1]
  if (uartp->config->txend1_cb != NULL)
 801145e:	b12a      	cbz	r2, 801146c <uart_lld_serve_tx_end_irq+0x3c>
    uartp->config->txend1_cb(uartp);
 8011460:	4620      	mov	r0, r4
 8011462:	4790      	blx	r2
  if (uartp->txstate == UART_TX_COMPLETE)
 8011464:	7863      	ldrb	r3, [r4, #1]
 8011466:	2b02      	cmp	r3, #2
 8011468:	d000      	beq.n	801146c <uart_lld_serve_tx_end_irq+0x3c>
}
 801146a:	bd38      	pop	{r3, r4, r5, pc}
    uartp->txstate = UART_TX_IDLE;
 801146c:	2300      	movs	r3, #0
 801146e:	7063      	strb	r3, [r4, #1]
}
 8011470:	bd38      	pop	{r3, r4, r5, pc}
  chSysHalt(reason);
 8011472:	4802      	ldr	r0, [pc, #8]	; (801147c <uart_lld_serve_tx_end_irq+0x4c>)
 8011474:	f7fc f84c 	bl	800d510 <chSysHalt>
 8011478:	e7df      	b.n	801143a <uart_lld_serve_tx_end_irq+0xa>
 801147a:	bf00      	nop
 801147c:	0802da70 	.word	0x0802da70

08011480 <uart_lld_serve_rx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8011480:	f011 0f0c 	tst.w	r1, #12
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8011484:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011488:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 801148a:	d13a      	bne.n	8011502 <uart_lld_serve_rx_end_irq+0x82>
  if (uartp->rxstate == UART_RX_IDLE) {
 801148c:	78a3      	ldrb	r3, [r4, #2]
 801148e:	6861      	ldr	r1, [r4, #4]
 8011490:	b93b      	cbnz	r3, 80114a2 <uart_lld_serve_rx_end_irq+0x22>
    if (uartp->config->rxchar_cb != NULL)
 8011492:	68cb      	ldr	r3, [r1, #12]
 8011494:	2b00      	cmp	r3, #0
 8011496:	d032      	beq.n	80114fe <uart_lld_serve_rx_end_irq+0x7e>
      uartp->config->rxchar_cb(uartp, uartp->rxbuf);
 8011498:	8b21      	ldrh	r1, [r4, #24]
 801149a:	4620      	mov	r0, r4
}
 801149c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      uartp->config->rxchar_cb(uartp, uartp->rxbuf);
 80114a0:	4718      	bx	r3
    dmaStreamDisable(uartp->dmarx);
 80114a2:	6920      	ldr	r0, [r4, #16]
 80114a4:	6802      	ldr	r2, [r0, #0]
 80114a6:	6813      	ldr	r3, [r2, #0]
 80114a8:	f023 031f 	bic.w	r3, r3, #31
 80114ac:	6013      	str	r3, [r2, #0]
 80114ae:	6813      	ldr	r3, [r2, #0]
 80114b0:	07db      	lsls	r3, r3, #31
 80114b2:	d4fc      	bmi.n	80114ae <uart_lld_serve_rx_end_irq+0x2e>
 80114b4:	7a07      	ldrb	r7, [r0, #8]
 80114b6:	6846      	ldr	r6, [r0, #4]
    if (uartp->config->rxend_cb != NULL)
 80114b8:	688d      	ldr	r5, [r1, #8]
    dmaStreamDisable(uartp->dmarx);
 80114ba:	233d      	movs	r3, #61	; 0x3d
 80114bc:	40bb      	lsls	r3, r7
    uartp->rxstate = UART_RX_COMPLETE;
 80114be:	2002      	movs	r0, #2
    dmaStreamDisable(uartp->dmarx);
 80114c0:	6033      	str	r3, [r6, #0]
    uartp->rxstate = UART_RX_COMPLETE;
 80114c2:	70a0      	strb	r0, [r4, #2]
    if (uartp->config->rxend_cb != NULL)
 80114c4:	b13d      	cbz	r5, 80114d6 <uart_lld_serve_rx_end_irq+0x56>
      uartp->config->rxend_cb(uartp);
 80114c6:	4620      	mov	r0, r4
 80114c8:	47a8      	blx	r5
    if (uartp->rxstate == UART_RX_COMPLETE) {
 80114ca:	78a3      	ldrb	r3, [r4, #2]
 80114cc:	2b02      	cmp	r3, #2
 80114ce:	d116      	bne.n	80114fe <uart_lld_serve_rx_end_irq+0x7e>
 80114d0:	6923      	ldr	r3, [r4, #16]
 80114d2:	6861      	ldr	r1, [r4, #4]
 80114d4:	681a      	ldr	r2, [r3, #0]
  if (uartp->config->rxchar_cb == NULL)
 80114d6:	68cb      	ldr	r3, [r1, #12]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 80114d8:	68e1      	ldr	r1, [r4, #12]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 80114da:	2b00      	cmp	r3, #0
 80114dc:	bf14      	ite	ne
 80114de:	f44f 7388 	movne.w	r3, #272	; 0x110
 80114e2:	f44f 7380 	moveq.w	r3, #256	; 0x100
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 80114e6:	430b      	orrs	r3, r1
      uartp->rxstate = UART_RX_IDLE;
 80114e8:	2500      	movs	r5, #0
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 80114ea:	2101      	movs	r1, #1
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 80114ec:	f104 0018 	add.w	r0, r4, #24
      uartp->rxstate = UART_RX_IDLE;
 80114f0:	70a5      	strb	r5, [r4, #2]
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 80114f2:	60d0      	str	r0, [r2, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 80114f4:	6051      	str	r1, [r2, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 80114f6:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(uartp->dmarx);
 80114f8:	6813      	ldr	r3, [r2, #0]
 80114fa:	430b      	orrs	r3, r1
 80114fc:	6013      	str	r3, [r2, #0]
}
 80114fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011502:	4802      	ldr	r0, [pc, #8]	; (801150c <uart_lld_serve_rx_end_irq+0x8c>)
 8011504:	f7fc f804 	bl	800d510 <chSysHalt>
 8011508:	e7c0      	b.n	801148c <uart_lld_serve_rx_end_irq+0xc>
 801150a:	bf00      	nop
 801150c:	0802da70 	.word	0x0802da70

08011510 <VectorDC>:
/**
 * @brief   USART3 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8011510:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);
 8011512:	4803      	ldr	r0, [pc, #12]	; (8011520 <VectorDC+0x10>)
 8011514:	f7ff ff4c 	bl	80113b0 <serve_usart_irq>

  OSAL_IRQ_EPILOGUE();
}
 8011518:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 801151c:	f7fc bf18 	b.w	800e350 <_port_irq_epilogue>
 8011520:	200020a0 	.word	0x200020a0
	...

08011530 <Vector15C>:
/**
 * @brief   USART6 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 8011530:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD6);
 8011532:	4803      	ldr	r0, [pc, #12]	; (8011540 <Vector15C+0x10>)
 8011534:	f7ff ff3c 	bl	80113b0 <serve_usart_irq>

  OSAL_IRQ_EPILOGUE();
}
 8011538:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 801153c:	f7fc bf08 	b.w	800e350 <_port_irq_epilogue>
 8011540:	200020bc 	.word	0x200020bc
	...

08011550 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
 8011550:	b570      	push	{r4, r5, r6, lr}
  UARTD2.dmarx   = STM32_DMA_STREAM(STM32_UART_USART2_RX_DMA_STREAM);
  UARTD2.dmatx   = STM32_DMA_STREAM(STM32_UART_USART2_TX_DMA_STREAM);
#endif

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
 8011552:	4d0c      	ldr	r5, [pc, #48]	; (8011584 <uart_lld_init+0x34>)
  UARTD3.usart   = USART3;
  UARTD3.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
  UARTD3.dmarx   = STM32_DMA_STREAM(STM32_UART_USART3_RX_DMA_STREAM);
 8011554:	4c0c      	ldr	r4, [pc, #48]	; (8011588 <uart_lld_init+0x38>)
  UARTD5.dmarx   = STM32_DMA_STREAM(STM32_UART_UART5_RX_DMA_STREAM);
  UARTD5.dmatx   = STM32_DMA_STREAM(STM32_UART_UART5_TX_DMA_STREAM);
#endif

#if STM32_UART_USE_USART6
  uartObjectInit(&UARTD6);
 8011556:	4e0d      	ldr	r6, [pc, #52]	; (801158c <uart_lld_init+0x3c>)
  uartObjectInit(&UARTD3);
 8011558:	4628      	mov	r0, r5
 801155a:	f7fd fa91 	bl	800ea80 <uartObjectInit>
  UARTD3.usart   = USART3;
 801155e:	4b0c      	ldr	r3, [pc, #48]	; (8011590 <uart_lld_init+0x40>)
 8011560:	60ab      	str	r3, [r5, #8]
  UARTD3.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8011562:	2206      	movs	r2, #6
  UARTD3.dmatx   = STM32_DMA_STREAM(STM32_UART_USART3_TX_DMA_STREAM);
 8011564:	f104 0318 	add.w	r3, r4, #24
  uartObjectInit(&UARTD6);
 8011568:	4630      	mov	r0, r6
  UARTD3.dmarx   = STM32_DMA_STREAM(STM32_UART_USART3_RX_DMA_STREAM);
 801156a:	e9c5 2403 	strd	r2, r4, [r5, #12]
  UARTD3.dmatx   = STM32_DMA_STREAM(STM32_UART_USART3_TX_DMA_STREAM);
 801156e:	616b      	str	r3, [r5, #20]
  uartObjectInit(&UARTD6);
 8011570:	f7fd fa86 	bl	800ea80 <uartObjectInit>
  UARTD6.usart   = USART6;
 8011574:	4b07      	ldr	r3, [pc, #28]	; (8011594 <uart_lld_init+0x44>)
 8011576:	60b3      	str	r3, [r6, #8]
  UARTD6.dmarx   = STM32_DMA_STREAM(STM32_UART_USART6_RX_DMA_STREAM);
 8011578:	f104 036c 	add.w	r3, r4, #108	; 0x6c
  UARTD6.dmatx   = STM32_DMA_STREAM(STM32_UART_USART6_TX_DMA_STREAM);
 801157c:	34a8      	adds	r4, #168	; 0xa8
 801157e:	e9c6 3404 	strd	r3, r4, [r6, #16]
#endif
}
 8011582:	bd70      	pop	{r4, r5, r6, pc}
 8011584:	200020a0 	.word	0x200020a0
 8011588:	0802d9bc 	.word	0x0802d9bc
 801158c:	200020bc 	.word	0x200020bc
 8011590:	40004800 	.word	0x40004800
 8011594:	40011400 	.word	0x40011400
	...

080115a0 <uart_lld_start>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
 80115a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if (uartp->state == UART_STOP) {
 80115a2:	7803      	ldrb	r3, [r0, #0]
 80115a4:	2b01      	cmp	r3, #1
void uart_lld_start(UARTDriver *uartp) {
 80115a6:	4604      	mov	r4, r0
  if (uartp->state == UART_STOP) {
 80115a8:	d040      	beq.n	801162c <uart_lld_start+0x8c>
 80115aa:	6885      	ldr	r5, [r0, #8]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
    uartp->rxbuf = 0;
  }

  uartp->rxstate = UART_RX_IDLE;
 80115ac:	2300      	movs	r3, #0
 80115ae:	70a3      	strb	r3, [r4, #2]
  uartp->txstate = UART_TX_IDLE;
 80115b0:	7063      	strb	r3, [r4, #1]
  usart_stop(uartp);
 80115b2:	4620      	mov	r0, r4
 80115b4:	f7ff fed4 	bl	8011360 <usart_stop>
  if ((uartp->usart == USART1) || (uartp->usart == USART6))
 80115b8:	4b44      	ldr	r3, [pc, #272]	; (80116cc <uart_lld_start+0x12c>)
 80115ba:	68a2      	ldr	r2, [r4, #8]
 80115bc:	429a      	cmp	r2, r3
 80115be:	6863      	ldr	r3, [r4, #4]
 80115c0:	d008      	beq.n	80115d4 <uart_lld_start+0x34>
 80115c2:	4843      	ldr	r0, [pc, #268]	; (80116d0 <uart_lld_start+0x130>)
 80115c4:	6959      	ldr	r1, [r3, #20]
 80115c6:	4282      	cmp	r2, r0
 80115c8:	d005      	beq.n	80115d6 <uart_lld_start+0x36>
    u->BRR = STM32_PCLK1 / uartp->config->speed;
 80115ca:	4a42      	ldr	r2, [pc, #264]	; (80116d4 <uart_lld_start+0x134>)
 80115cc:	fbb2 f2f1 	udiv	r2, r2, r1
 80115d0:	60aa      	str	r2, [r5, #8]
 80115d2:	e004      	b.n	80115de <uart_lld_start+0x3e>
 80115d4:	6959      	ldr	r1, [r3, #20]
    u->BRR = STM32_PCLK2 / uartp->config->speed;
 80115d6:	4a40      	ldr	r2, [pc, #256]	; (80116d8 <uart_lld_start+0x138>)
 80115d8:	fbb2 f2f1 	udiv	r2, r2, r1
 80115dc:	60aa      	str	r2, [r5, #8]
  if (uartp->config->rxchar_cb == NULL)
 80115de:	68d9      	ldr	r1, [r3, #12]
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 80115e0:	8b5e      	ldrh	r6, [r3, #26]
  u->CR1 = uartp->config->cr1 | cr1;
 80115e2:	8b1a      	ldrh	r2, [r3, #24]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 80115e4:	8b98      	ldrh	r0, [r3, #28]
  (void)u->SR;  /* SR reset step 1.*/
 80115e6:	682b      	ldr	r3, [r5, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80115e8:	686b      	ldr	r3, [r5, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 80115ea:	e9d4 7303 	ldrd	r7, r3, [r4, #12]
  if (uartp->config->rxchar_cb == NULL)
 80115ee:	2900      	cmp	r1, #0
  u->SR = 0;
 80115f0:	f04f 0100 	mov.w	r1, #0
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 80115f4:	681b      	ldr	r3, [r3, #0]
  u->SR = 0;
 80115f6:	6029      	str	r1, [r5, #0]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 80115f8:	f040 00c1 	orr.w	r0, r0, #193	; 0xc1
  u->CR1 = uartp->config->cr1 | cr1;
 80115fc:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8011600:	f046 0640 	orr.w	r6, r6, #64	; 0x40
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8011604:	bf14      	ite	ne
 8011606:	f44f 7188 	movne.w	r1, #272	; 0x110
 801160a:	f44f 7180 	moveq.w	r1, #256	; 0x100
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 801160e:	612e      	str	r6, [r5, #16]
  u->CR1 = uartp->config->cr1 | cr1;
 8011610:	f042 020c 	orr.w	r2, r2, #12
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8011614:	6168      	str	r0, [r5, #20]
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8011616:	3418      	adds	r4, #24
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8011618:	2001      	movs	r0, #1
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 801161a:	4339      	orrs	r1, r7
  u->CR1 = uartp->config->cr1 | cr1;
 801161c:	60ea      	str	r2, [r5, #12]
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 801161e:	60dc      	str	r4, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8011620:	6058      	str	r0, [r3, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8011622:	6019      	str	r1, [r3, #0]
  dmaStreamEnable(uartp->dmarx);
 8011624:	681a      	ldr	r2, [r3, #0]
 8011626:	4302      	orrs	r2, r0
 8011628:	601a      	str	r2, [r3, #0]
  usart_start(uartp);
}
 801162a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (&UARTD3 == uartp) {
 801162c:	4b2b      	ldr	r3, [pc, #172]	; (80116dc <uart_lld_start+0x13c>)
 801162e:	4298      	cmp	r0, r3
 8011630:	d032      	beq.n	8011698 <uart_lld_start+0xf8>
    if (&UARTD6 == uartp) {
 8011632:	4b2b      	ldr	r3, [pc, #172]	; (80116e0 <uart_lld_start+0x140>)
 8011634:	4298      	cmp	r0, r3
 8011636:	d015      	beq.n	8011664 <uart_lld_start+0xc4>
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 8011638:	6863      	ldr	r3, [r4, #4]
 801163a:	8b1b      	ldrh	r3, [r3, #24]
 801163c:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8011640:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8011644:	d103      	bne.n	801164e <uart_lld_start+0xae>
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8011646:	68e3      	ldr	r3, [r4, #12]
 8011648:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 801164c:	60e3      	str	r3, [r4, #12]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 801164e:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 8011652:	68a5      	ldr	r5, [r4, #8]
 8011654:	6810      	ldr	r0, [r2, #0]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 8011656:	6819      	ldr	r1, [r3, #0]
    uartp->rxbuf = 0;
 8011658:	2200      	movs	r2, #0
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 801165a:	1d2b      	adds	r3, r5, #4
 801165c:	6083      	str	r3, [r0, #8]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 801165e:	608b      	str	r3, [r1, #8]
    uartp->rxbuf = 0;
 8011660:	8322      	strh	r2, [r4, #24]
 8011662:	e7a3      	b.n	80115ac <uart_lld_start+0xc>
      b = dmaStreamAllocate(uartp->dmarx,
 8011664:	4603      	mov	r3, r0
 8011666:	4a1f      	ldr	r2, [pc, #124]	; (80116e4 <uart_lld_start+0x144>)
 8011668:	6900      	ldr	r0, [r0, #16]
 801166a:	210c      	movs	r1, #12
 801166c:	f7fd ff50 	bl	800f510 <dmaStreamAllocate>
      b = dmaStreamAllocate(uartp->dmatx,
 8011670:	4623      	mov	r3, r4
 8011672:	4a1d      	ldr	r2, [pc, #116]	; (80116e8 <uart_lld_start+0x148>)
 8011674:	6960      	ldr	r0, [r4, #20]
 8011676:	210c      	movs	r1, #12
 8011678:	f7fd ff4a 	bl	800f510 <dmaStreamAllocate>
      rccEnableUSART6(FALSE);
 801167c:	4a1b      	ldr	r2, [pc, #108]	; (80116ec <uart_lld_start+0x14c>)
 801167e:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8011680:	f043 0320 	orr.w	r3, r3, #32
 8011684:	6453      	str	r3, [r2, #68]	; 0x44
      nvicEnableVector(STM32_USART6_NUMBER, STM32_UART_USART6_IRQ_PRIORITY);
 8011686:	210c      	movs	r1, #12
 8011688:	2047      	movs	r0, #71	; 0x47
 801168a:	f7fd fd51 	bl	800f130 <nvicEnableVector>
      uartp->dmamode |= STM32_DMA_CR_CHSEL(USART6_RX_DMA_CHANNEL) |
 801168e:	68e3      	ldr	r3, [r4, #12]
 8011690:	f043 6320 	orr.w	r3, r3, #167772160	; 0xa000000
 8011694:	60e3      	str	r3, [r4, #12]
 8011696:	e7cf      	b.n	8011638 <uart_lld_start+0x98>
      b = dmaStreamAllocate(uartp->dmarx,
 8011698:	4603      	mov	r3, r0
 801169a:	4a12      	ldr	r2, [pc, #72]	; (80116e4 <uart_lld_start+0x144>)
 801169c:	6900      	ldr	r0, [r0, #16]
 801169e:	210c      	movs	r1, #12
 80116a0:	f7fd ff36 	bl	800f510 <dmaStreamAllocate>
      b = dmaStreamAllocate(uartp->dmatx,
 80116a4:	4623      	mov	r3, r4
 80116a6:	4a10      	ldr	r2, [pc, #64]	; (80116e8 <uart_lld_start+0x148>)
 80116a8:	6960      	ldr	r0, [r4, #20]
 80116aa:	210c      	movs	r1, #12
 80116ac:	f7fd ff30 	bl	800f510 <dmaStreamAllocate>
      rccEnableUSART3(FALSE);
 80116b0:	4a0e      	ldr	r2, [pc, #56]	; (80116ec <uart_lld_start+0x14c>)
 80116b2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80116b4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80116b8:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_UART_USART3_IRQ_PRIORITY);
 80116ba:	210c      	movs	r1, #12
 80116bc:	2027      	movs	r0, #39	; 0x27
 80116be:	f7fd fd37 	bl	800f130 <nvicEnableVector>
      uartp->dmamode |= STM32_DMA_CR_CHSEL(USART3_RX_DMA_CHANNEL) |
 80116c2:	68e3      	ldr	r3, [r4, #12]
 80116c4:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80116c8:	60e3      	str	r3, [r4, #12]
 80116ca:	e7b5      	b.n	8011638 <uart_lld_start+0x98>
 80116cc:	40011000 	.word	0x40011000
 80116d0:	40011400 	.word	0x40011400
 80116d4:	0280de80 	.word	0x0280de80
 80116d8:	0501bd00 	.word	0x0501bd00
 80116dc:	200020a0 	.word	0x200020a0
 80116e0:	200020bc 	.word	0x200020bc
 80116e4:	08011481 	.word	0x08011481
 80116e8:	08011431 	.word	0x08011431
 80116ec:	40023800 	.word	0x40023800

080116f0 <uart_lld_stop>:
 *
 * @notapi
 */
void uart_lld_stop(UARTDriver *uartp) {

  if (uartp->state == UART_READY) {
 80116f0:	7802      	ldrb	r2, [r0, #0]
 80116f2:	2a02      	cmp	r2, #2
 80116f4:	d000      	beq.n	80116f8 <uart_lld_stop+0x8>
 80116f6:	4770      	bx	lr
void uart_lld_stop(UARTDriver *uartp) {
 80116f8:	b510      	push	{r4, lr}
 80116fa:	4604      	mov	r4, r0
    usart_stop(uartp);
 80116fc:	f7ff fe30 	bl	8011360 <usart_stop>
    dmaStreamRelease(uartp->dmarx);
 8011700:	6920      	ldr	r0, [r4, #16]
 8011702:	f7fd ff4d 	bl	800f5a0 <dmaStreamRelease>
    dmaStreamRelease(uartp->dmatx);
 8011706:	6960      	ldr	r0, [r4, #20]
 8011708:	f7fd ff4a 	bl	800f5a0 <dmaStreamRelease>
      return;
    }
#endif

#if STM32_UART_USE_USART3
    if (&UARTD3 == uartp) {
 801170c:	4b0c      	ldr	r3, [pc, #48]	; (8011740 <uart_lld_stop+0x50>)
 801170e:	429c      	cmp	r4, r3
 8011710:	d00c      	beq.n	801172c <uart_lld_stop+0x3c>
      return;
    }
#endif

#if STM32_UART_USE_USART6
    if (&UARTD6 == uartp) {
 8011712:	4b0c      	ldr	r3, [pc, #48]	; (8011744 <uart_lld_stop+0x54>)
 8011714:	429c      	cmp	r4, r3
 8011716:	d000      	beq.n	801171a <uart_lld_stop+0x2a>
      rccDisableUSART6(FALSE);
      return;
    }
#endif
  }
}
 8011718:	bd10      	pop	{r4, pc}
      nvicDisableVector(STM32_USART6_NUMBER);
 801171a:	2047      	movs	r0, #71	; 0x47
 801171c:	f7fd fd28 	bl	800f170 <nvicDisableVector>
      rccDisableUSART6(FALSE);
 8011720:	4a09      	ldr	r2, [pc, #36]	; (8011748 <uart_lld_stop+0x58>)
 8011722:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8011724:	f023 0320 	bic.w	r3, r3, #32
 8011728:	6453      	str	r3, [r2, #68]	; 0x44
}
 801172a:	bd10      	pop	{r4, pc}
      nvicDisableVector(STM32_USART3_NUMBER);
 801172c:	2027      	movs	r0, #39	; 0x27
 801172e:	f7fd fd1f 	bl	800f170 <nvicDisableVector>
      rccDisableUSART3(FALSE);
 8011732:	4a05      	ldr	r2, [pc, #20]	; (8011748 <uart_lld_stop+0x58>)
 8011734:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8011736:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 801173a:	6413      	str	r3, [r2, #64]	; 0x40
}
 801173c:	bd10      	pop	{r4, pc}
 801173e:	bf00      	nop
 8011740:	200020a0 	.word	0x200020a0
 8011744:	200020bc 	.word	0x200020bc
 8011748:	40023800 	.word	0x40023800
 801174c:	00000000 	.word	0x00000000

08011750 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
 8011750:	b430      	push	{r4, r5}

  /* TX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 8011752:	6943      	ldr	r3, [r0, #20]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Only enable TC interrupt if there's a callback attached to it.
     Also we need to clear TC flag which could be set before. */
  if (uartp->config->txend2_cb != NULL) {
 8011754:	6845      	ldr	r5, [r0, #4]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 8011756:	68c4      	ldr	r4, [r0, #12]
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 8011758:	681b      	ldr	r3, [r3, #0]
  if (uartp->config->txend2_cb != NULL) {
 801175a:	686d      	ldr	r5, [r5, #4]
  dmaStreamSetMemory0(uartp->dmatx, txbuf);
 801175c:	60da      	str	r2, [r3, #12]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 801175e:	f444 648a 	orr.w	r4, r4, #1104	; 0x450
  dmaStreamSetTransactionSize(uartp->dmatx, n);
 8011762:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(uartp->dmatx, uartp->dmamode    | STM32_DMA_CR_DIR_M2P |
 8011764:	601c      	str	r4, [r3, #0]
  if (uartp->config->txend2_cb != NULL) {
 8011766:	b13d      	cbz	r5, 8011778 <uart_lld_start_send+0x28>
    uartp->usart->SR = ~USART_SR_TC;
 8011768:	6882      	ldr	r2, [r0, #8]
 801176a:	f06f 0140 	mvn.w	r1, #64	; 0x40
 801176e:	6011      	str	r1, [r2, #0]
    uartp->usart->CR1 |= USART_CR1_TCIE;
 8011770:	68d1      	ldr	r1, [r2, #12]
 8011772:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8011776:	60d1      	str	r1, [r2, #12]
  }

  /* Starting transfer.*/
  dmaStreamEnable(uartp->dmatx);
 8011778:	681a      	ldr	r2, [r3, #0]
 801177a:	f042 0201 	orr.w	r2, r2, #1
 801177e:	601a      	str	r2, [r3, #0]
}
 8011780:	bc30      	pop	{r4, r5}
 8011782:	4770      	bx	lr
	...

08011790 <_sbrk_r>:
 8011790:	b510      	push	{r4, lr}
 8011792:	4604      	mov	r4, r0
 8011794:	4608      	mov	r0, r1
 8011796:	f7fc fd03 	bl	800e1a0 <chCoreAlloc>
 801179a:	b100      	cbz	r0, 801179e <_sbrk_r+0xe>
 801179c:	bd10      	pop	{r4, pc}
 801179e:	230c      	movs	r3, #12
 80117a0:	6023      	str	r3, [r4, #0]
 80117a2:	f04f 30ff 	mov.w	r0, #4294967295
 80117a6:	bd10      	pop	{r4, pc}
	...

080117b0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80117b0:	f7fd bf56 	b.w	800f660 <stm32_clock_init>
	...

080117c0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80117c0:	4770      	bx	lr
 80117c2:	bf00      	nop
	...

080117d0 <timer_thread>:
//				(double)mc_interface_get_configuration()->lo_current_motor_max_now,
//				(double)mc_interface_get_configuration()->lo_current_motor_min_now);
	}
}

static THD_FUNCTION(timer_thread, arg) {
 80117d0:	b508      	push	{r3, lr}
 80117d2:	4b05      	ldr	r3, [pc, #20]	; (80117e8 <timer_thread+0x18>)
 80117d4:	4a05      	ldr	r2, [pc, #20]	; (80117ec <timer_thread+0x1c>)
 80117d6:	699b      	ldr	r3, [r3, #24]
 80117d8:	619a      	str	r2, [r3, #24]
	(void)arg;

	chRegSetThreadName("msec_timer");

	for(;;) {
		packet_timerfunc();
 80117da:	f004 fcd9 	bl	8016190 <packet_timerfunc>
		chThdSleepMilliseconds(1);
 80117de:	200a      	movs	r0, #10
 80117e0:	f7fc f8fe 	bl	800d9e0 <chThdSleep>
 80117e4:	e7f9      	b.n	80117da <timer_thread+0xa>
 80117e6:	bf00      	nop
 80117e8:	20001a48 	.word	0x20001a48
 80117ec:	0802dbe0 	.word	0x0802dbe0

080117f0 <periodic_thread>:
static THD_FUNCTION(periodic_thread, arg) {
 80117f0:	b538      	push	{r3, r4, r5, lr}
 80117f2:	4b47      	ldr	r3, [pc, #284]	; (8011910 <periodic_thread+0x120>)
 80117f4:	4a47      	ldr	r2, [pc, #284]	; (8011914 <periodic_thread+0x124>)
 80117f6:	699b      	ldr	r3, [r3, #24]
 80117f8:	ed2d 8b04 	vpush	{d8-d9}
			ledpwm_set_intensity(LED_GREEN, 0.2);
 80117fc:	eddf 8a46 	vldr	s17, [pc, #280]	; 8011918 <periodic_thread+0x128>
				ledpwm_set_intensity(LED_RED, 0.0);
 8011800:	ed9f 8a46 	vldr	s16, [pc, #280]	; 801191c <periodic_thread+0x12c>
 8011804:	619a      	str	r2, [r3, #24]
 8011806:	e02b      	b.n	8011860 <periodic_thread+0x70>
			ledpwm_set_intensity(LED_RED, 0.0);
 8011808:	eeb0 0a48 	vmov.f32	s0, s16
 801180c:	2001      	movs	r0, #1
 801180e:	f000 fe0f 	bl	8012430 <ledpwm_set_intensity>
		if (mc_interface_get_state() == MC_STATE_DETECTING) {
 8011812:	f009 fe3d 	bl	801b490 <mc_interface_get_state>
 8011816:	2801      	cmp	r0, #1
 8011818:	d050      	beq.n	80118bc <periodic_thread+0xcc>
		disp_pos_mode display_mode = commands_get_disp_pos_mode();
 801181a:	f006 ff59 	bl	80186d0 <commands_get_disp_pos_mode>
		switch (display_mode) {
 801181e:	2804      	cmp	r0, #4
		disp_pos_mode display_mode = commands_get_disp_pos_mode();
 8011820:	4604      	mov	r4, r0
		switch (display_mode) {
 8011822:	d054      	beq.n	80118ce <periodic_thread+0xde>
 8011824:	2805      	cmp	r0, #5
 8011826:	d05f      	beq.n	80118e8 <periodic_thread+0xf8>
 8011828:	2803      	cmp	r0, #3
 801182a:	d055      	beq.n	80118d8 <periodic_thread+0xe8>
		if (mc_interface_get_configuration()->motor_type == MOTOR_TYPE_FOC) {
 801182c:	f009 fde8 	bl	801b400 <mc_interface_get_configuration>
 8011830:	7883      	ldrb	r3, [r0, #2]
 8011832:	2b02      	cmp	r3, #2
 8011834:	d111      	bne.n	801185a <periodic_thread+0x6a>
			switch (display_mode) {
 8011836:	2c02      	cmp	r4, #2
 8011838:	d065      	beq.n	8011906 <periodic_thread+0x116>
 801183a:	2c06      	cmp	r4, #6
 801183c:	d10d      	bne.n	801185a <periodic_thread+0x6a>
				commands_send_rotor_pos(utils_angle_difference(mcpwm_foc_get_phase_observer(), mcpwm_foc_get_phase_encoder()));
 801183e:	f00c fad7 	bl	801ddf0 <mcpwm_foc_get_phase_observer>
 8011842:	eeb0 9a40 	vmov.f32	s18, s0
 8011846:	f00c faeb 	bl	801de20 <mcpwm_foc_get_phase_encoder>
 801184a:	eef0 0a40 	vmov.f32	s1, s0
 801184e:	eeb0 0a49 	vmov.f32	s0, s18
 8011852:	f004 f98d 	bl	8015b70 <utils_angle_difference>
 8011856:	f006 ff1b 	bl	8018690 <commands_send_rotor_pos>
		chThdSleepMilliseconds(10);
 801185a:	2064      	movs	r0, #100	; 0x64
 801185c:	f7fc f8c0 	bl	800d9e0 <chThdSleep>
		if (mc_interface_get_state() == MC_STATE_RUNNING) {
 8011860:	f009 fe16 	bl	801b490 <mc_interface_get_state>
 8011864:	2802      	cmp	r0, #2
			ledpwm_set_intensity(LED_GREEN, 1.0);
 8011866:	bf0c      	ite	eq
 8011868:	eeb7 0a00 	vmoveq.f32	s0, #112	; 0x3f800000  1.0
			ledpwm_set_intensity(LED_GREEN, 0.2);
 801186c:	eeb0 0a68 	vmovne.f32	s0, s17
 8011870:	2000      	movs	r0, #0
 8011872:	f000 fddd 	bl	8012430 <ledpwm_set_intensity>
		mc_fault_code fault = mc_interface_get_fault();
 8011876:	f009 fdf3 	bl	801b460 <mc_interface_get_fault>
		if (fault != FAULT_CODE_NONE) {
 801187a:	4605      	mov	r5, r0
 801187c:	2800      	cmp	r0, #0
 801187e:	d0c3      	beq.n	8011808 <periodic_thread+0x18>
			for (int i = 0;i < (int)fault;i++) {
 8011880:	2400      	movs	r4, #0
				ledpwm_set_intensity(LED_RED, 1.0);
 8011882:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8011886:	2001      	movs	r0, #1
 8011888:	f000 fdd2 	bl	8012430 <ledpwm_set_intensity>
				chThdSleepMilliseconds(250);
 801188c:	f640 10c4 	movw	r0, #2500	; 0x9c4
 8011890:	f7fc f8a6 	bl	800d9e0 <chThdSleep>
				ledpwm_set_intensity(LED_RED, 0.0);
 8011894:	2001      	movs	r0, #1
 8011896:	eeb0 0a48 	vmov.f32	s0, s16
			for (int i = 0;i < (int)fault;i++) {
 801189a:	4404      	add	r4, r0
				ledpwm_set_intensity(LED_RED, 0.0);
 801189c:	f000 fdc8 	bl	8012430 <ledpwm_set_intensity>
				chThdSleepMilliseconds(250);
 80118a0:	f640 10c4 	movw	r0, #2500	; 0x9c4
 80118a4:	f7fc f89c 	bl	800d9e0 <chThdSleep>
			for (int i = 0;i < (int)fault;i++) {
 80118a8:	42ac      	cmp	r4, r5
 80118aa:	d1ea      	bne.n	8011882 <periodic_thread+0x92>
			chThdSleepMilliseconds(500);
 80118ac:	f241 3088 	movw	r0, #5000	; 0x1388
 80118b0:	f7fc f896 	bl	800d9e0 <chThdSleep>
		if (mc_interface_get_state() == MC_STATE_DETECTING) {
 80118b4:	f009 fdec 	bl	801b490 <mc_interface_get_state>
 80118b8:	2801      	cmp	r0, #1
 80118ba:	d1ae      	bne.n	801181a <periodic_thread+0x2a>
			commands_send_rotor_pos(mcpwm_get_detect_pos());
 80118bc:	f002 fc20 	bl	8014100 <mcpwm_get_detect_pos>
 80118c0:	f006 fee6 	bl	8018690 <commands_send_rotor_pos>
		disp_pos_mode display_mode = commands_get_disp_pos_mode();
 80118c4:	f006 ff04 	bl	80186d0 <commands_get_disp_pos_mode>
		switch (display_mode) {
 80118c8:	2804      	cmp	r0, #4
		disp_pos_mode display_mode = commands_get_disp_pos_mode();
 80118ca:	4604      	mov	r4, r0
		switch (display_mode) {
 80118cc:	d1aa      	bne.n	8011824 <periodic_thread+0x34>
				commands_send_rotor_pos(mc_interface_get_pid_pos_now());
 80118ce:	f00a fbbf 	bl	801c050 <mc_interface_get_pid_pos_now>
 80118d2:	f006 fedd 	bl	8018690 <commands_send_rotor_pos>
				break;
 80118d6:	e003      	b.n	80118e0 <periodic_thread+0xf0>
				commands_send_rotor_pos(encoder_read_deg());
 80118d8:	f009 f9f2 	bl	801acc0 <encoder_read_deg>
 80118dc:	f006 fed8 	bl	8018690 <commands_send_rotor_pos>
		if (mc_interface_get_configuration()->motor_type == MOTOR_TYPE_FOC) {
 80118e0:	f009 fd8e 	bl	801b400 <mc_interface_get_configuration>
 80118e4:	7883      	ldrb	r3, [r0, #2]
 80118e6:	e7b8      	b.n	801185a <periodic_thread+0x6a>
				commands_send_rotor_pos(utils_angle_difference(mc_interface_get_pid_pos_set(), mc_interface_get_pid_pos_now()));
 80118e8:	f00a fbaa 	bl	801c040 <mc_interface_get_pid_pos_set>
 80118ec:	eeb0 9a40 	vmov.f32	s18, s0
 80118f0:	f00a fbae 	bl	801c050 <mc_interface_get_pid_pos_now>
 80118f4:	eef0 0a40 	vmov.f32	s1, s0
 80118f8:	eeb0 0a49 	vmov.f32	s0, s18
 80118fc:	f004 f938 	bl	8015b70 <utils_angle_difference>
 8011900:	f006 fec6 	bl	8018690 <commands_send_rotor_pos>
				break;
 8011904:	e7ec      	b.n	80118e0 <periodic_thread+0xf0>
				commands_send_rotor_pos(mcpwm_foc_get_phase_observer());
 8011906:	f00c fa73 	bl	801ddf0 <mcpwm_foc_get_phase_observer>
 801190a:	f006 fec1 	bl	8018690 <commands_send_rotor_pos>
				break;
 801190e:	e7a4      	b.n	801185a <periodic_thread+0x6a>
 8011910:	20001a48 	.word	0x20001a48
 8011914:	0802dbd0 	.word	0x0802dbd0
 8011918:	3e4ccccd 	.word	0x3e4ccccd
 801191c:	00000000 	.word	0x00000000

08011920 <main>:
	}
}

int main(void) {
 8011920:	b500      	push	{lr}
 8011922:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
	halInit();
 8011926:	f7fc fd43 	bl	800e3b0 <halInit>
	chSysInit();
 801192a:	f7fb fd99 	bl	800d460 <chSysInit>
	// floating pins.
#ifdef HW_HAS_DRV8313
	INIT_BR();
#endif

	chThdSleepMilliseconds(1000);
 801192e:	f242 7010 	movw	r0, #10000	; 0x2710
 8011932:	f7fc f855 	bl	800d9e0 <chThdSleep>

	hw_init_gpio();
 8011936:	f00e fc63 	bl	8020200 <hw_init_gpio>
	LED_RED_OFF();
 801193a:	4b1c      	ldr	r3, [pc, #112]	; (80119ac <main+0x8c>)
 801193c:	2120      	movs	r1, #32
	LED_GREEN_OFF();
 801193e:	2210      	movs	r2, #16
	LED_RED_OFF();
 8011940:	8359      	strh	r1, [r3, #26]
	LED_GREEN_OFF();
 8011942:	835a      	strh	r2, [r3, #26]

	conf_general_init();
 8011944:	f005 fdfc 	bl	8017540 <conf_general_init>
	ledpwm_init();
 8011948:	f000 fd3a 	bl	80123c0 <ledpwm_init>

	mc_configuration mcconf;
	conf_general_read_mc_configuration(&mcconf);
 801194c:	a835      	add	r0, sp, #212	; 0xd4
 801194e:	f006 f897 	bl	8017a80 <conf_general_read_mc_configuration>
	mc_interface_init(&mcconf);
 8011952:	a835      	add	r0, sp, #212	; 0xd4
 8011954:	f009 fc94 	bl	801b280 <mc_interface_init>

	commands_init();
 8011958:	f006 fe4a 	bl	80185f0 <commands_init>
	comm_usb_init();
 801195c:	f000 fad8 	bl	8011f10 <comm_usb_init>

#if CAN_ENABLE
	comm_can_init();
 8011960:	f008 fe66 	bl	801a630 <comm_can_init>
#endif

	app_configuration appconf;
	conf_general_read_app_configuration(&appconf);
 8011964:	a803      	add	r0, sp, #12
 8011966:	f006 f823 	bl	80179b0 <conf_general_read_app_configuration>
	app_set_configuration(&appconf);
 801196a:	a803      	add	r0, sp, #12
 801196c:	f00e fe20 	bl	80205b0 <app_set_configuration>
	servo_init();
#endif
#endif

	// Threads
	chThdCreateStatic(periodic_thread_wa, sizeof(periodic_thread_wa), NORMALPRIO, periodic_thread, NULL);
 8011970:	2400      	movs	r4, #0
	timeout_init();
 8011972:	f008 fbbd 	bl	801a0f0 <timeout_init>
	timeout_configure(appconf.timeout_msec, appconf.timeout_brake_current);
 8011976:	ed9d 0a05 	vldr	s0, [sp, #20]
 801197a:	9804      	ldr	r0, [sp, #16]
 801197c:	f008 fbe0 	bl	801a140 <timeout_configure>
	chThdCreateStatic(periodic_thread_wa, sizeof(periodic_thread_wa), NORMALPRIO, periodic_thread, NULL);
 8011980:	4b0b      	ldr	r3, [pc, #44]	; (80119b0 <main+0x90>)
 8011982:	9400      	str	r4, [sp, #0]
 8011984:	2240      	movs	r2, #64	; 0x40
 8011986:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 801198a:	480a      	ldr	r0, [pc, #40]	; (80119b4 <main+0x94>)
 801198c:	f7fb fff0 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 8011990:	9400      	str	r4, [sp, #0]
 8011992:	4b09      	ldr	r3, [pc, #36]	; (80119b8 <main+0x98>)
 8011994:	4809      	ldr	r0, [pc, #36]	; (80119bc <main+0x9c>)
 8011996:	2240      	movs	r2, #64	; 0x40
 8011998:	f44f 7106 	mov.w	r1, #536	; 0x218
 801199c:	f7fb ffe8 	bl	800d970 <chThdCreateStatic>
		}
	}
#endif

	for(;;) {
		chThdSleepMilliseconds(10);
 80119a0:	2064      	movs	r0, #100	; 0x64
 80119a2:	f7fc f81d 	bl	800d9e0 <chThdSleep>

		if (encoder_is_configured()) {
 80119a6:	f009 f983 	bl	801acb0 <encoder_is_configured>
 80119aa:	e7f9      	b.n	80119a0 <main+0x80>
 80119ac:	40020800 	.word	0x40020800
 80119b0:	080117f1 	.word	0x080117f1
 80119b4:	200020d8 	.word	0x200020d8
 80119b8:	080117d1 	.word	0x080117d1
 80119bc:	20002670 	.word	0x20002670

080119c0 <get_descriptor>:
		uint8_t dindex,
		uint16_t lang) {

	(void)usbp;
	(void)lang;
	switch (dtype) {
 80119c0:	2902      	cmp	r1, #2
 80119c2:	d006      	beq.n	80119d2 <get_descriptor+0x12>
 80119c4:	2903      	cmp	r1, #3
 80119c6:	d006      	beq.n	80119d6 <get_descriptor+0x16>
 80119c8:	2901      	cmp	r1, #1
		return &vcom_configuration_descriptor;
	case USB_DESCRIPTOR_STRING:
		if (dindex < 4)
			return &vcom_strings[dindex];
	}
	return NULL;
 80119ca:	4806      	ldr	r0, [pc, #24]	; (80119e4 <get_descriptor+0x24>)
 80119cc:	bf18      	it	ne
 80119ce:	2000      	movne	r0, #0
 80119d0:	4770      	bx	lr
		return &vcom_configuration_descriptor;
 80119d2:	4805      	ldr	r0, [pc, #20]	; (80119e8 <get_descriptor+0x28>)
 80119d4:	4770      	bx	lr
		if (dindex < 4)
 80119d6:	2a03      	cmp	r2, #3
			return &vcom_strings[dindex];
 80119d8:	bf9a      	itte	ls
 80119da:	4804      	ldrls	r0, [pc, #16]	; (80119ec <get_descriptor+0x2c>)
 80119dc:	eb00 00c2 	addls.w	r0, r0, r2, lsl #3
	return NULL;
 80119e0:	2000      	movhi	r0, #0
}
 80119e2:	4770      	bx	lr
 80119e4:	0802dcd0 	.word	0x0802dcd0
 80119e8:	0802dc70 	.word	0x0802dc70
 80119ec:	0802dd90 	.word	0x0802dd90

080119f0 <usb_event>:
/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {

	switch (event) {
 80119f0:	2902      	cmp	r1, #2
 80119f2:	d115      	bne.n	8011a20 <usb_event+0x30>
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80119f4:	b538      	push	{r3, r4, r5, lr}
 80119f6:	4605      	mov	r5, r0
 80119f8:	460c      	mov	r4, r1
 80119fa:	2320      	movs	r3, #32
 80119fc:	f383 8811 	msr	BASEPRI, r3
		chSysLockFromISR();

		/* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
		usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
 8011a00:	4a08      	ldr	r2, [pc, #32]	; (8011a24 <usb_event+0x34>)
 8011a02:	2101      	movs	r1, #1
 8011a04:	f7fd f8b4 	bl	800eb70 <usbInitEndpointI>
		usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
 8011a08:	4621      	mov	r1, r4
 8011a0a:	4628      	mov	r0, r5
 8011a0c:	4a06      	ldr	r2, [pc, #24]	; (8011a28 <usb_event+0x38>)
 8011a0e:	f7fd f8af 	bl	800eb70 <usbInitEndpointI>

		/* Resetting the state of the CDC subsystem.*/
		sduConfigureHookI(&SDU1);
 8011a12:	4806      	ldr	r0, [pc, #24]	; (8011a2c <usb_event+0x3c>)
 8011a14:	f7fc ff5c 	bl	800e8d0 <sduConfigureHookI>
 8011a18:	2300      	movs	r3, #0
 8011a1a:	f383 8811 	msr	BASEPRI, r3
		return;
	case USB_EVENT_STALLED:
		return;
	}
	return;
}
 8011a1e:	bd38      	pop	{r3, r4, r5, pc}
 8011a20:	4770      	bx	lr
 8011a22:	bf00      	nop
 8011a24:	0802dbf0 	.word	0x0802dbf0
 8011a28:	0802dc20 	.word	0x0802dc20
 8011a2c:	20002888 	.word	0x20002888

08011a30 <comm_usb_serial_init>:
		USBD2_DATA_REQUEST_EP,
		USBD2_DATA_AVAILABLE_EP,
		USBD2_INTERRUPT_REQUEST_EP
};

void comm_usb_serial_init(void) {
 8011a30:	b570      	push	{r4, r5, r6, lr}
	palSetPadMode(GPIOA, 11,
 8011a32:	4e15      	ldr	r6, [pc, #84]	; (8011a88 <comm_usb_serial_init+0x58>)
	palSetPadMode(GPIOA, 12,
			PAL_MODE_ALTERNATE(GPIO_AF_OTG_FS) |
			PAL_STM32_OTYPE_PUSHPULL |
			PAL_STM32_OSPEED_MID1);

	sduObjectInit(&SDU1);
 8011a34:	4d15      	ldr	r5, [pc, #84]	; (8011a8c <comm_usb_serial_init+0x5c>)
	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 * Note, a delay is inserted in order to not have to disconnect the cable
	 * after a reset.
	 */
	usbDisconnectBus(serusbcfg.usbp);
 8011a36:	4c16      	ldr	r4, [pc, #88]	; (8011a90 <comm_usb_serial_init+0x60>)
	palSetPadMode(GPIOA, 11,
 8011a38:	4630      	mov	r0, r6
 8011a3a:	f240 520a 	movw	r2, #1290	; 0x50a
 8011a3e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8011a42:	f7fe fa0d 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 12,
 8011a46:	f240 520a 	movw	r2, #1290	; 0x50a
 8011a4a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8011a4e:	4630      	mov	r0, r6
 8011a50:	f7fe fa06 	bl	800fe60 <_pal_lld_setgroupmode>
	sduObjectInit(&SDU1);
 8011a54:	4628      	mov	r0, r5
 8011a56:	f7fc fef3 	bl	800e840 <sduObjectInit>
	sduStart(&SDU1, &serusbcfg);
 8011a5a:	490e      	ldr	r1, [pc, #56]	; (8011a94 <comm_usb_serial_init+0x64>)
 8011a5c:	4628      	mov	r0, r5
 8011a5e:	f7fc ff17 	bl	800e890 <sduStart>
	usbDisconnectBus(serusbcfg.usbp);
 8011a62:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8011a64:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8011a66:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8011a6a:	6393      	str	r3, [r2, #56]	; 0x38
	chThdSleepMilliseconds(1500);
 8011a6c:	f643 2098 	movw	r0, #15000	; 0x3a98
 8011a70:	f7fb ffb6 	bl	800d9e0 <chThdSleep>
	usbStart(serusbcfg.usbp, &usbcfg);
 8011a74:	4620      	mov	r0, r4
 8011a76:	4908      	ldr	r1, [pc, #32]	; (8011a98 <comm_usb_serial_init+0x68>)
 8011a78:	f7fd f852 	bl	800eb20 <usbStart>
	usbConnectBus(serusbcfg.usbp);
 8011a7c:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8011a7e:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8011a80:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8011a84:	6393      	str	r3, [r2, #56]	; 0x38
}
 8011a86:	bd70      	pop	{r4, r5, r6, pc}
 8011a88:	40020000 	.word	0x40020000
 8011a8c:	20002888 	.word	0x20002888
 8011a90:	20001db8 	.word	0x20001db8
 8011a94:	0802dc50 	.word	0x0802dc50
 8011a98:	0802dc60 	.word	0x0802dc60
 8011a9c:	00000000 	.word	0x00000000

08011aa0 <Vector88>:
	servo_irq();
	CH_IRQ_EPILOGUE();
}
#endif

CH_IRQ_HANDLER(ADC1_2_3_IRQHandler) {
 8011aa0:	b508      	push	{r3, lr}
	CH_IRQ_PROLOGUE();
	ADC_ClearITPendingBit(ADC1, ADC_IT_JEOC);
 8011aa2:	f240 4107 	movw	r1, #1031	; 0x407
 8011aa6:	4804      	ldr	r0, [pc, #16]	; (8011ab8 <Vector88+0x18>)
 8011aa8:	f012 f98a 	bl	8023dc0 <ADC_ClearITPendingBit>
	mc_interface_adc_inj_int_handler();
 8011aac:	f00b f858 	bl	801cb60 <mc_interface_adc_inj_int_handler>
	CH_IRQ_EPILOGUE();
}
 8011ab0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	CH_IRQ_EPILOGUE();
 8011ab4:	f7fc bc4c 	b.w	800e350 <_port_irq_epilogue>
 8011ab8:	40012000 	.word	0x40012000
 8011abc:	00000000 	.word	0x00000000

08011ac0 <VectorE0>:

CH_IRQ_HANDLER(HW_ENC_EXTI_ISR_VEC) {
 8011ac0:	b508      	push	{r3, lr}
	if (EXTI_GetITStatus(HW_ENC_EXTI_LINE) != RESET) {
 8011ac2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8011ac6:	f012 fabb 	bl	8024040 <EXTI_GetITStatus>
 8011aca:	b900      	cbnz	r0, 8011ace <VectorE0+0xe>
		encoder_reset();

		// Clear the EXTI line pending bit
		EXTI_ClearITPendingBit(HW_ENC_EXTI_LINE);
	}
}
 8011acc:	bd08      	pop	{r3, pc}
		encoder_reset();
 8011ace:	f009 f92f 	bl	801ad30 <encoder_reset>
		EXTI_ClearITPendingBit(HW_ENC_EXTI_LINE);
 8011ad2:	f44f 6000 	mov.w	r0, #2048	; 0x800
}
 8011ad6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EXTI_ClearITPendingBit(HW_ENC_EXTI_LINE);
 8011ada:	f012 bac1 	b.w	8024060 <EXTI_ClearITPendingBit>
 8011ade:	bf00      	nop

08011ae0 <VectorB8>:

CH_IRQ_HANDLER(HW_ENC_TIM_ISR_VEC) {
 8011ae0:	b508      	push	{r3, lr}
	if (TIM_GetITStatus(HW_ENC_TIM, TIM_IT_Update) != RESET) {
 8011ae2:	2101      	movs	r1, #1
 8011ae4:	4806      	ldr	r0, [pc, #24]	; (8011b00 <VectorB8+0x20>)
 8011ae6:	f012 ff0b 	bl	8024900 <TIM_GetITStatus>
 8011aea:	b900      	cbnz	r0, 8011aee <VectorB8+0xe>
		encoder_tim_isr();

		// Clear the IT pending bit
		TIM_ClearITPendingBit(HW_ENC_TIM, TIM_IT_Update);
	}
}
 8011aec:	bd08      	pop	{r3, pc}
		encoder_tim_isr();
 8011aee:	f009 f95f 	bl	801adb0 <encoder_tim_isr>
		TIM_ClearITPendingBit(HW_ENC_TIM, TIM_IT_Update);
 8011af2:	2101      	movs	r1, #1
 8011af4:	4802      	ldr	r0, [pc, #8]	; (8011b00 <VectorB8+0x20>)
}
 8011af6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		TIM_ClearITPendingBit(HW_ENC_TIM, TIM_IT_Update);
 8011afa:	f012 bf11 	b.w	8024920 <TIM_ClearITPendingBit>
 8011afe:	bf00      	nop
 8011b00:	40000800 	.word	0x40000800
	...

08011b10 <VectorF8>:

CH_IRQ_HANDLER(TIM8_CC_IRQHandler) {
 8011b10:	b508      	push	{r3, lr}
	if (TIM_GetITStatus(TIM8, TIM_IT_CC1) != RESET) {
 8011b12:	2102      	movs	r1, #2
 8011b14:	4806      	ldr	r0, [pc, #24]	; (8011b30 <VectorF8+0x20>)
 8011b16:	f012 fef3 	bl	8024900 <TIM_GetITStatus>
 8011b1a:	b900      	cbnz	r0, 8011b1e <VectorF8+0xe>
		mcpwm_foc_tim_sample_int_handler();

		// Clear the IT pending bit
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC1);
	}
}
 8011b1c:	bd08      	pop	{r3, pc}
		mcpwm_foc_tim_sample_int_handler();
 8011b1e:	f00d f8a7 	bl	801ec70 <mcpwm_foc_tim_sample_int_handler>
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC1);
 8011b22:	2102      	movs	r1, #2
 8011b24:	4802      	ldr	r0, [pc, #8]	; (8011b30 <VectorF8+0x20>)
}
 8011b26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC1);
 8011b2a:	f012 bef9 	b.w	8024920 <TIM_ClearITPendingBit>
 8011b2e:	bf00      	nop
 8011b30:	40010400 	.word	0x40010400
	...

08011b40 <buffer_append_int16>:
 8011b40:	6813      	ldr	r3, [r2, #0]
 8011b42:	b430      	push	{r4, r5}
 8011b44:	1c5d      	adds	r5, r3, #1
 8011b46:	120c      	asrs	r4, r1, #8
 8011b48:	6015      	str	r5, [r2, #0]
 8011b4a:	54c4      	strb	r4, [r0, r3]
 8011b4c:	6813      	ldr	r3, [r2, #0]
 8011b4e:	1c5c      	adds	r4, r3, #1
 8011b50:	6014      	str	r4, [r2, #0]
 8011b52:	54c1      	strb	r1, [r0, r3]
 8011b54:	bc30      	pop	{r4, r5}
 8011b56:	4770      	bx	lr
	...

08011b60 <buffer_append_uint16>:
 8011b60:	6813      	ldr	r3, [r2, #0]
 8011b62:	b430      	push	{r4, r5}
 8011b64:	1c5d      	adds	r5, r3, #1
 8011b66:	0a0c      	lsrs	r4, r1, #8
 8011b68:	6015      	str	r5, [r2, #0]
 8011b6a:	54c4      	strb	r4, [r0, r3]
 8011b6c:	6813      	ldr	r3, [r2, #0]
 8011b6e:	1c5c      	adds	r4, r3, #1
 8011b70:	6014      	str	r4, [r2, #0]
 8011b72:	54c1      	strb	r1, [r0, r3]
 8011b74:	bc30      	pop	{r4, r5}
 8011b76:	4770      	bx	lr
	...

08011b80 <buffer_append_int32>:
 8011b80:	6813      	ldr	r3, [r2, #0]
 8011b82:	b430      	push	{r4, r5}
 8011b84:	1c5d      	adds	r5, r3, #1
 8011b86:	160c      	asrs	r4, r1, #24
 8011b88:	6015      	str	r5, [r2, #0]
 8011b8a:	54c4      	strb	r4, [r0, r3]
 8011b8c:	6813      	ldr	r3, [r2, #0]
 8011b8e:	140c      	asrs	r4, r1, #16
 8011b90:	1c5d      	adds	r5, r3, #1
 8011b92:	6015      	str	r5, [r2, #0]
 8011b94:	54c4      	strb	r4, [r0, r3]
 8011b96:	6813      	ldr	r3, [r2, #0]
 8011b98:	120c      	asrs	r4, r1, #8
 8011b9a:	1c5d      	adds	r5, r3, #1
 8011b9c:	6015      	str	r5, [r2, #0]
 8011b9e:	54c4      	strb	r4, [r0, r3]
 8011ba0:	6813      	ldr	r3, [r2, #0]
 8011ba2:	1c5c      	adds	r4, r3, #1
 8011ba4:	6014      	str	r4, [r2, #0]
 8011ba6:	54c1      	strb	r1, [r0, r3]
 8011ba8:	bc30      	pop	{r4, r5}
 8011baa:	4770      	bx	lr
 8011bac:	0000      	movs	r0, r0
	...

08011bb0 <buffer_append_uint32>:
 8011bb0:	6813      	ldr	r3, [r2, #0]
 8011bb2:	b430      	push	{r4, r5}
 8011bb4:	1c5d      	adds	r5, r3, #1
 8011bb6:	0e0c      	lsrs	r4, r1, #24
 8011bb8:	6015      	str	r5, [r2, #0]
 8011bba:	54c4      	strb	r4, [r0, r3]
 8011bbc:	6813      	ldr	r3, [r2, #0]
 8011bbe:	0c0c      	lsrs	r4, r1, #16
 8011bc0:	1c5d      	adds	r5, r3, #1
 8011bc2:	6015      	str	r5, [r2, #0]
 8011bc4:	54c4      	strb	r4, [r0, r3]
 8011bc6:	6813      	ldr	r3, [r2, #0]
 8011bc8:	0a0c      	lsrs	r4, r1, #8
 8011bca:	1c5d      	adds	r5, r3, #1
 8011bcc:	6015      	str	r5, [r2, #0]
 8011bce:	54c4      	strb	r4, [r0, r3]
 8011bd0:	6813      	ldr	r3, [r2, #0]
 8011bd2:	1c5c      	adds	r4, r3, #1
 8011bd4:	6014      	str	r4, [r2, #0]
 8011bd6:	54c1      	strb	r1, [r0, r3]
 8011bd8:	bc30      	pop	{r4, r5}
 8011bda:	4770      	bx	lr
 8011bdc:	0000      	movs	r0, r0
	...

08011be0 <buffer_append_float16>:
 8011be0:	b430      	push	{r4, r5}
 8011be2:	ee60 0a20 	vmul.f32	s1, s0, s1
 8011be6:	b082      	sub	sp, #8
 8011be8:	eefd 7ae0 	vcvt.s32.f32	s15, s1
 8011bec:	680a      	ldr	r2, [r1, #0]
 8011bee:	edcd 7a01 	vstr	s15, [sp, #4]
 8011bf2:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 8011bf6:	1c55      	adds	r5, r2, #1
 8011bf8:	121c      	asrs	r4, r3, #8
 8011bfa:	600d      	str	r5, [r1, #0]
 8011bfc:	5484      	strb	r4, [r0, r2]
 8011bfe:	680a      	ldr	r2, [r1, #0]
 8011c00:	1c54      	adds	r4, r2, #1
 8011c02:	600c      	str	r4, [r1, #0]
 8011c04:	5483      	strb	r3, [r0, r2]
 8011c06:	b002      	add	sp, #8
 8011c08:	bc30      	pop	{r4, r5}
 8011c0a:	4770      	bx	lr
 8011c0c:	0000      	movs	r0, r0
	...

08011c10 <buffer_append_float32>:
 8011c10:	ee60 0a20 	vmul.f32	s1, s0, s1
 8011c14:	460a      	mov	r2, r1
 8011c16:	eefd 7ae0 	vcvt.s32.f32	s15, s1
 8011c1a:	ee17 1a90 	vmov	r1, s15
 8011c1e:	f7ff bfaf 	b.w	8011b80 <buffer_append_int32>
 8011c22:	bf00      	nop
	...

08011c30 <buffer_append_float32_auto>:
 8011c30:	b570      	push	{r4, r5, r6, lr}
 8011c32:	b082      	sub	sp, #8
 8011c34:	ab02      	add	r3, sp, #8
 8011c36:	2400      	movs	r4, #0
 8011c38:	f843 4d04 	str.w	r4, [r3, #-4]!
 8011c3c:	4605      	mov	r5, r0
 8011c3e:	4618      	mov	r0, r3
 8011c40:	460e      	mov	r6, r1
 8011c42:	f013 f875 	bl	8024d30 <frexpf>
 8011c46:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8011c4a:	eef0 7ac0 	vabs.f32	s15, s0
 8011c4e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8011c52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011c56:	da13      	bge.n	8011c80 <buffer_append_float32_auto+0x50>
 8011c58:	9801      	ldr	r0, [sp, #4]
 8011c5a:	05c3      	lsls	r3, r0, #23
 8011c5c:	f003 43ff 	and.w	r3, r3, #2139095040	; 0x7f800000
 8011c60:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8011c64:	ea43 0104 	orr.w	r1, r3, r4
 8011c68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011c6c:	bf48      	it	mi
 8011c6e:	f041 4100 	orrmi.w	r1, r1, #2147483648	; 0x80000000
 8011c72:	4632      	mov	r2, r6
 8011c74:	4628      	mov	r0, r5
 8011c76:	b002      	add	sp, #8
 8011c78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8011c7c:	f7ff bf98 	b.w	8011bb0 <buffer_append_uint32>
 8011c80:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8011c84:	ed9f 7a07 	vldr	s14, [pc, #28]	; 8011ca4 <buffer_append_float32_auto+0x74>
 8011c88:	9b01      	ldr	r3, [sp, #4]
 8011c8a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8011c8e:	f103 007e 	add.w	r0, r3, #126	; 0x7e
 8011c92:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011c96:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011c9a:	ee17 4a90 	vmov	r4, s15
 8011c9e:	f3c4 0416 	ubfx	r4, r4, #0, #23
 8011ca2:	e7da      	b.n	8011c5a <buffer_append_float32_auto+0x2a>
 8011ca4:	4b000000 	.word	0x4b000000
	...

08011cb0 <buffer_get_int16>:
 8011cb0:	680b      	ldr	r3, [r1, #0]
 8011cb2:	18c2      	adds	r2, r0, r3
 8011cb4:	5cc0      	ldrb	r0, [r0, r3]
 8011cb6:	7852      	ldrb	r2, [r2, #1]
 8011cb8:	3302      	adds	r3, #2
 8011cba:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8011cbe:	600b      	str	r3, [r1, #0]
 8011cc0:	b200      	sxth	r0, r0
 8011cc2:	4770      	bx	lr
	...

08011cd0 <buffer_get_uint16>:
 8011cd0:	680b      	ldr	r3, [r1, #0]
 8011cd2:	18c2      	adds	r2, r0, r3
 8011cd4:	5cc0      	ldrb	r0, [r0, r3]
 8011cd6:	7852      	ldrb	r2, [r2, #1]
 8011cd8:	3302      	adds	r3, #2
 8011cda:	600b      	str	r3, [r1, #0]
 8011cdc:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8011ce0:	4770      	bx	lr
 8011ce2:	bf00      	nop
	...

08011cf0 <buffer_get_int32>:
 8011cf0:	b470      	push	{r4, r5, r6}
 8011cf2:	680c      	ldr	r4, [r1, #0]
 8011cf4:	1905      	adds	r5, r0, r4
 8011cf6:	5d03      	ldrb	r3, [r0, r4]
 8011cf8:	78ea      	ldrb	r2, [r5, #3]
 8011cfa:	786e      	ldrb	r6, [r5, #1]
 8011cfc:	78a8      	ldrb	r0, [r5, #2]
 8011cfe:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
 8011d02:	3404      	adds	r4, #4
 8011d04:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8011d08:	600c      	str	r4, [r1, #0]
 8011d0a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8011d0e:	bc70      	pop	{r4, r5, r6}
 8011d10:	4770      	bx	lr
 8011d12:	bf00      	nop
	...

08011d20 <buffer_get_uint32>:
 8011d20:	b470      	push	{r4, r5, r6}
 8011d22:	680c      	ldr	r4, [r1, #0]
 8011d24:	1905      	adds	r5, r0, r4
 8011d26:	5d03      	ldrb	r3, [r0, r4]
 8011d28:	78ea      	ldrb	r2, [r5, #3]
 8011d2a:	786e      	ldrb	r6, [r5, #1]
 8011d2c:	78a8      	ldrb	r0, [r5, #2]
 8011d2e:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
 8011d32:	3404      	adds	r4, #4
 8011d34:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8011d38:	600c      	str	r4, [r1, #0]
 8011d3a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8011d3e:	bc70      	pop	{r4, r5, r6}
 8011d40:	4770      	bx	lr
 8011d42:	bf00      	nop
	...

08011d50 <buffer_get_float32>:
 8011d50:	b508      	push	{r3, lr}
 8011d52:	f7ff ffcd 	bl	8011cf0 <buffer_get_int32>
 8011d56:	ee07 0a90 	vmov	s15, r0
 8011d5a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011d5e:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8011d62:	bd08      	pop	{r3, pc}
	...

08011d70 <buffer_get_float32_auto>:
 8011d70:	b508      	push	{r3, lr}
 8011d72:	f7ff ffd5 	bl	8011d20 <buffer_get_uint32>
 8011d76:	4603      	mov	r3, r0
 8011d78:	f3c0 50c7 	ubfx	r0, r0, #23, #8
 8011d7c:	f3c3 0216 	ubfx	r2, r3, #0, #23
 8011d80:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8011d84:	b900      	cbnz	r0, 8011d88 <buffer_get_float32_auto+0x18>
 8011d86:	b18a      	cbz	r2, 8011dac <buffer_get_float32_auto+0x3c>
 8011d88:	ee07 2a90 	vmov	s15, r2
 8011d8c:	ed9f 7a09 	vldr	s14, [pc, #36]	; 8011db4 <buffer_get_float32_auto+0x44>
 8011d90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011d94:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 8011d98:	eea7 0a87 	vfma.f32	s0, s15, s14
 8011d9c:	387e      	subs	r0, #126	; 0x7e
 8011d9e:	b10b      	cbz	r3, 8011da4 <buffer_get_float32_auto+0x34>
 8011da0:	eeb1 0a40 	vneg.f32	s0, s0
 8011da4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8011da8:	f012 bff2 	b.w	8024d90 <ldexpf>
 8011dac:	ed9f 0a02 	vldr	s0, [pc, #8]	; 8011db8 <buffer_get_float32_auto+0x48>
 8011db0:	e7f5      	b.n	8011d9e <buffer_get_float32_auto+0x2e>
 8011db2:	bf00      	nop
 8011db4:	33800000 	.word	0x33800000
	...

08011dc0 <send_packet>:
	packet_send_packet(data, len, PACKET_HANDLER);
	chMtxUnlock(&send_mutex);
}

static void send_packet(unsigned char *buffer, unsigned int len) {
	chSequentialStreamWrite(&SDU1, buffer, len);
 8011dc0:	4b05      	ldr	r3, [pc, #20]	; (8011dd8 <send_packet+0x18>)
static void send_packet(unsigned char *buffer, unsigned int len) {
 8011dc2:	b410      	push	{r4}
	chSequentialStreamWrite(&SDU1, buffer, len);
 8011dc4:	681c      	ldr	r4, [r3, #0]
 8011dc6:	6824      	ldr	r4, [r4, #0]
 8011dc8:	460a      	mov	r2, r1
 8011dca:	4601      	mov	r1, r0
 8011dcc:	4618      	mov	r0, r3
 8011dce:	4623      	mov	r3, r4
}
 8011dd0:	f85d 4b04 	ldr.w	r4, [sp], #4
	chSequentialStreamWrite(&SDU1, buffer, len);
 8011dd4:	4718      	bx	r3
 8011dd6:	bf00      	nop
 8011dd8:	20002888 	.word	0x20002888
 8011ddc:	00000000 	.word	0x00000000

08011de0 <serial_process_thread>:
 8011de0:	4b11      	ldr	r3, [pc, #68]	; (8011e28 <serial_process_thread+0x48>)
	process_tp = chThdGetSelfX();
 8011de2:	4a12      	ldr	r2, [pc, #72]	; (8011e2c <serial_process_thread+0x4c>)
 8011de4:	699b      	ldr	r3, [r3, #24]
 8011de6:	4912      	ldr	r1, [pc, #72]	; (8011e30 <serial_process_thread+0x50>)
 8011de8:	4c12      	ldr	r4, [pc, #72]	; (8011e34 <serial_process_thread+0x54>)
 8011dea:	4e13      	ldr	r6, [pc, #76]	; (8011e38 <serial_process_thread+0x58>)
static THD_FUNCTION(serial_process_thread, arg) {
 8011dec:	b580      	push	{r7, lr}
 8011dee:	4f13      	ldr	r7, [pc, #76]	; (8011e3c <serial_process_thread+0x5c>)
 8011df0:	6199      	str	r1, [r3, #24]
	process_tp = chThdGetSelfX();
 8011df2:	6013      	str	r3, [r2, #0]
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8011df4:	f04f 0800 	mov.w	r8, #0
		chEvtWaitAny((eventmask_t) 1);
 8011df8:	2001      	movs	r0, #1
 8011dfa:	f7fc f851 	bl	800dea0 <chEvtWaitAny>
 8011dfe:	6823      	ldr	r3, [r4, #0]
		while (serial_rx_read_pos != serial_rx_write_pos) {
 8011e00:	6832      	ldr	r2, [r6, #0]
 8011e02:	429a      	cmp	r2, r3
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8011e04:	f103 0501 	add.w	r5, r3, #1
 8011e08:	f04f 0100 	mov.w	r1, #0
		while (serial_rx_read_pos != serial_rx_write_pos) {
 8011e0c:	d0f4      	beq.n	8011df8 <serial_process_thread+0x18>
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8011e0e:	5cf8      	ldrb	r0, [r7, r3]
 8011e10:	6025      	str	r5, [r4, #0]
 8011e12:	f004 f9e5 	bl	80161e0 <packet_process_byte>
			if (serial_rx_read_pos == SERIAL_RX_BUFFER_SIZE) {
 8011e16:	6823      	ldr	r3, [r4, #0]
 8011e18:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
				serial_rx_read_pos = 0;
 8011e1c:	bf04      	itt	eq
 8011e1e:	f8c4 8000 	streq.w	r8, [r4]
 8011e22:	2300      	moveq	r3, #0
 8011e24:	e7ec      	b.n	8011e00 <serial_process_thread+0x20>
 8011e26:	bf00      	nop
 8011e28:	20001a48 	.word	0x20001a48
 8011e2c:	20002b1c 	.word	0x20002b1c
 8011e30:	0802ddb0 	.word	0x0802ddb0
 8011e34:	20004860 	.word	0x20004860
 8011e38:	20004864 	.word	0x20004864
 8011e3c:	20004060 	.word	0x20004060

08011e40 <serial_read_thread>:
static THD_FUNCTION(serial_read_thread, arg) {
 8011e40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8011e44:	4b15      	ldr	r3, [pc, #84]	; (8011e9c <serial_read_thread+0x5c>)
 8011e46:	4e16      	ldr	r6, [pc, #88]	; (8011ea0 <serial_read_thread+0x60>)
 8011e48:	699b      	ldr	r3, [r3, #24]
 8011e4a:	4a16      	ldr	r2, [pc, #88]	; (8011ea4 <serial_read_thread+0x64>)
 8011e4c:	4d16      	ldr	r5, [pc, #88]	; (8011ea8 <serial_read_thread+0x68>)
 8011e4e:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8011eac <serial_read_thread+0x6c>
 8011e52:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8011eb0 <serial_read_thread+0x70>
 8011e56:	619a      	str	r2, [r3, #24]
 8011e58:	b0a1      	sub	sp, #132	; 0x84
		len = chSequentialStreamRead(&SDU1, (uint8_t*) buffer, 1);
 8011e5a:	4637      	mov	r7, r6
 8011e5c:	466c      	mov	r4, sp
 8011e5e:	6833      	ldr	r3, [r6, #0]
 8011e60:	2201      	movs	r2, #1
 8011e62:	685b      	ldr	r3, [r3, #4]
 8011e64:	4621      	mov	r1, r4
 8011e66:	4638      	mov	r0, r7
 8011e68:	4798      	blx	r3
		for (i = 0;i < len;i++) {
 8011e6a:	2800      	cmp	r0, #0
 8011e6c:	ddf7      	ble.n	8011e5e <serial_read_thread+0x1e>
 8011e6e:	682b      	ldr	r3, [r5, #0]
 8011e70:	4622      	mov	r2, r4
			serial_rx_buffer[serial_rx_write_pos++] = buffer[i];
 8011e72:	f812 1b01 	ldrb.w	r1, [r2], #1
 8011e76:	f809 1003 	strb.w	r1, [r9, r3]
 8011e7a:	3301      	adds	r3, #1
				serial_rx_write_pos = 0;
 8011e7c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
		for (i = 0;i < len;i++) {
 8011e80:	eba2 0104 	sub.w	r1, r2, r4
				serial_rx_write_pos = 0;
 8011e84:	bf08      	it	eq
 8011e86:	2300      	moveq	r3, #0
		for (i = 0;i < len;i++) {
 8011e88:	4288      	cmp	r0, r1
 8011e8a:	dcf2      	bgt.n	8011e72 <serial_read_thread+0x32>
			chEvtSignal(process_tp, (eventmask_t) 1);
 8011e8c:	2101      	movs	r1, #1
 8011e8e:	f8d8 0000 	ldr.w	r0, [r8]
 8011e92:	602b      	str	r3, [r5, #0]
 8011e94:	f7fb fff4 	bl	800de80 <chEvtSignal>
 8011e98:	e7e1      	b.n	8011e5e <serial_read_thread+0x1e>
 8011e9a:	bf00      	nop
 8011e9c:	20001a48 	.word	0x20001a48
 8011ea0:	20002888 	.word	0x20002888
 8011ea4:	0802ddd0 	.word	0x0802ddd0
 8011ea8:	20004864 	.word	0x20004864
 8011eac:	20004060 	.word	0x20004060
 8011eb0:	20002b1c 	.word	0x20002b1c
	...

08011ec0 <process_packet>:
static void process_packet(unsigned char *data, unsigned int len) {
 8011ec0:	b538      	push	{r3, r4, r5, lr}
 8011ec2:	4604      	mov	r4, r0
 8011ec4:	460d      	mov	r5, r1
	commands_set_send_func(send_packet_wrapper);
 8011ec6:	4804      	ldr	r0, [pc, #16]	; (8011ed8 <process_packet+0x18>)
 8011ec8:	f006 fbaa 	bl	8018620 <commands_set_send_func>
	commands_process_packet(data, len);
 8011ecc:	4629      	mov	r1, r5
 8011ece:	4620      	mov	r0, r4
}
 8011ed0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	commands_process_packet(data, len);
 8011ed4:	f006 bd6c 	b.w	80189b0 <commands_process_packet>
 8011ed8:	08011ee1 	.word	0x08011ee1
 8011edc:	00000000 	.word	0x00000000

08011ee0 <send_packet_wrapper>:
static void send_packet_wrapper(unsigned char *data, unsigned int len) {
 8011ee0:	b570      	push	{r4, r5, r6, lr}
	chMtxLock(&send_mutex);
 8011ee2:	4c08      	ldr	r4, [pc, #32]	; (8011f04 <send_packet_wrapper+0x24>)
static void send_packet_wrapper(unsigned char *data, unsigned int len) {
 8011ee4:	4605      	mov	r5, r0
 8011ee6:	460e      	mov	r6, r1
	chMtxLock(&send_mutex);
 8011ee8:	4620      	mov	r0, r4
 8011eea:	f7fb ff21 	bl	800dd30 <chMtxLock>
	packet_send_packet(data, len, PACKET_HANDLER);
 8011eee:	4628      	mov	r0, r5
 8011ef0:	4631      	mov	r1, r6
 8011ef2:	2200      	movs	r2, #0
 8011ef4:	f004 f904 	bl	8016100 <packet_send_packet>
	chMtxUnlock(&send_mutex);
 8011ef8:	4620      	mov	r0, r4
}
 8011efa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	chMtxUnlock(&send_mutex);
 8011efe:	f7fb bf27 	b.w	800dd50 <chMtxUnlock>
 8011f02:	bf00      	nop
 8011f04:	20002b20 	.word	0x20002b20
	...

08011f10 <comm_usb_init>:

void comm_usb_init(void) {
 8011f10:	b510      	push	{r4, lr}
 8011f12:	b082      	sub	sp, #8
	comm_usb_serial_init();
 8011f14:	f7ff fd8c 	bl	8011a30 <comm_usb_serial_init>
	packet_init(send_packet, process_packet, PACKET_HANDLER);
 8011f18:	2200      	movs	r2, #0
 8011f1a:	490d      	ldr	r1, [pc, #52]	; (8011f50 <comm_usb_init+0x40>)
 8011f1c:	480d      	ldr	r0, [pc, #52]	; (8011f54 <comm_usb_init+0x44>)
 8011f1e:	f004 f8df 	bl	80160e0 <packet_init>

	chMtxObjectInit(&send_mutex);

	// Threads
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 8011f22:	2400      	movs	r4, #0
	chMtxObjectInit(&send_mutex);
 8011f24:	480c      	ldr	r0, [pc, #48]	; (8011f58 <comm_usb_init+0x48>)
 8011f26:	f7fb fe93 	bl	800dc50 <chMtxObjectInit>
	chThdCreateStatic(serial_read_thread_wa, sizeof(serial_read_thread_wa), NORMALPRIO, serial_read_thread, NULL);
 8011f2a:	9400      	str	r4, [sp, #0]
 8011f2c:	4b0b      	ldr	r3, [pc, #44]	; (8011f5c <comm_usb_init+0x4c>)
 8011f2e:	480c      	ldr	r0, [pc, #48]	; (8011f60 <comm_usb_init+0x50>)
 8011f30:	2240      	movs	r2, #64	; 0x40
 8011f32:	f44f 7166 	mov.w	r1, #920	; 0x398
 8011f36:	f7fb fd1b 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(serial_process_thread_wa, sizeof(serial_process_thread_wa), NORMALPRIO, serial_process_thread, NULL);
 8011f3a:	9400      	str	r4, [sp, #0]
 8011f3c:	4b09      	ldr	r3, [pc, #36]	; (8011f64 <comm_usb_init+0x54>)
 8011f3e:	480a      	ldr	r0, [pc, #40]	; (8011f68 <comm_usb_init+0x58>)
 8011f40:	2240      	movs	r2, #64	; 0x40
 8011f42:	f241 1198 	movw	r1, #4504	; 0x1198
 8011f46:	f7fb fd13 	bl	800d970 <chThdCreateStatic>
}
 8011f4a:	b002      	add	sp, #8
 8011f4c:	bd10      	pop	{r4, pc}
 8011f4e:	bf00      	nop
 8011f50:	08011ec1 	.word	0x08011ec1
 8011f54:	08011dc1 	.word	0x08011dc1
 8011f58:	20002b20 	.word	0x20002b20
 8011f5c:	08011e41 	.word	0x08011e41
 8011f60:	20003cc8 	.word	0x20003cc8
 8011f64:	08011de1 	.word	0x08011de1
 8011f68:	20002b30 	.word	0x20002b30
 8011f6c:	00000000 	.word	0x00000000

08011f70 <crc16>:
 8011f70:	b191      	cbz	r1, 8011f98 <crc16+0x28>
 8011f72:	b470      	push	{r4, r5, r6}
 8011f74:	4e09      	ldr	r6, [pc, #36]	; (8011f9c <crc16+0x2c>)
 8011f76:	1845      	adds	r5, r0, r1
 8011f78:	2300      	movs	r3, #0
 8011f7a:	f810 2b01 	ldrb.w	r2, [r0], #1
 8011f7e:	f3c3 240f 	ubfx	r4, r3, #8, #16
 8011f82:	4062      	eors	r2, r4
 8011f84:	42a8      	cmp	r0, r5
 8011f86:	f836 1012 	ldrh.w	r1, [r6, r2, lsl #1]
 8011f8a:	ea81 2303 	eor.w	r3, r1, r3, lsl #8
 8011f8e:	b29b      	uxth	r3, r3
 8011f90:	d1f3      	bne.n	8011f7a <crc16+0xa>
 8011f92:	4618      	mov	r0, r3
 8011f94:	bc70      	pop	{r4, r5, r6}
 8011f96:	4770      	bx	lr
 8011f98:	4608      	mov	r0, r1
 8011f9a:	4770      	bx	lr
 8011f9c:	0802dde0 	.word	0x0802dde0

08011fa0 <filter_fft>:
 8011fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011fa4:	ed2d 8b04 	vpush	{d8-d9}
 8011fa8:	2701      	movs	r7, #1
 8011faa:	b085      	sub	sp, #20
 8011fac:	408f      	lsls	r7, r1
 8011fae:	2f01      	cmp	r7, #1
 8011fb0:	9103      	str	r1, [sp, #12]
 8011fb2:	9002      	str	r0, [sp, #8]
 8011fb4:	4691      	mov	r9, r2
 8011fb6:	9300      	str	r3, [sp, #0]
 8011fb8:	dd2b      	ble.n	8012012 <filter_fft+0x72>
 8011fba:	2100      	movs	r1, #0
 8011fbc:	107d      	asrs	r5, r7, #1
 8011fbe:	460a      	mov	r2, r1
 8011fc0:	f109 0404 	add.w	r4, r9, #4
 8011fc4:	1d18      	adds	r0, r3, #4
 8011fc6:	1e7e      	subs	r6, r7, #1
 8011fc8:	4698      	mov	r8, r3
 8011fca:	4295      	cmp	r5, r2
 8011fcc:	462b      	mov	r3, r5
 8011fce:	dc03      	bgt.n	8011fd8 <filter_fft+0x38>
 8011fd0:	1ad2      	subs	r2, r2, r3
 8011fd2:	105b      	asrs	r3, r3, #1
 8011fd4:	429a      	cmp	r2, r3
 8011fd6:	dafb      	bge.n	8011fd0 <filter_fft+0x30>
 8011fd8:	3101      	adds	r1, #1
 8011fda:	42b1      	cmp	r1, r6
 8011fdc:	441a      	add	r2, r3
 8011fde:	d018      	beq.n	8012012 <filter_fft+0x72>
 8011fe0:	428a      	cmp	r2, r1
 8011fe2:	dd13      	ble.n	801200c <filter_fft+0x6c>
 8011fe4:	0093      	lsls	r3, r2, #2
 8011fe6:	eb09 0e03 	add.w	lr, r9, r3
 8011fea:	4443      	add	r3, r8
 8011fec:	f8de b000 	ldr.w	fp, [lr]
 8011ff0:	f8d4 a000 	ldr.w	sl, [r4]
 8011ff4:	f8d0 c000 	ldr.w	ip, [r0]
 8011ff8:	f8c4 b000 	str.w	fp, [r4]
 8011ffc:	f8d3 b000 	ldr.w	fp, [r3]
 8012000:	f8c0 b000 	str.w	fp, [r0]
 8012004:	f8ce a000 	str.w	sl, [lr]
 8012008:	f8c3 c000 	str.w	ip, [r3]
 801200c:	3404      	adds	r4, #4
 801200e:	3004      	adds	r0, #4
 8012010:	e7db      	b.n	8011fca <filter_fft+0x2a>
 8012012:	9b03      	ldr	r3, [sp, #12]
 8012014:	2b00      	cmp	r3, #0
 8012016:	f340 809a 	ble.w	801214e <filter_fft+0x1ae>
 801201a:	2300      	movs	r3, #0
 801201c:	eddf 9a5b 	vldr	s19, [pc, #364]	; 801218c <filter_fft+0x1ec>
 8012020:	9301      	str	r3, [sp, #4]
 8012022:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
 8012026:	f04f 0b01 	mov.w	fp, #1
 801202a:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 801202e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 8012032:	f1bb 0f00 	cmp.w	fp, #0
 8012036:	ea4f 064b 	mov.w	r6, fp, lsl #1
 801203a:	dd56      	ble.n	80120ea <filter_fft+0x14a>
 801203c:	f8dd 8000 	ldr.w	r8, [sp]
 8012040:	ed9f 5a52 	vldr	s10, [pc, #328]	; 801218c <filter_fft+0x1ec>
 8012044:	46ca      	mov	sl, r9
 8012046:	46dc      	mov	ip, fp
 8012048:	ea4f 04cb 	mov.w	r4, fp, lsl #3
 801204c:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
 8012050:	f04f 0e00 	mov.w	lr, #0
 8012054:	4577      	cmp	r7, lr
 8012056:	dd33      	ble.n	80120c0 <filter_fft+0x120>
 8012058:	9b00      	ldr	r3, [sp, #0]
 801205a:	ea4f 018c 	mov.w	r1, ip, lsl #2
 801205e:	eb09 0001 	add.w	r0, r9, r1
 8012062:	4642      	mov	r2, r8
 8012064:	4419      	add	r1, r3
 8012066:	4675      	mov	r5, lr
 8012068:	4653      	mov	r3, sl
 801206a:	ed91 6a00 	vldr	s12, [r1]
 801206e:	edd0 5a00 	vldr	s11, [r0]
 8012072:	edd3 6a00 	vldr	s13, [r3]
 8012076:	ee25 7a46 	vnmul.f32	s14, s10, s12
 801207a:	ee65 7a85 	vmul.f32	s15, s11, s10
 801207e:	eea5 7aa4 	vfma.f32	s14, s11, s9
 8012082:	4435      	add	r5, r6
 8012084:	42af      	cmp	r7, r5
 8012086:	eee6 7a24 	vfma.f32	s15, s12, s9
 801208a:	ee76 6ac7 	vsub.f32	s13, s13, s14
 801208e:	edc0 6a00 	vstr	s13, [r0]
 8012092:	edd2 6a00 	vldr	s13, [r2]
 8012096:	ee76 6ae7 	vsub.f32	s13, s13, s15
 801209a:	4420      	add	r0, r4
 801209c:	edc1 6a00 	vstr	s13, [r1]
 80120a0:	edd3 6a00 	vldr	s13, [r3]
 80120a4:	ee36 7a87 	vadd.f32	s14, s13, s14
 80120a8:	4421      	add	r1, r4
 80120aa:	ed83 7a00 	vstr	s14, [r3]
 80120ae:	ed92 7a00 	vldr	s14, [r2]
 80120b2:	ee77 7a27 	vadd.f32	s15, s14, s15
 80120b6:	4423      	add	r3, r4
 80120b8:	edc2 7a00 	vstr	s15, [r2]
 80120bc:	4422      	add	r2, r4
 80120be:	dcd4      	bgt.n	801206a <filter_fft+0xca>
 80120c0:	ee65 7a69 	vnmul.f32	s15, s10, s19
 80120c4:	f10e 0e01 	add.w	lr, lr, #1
 80120c8:	ee29 5a05 	vmul.f32	s10, s18, s10
 80120cc:	45de      	cmp	lr, fp
 80120ce:	f10a 0a04 	add.w	sl, sl, #4
 80120d2:	f108 0804 	add.w	r8, r8, #4
 80120d6:	f10c 0c01 	add.w	ip, ip, #1
 80120da:	eee9 7a24 	vfma.f32	s15, s18, s9
 80120de:	eea9 5aa4 	vfma.f32	s10, s19, s9
 80120e2:	d002      	beq.n	80120ea <filter_fft+0x14a>
 80120e4:	eef0 4a67 	vmov.f32	s9, s15
 80120e8:	e7b4      	b.n	8012054 <filter_fft+0xb4>
 80120ea:	ee78 7ac9 	vsub.f32	s15, s17, s18
 80120ee:	ee67 7a88 	vmul.f32	s15, s15, s16
 80120f2:	ee17 0a90 	vmov	r0, s15
 80120f6:	f7fa f987 	bl	800c408 <__aeabi_f2d>
 80120fa:	ec41 0b10 	vmov	d0, r0, r1
 80120fe:	f013 f9cf 	bl	80254a0 <sqrt>
 8012102:	ec51 0b10 	vmov	r0, r1, d0
 8012106:	f7fa fcbb 	bl	800ca80 <__aeabi_d2f>
 801210a:	9b02      	ldr	r3, [sp, #8]
 801210c:	ee09 0a90 	vmov	s19, r0
 8012110:	b10b      	cbz	r3, 8012116 <filter_fft+0x176>
 8012112:	eef1 9a69 	vneg.f32	s19, s19
 8012116:	ee39 9a28 	vadd.f32	s18, s18, s17
 801211a:	9b01      	ldr	r3, [sp, #4]
 801211c:	ee69 7a08 	vmul.f32	s15, s18, s16
 8012120:	3301      	adds	r3, #1
 8012122:	ee17 0a90 	vmov	r0, s15
 8012126:	461c      	mov	r4, r3
 8012128:	9301      	str	r3, [sp, #4]
 801212a:	f7fa f96d 	bl	800c408 <__aeabi_f2d>
 801212e:	ec41 0b10 	vmov	d0, r0, r1
 8012132:	f013 f9b5 	bl	80254a0 <sqrt>
 8012136:	ec51 0b10 	vmov	r0, r1, d0
 801213a:	f7fa fca1 	bl	800ca80 <__aeabi_d2f>
 801213e:	9b03      	ldr	r3, [sp, #12]
 8012140:	461a      	mov	r2, r3
 8012142:	42a2      	cmp	r2, r4
 8012144:	ee09 0a10 	vmov	s18, r0
 8012148:	46b3      	mov	fp, r6
 801214a:	f47f af72 	bne.w	8012032 <filter_fft+0x92>
 801214e:	9b02      	ldr	r3, [sp, #8]
 8012150:	b1b3      	cbz	r3, 8012180 <filter_fft+0x1e0>
 8012152:	2f00      	cmp	r7, #0
 8012154:	dd14      	ble.n	8012180 <filter_fft+0x1e0>
 8012156:	ee07 7a90 	vmov	s15, r7
 801215a:	9b00      	ldr	r3, [sp, #0]
 801215c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012160:	eb09 0787 	add.w	r7, r9, r7, lsl #2
 8012164:	edd9 6a00 	vldr	s13, [r9]
 8012168:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801216c:	eca9 7a01 	vstmia	r9!, {s14}
 8012170:	edd3 6a00 	vldr	s13, [r3]
 8012174:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8012178:	454f      	cmp	r7, r9
 801217a:	eca3 7a01 	vstmia	r3!, {s14}
 801217e:	d1f1      	bne.n	8012164 <filter_fft+0x1c4>
 8012180:	b005      	add	sp, #20
 8012182:	ecbd 8b04 	vpop	{d8-d9}
 8012186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801218a:	bf00      	nop
 801218c:	00000000 	.word	0x00000000

08012190 <filter_hamming>:
 8012190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012192:	f011 0501 	ands.w	r5, r1, #1
 8012196:	ed2d 8b04 	vpush	{d8-d9}
 801219a:	460e      	mov	r6, r1
 801219c:	d028      	beq.n	80121f0 <filter_hamming+0x60>
 801219e:	2900      	cmp	r1, #0
 80121a0:	dd23      	ble.n	80121ea <filter_hamming+0x5a>
 80121a2:	1e4b      	subs	r3, r1, #1
 80121a4:	ee08 3a10 	vmov	s16, r3
 80121a8:	eddf 9a2b 	vldr	s19, [pc, #172]	; 8012258 <filter_hamming+0xc8>
 80121ac:	ed9f 9a2b 	vldr	s18, [pc, #172]	; 801225c <filter_hamming+0xcc>
 80121b0:	eddf 8a2b 	vldr	s17, [pc, #172]	; 8012260 <filter_hamming+0xd0>
 80121b4:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 80121b8:	4604      	mov	r4, r0
 80121ba:	2500      	movs	r5, #0
 80121bc:	ee07 5a90 	vmov	s15, r5
 80121c0:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 80121c4:	3501      	adds	r5, #1
 80121c6:	ee20 0a29 	vmul.f32	s0, s0, s19
 80121ca:	ee80 0a08 	vdiv.f32	s0, s0, s16
 80121ce:	f012 fc67 	bl	8024aa0 <cosf>
 80121d2:	42ae      	cmp	r6, r5
 80121d4:	eeb0 7a68 	vmov.f32	s14, s17
 80121d8:	eea0 7a49 	vfms.f32	s14, s0, s18
 80121dc:	edd4 7a00 	vldr	s15, [r4]
 80121e0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80121e4:	ece4 7a01 	vstmia	r4!, {s15}
 80121e8:	d1e8      	bne.n	80121bc <filter_hamming+0x2c>
 80121ea:	ecbd 8b04 	vpop	{d8-d9}
 80121ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80121f0:	eb01 77d1 	add.w	r7, r1, r1, lsr #31
 80121f4:	107f      	asrs	r7, r7, #1
 80121f6:	2f00      	cmp	r7, #0
 80121f8:	ddf7      	ble.n	80121ea <filter_hamming+0x5a>
 80121fa:	1e4b      	subs	r3, r1, #1
 80121fc:	ee08 3a10 	vmov	s16, r3
 8012200:	eddf 9a15 	vldr	s19, [pc, #84]	; 8012258 <filter_hamming+0xc8>
 8012204:	ed9f 9a15 	vldr	s18, [pc, #84]	; 801225c <filter_hamming+0xcc>
 8012208:	eddf 8a15 	vldr	s17, [pc, #84]	; 8012260 <filter_hamming+0xd0>
 801220c:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 8012210:	4604      	mov	r4, r0
 8012212:	eb00 0681 	add.w	r6, r0, r1, lsl #2
 8012216:	ee07 5a90 	vmov	s15, r5
 801221a:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801221e:	3501      	adds	r5, #1
 8012220:	ee20 0a29 	vmul.f32	s0, s0, s19
 8012224:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8012228:	f012 fc3a 	bl	8024aa0 <cosf>
 801222c:	42bd      	cmp	r5, r7
 801222e:	eef0 6a68 	vmov.f32	s13, s17
 8012232:	eee0 6a49 	vfms.f32	s13, s0, s18
 8012236:	ed94 7a00 	vldr	s14, [r4]
 801223a:	ee27 7a26 	vmul.f32	s14, s14, s13
 801223e:	eca4 7a01 	vstmia	r4!, {s14}
 8012242:	ed76 7a01 	vldmdb	r6!, {s15}
 8012246:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801224a:	edc6 7a00 	vstr	s15, [r6]
 801224e:	d1e2      	bne.n	8012216 <filter_hamming+0x86>
 8012250:	ecbd 8b04 	vpop	{d8-d9}
 8012254:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012256:	bf00      	nop
 8012258:	40c90fdb 	.word	0x40c90fdb
 801225c:	3eeb851f 	.word	0x3eeb851f
 8012260:	3f0a3d71 	.word	0x3f0a3d71
	...

08012270 <filter_create_fir_lowpass>:
 8012270:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012274:	f04f 0801 	mov.w	r8, #1
 8012278:	fa08 f801 	lsl.w	r8, r8, r1
 801227c:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8012280:	f104 030a 	add.w	r3, r4, #10
 8012284:	f023 0307 	bic.w	r3, r3, #7
 8012288:	af00      	add	r7, sp, #0
 801228a:	f1b8 0f00 	cmp.w	r8, #0
 801228e:	ebad 0d03 	sub.w	sp, sp, r3
 8012292:	4681      	mov	r9, r0
 8012294:	4692      	mov	sl, r2
 8012296:	466b      	mov	r3, sp
 8012298:	dd1d      	ble.n	80122d6 <filter_create_fir_lowpass+0x66>
 801229a:	ee07 8a90 	vmov	s15, r8
 801229e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80122a2:	f04f 0e00 	mov.w	lr, #0
 80122a6:	ee27 0a80 	vmul.f32	s0, s15, s0
 80122aa:	466d      	mov	r5, sp
 80122ac:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80122b0:	2200      	movs	r2, #0
 80122b2:	ee17 6a90 	vmov	r6, s15
 80122b6:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
 80122ba:	42b2      	cmp	r2, r6
 80122bc:	f102 0201 	add.w	r2, r2, #1
 80122c0:	bfb4      	ite	lt
 80122c2:	f8c0 c000 	strlt.w	ip, [r0]
 80122c6:	f8c0 e000 	strge.w	lr, [r0]
 80122ca:	4590      	cmp	r8, r2
 80122cc:	f845 eb04 	str.w	lr, [r5], #4
 80122d0:	f100 0004 	add.w	r0, r0, #4
 80122d4:	d1f1      	bne.n	80122ba <filter_create_fir_lowpass+0x4a>
 80122d6:	eb08 76d8 	add.w	r6, r8, r8, lsr #31
 80122da:	1076      	asrs	r6, r6, #1
 80122dc:	2e00      	cmp	r6, #0
 80122de:	dd24      	ble.n	801232a <filter_create_fir_lowpass+0xba>
 80122e0:	00b6      	lsls	r6, r6, #2
 80122e2:	eb09 0b06 	add.w	fp, r9, r6
 80122e6:	eb09 0004 	add.w	r0, r9, r4
 80122ea:	464d      	mov	r5, r9
 80122ec:	465c      	mov	r4, fp
 80122ee:	464a      	mov	r2, r9
 80122f0:	f852 eb04 	ldr.w	lr, [r2], #4
 80122f4:	f840 ed04 	str.w	lr, [r0, #-4]!
 80122f8:	4593      	cmp	fp, r2
 80122fa:	d1f9      	bne.n	80122f0 <filter_create_fir_lowpass+0x80>
 80122fc:	464a      	mov	r2, r9
 80122fe:	2001      	movs	r0, #1
 8012300:	f7ff fe4e 	bl	8011fa0 <filter_fft>
 8012304:	445e      	add	r6, fp
 8012306:	682b      	ldr	r3, [r5, #0]
 8012308:	6822      	ldr	r2, [r4, #0]
 801230a:	f845 2b04 	str.w	r2, [r5], #4
 801230e:	f844 3b04 	str.w	r3, [r4], #4
 8012312:	42a6      	cmp	r6, r4
 8012314:	d1f7      	bne.n	8012306 <filter_create_fir_lowpass+0x96>
 8012316:	f1ba 0f00 	cmp.w	sl, #0
 801231a:	d003      	beq.n	8012324 <filter_create_fir_lowpass+0xb4>
 801231c:	4641      	mov	r1, r8
 801231e:	4648      	mov	r0, r9
 8012320:	f7ff ff36 	bl	8012190 <filter_hamming>
 8012324:	46bd      	mov	sp, r7
 8012326:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801232a:	464a      	mov	r2, r9
 801232c:	2001      	movs	r0, #1
 801232e:	f7ff fe37 	bl	8011fa0 <filter_fft>
 8012332:	e7f0      	b.n	8012316 <filter_create_fir_lowpass+0xa6>
	...

08012340 <filter_run_fir_iteration>:
 8012340:	b470      	push	{r4, r5, r6}
 8012342:	2401      	movs	r4, #1
 8012344:	f1c2 0620 	rsb	r6, r2, #32
 8012348:	fa04 f202 	lsl.w	r2, r4, r2
 801234c:	f04f 35ff 	mov.w	r5, #4294967295
 8012350:	2a00      	cmp	r2, #0
 8012352:	fa25 f506 	lsr.w	r5, r5, r6
 8012356:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8012380 <filter_run_fir_iteration+0x40>
 801235a:	dd0e      	ble.n	801237a <filter_run_fir_iteration+0x3a>
 801235c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8012360:	eb00 0483 	add.w	r4, r0, r3, lsl #2
 8012364:	ecb1 7a01 	vldmia	r1!, {s14}
 8012368:	edd4 7a00 	vldr	s15, [r4]
 801236c:	3301      	adds	r3, #1
 801236e:	428a      	cmp	r2, r1
 8012370:	ea03 0305 	and.w	r3, r3, r5
 8012374:	eea7 0a27 	vfma.f32	s0, s14, s15
 8012378:	d1f2      	bne.n	8012360 <filter_run_fir_iteration+0x20>
 801237a:	bc70      	pop	{r4, r5, r6}
 801237c:	4770      	bx	lr
 801237e:	bf00      	nop
	...

08012390 <filter_add_sample>:
 8012390:	6813      	ldr	r3, [r2, #0]
 8012392:	b410      	push	{r4}
 8012394:	f1c1 0120 	rsb	r1, r1, #32
 8012398:	f04f 34ff 	mov.w	r4, #4294967295
 801239c:	fa24 f101 	lsr.w	r1, r4, r1
 80123a0:	1c5c      	adds	r4, r3, #1
 80123a2:	400c      	ands	r4, r1
 80123a4:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80123a8:	ed80 0a00 	vstr	s0, [r0]
 80123ac:	6014      	str	r4, [r2, #0]
 80123ae:	f85d 4b04 	ldr.w	r4, [sp], #4
 80123b2:	4770      	bx	lr
	...

080123c0 <ledpwm_init>:

// Private variables
static volatile int led_values[LEDPWM_LED_NUM];
static uint8_t gamma_table[LEDPWM_CNT_TOP + 1];

void ledpwm_init(void) {
 80123c0:	b570      	push	{r4, r5, r6, lr}
	memset((int*)led_values, 0, sizeof(led_values));
 80123c2:	4b14      	ldr	r3, [pc, #80]	; (8012414 <ledpwm_init+0x54>)
 80123c4:	4d14      	ldr	r5, [pc, #80]	; (8012418 <ledpwm_init+0x58>)
void ledpwm_init(void) {
 80123c6:	ed2d 8b02 	vpush	{d8}
	memset((int*)led_values, 0, sizeof(led_values));
 80123ca:	2200      	movs	r2, #0

	// Generate gamma correction table
	for (int i = 0;i < (LEDPWM_CNT_TOP + 1);i++) {
		gamma_table[i] = (int)roundf(powf((float)i / (float)LEDPWM_CNT_TOP, 1.0 / 0.45) * (float)LEDPWM_CNT_TOP);
 80123cc:	ed9f 8a13 	vldr	s16, [pc, #76]	; 801241c <ledpwm_init+0x5c>
 80123d0:	eddf 8a13 	vldr	s17, [pc, #76]	; 8012420 <ledpwm_init+0x60>
	memset((int*)led_values, 0, sizeof(led_values));
 80123d4:	601a      	str	r2, [r3, #0]
 80123d6:	f105 06c9 	add.w	r6, r5, #201	; 0xc9
 80123da:	605a      	str	r2, [r3, #4]
 80123dc:	462c      	mov	r4, r5
		gamma_table[i] = (int)roundf(powf((float)i / (float)LEDPWM_CNT_TOP, 1.0 / 0.45) * (float)LEDPWM_CNT_TOP);
 80123de:	1b63      	subs	r3, r4, r5
 80123e0:	ee00 3a10 	vmov	s0, r3
 80123e4:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80123e8:	eef0 0a68 	vmov.f32	s1, s17
 80123ec:	ee80 0a08 	vdiv.f32	s0, s0, s16
 80123f0:	f012 fd96 	bl	8024f20 <powf>
 80123f4:	ee20 0a08 	vmul.f32	s0, s0, s16
 80123f8:	f012 ff6a 	bl	80252d0 <roundf>
 80123fc:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8012400:	ee17 3a90 	vmov	r3, s15
 8012404:	f804 3b01 	strb.w	r3, [r4], #1
	for (int i = 0;i < (LEDPWM_CNT_TOP + 1);i++) {
 8012408:	42b4      	cmp	r4, r6
 801240a:	d1e8      	bne.n	80123de <ledpwm_init+0x1e>
	}
}
 801240c:	ecbd 8b02 	vpop	{d8}
 8012410:	bd70      	pop	{r4, r5, r6, pc}
 8012412:	bf00      	nop
 8012414:	20004938 	.word	0x20004938
 8012418:	2000486c 	.word	0x2000486c
 801241c:	43480000 	.word	0x43480000
 8012420:	400e38e4 	.word	0x400e38e4
	...

08012430 <ledpwm_set_intensity>:
 * according to human luminance perception.
 *
 * Intensity range is 0.0 to 1.0
 */
void ledpwm_set_intensity(unsigned int led, float intensity) {
	if (led >= LEDPWM_LED_NUM) {
 8012430:	2801      	cmp	r0, #1
 8012432:	d900      	bls.n	8012436 <ledpwm_set_intensity+0x6>
	if (intensity > 1.0) {
		intensity = 1.0;
	}

	led_values[led] = gamma_table[(int)(intensity * LEDPWM_CNT_TOP)];
}
 8012434:	4770      	bx	lr
	if (intensity < 0.0) {
 8012436:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801243a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801243e:	d40e      	bmi.n	801245e <ledpwm_set_intensity+0x2e>
	if (intensity > 1.0) {
 8012440:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012444:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8012448:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801244c:	bfc8      	it	gt
 801244e:	23c8      	movgt	r3, #200	; 0xc8
 8012450:	dd07      	ble.n	8012462 <ledpwm_set_intensity+0x32>
	led_values[led] = gamma_table[(int)(intensity * LEDPWM_CNT_TOP)];
 8012452:	4908      	ldr	r1, [pc, #32]	; (8012474 <ledpwm_set_intensity+0x44>)
 8012454:	4a08      	ldr	r2, [pc, #32]	; (8012478 <ledpwm_set_intensity+0x48>)
 8012456:	5ccb      	ldrb	r3, [r1, r3]
 8012458:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
 801245c:	4770      	bx	lr
 801245e:	2300      	movs	r3, #0
 8012460:	e7f7      	b.n	8012452 <ledpwm_set_intensity+0x22>
 8012462:	eddf 7a06 	vldr	s15, [pc, #24]	; 801247c <ledpwm_set_intensity+0x4c>
 8012466:	ee20 0a27 	vmul.f32	s0, s0, s15
 801246a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 801246e:	ee17 3a90 	vmov	r3, s15
 8012472:	e7ee      	b.n	8012452 <ledpwm_set_intensity+0x22>
 8012474:	2000486c 	.word	0x2000486c
 8012478:	20004938 	.word	0x20004938
 801247c:	43480000 	.word	0x43480000

08012480 <ledpwm_update_pwm>:
/*
 * Call this function as fast as possible, with a deterministic rate.
 */
void ledpwm_update_pwm(void) {
	static int cnt = 0;
	cnt++;
 8012480:	4a0c      	ldr	r2, [pc, #48]	; (80124b4 <ledpwm_update_pwm+0x34>)
 8012482:	6813      	ldr	r3, [r2, #0]
 8012484:	3301      	adds	r3, #1
	if (cnt == LEDPWM_CNT_TOP) {
 8012486:	2bc8      	cmp	r3, #200	; 0xc8
		cnt = 0;
 8012488:	bf08      	it	eq
 801248a:	2300      	moveq	r3, #0
 801248c:	6013      	str	r3, [r2, #0]
	}

	if (cnt >= led_values[0]) {
 801248e:	4a0a      	ldr	r2, [pc, #40]	; (80124b8 <ledpwm_update_pwm+0x38>)
 8012490:	6811      	ldr	r1, [r2, #0]
 8012492:	4299      	cmp	r1, r3
		LED_GREEN_OFF();
 8012494:	4909      	ldr	r1, [pc, #36]	; (80124bc <ledpwm_update_pwm+0x3c>)
 8012496:	f04f 0010 	mov.w	r0, #16
 801249a:	bfd4      	ite	le
 801249c:	8348      	strhle	r0, [r1, #26]
	} else {
		LED_GREEN_ON();
 801249e:	8308      	strhgt	r0, [r1, #24]
	}

	if (cnt >= led_values[1]) {
 80124a0:	6852      	ldr	r2, [r2, #4]
 80124a2:	429a      	cmp	r2, r3
		LED_RED_OFF();
 80124a4:	4b05      	ldr	r3, [pc, #20]	; (80124bc <ledpwm_update_pwm+0x3c>)
 80124a6:	f04f 0220 	mov.w	r2, #32
 80124aa:	bfd4      	ite	le
 80124ac:	835a      	strhle	r2, [r3, #26]
	} else {
		LED_RED_ON();
 80124ae:	831a      	strhgt	r2, [r3, #24]
	}
}
 80124b0:	4770      	bx	lr
 80124b2:	bf00      	nop
 80124b4:	20004868 	.word	0x20004868
 80124b8:	20004938 	.word	0x20004938
 80124bc:	40020800 	.word	0x40020800

080124c0 <update_adc_sample_pos>:
 * 4		0		+		-
 * 5		-		+		0
 * 6		-		0		+
 */

static void update_adc_sample_pos(mc_timer_struct *timer_tmp) {
 80124c0:	b4f0      	push	{r4, r5, r6, r7}
 80124c2:	b086      	sub	sp, #24
	volatile uint32_t duty = timer_tmp->duty;
 80124c4:	6882      	ldr	r2, [r0, #8]
 80124c6:	9201      	str	r2, [sp, #4]
	volatile uint32_t top = timer_tmp->top;
 80124c8:	6842      	ldr	r2, [r0, #4]
 80124ca:	9202      	str	r2, [sp, #8]
	volatile uint32_t val_sample = timer_tmp->val_sample;
 80124cc:	68c2      	ldr	r2, [r0, #12]
 80124ce:	9203      	str	r2, [sp, #12]
	volatile uint32_t curr1_sample = timer_tmp->curr1_sample;
 80124d0:	6902      	ldr	r2, [r0, #16]
 80124d2:	9204      	str	r2, [sp, #16]
	volatile uint32_t curr2_sample = timer_tmp->curr2_sample;
 80124d4:	6942      	ldr	r2, [r0, #20]

#ifdef HW_HAS_3_SHUNTS
	volatile uint32_t curr3_sample = timer_tmp->curr3_sample;
#endif

	if (duty > (uint32_t)((float)top * conf->l_max_duty)) {
 80124d6:	4b65      	ldr	r3, [pc, #404]	; (801266c <update_adc_sample_pos+0x1ac>)
	volatile uint32_t curr2_sample = timer_tmp->curr2_sample;
 80124d8:	9205      	str	r2, [sp, #20]
	if (duty > (uint32_t)((float)top * conf->l_max_duty)) {
 80124da:	eddd 7a02 	vldr	s15, [sp, #8]
 80124de:	681a      	ldr	r2, [r3, #0]
 80124e0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80124e4:	ed92 7a16 	vldr	s14, [r2, #88]	; 0x58
 80124e8:	9b01      	ldr	r3, [sp, #4]
 80124ea:	ee67 7a87 	vmul.f32	s15, s15, s14
 80124ee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80124f2:	ee17 1a90 	vmov	r1, s15
 80124f6:	4299      	cmp	r1, r3
 80124f8:	d20b      	bcs.n	8012512 <update_adc_sample_pos+0x52>
		duty = (uint32_t)((float)top * conf->l_max_duty);
 80124fa:	eddd 7a02 	vldr	s15, [sp, #8]
 80124fe:	ed92 7a16 	vldr	s14, [r2, #88]	; 0x58
 8012502:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012506:	ee67 7a87 	vmul.f32	s15, s15, s14
 801250a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801250e:	edcd 7a01 	vstr	s15, [sp, #4]
	}

	curr_samp_volt = 0;
 8012512:	4957      	ldr	r1, [pc, #348]	; (8012670 <update_adc_sample_pos+0x1b0>)
 8012514:	2300      	movs	r3, #0
 8012516:	600b      	str	r3, [r1, #0]

	if (conf->motor_type == MOTOR_TYPE_DC) {
 8012518:	7893      	ldrb	r3, [r2, #2]
 801251a:	b2db      	uxtb	r3, r3
 801251c:	2b01      	cmp	r3, #1
 801251e:	d045      	beq.n	80125ac <update_adc_sample_pos+0xec>
		//		} else {
		//			val_sample = duty / 2;
		//		}
	} else {
		// Sample the ADC at an appropriate time during the pwm cycle
		if (IS_DETECTING()) {
 8012520:	4b54      	ldr	r3, [pc, #336]	; (8012674 <update_adc_sample_pos+0x1b4>)
 8012522:	781b      	ldrb	r3, [r3, #0]
 8012524:	2b01      	cmp	r3, #1
 8012526:	d027      	beq.n	8012578 <update_adc_sample_pos+0xb8>
			curr2_sample = (top - duty) / 2 + duty;
#ifdef HW_HAS_3_SHUNTS
			curr3_sample = (top - duty) / 2 + duty;
#endif
		} else {
			if (conf->pwm_mode == PWM_MODE_BIPOLAR) {
 8012528:	7813      	ldrb	r3, [r2, #0]
 801252a:	2b02      	cmp	r3, #2
 801252c:	d055      	beq.n	80125da <update_adc_sample_pos+0x11a>
					}
					break;
				}
			} else {
				// Voltage samples
				val_sample = duty / 2;
 801252e:	9b01      	ldr	r3, [sp, #4]
 8012530:	085b      	lsrs	r3, r3, #1
 8012532:	9303      	str	r3, [sp, #12]

				// Current samples
				curr1_sample = duty + (top - duty) / 2;
 8012534:	9a02      	ldr	r2, [sp, #8]
 8012536:	9c01      	ldr	r4, [sp, #4]
 8012538:	9b01      	ldr	r3, [sp, #4]
 801253a:	1b12      	subs	r2, r2, r4
 801253c:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8012540:	9304      	str	r3, [sp, #16]
				if (curr1_sample > (top - 70)) {
 8012542:	9b02      	ldr	r3, [sp, #8]
 8012544:	9a04      	ldr	r2, [sp, #16]
 8012546:	3b46      	subs	r3, #70	; 0x46
 8012548:	4293      	cmp	r3, r2
 801254a:	d202      	bcs.n	8012552 <update_adc_sample_pos+0x92>
					curr1_sample = top - 70;
 801254c:	9b02      	ldr	r3, [sp, #8]
 801254e:	3b46      	subs	r3, #70	; 0x46
 8012550:	9304      	str	r3, [sp, #16]
				}

				curr2_sample = curr1_sample;
 8012552:	9b04      	ldr	r3, [sp, #16]
 8012554:	9305      	str	r3, [sp, #20]
				curr3_sample = curr1_sample;
#endif

				// The off sampling time is short, so use the on sampling time
				// where possible
				if (duty > (top / 2)) {
 8012556:	9a02      	ldr	r2, [sp, #8]
 8012558:	9b01      	ldr	r3, [sp, #4]
 801255a:	ebb3 0f52 	cmp.w	r3, r2, lsr #1
 801255e:	d91c      	bls.n	801259a <update_adc_sample_pos+0xda>
						case 6: curr_samp_volt = (1 << 0) || (1 << 1); break;
						default: break;
						}
					}
#else
					if (direction) {
 8012560:	4b45      	ldr	r3, [pc, #276]	; (8012678 <update_adc_sample_pos+0x1b8>)
 8012562:	681b      	ldr	r3, [r3, #0]
						case 5: curr_samp_volt = (1 << 0); break;
						case 6: curr_samp_volt = (1 << 0) || (1 << 1); break;
						default: break;
						}
					} else {
						switch (comm_step) {
 8012564:	4b45      	ldr	r3, [pc, #276]	; (801267c <update_adc_sample_pos+0x1bc>)
 8012566:	681b      	ldr	r3, [r3, #0]
 8012568:	3b01      	subs	r3, #1
 801256a:	2b05      	cmp	r3, #5
 801256c:	d815      	bhi.n	801259a <update_adc_sample_pos+0xda>
 801256e:	e8df f003 	tbb	[pc, r3]
 8012572:	4b31      	.short	0x4b31
 8012574:	3131314b 	.word	0x3131314b
			val_sample = duty / 2;
 8012578:	9b01      	ldr	r3, [sp, #4]
 801257a:	085b      	lsrs	r3, r3, #1
 801257c:	9303      	str	r3, [sp, #12]
			curr1_sample = (top - duty) / 2 + duty;
 801257e:	9a02      	ldr	r2, [sp, #8]
 8012580:	9901      	ldr	r1, [sp, #4]
 8012582:	9b01      	ldr	r3, [sp, #4]
 8012584:	1a52      	subs	r2, r2, r1
 8012586:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 801258a:	9304      	str	r3, [sp, #16]
			curr2_sample = (top - duty) / 2 + duty;
 801258c:	9a02      	ldr	r2, [sp, #8]
 801258e:	9901      	ldr	r1, [sp, #4]
 8012590:	9b01      	ldr	r3, [sp, #4]
 8012592:	1a52      	subs	r2, r2, r1
 8012594:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8012598:	9305      	str	r3, [sp, #20]
				}
			}
		}
	}

	timer_tmp->val_sample = val_sample;
 801259a:	9b03      	ldr	r3, [sp, #12]
 801259c:	60c3      	str	r3, [r0, #12]
	timer_tmp->curr1_sample = curr1_sample;
 801259e:	9b04      	ldr	r3, [sp, #16]
 80125a0:	6103      	str	r3, [r0, #16]
	timer_tmp->curr2_sample = curr2_sample;
 80125a2:	9b05      	ldr	r3, [sp, #20]
 80125a4:	6143      	str	r3, [r0, #20]
#ifdef HW_HAS_3_SHUNTS
	timer_tmp->curr3_sample = curr3_sample;
#endif
}
 80125a6:	b006      	add	sp, #24
 80125a8:	bcf0      	pop	{r4, r5, r6, r7}
 80125aa:	4770      	bx	lr
		curr1_sample = top - 10; // Not used anyway
 80125ac:	9a02      	ldr	r2, [sp, #8]
 80125ae:	3a0a      	subs	r2, #10
 80125b0:	9204      	str	r2, [sp, #16]
		curr2_sample = top - 10;
 80125b2:	9a02      	ldr	r2, [sp, #8]
 80125b4:	3a0a      	subs	r2, #10
 80125b6:	9205      	str	r2, [sp, #20]
		if (duty > 1000) {
 80125b8:	9a01      	ldr	r2, [sp, #4]
 80125ba:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 80125be:	d903      	bls.n	80125c8 <update_adc_sample_pos+0x108>
			val_sample = duty / 2;
 80125c0:	9b01      	ldr	r3, [sp, #4]
 80125c2:	085b      	lsrs	r3, r3, #1
 80125c4:	9303      	str	r3, [sp, #12]
 80125c6:	e7e8      	b.n	801259a <update_adc_sample_pos+0xda>
			val_sample = duty + 800;
 80125c8:	9a01      	ldr	r2, [sp, #4]
 80125ca:	f502 7248 	add.w	r2, r2, #800	; 0x320
 80125ce:	9203      	str	r2, [sp, #12]
			curr_samp_volt = (1 << 0) || (1 << 1) || (1 << 2);
 80125d0:	600b      	str	r3, [r1, #0]
 80125d2:	e7e2      	b.n	801259a <update_adc_sample_pos+0xda>
						case 6: curr_samp_volt = (1 << 0); break;
 80125d4:	2301      	movs	r3, #1
 80125d6:	600b      	str	r3, [r1, #0]
 80125d8:	e7df      	b.n	801259a <update_adc_sample_pos+0xda>
				uint32_t samp_neg = top - 2;
 80125da:	9d02      	ldr	r5, [sp, #8]
				uint32_t samp_pos = duty + (top - duty) / 2;
 80125dc:	9a02      	ldr	r2, [sp, #8]
 80125de:	9f01      	ldr	r7, [sp, #4]
 80125e0:	9c01      	ldr	r4, [sp, #4]
				uint32_t samp_zero = top - 2;
 80125e2:	9e02      	ldr	r6, [sp, #8]
				val_sample = top / 4;
 80125e4:	9b02      	ldr	r3, [sp, #8]
 80125e6:	089b      	lsrs	r3, r3, #2
 80125e8:	9303      	str	r3, [sp, #12]
				switch (comm_step) {
 80125ea:	4b24      	ldr	r3, [pc, #144]	; (801267c <update_adc_sample_pos+0x1bc>)
 80125ec:	681b      	ldr	r3, [r3, #0]
				uint32_t samp_pos = duty + (top - duty) / 2;
 80125ee:	1bd2      	subs	r2, r2, r7
				switch (comm_step) {
 80125f0:	3b01      	subs	r3, #1
				uint32_t samp_neg = top - 2;
 80125f2:	3d02      	subs	r5, #2
				uint32_t samp_pos = duty + (top - duty) / 2;
 80125f4:	eb04 0252 	add.w	r2, r4, r2, lsr #1
				uint32_t samp_zero = top - 2;
 80125f8:	3e02      	subs	r6, #2
				switch (comm_step) {
 80125fa:	2b05      	cmp	r3, #5
 80125fc:	d8cd      	bhi.n	801259a <update_adc_sample_pos+0xda>
 80125fe:	e8df f003 	tbb	[pc, r3]
 8012602:	232c      	.short	0x232c
 8012604:	060e171d 	.word	0x060e171d
						case 3: curr_samp_volt = (1 << 1); break;
 8012608:	2302      	movs	r3, #2
 801260a:	600b      	str	r3, [r1, #0]
 801260c:	e7c5      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 801260e:	4b1a      	ldr	r3, [pc, #104]	; (8012678 <update_adc_sample_pos+0x1b8>)
 8012610:	681b      	ldr	r3, [r3, #0]
 8012612:	b143      	cbz	r3, 8012626 <update_adc_sample_pos+0x166>
						curr_samp_volt = (1 << 0);
 8012614:	2301      	movs	r3, #1
						curr1_sample = samp_neg;
 8012616:	9504      	str	r5, [sp, #16]
						curr2_sample = samp_zero;
 8012618:	9605      	str	r6, [sp, #20]
						curr_samp_volt = (1 << 0);
 801261a:	600b      	str	r3, [r1, #0]
 801261c:	e7bd      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 801261e:	4b16      	ldr	r3, [pc, #88]	; (8012678 <update_adc_sample_pos+0x1b8>)
 8012620:	681b      	ldr	r3, [r3, #0]
 8012622:	2b00      	cmp	r3, #0
 8012624:	d0f6      	beq.n	8012614 <update_adc_sample_pos+0x154>
						curr_samp_volt = (1 << 0);
 8012626:	2301      	movs	r3, #1
						curr1_sample = samp_neg;
 8012628:	9504      	str	r5, [sp, #16]
						curr2_sample = samp_pos;
 801262a:	9205      	str	r2, [sp, #20]
						curr_samp_volt = (1 << 0);
 801262c:	600b      	str	r3, [r1, #0]
 801262e:	e7b4      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 8012630:	4b11      	ldr	r3, [pc, #68]	; (8012678 <update_adc_sample_pos+0x1b8>)
 8012632:	681b      	ldr	r3, [r3, #0]
 8012634:	b1ab      	cbz	r3, 8012662 <update_adc_sample_pos+0x1a2>
						curr1_sample = samp_zero;
 8012636:	9604      	str	r6, [sp, #16]
						curr2_sample = samp_pos;
 8012638:	9205      	str	r2, [sp, #20]
 801263a:	e7ae      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 801263c:	4b0e      	ldr	r3, [pc, #56]	; (8012678 <update_adc_sample_pos+0x1b8>)
 801263e:	681b      	ldr	r3, [r3, #0]
 8012640:	b133      	cbz	r3, 8012650 <update_adc_sample_pos+0x190>
						curr1_sample = samp_pos;
 8012642:	9204      	str	r2, [sp, #16]
						curr2_sample = samp_zero;
 8012644:	9605      	str	r6, [sp, #20]
 8012646:	e7a8      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 8012648:	4b0b      	ldr	r3, [pc, #44]	; (8012678 <update_adc_sample_pos+0x1b8>)
 801264a:	681b      	ldr	r3, [r3, #0]
 801264c:	2b00      	cmp	r3, #0
 801264e:	d0f8      	beq.n	8012642 <update_adc_sample_pos+0x182>
						curr_samp_volt = (1 << 1);
 8012650:	2302      	movs	r3, #2
						curr1_sample = samp_pos;
 8012652:	9204      	str	r2, [sp, #16]
						curr2_sample = samp_neg;
 8012654:	9505      	str	r5, [sp, #20]
						curr_samp_volt = (1 << 1);
 8012656:	600b      	str	r3, [r1, #0]
 8012658:	e79f      	b.n	801259a <update_adc_sample_pos+0xda>
					if (direction) {
 801265a:	4b07      	ldr	r3, [pc, #28]	; (8012678 <update_adc_sample_pos+0x1b8>)
 801265c:	681b      	ldr	r3, [r3, #0]
 801265e:	2b00      	cmp	r3, #0
 8012660:	d0e9      	beq.n	8012636 <update_adc_sample_pos+0x176>
						curr_samp_volt = (1 << 1);
 8012662:	2302      	movs	r3, #2
						curr1_sample = samp_zero;
 8012664:	9604      	str	r6, [sp, #16]
						curr2_sample = samp_neg;
 8012666:	9505      	str	r5, [sp, #20]
						curr_samp_volt = (1 << 1);
 8012668:	600b      	str	r3, [r1, #0]
 801266a:	e796      	b.n	801259a <update_adc_sample_pos+0xda>
 801266c:	20004d50 	.word	0x20004d50
 8012670:	20004d68 	.word	0x20004d68
 8012674:	200059f4 	.word	0x200059f4
 8012678:	20004e18 	.word	0x20004e18
 801267c:	20004d4c 	.word	0x20004d4c

08012680 <update_rpm_tacho>:

static void update_rpm_tacho(void) {
	int step = comm_step - 1;
 8012680:	4b1f      	ldr	r3, [pc, #124]	; (8012700 <update_rpm_tacho+0x80>)
	static int last_step = 0;
	int tacho_diff = (step - last_step) % 6;
 8012682:	4820      	ldr	r0, [pc, #128]	; (8012704 <update_rpm_tacho+0x84>)
	int step = comm_step - 1;
 8012684:	6819      	ldr	r1, [r3, #0]
	int tacho_diff = (step - last_step) % 6;
 8012686:	6802      	ldr	r2, [r0, #0]
 8012688:	4b1f      	ldr	r3, [pc, #124]	; (8012708 <update_rpm_tacho+0x88>)
	int step = comm_step - 1;
 801268a:	3901      	subs	r1, #1
	int tacho_diff = (step - last_step) % 6;
 801268c:	1a8a      	subs	r2, r1, r2
static void update_rpm_tacho(void) {
 801268e:	b410      	push	{r4}
	int tacho_diff = (step - last_step) % 6;
 8012690:	fb83 4302 	smull	r4, r3, r3, r2
 8012694:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 8012698:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801269c:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
	last_step = step;

	if (tacho_diff > 3) {
 80126a0:	2b03      	cmp	r3, #3
	last_step = step;
 80126a2:	6001      	str	r1, [r0, #0]
	if (tacho_diff > 3) {
 80126a4:	dd1e      	ble.n	80126e4 <update_rpm_tacho+0x64>
		tacho_diff -= 6;
 80126a6:	3b06      	subs	r3, #6
	} else if (tacho_diff < -2) {
		tacho_diff += 6;
	}

	if (tacho_diff != 0) {
		rpm_dep.comms += tacho_diff;
 80126a8:	4a18      	ldr	r2, [pc, #96]	; (801270c <update_rpm_tacho+0x8c>)
 80126aa:	6951      	ldr	r1, [r2, #20]
		rpm_dep.time_at_comm += TIM2->CNT;
 80126ac:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
		rpm_dep.comms += tacho_diff;
 80126b0:	4419      	add	r1, r3
 80126b2:	6151      	str	r1, [r2, #20]
		rpm_dep.time_at_comm += TIM2->CNT;
 80126b4:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80126b6:	6991      	ldr	r1, [r2, #24]
 80126b8:	4421      	add	r1, r4
		TIM2->CNT = 0;
 80126ba:	2400      	movs	r4, #0
		rpm_dep.time_at_comm += TIM2->CNT;
 80126bc:	6191      	str	r1, [r2, #24]
		TIM2->CNT = 0;
 80126be:	6244      	str	r4, [r0, #36]	; 0x24
	}

	// Tachometers
	tachometer_for_direction += tacho_diff;
 80126c0:	4813      	ldr	r0, [pc, #76]	; (8012710 <update_rpm_tacho+0x90>)
	tachometer_abs += tacho_diff;
 80126c2:	4914      	ldr	r1, [pc, #80]	; (8012714 <update_rpm_tacho+0x94>)
	tachometer_for_direction += tacho_diff;
 80126c4:	6802      	ldr	r2, [r0, #0]

	if (direction) {
 80126c6:	4c14      	ldr	r4, [pc, #80]	; (8012718 <update_rpm_tacho+0x98>)
	tachometer_for_direction += tacho_diff;
 80126c8:	441a      	add	r2, r3
 80126ca:	6002      	str	r2, [r0, #0]
	tachometer_abs += tacho_diff;
 80126cc:	680a      	ldr	r2, [r1, #0]
 80126ce:	441a      	add	r2, r3
 80126d0:	600a      	str	r2, [r1, #0]
	if (direction) {
 80126d2:	6822      	ldr	r2, [r4, #0]
		tachometer += tacho_diff;
 80126d4:	4911      	ldr	r1, [pc, #68]	; (801271c <update_rpm_tacho+0x9c>)
	if (direction) {
 80126d6:	b962      	cbnz	r2, 80126f2 <update_rpm_tacho+0x72>
	} else {
		tachometer -= tacho_diff;
 80126d8:	680a      	ldr	r2, [r1, #0]
	}
}
 80126da:	f85d 4b04 	ldr.w	r4, [sp], #4
		tachometer -= tacho_diff;
 80126de:	1ad3      	subs	r3, r2, r3
 80126e0:	600b      	str	r3, [r1, #0]
}
 80126e2:	4770      	bx	lr
	} else if (tacho_diff < -2) {
 80126e4:	1c9a      	adds	r2, r3, #2
 80126e6:	da01      	bge.n	80126ec <update_rpm_tacho+0x6c>
		tacho_diff += 6;
 80126e8:	3306      	adds	r3, #6
 80126ea:	e7dd      	b.n	80126a8 <update_rpm_tacho+0x28>
	if (tacho_diff != 0) {
 80126ec:	2b00      	cmp	r3, #0
 80126ee:	d0e7      	beq.n	80126c0 <update_rpm_tacho+0x40>
 80126f0:	e7da      	b.n	80126a8 <update_rpm_tacho+0x28>
		tachometer += tacho_diff;
 80126f2:	680a      	ldr	r2, [r1, #0]
}
 80126f4:	f85d 4b04 	ldr.w	r4, [sp], #4
		tachometer += tacho_diff;
 80126f8:	4413      	add	r3, r2
 80126fa:	600b      	str	r3, [r1, #0]
}
 80126fc:	4770      	bx	lr
 80126fe:	bf00      	nop
 8012700:	20004d4c 	.word	0x20004d4c
 8012704:	20005388 	.word	0x20005388
 8012708:	2aaaaaab 	.word	0x2aaaaaab
 801270c:	20005424 	.word	0x20005424
 8012710:	20005a04 	.word	0x20005a04
 8012714:	20005a00 	.word	0x20005a00
 8012718:	20004e18 	.word	0x20004e18
 801271c:	200059fc 	.word	0x200059fc

08012720 <update_sensor_mode>:

static void update_sensor_mode(void) {
	if (conf->sensor_mode == SENSOR_MODE_SENSORLESS ||
 8012720:	4b0e      	ldr	r3, [pc, #56]	; (801275c <update_sensor_mode+0x3c>)
 8012722:	681b      	ldr	r3, [r3, #0]
 8012724:	78da      	ldrb	r2, [r3, #3]
 8012726:	b1a2      	cbz	r2, 8012752 <update_sensor_mode+0x32>
			(conf->sensor_mode == SENSOR_MODE_HYBRID &&
 8012728:	78da      	ldrb	r2, [r3, #3]
	if (conf->sensor_mode == SENSOR_MODE_SENSORLESS ||
 801272a:	2a02      	cmp	r2, #2
 801272c:	d003      	beq.n	8012736 <update_sensor_mode+0x16>
					fabsf(mcpwm_get_rpm()) > conf->hall_sl_erpm)) {
		sensorless_now = true;
	} else {
		sensorless_now = false;
 801272e:	4b0c      	ldr	r3, [pc, #48]	; (8012760 <update_sensor_mode+0x40>)
 8012730:	2200      	movs	r2, #0
 8012732:	701a      	strb	r2, [r3, #0]
	}
}
 8012734:	4770      	bx	lr
	return direction ? rpm_now : -rpm_now;
 8012736:	4a0b      	ldr	r2, [pc, #44]	; (8012764 <update_sensor_mode+0x44>)
 8012738:	6812      	ldr	r2, [r2, #0]
 801273a:	4a0b      	ldr	r2, [pc, #44]	; (8012768 <update_sensor_mode+0x48>)
 801273c:	edd2 7a00 	vldr	s15, [r2]
					fabsf(mcpwm_get_rpm()) > conf->hall_sl_erpm)) {
 8012740:	ed93 7a28 	vldr	s14, [r3, #160]	; 0xa0
 8012744:	eef0 7ae7 	vabs.f32	s15, s15
			(conf->sensor_mode == SENSOR_MODE_HYBRID &&
 8012748:	eef4 7ac7 	vcmpe.f32	s15, s14
 801274c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012750:	dded      	ble.n	801272e <update_sensor_mode+0xe>
		sensorless_now = true;
 8012752:	4b03      	ldr	r3, [pc, #12]	; (8012760 <update_sensor_mode+0x40>)
 8012754:	2201      	movs	r2, #1
 8012756:	701a      	strb	r2, [r3, #0]
 8012758:	4770      	bx	lr
 801275a:	bf00      	nop
 801275c:	20004d50 	.word	0x20004d50
 8012760:	200059e8 	.word	0x200059e8
 8012764:	20004e18 	.word	0x20004e18
 8012768:	20005444 	.word	0x20005444
 801276c:	00000000 	.word	0x00000000

08012770 <update_timer_attempt>:

/**
 * Try to apply the new timer settings. This is really not an elegant solution, but for now it is
 * the best I can come up with.
 */
static void update_timer_attempt(void) {
 8012770:	b508      	push	{r3, lr}
	utils_sys_lock_cnt();
 8012772:	f003 fc95 	bl	80160a0 <utils_sys_lock_cnt>

	// Set the next timer settings if an update is far enough away
	if (!timer_struct.updated && TIM1->CNT > 10 && TIM1->CNT < (TIM1->ARR - 500)) {
 8012776:	4b19      	ldr	r3, [pc, #100]	; (80127dc <update_timer_attempt+0x6c>)
 8012778:	781a      	ldrb	r2, [r3, #0]
 801277a:	2a00      	cmp	r2, #0
 801277c:	d12a      	bne.n	80127d4 <update_timer_attempt+0x64>
 801277e:	4a18      	ldr	r2, [pc, #96]	; (80127e0 <update_timer_attempt+0x70>)
 8012780:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8012782:	290a      	cmp	r1, #10
 8012784:	d926      	bls.n	80127d4 <update_timer_attempt+0x64>
 8012786:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8012788:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 801278a:	f5a1 71fa 	sub.w	r1, r1, #500	; 0x1f4
 801278e:	4288      	cmp	r0, r1
 8012790:	d220      	bcs.n	80127d4 <update_timer_attempt+0x64>
		// Disable preload register updates
		TIM1->CR1 |= TIM_CR1_UDIS;
 8012792:	6810      	ldr	r0, [r2, #0]
		TIM8->CR1 |= TIM_CR1_UDIS;
 8012794:	4913      	ldr	r1, [pc, #76]	; (80127e4 <update_timer_attempt+0x74>)
		TIM1->CR1 |= TIM_CR1_UDIS;
 8012796:	f040 0002 	orr.w	r0, r0, #2
 801279a:	6010      	str	r0, [r2, #0]
		TIM8->CR1 |= TIM_CR1_UDIS;
 801279c:	6808      	ldr	r0, [r1, #0]
 801279e:	f040 0002 	orr.w	r0, r0, #2
 80127a2:	6008      	str	r0, [r1, #0]

		// Set the new configuration
		TIM1->ARR = timer_struct.top;
 80127a4:	6858      	ldr	r0, [r3, #4]
 80127a6:	62d0      	str	r0, [r2, #44]	; 0x2c
		TIM1->CCR1 = timer_struct.duty;
 80127a8:	6898      	ldr	r0, [r3, #8]
 80127aa:	6350      	str	r0, [r2, #52]	; 0x34
		TIM1->CCR2 = timer_struct.duty;
 80127ac:	6898      	ldr	r0, [r3, #8]
 80127ae:	6390      	str	r0, [r2, #56]	; 0x38
		TIM1->CCR3 = timer_struct.duty;
 80127b0:	6898      	ldr	r0, [r3, #8]
 80127b2:	63d0      	str	r0, [r2, #60]	; 0x3c
		TIM8->CCR1 = timer_struct.val_sample;
 80127b4:	68d8      	ldr	r0, [r3, #12]
 80127b6:	6348      	str	r0, [r1, #52]	; 0x34
		TIM1->CCR4 = timer_struct.curr1_sample;
 80127b8:	6918      	ldr	r0, [r3, #16]
 80127ba:	6410      	str	r0, [r2, #64]	; 0x40
		TIM8->CCR2 = timer_struct.curr2_sample;
 80127bc:	6958      	ldr	r0, [r3, #20]
 80127be:	6388      	str	r0, [r1, #56]	; 0x38
#ifdef HW_HAS_3_SHUNTS
		TIM8->CCR3 = timer_struct.curr3_sample;
#endif

		// Enables preload register updates
		TIM1->CR1 &= ~TIM_CR1_UDIS;
 80127c0:	6810      	ldr	r0, [r2, #0]
 80127c2:	f020 0002 	bic.w	r0, r0, #2
 80127c6:	6010      	str	r0, [r2, #0]
		TIM8->CR1 &= ~TIM_CR1_UDIS;
 80127c8:	680a      	ldr	r2, [r1, #0]
		timer_struct.updated = true;
 80127ca:	2001      	movs	r0, #1
		TIM8->CR1 &= ~TIM_CR1_UDIS;
 80127cc:	f022 0202 	bic.w	r2, r2, #2
 80127d0:	600a      	str	r2, [r1, #0]
		timer_struct.updated = true;
 80127d2:	7018      	strb	r0, [r3, #0]
	}

	utils_sys_unlock_cnt();
}
 80127d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	utils_sys_unlock_cnt();
 80127d8:	f003 bc72 	b.w	80160c0 <utils_sys_unlock_cnt>
 80127dc:	20005a08 	.word	0x20005a08
 80127e0:	40010000 	.word	0x40010000
 80127e4:	40010400 	.word	0x40010400
	...

080127f0 <set_next_timer_settings>:
static void set_next_timer_settings(mc_timer_struct *settings) {
 80127f0:	b570      	push	{r4, r5, r6, lr}
 80127f2:	4604      	mov	r4, r0
	utils_sys_lock_cnt();
 80127f4:	f003 fc54 	bl	80160a0 <utils_sys_lock_cnt>
	timer_struct = *settings;
 80127f8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80127fa:	4e07      	ldr	r6, [pc, #28]	; (8012818 <set_next_timer_settings+0x28>)
 80127fc:	4635      	mov	r5, r6
 80127fe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8012800:	e894 0003 	ldmia.w	r4, {r0, r1}
	timer_struct.updated = false;
 8012804:	2300      	movs	r3, #0
	timer_struct = *settings;
 8012806:	e885 0003 	stmia.w	r5, {r0, r1}
	timer_struct.updated = false;
 801280a:	7033      	strb	r3, [r6, #0]
	utils_sys_unlock_cnt();
 801280c:	f003 fc58 	bl	80160c0 <utils_sys_unlock_cnt>
}
 8012810:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_timer_attempt();
 8012814:	f7ff bfac 	b.w	8012770 <update_timer_attempt>
 8012818:	20005a08 	.word	0x20005a08
 801281c:	00000000 	.word	0x00000000

08012820 <set_switching_frequency>:

static void set_switching_frequency(float frequency) {
 8012820:	b570      	push	{r4, r5, r6, lr}
	switching_frequency_now = frequency;
 8012822:	4e11      	ldr	r6, [pc, #68]	; (8012868 <set_switching_frequency+0x48>)
	mc_timer_struct timer_tmp;

	utils_sys_lock_cnt();
	timer_tmp = timer_struct;
 8012824:	4d11      	ldr	r5, [pc, #68]	; (801286c <set_switching_frequency+0x4c>)
	switching_frequency_now = frequency;
 8012826:	ed86 0a00 	vstr	s0, [r6]
static void set_switching_frequency(float frequency) {
 801282a:	b086      	sub	sp, #24
	utils_sys_lock_cnt();
 801282c:	f003 fc38 	bl	80160a0 <utils_sys_lock_cnt>
	timer_tmp = timer_struct;
 8012830:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8012832:	466c      	mov	r4, sp
 8012834:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8012836:	e895 0003 	ldmia.w	r5, {r0, r1}
 801283a:	e884 0003 	stmia.w	r4, {r0, r1}
	utils_sys_unlock_cnt();
 801283e:	f003 fc3f 	bl	80160c0 <utils_sys_unlock_cnt>

	timer_tmp.top = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 8012842:	edd6 7a00 	vldr	s15, [r6]
 8012846:	4a0a      	ldr	r2, [pc, #40]	; (8012870 <set_switching_frequency+0x50>)
 8012848:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	update_adc_sample_pos(&timer_tmp);
 801284c:	4668      	mov	r0, sp
	timer_tmp.top = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 801284e:	ee17 3a90 	vmov	r3, s15
 8012852:	fb92 f3f3 	sdiv	r3, r2, r3
 8012856:	9301      	str	r3, [sp, #4]
	update_adc_sample_pos(&timer_tmp);
 8012858:	f7ff fe32 	bl	80124c0 <update_adc_sample_pos>
	set_next_timer_settings(&timer_tmp);
 801285c:	4668      	mov	r0, sp
 801285e:	f7ff ffc7 	bl	80127f0 <set_next_timer_settings>
}
 8012862:	b006      	add	sp, #24
 8012864:	bd70      	pop	{r4, r5, r6, pc}
 8012866:	bf00      	nop
 8012868:	200059f8 	.word	0x200059f8
 801286c:	20005a08 	.word	0x20005a08
 8012870:	0a037a00 	.word	0x0a037a00
	...

08012880 <set_duty_cycle_hw>:
static void set_duty_cycle_hw(float dutyCycle) {
 8012880:	b570      	push	{r4, r5, r6, lr}
	timer_tmp = timer_struct;
 8012882:	4d40      	ldr	r5, [pc, #256]	; (8012984 <set_duty_cycle_hw+0x104>)
	utils_truncate_number(&dutyCycle, conf->l_min_duty, conf->l_max_duty);
 8012884:	4e40      	ldr	r6, [pc, #256]	; (8012988 <set_duty_cycle_hw+0x108>)
static void set_duty_cycle_hw(float dutyCycle) {
 8012886:	b088      	sub	sp, #32
 8012888:	ed8d 0a01 	vstr	s0, [sp, #4]
	utils_sys_lock_cnt();
 801288c:	f003 fc08 	bl	80160a0 <utils_sys_lock_cnt>
	timer_tmp = timer_struct;
 8012890:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8012892:	ac02      	add	r4, sp, #8
 8012894:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8012896:	e895 0003 	ldmia.w	r5, {r0, r1}
 801289a:	e884 0003 	stmia.w	r4, {r0, r1}
	utils_sys_unlock_cnt();
 801289e:	f003 fc0f 	bl	80160c0 <utils_sys_unlock_cnt>
	utils_truncate_number(&dutyCycle, conf->l_min_duty, conf->l_max_duty);
 80128a2:	6833      	ldr	r3, [r6, #0]
 80128a4:	a801      	add	r0, sp, #4
 80128a6:	ed93 0a15 	vldr	s0, [r3, #84]	; 0x54
 80128aa:	edd3 0a16 	vldr	s1, [r3, #88]	; 0x58
 80128ae:	f003 f8e7 	bl	8015a80 <utils_truncate_number>
	if (conf->motor_type == MOTOR_TYPE_DC) {
 80128b2:	6833      	ldr	r3, [r6, #0]
 80128b4:	789a      	ldrb	r2, [r3, #2]
 80128b6:	2a01      	cmp	r2, #1
 80128b8:	d041      	beq.n	801293e <set_duty_cycle_hw+0xbe>
		if (IS_DETECTING() || conf->pwm_mode == PWM_MODE_BIPOLAR) {
 80128ba:	4a34      	ldr	r2, [pc, #208]	; (801298c <set_duty_cycle_hw+0x10c>)
 80128bc:	eddd 6a01 	vldr	s13, [sp, #4]
 80128c0:	7812      	ldrb	r2, [r2, #0]
 80128c2:	2a01      	cmp	r2, #1
 80128c4:	d036      	beq.n	8012934 <set_duty_cycle_hw+0xb4>
 80128c6:	781a      	ldrb	r2, [r3, #0]
 80128c8:	2a02      	cmp	r2, #2
 80128ca:	d033      	beq.n	8012934 <set_duty_cycle_hw+0xb4>
			switching_frequency_now = (float)conf->m_bldc_f_sw_min * (1.0 - fabsf(dutyCycle)) +
 80128cc:	edd3 5a59 	vldr	s11, [r3, #356]	; 0x164
					conf->m_bldc_f_sw_max * fabsf(dutyCycle);
 80128d0:	edd3 7a5a 	vldr	s15, [r3, #360]	; 0x168
			switching_frequency_now = (float)conf->m_bldc_f_sw_min * (1.0 - fabsf(dutyCycle)) +
 80128d4:	4a2e      	ldr	r2, [pc, #184]	; (8012990 <set_duty_cycle_hw+0x110>)
 80128d6:	eeb0 6ae6 	vabs.f32	s12, s13
 80128da:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
					conf->m_bldc_f_sw_max * fabsf(dutyCycle);
 80128de:	ee66 7a27 	vmul.f32	s15, s12, s15
			switching_frequency_now = (float)conf->m_bldc_f_sw_min * (1.0 - fabsf(dutyCycle)) +
 80128e2:	ee37 7a46 	vsub.f32	s14, s14, s12
 80128e6:	eee5 7a87 	vfma.f32	s15, s11, s14
 80128ea:	edc2 7a00 	vstr	s15, [r2]
	timer_tmp.top = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 80128ee:	ed92 7a00 	vldr	s14, [r2]
 80128f2:	4928      	ldr	r1, [pc, #160]	; (8012994 <set_duty_cycle_hw+0x114>)
 80128f4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80128f8:	ee17 2a90 	vmov	r2, s15
 80128fc:	fb91 f2f2 	sdiv	r2, r1, r2
 8012900:	9203      	str	r2, [sp, #12]
	if (conf->motor_type == MOTOR_TYPE_BLDC && conf->pwm_mode == PWM_MODE_BIPOLAR && !IS_DETECTING()) {
 8012902:	789a      	ldrb	r2, [r3, #2]
 8012904:	b912      	cbnz	r2, 801290c <set_duty_cycle_hw+0x8c>
 8012906:	781b      	ldrb	r3, [r3, #0]
 8012908:	2b02      	cmp	r3, #2
 801290a:	d01f      	beq.n	801294c <set_duty_cycle_hw+0xcc>
		timer_tmp.duty = (uint16_t)((float)timer_tmp.top * dutyCycle);
 801290c:	eddd 7a03 	vldr	s15, [sp, #12]
 8012910:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012914:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8012918:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801291c:	ee17 3a90 	vmov	r3, s15
 8012920:	b29b      	uxth	r3, r3
 8012922:	9304      	str	r3, [sp, #16]
	update_adc_sample_pos(&timer_tmp);
 8012924:	a802      	add	r0, sp, #8
 8012926:	f7ff fdcb 	bl	80124c0 <update_adc_sample_pos>
	set_next_timer_settings(&timer_tmp);
 801292a:	a802      	add	r0, sp, #8
 801292c:	f7ff ff60 	bl	80127f0 <set_next_timer_settings>
}
 8012930:	b008      	add	sp, #32
 8012932:	bd70      	pop	{r4, r5, r6, pc}
			switching_frequency_now = conf->m_bldc_f_sw_max;
 8012934:	4a16      	ldr	r2, [pc, #88]	; (8012990 <set_duty_cycle_hw+0x110>)
 8012936:	f8d3 1168 	ldr.w	r1, [r3, #360]	; 0x168
 801293a:	6011      	str	r1, [r2, #0]
 801293c:	e7d7      	b.n	80128ee <set_duty_cycle_hw+0x6e>
		switching_frequency_now = conf->m_dc_f_sw;
 801293e:	4a14      	ldr	r2, [pc, #80]	; (8012990 <set_duty_cycle_hw+0x110>)
 8012940:	f8d3 116c 	ldr.w	r1, [r3, #364]	; 0x16c
 8012944:	eddd 6a01 	vldr	s13, [sp, #4]
 8012948:	6011      	str	r1, [r2, #0]
 801294a:	e7d0      	b.n	80128ee <set_duty_cycle_hw+0x6e>
	if (conf->motor_type == MOTOR_TYPE_BLDC && conf->pwm_mode == PWM_MODE_BIPOLAR && !IS_DETECTING()) {
 801294c:	4b0f      	ldr	r3, [pc, #60]	; (801298c <set_duty_cycle_hw+0x10c>)
 801294e:	781b      	ldrb	r3, [r3, #0]
 8012950:	2b01      	cmp	r3, #1
 8012952:	d0db      	beq.n	801290c <set_duty_cycle_hw+0x8c>
		timer_tmp.duty = (uint16_t) (((float) timer_tmp.top / 2.0) * dutyCycle
 8012954:	ed9d 7a03 	vldr	s14, [sp, #12]
				+ ((float) timer_tmp.top / 2.0));
 8012958:	eddd 7a03 	vldr	s15, [sp, #12]
		timer_tmp.duty = (uint16_t) (((float) timer_tmp.top / 2.0) * dutyCycle
 801295c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
				+ ((float) timer_tmp.top / 2.0));
 8012960:	eef8 7a67 	vcvt.f32.u32	s15, s15
		timer_tmp.duty = (uint16_t) (((float) timer_tmp.top / 2.0) * dutyCycle
 8012964:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8012968:	ee27 7a06 	vmul.f32	s14, s14, s12
				+ ((float) timer_tmp.top / 2.0));
 801296c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8012970:	eee7 7a26 	vfma.f32	s15, s14, s13
		timer_tmp.duty = (uint16_t) (((float) timer_tmp.top / 2.0) * dutyCycle
 8012974:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012978:	ee17 3a90 	vmov	r3, s15
 801297c:	b29b      	uxth	r3, r3
 801297e:	9304      	str	r3, [sp, #16]
 8012980:	e7d0      	b.n	8012924 <set_duty_cycle_hw+0xa4>
 8012982:	bf00      	nop
 8012984:	20005a08 	.word	0x20005a08
 8012988:	20004d50 	.word	0x20004d50
 801298c:	200059f4 	.word	0x200059f4
 8012990:	200059f8 	.word	0x200059f8
 8012994:	0a037a00 	.word	0x0a037a00
	...

080129a0 <set_next_comm_step>:

static void set_next_comm_step(int next_step) {
 80129a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conf->motor_type == MOTOR_TYPE_DC) {
 80129a2:	4bbd      	ldr	r3, [pc, #756]	; (8012c98 <set_next_comm_step+0x2f8>)
 80129a4:	681b      	ldr	r3, [r3, #0]
 80129a6:	789c      	ldrb	r4, [r3, #2]
 80129a8:	b2e4      	uxtb	r4, r4
 80129aa:	2c01      	cmp	r4, #1
 80129ac:	d079      	beq.n	8012aa2 <set_next_comm_step+0x102>
	uint16_t positive_lowside = TIM_CCxN_Enable;

	uint16_t negative_highside = TIM_CCx_Enable;
	uint16_t negative_lowside = TIM_CCxN_Enable;

	if (!IS_DETECTING()) {
 80129ae:	4abb      	ldr	r2, [pc, #748]	; (8012c9c <set_next_comm_step+0x2fc>)
 80129b0:	7812      	ldrb	r2, [r2, #0]
 80129b2:	2a01      	cmp	r2, #1
 80129b4:	4605      	mov	r5, r0
 80129b6:	d03c      	beq.n	8012a32 <set_next_comm_step+0x92>
		switch (conf->pwm_mode) {
 80129b8:	781b      	ldrb	r3, [r3, #0]
 80129ba:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 80129be:	2b00      	cmp	r3, #0
 80129c0:	d038      	beq.n	8012a34 <set_next_comm_step+0x94>
	uint16_t positive_lowside = TIM_CCxN_Enable;
 80129c2:	2c02      	cmp	r4, #2
 80129c4:	bf0c      	ite	eq
 80129c6:	2670      	moveq	r6, #112	; 0x70
 80129c8:	2620      	movne	r6, #32
			negative_oc_mode = TIM_OCMode_PWM2;
			break;
		}
	}

	if (next_step == 1) {
 80129ca:	2d01      	cmp	r5, #1
	uint16_t positive_lowside = TIM_CCxN_Enable;
 80129cc:	f04f 0404 	mov.w	r4, #4
	if (next_step == 1) {
 80129d0:	d034      	beq.n	8012a3c <set_next_comm_step+0x9c>
			// -
			TIM_SelectOCxM(TIM1, TIM_Channel_2, negative_oc_mode);
			TIM_CCxCmd(TIM1, TIM_Channel_2, negative_highside);
			TIM_CCxNCmd(TIM1, TIM_Channel_2, negative_lowside);
		}
	} else if (next_step == 2) {
 80129d2:	2d02      	cmp	r5, #2
 80129d4:	f000 80e1 	beq.w	8012b9a <set_next_comm_step+0x1fa>
			// -
			TIM_SelectOCxM(TIM1, TIM_Channel_2, negative_oc_mode);
			TIM_CCxCmd(TIM1, TIM_Channel_2, negative_highside);
			TIM_CCxNCmd(TIM1, TIM_Channel_2, negative_lowside);
		}
	} else if (next_step == 3) {
 80129d8:	2d03      	cmp	r5, #3
 80129da:	f000 8107 	beq.w	8012bec <set_next_comm_step+0x24c>
			// -
			TIM_SelectOCxM(TIM1, TIM_Channel_3, negative_oc_mode);
			TIM_CCxCmd(TIM1, TIM_Channel_3, negative_highside);
			TIM_CCxNCmd(TIM1, TIM_Channel_3, negative_lowside);
		}
	} else if (next_step == 4) {
 80129de:	2d04      	cmp	r5, #4
 80129e0:	f000 8092 	beq.w	8012b08 <set_next_comm_step+0x168>
			// -
			TIM_SelectOCxM(TIM1, TIM_Channel_3, negative_oc_mode);
			TIM_CCxCmd(TIM1, TIM_Channel_3, negative_highside);
			TIM_CCxNCmd(TIM1, TIM_Channel_3, negative_lowside);
		}
	} else if (next_step == 5) {
 80129e4:	2d05      	cmp	r5, #5
 80129e6:	f000 815f 	beq.w	8012ca8 <set_next_comm_step+0x308>
			// -
			TIM_SelectOCxM(TIM1, TIM_Channel_1, negative_oc_mode);
			TIM_CCxCmd(TIM1, TIM_Channel_1, negative_highside);
			TIM_CCxNCmd(TIM1, TIM_Channel_1, negative_lowside);
		}
	} else if (next_step == 6) {
 80129ea:	2d06      	cmp	r5, #6
 80129ec:	f040 81d5 	bne.w	8012d9a <set_next_comm_step+0x3fa>
		if (direction) {
 80129f0:	4bab      	ldr	r3, [pc, #684]	; (8012ca0 <set_next_comm_step+0x300>)
 80129f2:	681d      	ldr	r5, [r3, #0]
			DISABLE_BR3();
			ENABLE_BR2();
			ENABLE_BR1();
#endif
			// 0
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 80129f4:	2220      	movs	r2, #32
		if (direction) {
 80129f6:	2d00      	cmp	r5, #0
 80129f8:	f000 81b4 	beq.w	8012d64 <set_next_comm_step+0x3c4>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 80129fc:	2108      	movs	r1, #8
 80129fe:	48a9      	ldr	r0, [pc, #676]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a00:	f011 fec6 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012a04:	2201      	movs	r2, #1
 8012a06:	2108      	movs	r1, #8
 8012a08:	48a6      	ldr	r0, [pc, #664]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a0a:	f011 ff19 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012a0e:	2200      	movs	r2, #0
 8012a10:	2108      	movs	r1, #8
 8012a12:	48a4      	ldr	r0, [pc, #656]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a14:	f011 ff24 	bl	8024860 <TIM_CCxNCmd>

			// +
			TIM_SelectOCxM(TIM1, TIM_Channel_2, positive_oc_mode);
 8012a18:	2260      	movs	r2, #96	; 0x60
 8012a1a:	2104      	movs	r1, #4
 8012a1c:	48a1      	ldr	r0, [pc, #644]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a1e:	f011 feb7 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, positive_highside);
 8012a22:	2201      	movs	r2, #1
 8012a24:	2104      	movs	r1, #4
 8012a26:	489f      	ldr	r0, [pc, #636]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a28:	f011 ff0a 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012a2c:	4622      	mov	r2, r4
 8012a2e:	2104      	movs	r1, #4
 8012a30:	e159      	b.n	8012ce6 <set_next_comm_step+0x346>
	uint16_t positive_lowside = TIM_CCxN_Enable;
 8012a32:	2404      	movs	r4, #4
	if (next_step == 1) {
 8012a34:	2d01      	cmp	r5, #1
	uint16_t negative_oc_mode = TIM_OCMode_Inactive;
 8012a36:	f04f 0620 	mov.w	r6, #32
	if (next_step == 1) {
 8012a3a:	d1ca      	bne.n	80129d2 <set_next_comm_step+0x32>
		if (direction) {
 8012a3c:	4b98      	ldr	r3, [pc, #608]	; (8012ca0 <set_next_comm_step+0x300>)
 8012a3e:	681f      	ldr	r7, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012a40:	2220      	movs	r2, #32
		if (direction) {
 8012a42:	2f00      	cmp	r7, #0
 8012a44:	d066      	beq.n	8012b14 <set_next_comm_step+0x174>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012a46:	2100      	movs	r1, #0
 8012a48:	4896      	ldr	r0, [pc, #600]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a4a:	f011 fea1 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012a4e:	462a      	mov	r2, r5
 8012a50:	2100      	movs	r1, #0
 8012a52:	4894      	ldr	r0, [pc, #592]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a54:	f011 fef4 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012a58:	2200      	movs	r2, #0
 8012a5a:	4611      	mov	r1, r2
 8012a5c:	4891      	ldr	r0, [pc, #580]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a5e:	f011 feff 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, positive_oc_mode);
 8012a62:	2260      	movs	r2, #96	; 0x60
 8012a64:	2104      	movs	r1, #4
 8012a66:	488f      	ldr	r0, [pc, #572]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a68:	f011 fe92 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, positive_highside);
 8012a6c:	462a      	mov	r2, r5
 8012a6e:	2104      	movs	r1, #4
 8012a70:	488c      	ldr	r0, [pc, #560]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a72:	f011 fee5 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012a76:	4622      	mov	r2, r4
 8012a78:	2104      	movs	r1, #4
 8012a7a:	488a      	ldr	r0, [pc, #552]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a7c:	f011 fef0 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, negative_oc_mode);
 8012a80:	4632      	mov	r2, r6
 8012a82:	2108      	movs	r1, #8
 8012a84:	4887      	ldr	r0, [pc, #540]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a86:	f011 fe83 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, negative_highside);
 8012a8a:	462a      	mov	r2, r5
 8012a8c:	2108      	movs	r1, #8
 8012a8e:	4885      	ldr	r0, [pc, #532]	; (8012ca4 <set_next_comm_step+0x304>)
 8012a90:	f011 fed6 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, negative_lowside);
 8012a94:	2204      	movs	r2, #4
 8012a96:	2108      	movs	r1, #8
 8012a98:	4882      	ldr	r0, [pc, #520]	; (8012ca4 <set_next_comm_step+0x304>)

		TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
		TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
		TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
	}
}
 8012a9a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			TIM_CCxNCmd(TIM1, TIM_Channel_3, negative_lowside);
 8012a9e:	f011 bedf 	b.w	8024860 <TIM_CCxNCmd>
		TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012aa2:	2220      	movs	r2, #32
 8012aa4:	2104      	movs	r1, #4
 8012aa6:	487f      	ldr	r0, [pc, #508]	; (8012ca4 <set_next_comm_step+0x304>)
 8012aa8:	f011 fe72 	bl	8024790 <TIM_SelectOCxM>
		TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012aac:	4622      	mov	r2, r4
 8012aae:	2104      	movs	r1, #4
 8012ab0:	487c      	ldr	r0, [pc, #496]	; (8012ca4 <set_next_comm_step+0x304>)
 8012ab2:	f011 fec5 	bl	8024840 <TIM_CCxCmd>
		TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012ab6:	2200      	movs	r2, #0
 8012ab8:	2104      	movs	r1, #4
 8012aba:	487a      	ldr	r0, [pc, #488]	; (8012ca4 <set_next_comm_step+0x304>)
 8012abc:	f011 fed0 	bl	8024860 <TIM_CCxNCmd>
		if (direction) {
 8012ac0:	4b77      	ldr	r3, [pc, #476]	; (8012ca0 <set_next_comm_step+0x300>)
 8012ac2:	681d      	ldr	r5, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
 8012ac4:	2260      	movs	r2, #96	; 0x60
		if (direction) {
 8012ac6:	2d00      	cmp	r5, #0
 8012ac8:	d152      	bne.n	8012b70 <set_next_comm_step+0x1d0>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
 8012aca:	2108      	movs	r1, #8
 8012acc:	4875      	ldr	r0, [pc, #468]	; (8012ca4 <set_next_comm_step+0x304>)
 8012ace:	f011 fe5f 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012ad2:	4622      	mov	r2, r4
 8012ad4:	2108      	movs	r1, #8
 8012ad6:	4873      	ldr	r0, [pc, #460]	; (8012ca4 <set_next_comm_step+0x304>)
 8012ad8:	f011 feb2 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
 8012adc:	2204      	movs	r2, #4
 8012ade:	2108      	movs	r1, #8
 8012ae0:	4870      	ldr	r0, [pc, #448]	; (8012ca4 <set_next_comm_step+0x304>)
 8012ae2:	f011 febd 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012ae6:	2220      	movs	r2, #32
			TIM_SelectOCxM(TIM1, TIM_Channel_1, negative_oc_mode);
 8012ae8:	4629      	mov	r1, r5
 8012aea:	486e      	ldr	r0, [pc, #440]	; (8012ca4 <set_next_comm_step+0x304>)
 8012aec:	f011 fe50 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, negative_highside);
 8012af0:	4629      	mov	r1, r5
 8012af2:	2201      	movs	r2, #1
 8012af4:	486b      	ldr	r0, [pc, #428]	; (8012ca4 <set_next_comm_step+0x304>)
 8012af6:	f011 fea3 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, negative_lowside);
 8012afa:	4629      	mov	r1, r5
 8012afc:	2204      	movs	r2, #4
 8012afe:	4869      	ldr	r0, [pc, #420]	; (8012ca4 <set_next_comm_step+0x304>)
}
 8012b00:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			TIM_CCxNCmd(TIM1, TIM_Channel_1, negative_lowside);
 8012b04:	f011 beac 	b.w	8024860 <TIM_CCxNCmd>
		if (direction) {
 8012b08:	4b65      	ldr	r3, [pc, #404]	; (8012ca0 <set_next_comm_step+0x300>)
 8012b0a:	681f      	ldr	r7, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012b0c:	2220      	movs	r2, #32
		if (direction) {
 8012b0e:	2f00      	cmp	r7, #0
 8012b10:	f000 80fd 	beq.w	8012d0e <set_next_comm_step+0x36e>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012b14:	2100      	movs	r1, #0
 8012b16:	4863      	ldr	r0, [pc, #396]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b18:	f011 fe3a 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012b1c:	2201      	movs	r2, #1
 8012b1e:	2100      	movs	r1, #0
 8012b20:	4860      	ldr	r0, [pc, #384]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b22:	f011 fe8d 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012b26:	2200      	movs	r2, #0
 8012b28:	4611      	mov	r1, r2
 8012b2a:	485e      	ldr	r0, [pc, #376]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b2c:	f011 fe98 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, positive_oc_mode);
 8012b30:	2260      	movs	r2, #96	; 0x60
 8012b32:	2108      	movs	r1, #8
 8012b34:	485b      	ldr	r0, [pc, #364]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b36:	f011 fe2b 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, positive_highside);
 8012b3a:	2201      	movs	r2, #1
 8012b3c:	2108      	movs	r1, #8
 8012b3e:	4859      	ldr	r0, [pc, #356]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b40:	f011 fe7e 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, positive_lowside);
 8012b44:	4622      	mov	r2, r4
 8012b46:	2108      	movs	r1, #8
			TIM_CCxNCmd(TIM1, TIM_Channel_1, positive_lowside);
 8012b48:	4856      	ldr	r0, [pc, #344]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b4a:	f011 fe89 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, negative_oc_mode);
 8012b4e:	4632      	mov	r2, r6
 8012b50:	2104      	movs	r1, #4
 8012b52:	4854      	ldr	r0, [pc, #336]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b54:	f011 fe1c 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, negative_highside);
 8012b58:	2201      	movs	r2, #1
 8012b5a:	2104      	movs	r1, #4
 8012b5c:	4851      	ldr	r0, [pc, #324]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b5e:	f011 fe6f 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, negative_lowside);
 8012b62:	2204      	movs	r2, #4
 8012b64:	4611      	mov	r1, r2
 8012b66:	484f      	ldr	r0, [pc, #316]	; (8012ca4 <set_next_comm_step+0x304>)
}
 8012b68:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			TIM_CCxNCmd(TIM1, TIM_Channel_2, negative_lowside);
 8012b6c:	f011 be78 	b.w	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
 8012b70:	2100      	movs	r1, #0
 8012b72:	484c      	ldr	r0, [pc, #304]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b74:	f011 fe0c 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012b78:	4622      	mov	r2, r4
 8012b7a:	2100      	movs	r1, #0
 8012b7c:	4849      	ldr	r0, [pc, #292]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b7e:	f011 fe5f 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);
 8012b82:	2204      	movs	r2, #4
 8012b84:	2100      	movs	r1, #0
 8012b86:	4847      	ldr	r0, [pc, #284]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b88:	f011 fe6a 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 8012b8c:	2220      	movs	r2, #32
 8012b8e:	2108      	movs	r1, #8
 8012b90:	4844      	ldr	r0, [pc, #272]	; (8012ca4 <set_next_comm_step+0x304>)
 8012b92:	f011 fdfd 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012b96:	4622      	mov	r2, r4
 8012b98:	e778      	b.n	8012a8c <set_next_comm_step+0xec>
		if (direction) {
 8012b9a:	4b41      	ldr	r3, [pc, #260]	; (8012ca0 <set_next_comm_step+0x300>)
 8012b9c:	681d      	ldr	r5, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012b9e:	2220      	movs	r2, #32
		if (direction) {
 8012ba0:	2d00      	cmp	r5, #0
 8012ba2:	d042      	beq.n	8012c2a <set_next_comm_step+0x28a>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012ba4:	2104      	movs	r1, #4
 8012ba6:	483f      	ldr	r0, [pc, #252]	; (8012ca4 <set_next_comm_step+0x304>)
 8012ba8:	f011 fdf2 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012bac:	2201      	movs	r2, #1
 8012bae:	2104      	movs	r1, #4
 8012bb0:	483c      	ldr	r0, [pc, #240]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bb2:	f011 fe45 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012bb6:	2200      	movs	r2, #0
 8012bb8:	2104      	movs	r1, #4
 8012bba:	483a      	ldr	r0, [pc, #232]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bbc:	f011 fe50 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, positive_oc_mode);
 8012bc0:	2260      	movs	r2, #96	; 0x60
 8012bc2:	2100      	movs	r1, #0
 8012bc4:	4837      	ldr	r0, [pc, #220]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bc6:	f011 fde3 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, positive_highside);
 8012bca:	2201      	movs	r2, #1
 8012bcc:	2100      	movs	r1, #0
 8012bce:	4835      	ldr	r0, [pc, #212]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bd0:	f011 fe36 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, positive_lowside);
 8012bd4:	4622      	mov	r2, r4
 8012bd6:	2100      	movs	r1, #0
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012bd8:	4832      	ldr	r0, [pc, #200]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bda:	f011 fe41 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, negative_oc_mode);
 8012bde:	4632      	mov	r2, r6
 8012be0:	2108      	movs	r1, #8
 8012be2:	4830      	ldr	r0, [pc, #192]	; (8012ca4 <set_next_comm_step+0x304>)
 8012be4:	f011 fdd4 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, negative_highside);
 8012be8:	2201      	movs	r2, #1
 8012bea:	e74f      	b.n	8012a8c <set_next_comm_step+0xec>
		if (direction) {
 8012bec:	4b2c      	ldr	r3, [pc, #176]	; (8012ca0 <set_next_comm_step+0x300>)
 8012bee:	681d      	ldr	r5, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 8012bf0:	2220      	movs	r2, #32
		if (direction) {
 8012bf2:	b3ad      	cbz	r5, 8012c60 <set_next_comm_step+0x2c0>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 8012bf4:	2108      	movs	r1, #8
 8012bf6:	482b      	ldr	r0, [pc, #172]	; (8012ca4 <set_next_comm_step+0x304>)
 8012bf8:	f011 fdca 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012bfc:	2201      	movs	r2, #1
 8012bfe:	2108      	movs	r1, #8
 8012c00:	4828      	ldr	r0, [pc, #160]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c02:	f011 fe1d 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012c06:	2200      	movs	r2, #0
 8012c08:	2108      	movs	r1, #8
 8012c0a:	4826      	ldr	r0, [pc, #152]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c0c:	f011 fe28 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, positive_oc_mode);
 8012c10:	2260      	movs	r2, #96	; 0x60
 8012c12:	2100      	movs	r1, #0
 8012c14:	4823      	ldr	r0, [pc, #140]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c16:	f011 fdbb 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, positive_highside);
 8012c1a:	2201      	movs	r2, #1
 8012c1c:	2100      	movs	r1, #0
 8012c1e:	4821      	ldr	r0, [pc, #132]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c20:	f011 fe0e 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, positive_lowside);
 8012c24:	4622      	mov	r2, r4
 8012c26:	2100      	movs	r1, #0
 8012c28:	e78e      	b.n	8012b48 <set_next_comm_step+0x1a8>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 8012c2a:	2108      	movs	r1, #8
 8012c2c:	481d      	ldr	r0, [pc, #116]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c2e:	f011 fdaf 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012c32:	2201      	movs	r2, #1
 8012c34:	2108      	movs	r1, #8
 8012c36:	481b      	ldr	r0, [pc, #108]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c38:	f011 fe02 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012c3c:	462a      	mov	r2, r5
 8012c3e:	2108      	movs	r1, #8
 8012c40:	4818      	ldr	r0, [pc, #96]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c42:	f011 fe0d 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, positive_oc_mode);
 8012c46:	2260      	movs	r2, #96	; 0x60
 8012c48:	4629      	mov	r1, r5
 8012c4a:	4816      	ldr	r0, [pc, #88]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c4c:	f011 fda0 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, positive_highside);
 8012c50:	2201      	movs	r2, #1
 8012c52:	4629      	mov	r1, r5
 8012c54:	4813      	ldr	r0, [pc, #76]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c56:	f011 fdf3 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, positive_lowside);
 8012c5a:	4622      	mov	r2, r4
 8012c5c:	4629      	mov	r1, r5
 8012c5e:	e773      	b.n	8012b48 <set_next_comm_step+0x1a8>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012c60:	2104      	movs	r1, #4
 8012c62:	4810      	ldr	r0, [pc, #64]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c64:	f011 fd94 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012c68:	2201      	movs	r2, #1
 8012c6a:	2104      	movs	r1, #4
 8012c6c:	480d      	ldr	r0, [pc, #52]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c6e:	f011 fde7 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012c72:	462a      	mov	r2, r5
 8012c74:	2104      	movs	r1, #4
			TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012c76:	480b      	ldr	r0, [pc, #44]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c78:	f011 fdf2 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, positive_oc_mode);
 8012c7c:	2260      	movs	r2, #96	; 0x60
 8012c7e:	4629      	mov	r1, r5
 8012c80:	4808      	ldr	r0, [pc, #32]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c82:	f011 fd85 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, positive_highside);
 8012c86:	2201      	movs	r2, #1
 8012c88:	4629      	mov	r1, r5
 8012c8a:	4806      	ldr	r0, [pc, #24]	; (8012ca4 <set_next_comm_step+0x304>)
 8012c8c:	f011 fdd8 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012c90:	4622      	mov	r2, r4
 8012c92:	4629      	mov	r1, r5
 8012c94:	e7a0      	b.n	8012bd8 <set_next_comm_step+0x238>
 8012c96:	bf00      	nop
 8012c98:	20004d50 	.word	0x20004d50
 8012c9c:	200059f4 	.word	0x200059f4
 8012ca0:	20004e18 	.word	0x20004e18
 8012ca4:	40010000 	.word	0x40010000
		if (direction) {
 8012ca8:	4b53      	ldr	r3, [pc, #332]	; (8012df8 <set_next_comm_step+0x458>)
 8012caa:	681d      	ldr	r5, [r3, #0]
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012cac:	2220      	movs	r2, #32
		if (direction) {
 8012cae:	2d00      	cmp	r5, #0
 8012cb0:	d039      	beq.n	8012d26 <set_next_comm_step+0x386>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012cb2:	2104      	movs	r1, #4
 8012cb4:	4851      	ldr	r0, [pc, #324]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cb6:	f011 fd6b 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012cba:	2201      	movs	r2, #1
 8012cbc:	2104      	movs	r1, #4
 8012cbe:	484f      	ldr	r0, [pc, #316]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cc0:	f011 fdbe 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012cc4:	2200      	movs	r2, #0
 8012cc6:	2104      	movs	r1, #4
 8012cc8:	484c      	ldr	r0, [pc, #304]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cca:	f011 fdc9 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, positive_oc_mode);
 8012cce:	2260      	movs	r2, #96	; 0x60
 8012cd0:	2108      	movs	r1, #8
 8012cd2:	484a      	ldr	r0, [pc, #296]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cd4:	f011 fd5c 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, positive_highside);
 8012cd8:	2201      	movs	r2, #1
 8012cda:	2108      	movs	r1, #8
 8012cdc:	4847      	ldr	r0, [pc, #284]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cde:	f011 fdaf 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, positive_lowside);
 8012ce2:	4622      	mov	r2, r4
 8012ce4:	2108      	movs	r1, #8
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012ce6:	4845      	ldr	r0, [pc, #276]	; (8012dfc <set_next_comm_step+0x45c>)
 8012ce8:	f011 fdba 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, negative_oc_mode);
 8012cec:	4632      	mov	r2, r6
 8012cee:	2100      	movs	r1, #0
 8012cf0:	4842      	ldr	r0, [pc, #264]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cf2:	f011 fd4d 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, negative_highside);
 8012cf6:	2201      	movs	r2, #1
 8012cf8:	2100      	movs	r1, #0
 8012cfa:	4840      	ldr	r0, [pc, #256]	; (8012dfc <set_next_comm_step+0x45c>)
 8012cfc:	f011 fda0 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, negative_lowside);
 8012d00:	2204      	movs	r2, #4
 8012d02:	2100      	movs	r1, #0
 8012d04:	483d      	ldr	r0, [pc, #244]	; (8012dfc <set_next_comm_step+0x45c>)
}
 8012d06:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			TIM_CCxNCmd(TIM1, TIM_Channel_1, negative_lowside);
 8012d0a:	f011 bda9 	b.w	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_Inactive);
 8012d0e:	4639      	mov	r1, r7
 8012d10:	483a      	ldr	r0, [pc, #232]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d12:	f011 fd3d 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012d16:	2201      	movs	r2, #1
 8012d18:	4639      	mov	r1, r7
 8012d1a:	4838      	ldr	r0, [pc, #224]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d1c:	f011 fd90 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012d20:	463a      	mov	r2, r7
 8012d22:	4639      	mov	r1, r7
 8012d24:	e7a7      	b.n	8012c76 <set_next_comm_step+0x2d6>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_Inactive);
 8012d26:	2108      	movs	r1, #8
 8012d28:	4834      	ldr	r0, [pc, #208]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d2a:	f011 fd31 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012d2e:	2201      	movs	r2, #1
 8012d30:	2108      	movs	r1, #8
 8012d32:	4832      	ldr	r0, [pc, #200]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d34:	f011 fd84 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012d38:	462a      	mov	r2, r5
 8012d3a:	2108      	movs	r1, #8
 8012d3c:	482f      	ldr	r0, [pc, #188]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d3e:	f011 fd8f 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, positive_oc_mode);
 8012d42:	2260      	movs	r2, #96	; 0x60
 8012d44:	2104      	movs	r1, #4
 8012d46:	482d      	ldr	r0, [pc, #180]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d48:	f011 fd22 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, positive_highside);
 8012d4c:	2201      	movs	r2, #1
 8012d4e:	2104      	movs	r1, #4
 8012d50:	482a      	ldr	r0, [pc, #168]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d52:	f011 fd75 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, positive_lowside);
 8012d56:	4622      	mov	r2, r4
 8012d58:	2104      	movs	r1, #4
			TIM_CCxNCmd(TIM1, TIM_Channel_3, positive_lowside);
 8012d5a:	4828      	ldr	r0, [pc, #160]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d5c:	f011 fd80 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_1, negative_oc_mode);
 8012d60:	4632      	mov	r2, r6
 8012d62:	e6c1      	b.n	8012ae8 <set_next_comm_step+0x148>
			TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_Inactive);
 8012d64:	2104      	movs	r1, #4
 8012d66:	4825      	ldr	r0, [pc, #148]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d68:	f011 fd12 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012d6c:	2201      	movs	r2, #1
 8012d6e:	2104      	movs	r1, #4
 8012d70:	4822      	ldr	r0, [pc, #136]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d72:	f011 fd65 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012d76:	462a      	mov	r2, r5
 8012d78:	2104      	movs	r1, #4
 8012d7a:	4820      	ldr	r0, [pc, #128]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d7c:	f011 fd70 	bl	8024860 <TIM_CCxNCmd>
			TIM_SelectOCxM(TIM1, TIM_Channel_3, positive_oc_mode);
 8012d80:	2260      	movs	r2, #96	; 0x60
 8012d82:	2108      	movs	r1, #8
 8012d84:	481d      	ldr	r0, [pc, #116]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d86:	f011 fd03 	bl	8024790 <TIM_SelectOCxM>
			TIM_CCxCmd(TIM1, TIM_Channel_3, positive_highside);
 8012d8a:	2201      	movs	r2, #1
 8012d8c:	2108      	movs	r1, #8
 8012d8e:	481b      	ldr	r0, [pc, #108]	; (8012dfc <set_next_comm_step+0x45c>)
 8012d90:	f011 fd56 	bl	8024840 <TIM_CCxCmd>
			TIM_CCxNCmd(TIM1, TIM_Channel_3, positive_lowside);
 8012d94:	4622      	mov	r2, r4
 8012d96:	2108      	movs	r1, #8
 8012d98:	e7df      	b.n	8012d5a <set_next_comm_step+0x3ba>
		TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);
 8012d9a:	2240      	movs	r2, #64	; 0x40
 8012d9c:	2100      	movs	r1, #0
 8012d9e:	4817      	ldr	r0, [pc, #92]	; (8012dfc <set_next_comm_step+0x45c>)
 8012da0:	f011 fcf6 	bl	8024790 <TIM_SelectOCxM>
		TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012da4:	2201      	movs	r2, #1
 8012da6:	2100      	movs	r1, #0
 8012da8:	4814      	ldr	r0, [pc, #80]	; (8012dfc <set_next_comm_step+0x45c>)
 8012daa:	f011 fd49 	bl	8024840 <TIM_CCxCmd>
		TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012dae:	2200      	movs	r2, #0
 8012db0:	4611      	mov	r1, r2
 8012db2:	4812      	ldr	r0, [pc, #72]	; (8012dfc <set_next_comm_step+0x45c>)
 8012db4:	f011 fd54 	bl	8024860 <TIM_CCxNCmd>
		TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);
 8012db8:	2240      	movs	r2, #64	; 0x40
 8012dba:	2104      	movs	r1, #4
 8012dbc:	480f      	ldr	r0, [pc, #60]	; (8012dfc <set_next_comm_step+0x45c>)
 8012dbe:	f011 fce7 	bl	8024790 <TIM_SelectOCxM>
		TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012dc2:	2201      	movs	r2, #1
 8012dc4:	2104      	movs	r1, #4
 8012dc6:	480d      	ldr	r0, [pc, #52]	; (8012dfc <set_next_comm_step+0x45c>)
 8012dc8:	f011 fd3a 	bl	8024840 <TIM_CCxCmd>
		TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012dcc:	2200      	movs	r2, #0
 8012dce:	2104      	movs	r1, #4
 8012dd0:	480a      	ldr	r0, [pc, #40]	; (8012dfc <set_next_comm_step+0x45c>)
 8012dd2:	f011 fd45 	bl	8024860 <TIM_CCxNCmd>
		TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
 8012dd6:	2240      	movs	r2, #64	; 0x40
 8012dd8:	2108      	movs	r1, #8
 8012dda:	4808      	ldr	r0, [pc, #32]	; (8012dfc <set_next_comm_step+0x45c>)
 8012ddc:	f011 fcd8 	bl	8024790 <TIM_SelectOCxM>
		TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012de0:	2201      	movs	r2, #1
 8012de2:	2108      	movs	r1, #8
 8012de4:	4805      	ldr	r0, [pc, #20]	; (8012dfc <set_next_comm_step+0x45c>)
 8012de6:	f011 fd2b 	bl	8024840 <TIM_CCxCmd>
		TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012dea:	2200      	movs	r2, #0
 8012dec:	2108      	movs	r1, #8
 8012dee:	4803      	ldr	r0, [pc, #12]	; (8012dfc <set_next_comm_step+0x45c>)
}
 8012df0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012df4:	f011 bd34 	b.w	8024860 <TIM_CCxNCmd>
 8012df8:	20004e18 	.word	0x20004e18
 8012dfc:	40010000 	.word	0x40010000

08012e00 <full_brake_hw>:
static void full_brake_hw(void) {
 8012e00:	b510      	push	{r4, lr}
	TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);
 8012e02:	4c1d      	ldr	r4, [pc, #116]	; (8012e78 <full_brake_hw+0x78>)
 8012e04:	2240      	movs	r2, #64	; 0x40
 8012e06:	4620      	mov	r0, r4
 8012e08:	2100      	movs	r1, #0
 8012e0a:	f011 fcc1 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012e0e:	4620      	mov	r0, r4
 8012e10:	2201      	movs	r2, #1
 8012e12:	2100      	movs	r1, #0
 8012e14:	f011 fd14 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);
 8012e18:	4620      	mov	r0, r4
 8012e1a:	2204      	movs	r2, #4
 8012e1c:	2100      	movs	r1, #0
 8012e1e:	f011 fd1f 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);
 8012e22:	4620      	mov	r0, r4
 8012e24:	2240      	movs	r2, #64	; 0x40
 8012e26:	2104      	movs	r1, #4
 8012e28:	f011 fcb2 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012e2c:	4620      	mov	r0, r4
 8012e2e:	2201      	movs	r2, #1
 8012e30:	2104      	movs	r1, #4
 8012e32:	f011 fd05 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
 8012e36:	2204      	movs	r2, #4
 8012e38:	4620      	mov	r0, r4
 8012e3a:	4611      	mov	r1, r2
 8012e3c:	f011 fd10 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
 8012e40:	4620      	mov	r0, r4
 8012e42:	2240      	movs	r2, #64	; 0x40
 8012e44:	2108      	movs	r1, #8
 8012e46:	f011 fca3 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012e4a:	4620      	mov	r0, r4
 8012e4c:	2201      	movs	r2, #1
 8012e4e:	2108      	movs	r1, #8
 8012e50:	f011 fcf6 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
 8012e54:	4620      	mov	r0, r4
 8012e56:	2204      	movs	r2, #4
 8012e58:	2108      	movs	r1, #8
 8012e5a:	f011 fd01 	bl	8024860 <TIM_CCxNCmd>
	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 8012e5e:	4620      	mov	r0, r4
 8012e60:	2120      	movs	r1, #32
 8012e62:	f011 fd45 	bl	80248f0 <TIM_GenerateEvent>
	set_switching_frequency(conf->m_bldc_f_sw_max);
 8012e66:	4b05      	ldr	r3, [pc, #20]	; (8012e7c <full_brake_hw+0x7c>)
 8012e68:	681b      	ldr	r3, [r3, #0]
}
 8012e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	set_switching_frequency(conf->m_bldc_f_sw_max);
 8012e6e:	ed93 0a5a 	vldr	s0, [r3, #360]	; 0x168
 8012e72:	f7ff bcd5 	b.w	8012820 <set_switching_frequency>
 8012e76:	bf00      	nop
 8012e78:	40010000 	.word	0x40010000
 8012e7c:	20004d50 	.word	0x20004d50

08012e80 <stop_pwm_hw>:
static void stop_pwm_hw(void) {
 8012e80:	b510      	push	{r4, lr}
	TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);
 8012e82:	4c1d      	ldr	r4, [pc, #116]	; (8012ef8 <stop_pwm_hw+0x78>)
 8012e84:	2240      	movs	r2, #64	; 0x40
 8012e86:	4620      	mov	r0, r4
 8012e88:	2100      	movs	r1, #0
 8012e8a:	f011 fc81 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 8012e8e:	4620      	mov	r0, r4
 8012e90:	2201      	movs	r2, #1
 8012e92:	2100      	movs	r1, #0
 8012e94:	f011 fcd4 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 8012e98:	2200      	movs	r2, #0
 8012e9a:	4620      	mov	r0, r4
 8012e9c:	4611      	mov	r1, r2
 8012e9e:	f011 fcdf 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);
 8012ea2:	4620      	mov	r0, r4
 8012ea4:	2240      	movs	r2, #64	; 0x40
 8012ea6:	2104      	movs	r1, #4
 8012ea8:	f011 fc72 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 8012eac:	4620      	mov	r0, r4
 8012eae:	2201      	movs	r2, #1
 8012eb0:	2104      	movs	r1, #4
 8012eb2:	f011 fcc5 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 8012eb6:	4620      	mov	r0, r4
 8012eb8:	2200      	movs	r2, #0
 8012eba:	2104      	movs	r1, #4
 8012ebc:	f011 fcd0 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
 8012ec0:	4620      	mov	r0, r4
 8012ec2:	2240      	movs	r2, #64	; 0x40
 8012ec4:	2108      	movs	r1, #8
 8012ec6:	f011 fc63 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 8012eca:	4620      	mov	r0, r4
 8012ecc:	2201      	movs	r2, #1
 8012ece:	2108      	movs	r1, #8
 8012ed0:	f011 fcb6 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 8012ed4:	4620      	mov	r0, r4
 8012ed6:	2200      	movs	r2, #0
 8012ed8:	2108      	movs	r1, #8
 8012eda:	f011 fcc1 	bl	8024860 <TIM_CCxNCmd>
	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 8012ede:	4620      	mov	r0, r4
 8012ee0:	2120      	movs	r1, #32
 8012ee2:	f011 fd05 	bl	80248f0 <TIM_GenerateEvent>
	set_switching_frequency(conf->m_bldc_f_sw_max);
 8012ee6:	4b05      	ldr	r3, [pc, #20]	; (8012efc <stop_pwm_hw+0x7c>)
 8012ee8:	681b      	ldr	r3, [r3, #0]
}
 8012eea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	set_switching_frequency(conf->m_bldc_f_sw_max);
 8012eee:	ed93 0a5a 	vldr	s0, [r3, #360]	; 0x168
 8012ef2:	f7ff bc95 	b.w	8012820 <set_switching_frequency>
 8012ef6:	bf00      	nop
 8012ef8:	40010000 	.word	0x40010000
 8012efc:	20004d50 	.word	0x20004d50

08012f00 <commutate>:
	last_pwm_cycles_sum = pwm_cycles_sum;
 8012f00:	4b2e      	ldr	r3, [pc, #184]	; (8012fbc <commutate+0xbc>)
 8012f02:	4a2f      	ldr	r2, [pc, #188]	; (8012fc0 <commutate+0xc0>)
 8012f04:	6819      	ldr	r1, [r3, #0]
static void commutate(int steps) {
 8012f06:	b5f0      	push	{r4, r5, r6, r7, lr}
	last_pwm_cycles_sums[comm_step - 1] = pwm_cycles_sum;
 8012f08:	4c2e      	ldr	r4, [pc, #184]	; (8012fc4 <commutate+0xc4>)
	last_pwm_cycles_sum = pwm_cycles_sum;
 8012f0a:	6011      	str	r1, [r2, #0]
	last_pwm_cycles_sums[comm_step - 1] = pwm_cycles_sum;
 8012f0c:	6821      	ldr	r1, [r4, #0]
 8012f0e:	4a2e      	ldr	r2, [pc, #184]	; (8012fc8 <commutate+0xc8>)
	if (conf->motor_type == MOTOR_TYPE_BLDC && sensorless_now) {
 8012f10:	4e2e      	ldr	r6, [pc, #184]	; (8012fcc <commutate+0xcc>)
	last_pwm_cycles_sums[comm_step - 1] = pwm_cycles_sum;
 8012f12:	681f      	ldr	r7, [r3, #0]
 8012f14:	3901      	subs	r1, #1
 8012f16:	eb02 0281 	add.w	r2, r2, r1, lsl #2
	pwm_cycles_sum = 0;
 8012f1a:	2500      	movs	r5, #0
	pwm_cycles = 0;
 8012f1c:	492c      	ldr	r1, [pc, #176]	; (8012fd0 <commutate+0xd0>)
	last_pwm_cycles_sums[comm_step - 1] = pwm_cycles_sum;
 8012f1e:	6017      	str	r7, [r2, #0]
	pwm_cycles_sum = 0;
 8012f20:	601d      	str	r5, [r3, #0]
	if (conf->motor_type == MOTOR_TYPE_BLDC && sensorless_now) {
 8012f22:	6832      	ldr	r2, [r6, #0]
	pwm_cycles = 0;
 8012f24:	2300      	movs	r3, #0
 8012f26:	600b      	str	r3, [r1, #0]
	if (conf->motor_type == MOTOR_TYPE_BLDC && sensorless_now) {
 8012f28:	7893      	ldrb	r3, [r2, #2]
static void commutate(int steps) {
 8012f2a:	b087      	sub	sp, #28
	if (conf->motor_type == MOTOR_TYPE_BLDC && sensorless_now) {
 8012f2c:	bb23      	cbnz	r3, 8012f78 <commutate+0x78>
 8012f2e:	4b29      	ldr	r3, [pc, #164]	; (8012fd4 <commutate+0xd4>)
 8012f30:	781b      	ldrb	r3, [r3, #0]
 8012f32:	b30b      	cbz	r3, 8012f78 <commutate+0x78>
		comm_step += steps;
 8012f34:	6823      	ldr	r3, [r4, #0]
 8012f36:	4418      	add	r0, r3
 8012f38:	6020      	str	r0, [r4, #0]
		while (comm_step > 6) {
 8012f3a:	6823      	ldr	r3, [r4, #0]
 8012f3c:	2b06      	cmp	r3, #6
 8012f3e:	dd0b      	ble.n	8012f58 <commutate+0x58>
			comm_step -= 6;
 8012f40:	6823      	ldr	r3, [r4, #0]
 8012f42:	3b06      	subs	r3, #6
 8012f44:	6023      	str	r3, [r4, #0]
		while (comm_step > 6) {
 8012f46:	6823      	ldr	r3, [r4, #0]
 8012f48:	2b06      	cmp	r3, #6
 8012f4a:	dcf9      	bgt.n	8012f40 <commutate+0x40>
		while (comm_step < 1) {
 8012f4c:	6823      	ldr	r3, [r4, #0]
 8012f4e:	2b00      	cmp	r3, #0
 8012f50:	dc05      	bgt.n	8012f5e <commutate+0x5e>
			comm_step += 6;
 8012f52:	6823      	ldr	r3, [r4, #0]
 8012f54:	3306      	adds	r3, #6
 8012f56:	6023      	str	r3, [r4, #0]
		while (comm_step < 1) {
 8012f58:	6823      	ldr	r3, [r4, #0]
 8012f5a:	2b00      	cmp	r3, #0
 8012f5c:	ddf9      	ble.n	8012f52 <commutate+0x52>
		update_rpm_tacho();
 8012f5e:	f7ff fb8f 	bl	8012680 <update_rpm_tacho>
		if (!(state == MC_STATE_RUNNING)) {
 8012f62:	4b1d      	ldr	r3, [pc, #116]	; (8012fd8 <commutate+0xd8>)
 8012f64:	781b      	ldrb	r3, [r3, #0]
 8012f66:	2b02      	cmp	r3, #2
 8012f68:	d003      	beq.n	8012f72 <commutate+0x72>
			update_sensor_mode();
 8012f6a:	f7ff fbd9 	bl	8012720 <update_sensor_mode>
}
 8012f6e:	b007      	add	sp, #28
 8012f70:	bdf0      	pop	{r4, r5, r6, r7, pc}
		set_next_comm_step(comm_step);
 8012f72:	6820      	ldr	r0, [r4, #0]
 8012f74:	f7ff fd14 	bl	80129a0 <set_next_comm_step>
	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 8012f78:	2120      	movs	r1, #32
 8012f7a:	4818      	ldr	r0, [pc, #96]	; (8012fdc <commutate+0xdc>)
	timer_tmp = timer_struct;
 8012f7c:	4d18      	ldr	r5, [pc, #96]	; (8012fe0 <commutate+0xe0>)
	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 8012f7e:	f011 fcb7 	bl	80248f0 <TIM_GenerateEvent>
	has_commutated = 1;
 8012f82:	4b18      	ldr	r3, [pc, #96]	; (8012fe4 <commutate+0xe4>)
 8012f84:	2201      	movs	r2, #1
 8012f86:	601a      	str	r2, [r3, #0]
	utils_sys_lock_cnt();
 8012f88:	f003 f88a 	bl	80160a0 <utils_sys_lock_cnt>
	timer_tmp = timer_struct;
 8012f8c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8012f8e:	466c      	mov	r4, sp
 8012f90:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8012f92:	e895 0003 	ldmia.w	r5, {r0, r1}
 8012f96:	e884 0003 	stmia.w	r4, {r0, r1}
	utils_sys_unlock_cnt();
 8012f9a:	f003 f891 	bl	80160c0 <utils_sys_unlock_cnt>
	update_adc_sample_pos(&timer_tmp);
 8012f9e:	4668      	mov	r0, sp
 8012fa0:	f7ff fa8e 	bl	80124c0 <update_adc_sample_pos>
	set_next_timer_settings(&timer_tmp);
 8012fa4:	4668      	mov	r0, sp
 8012fa6:	f7ff fc23 	bl	80127f0 <set_next_timer_settings>
	update_sensor_mode();
 8012faa:	f7ff fbb9 	bl	8012720 <update_sensor_mode>
	conf->comm_mode = comm_mode_next;
 8012fae:	4b0e      	ldr	r3, [pc, #56]	; (8012fe8 <commutate+0xe8>)
 8012fb0:	6832      	ldr	r2, [r6, #0]
 8012fb2:	781b      	ldrb	r3, [r3, #0]
 8012fb4:	b2db      	uxtb	r3, r3
 8012fb6:	7053      	strb	r3, [r2, #1]
}
 8012fb8:	b007      	add	sp, #28
 8012fba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012fbc:	20005420 	.word	0x20005420
 8012fc0:	2000536c 	.word	0x2000536c
 8012fc4:	20004d4c 	.word	0x20004d4c
 8012fc8:	20005370 	.word	0x20005370
 8012fcc:	20004d50 	.word	0x20004d50
 8012fd0:	2000541c 	.word	0x2000541c
 8012fd4:	200059e8 	.word	0x200059e8
 8012fd8:	200059f4 	.word	0x200059f4
 8012fdc:	40010000 	.word	0x40010000
 8012fe0:	20005a08 	.word	0x20005a08
 8012fe4:	20004f44 	.word	0x20004f44
 8012fe8:	20004d48 	.word	0x20004d48
 8012fec:	00000000 	.word	0x00000000

08012ff0 <timer_thread>:
static THD_FUNCTION(timer_thread, arg) {
 8012ff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012ff4:	4b7a      	ldr	r3, [pc, #488]	; (80131e0 <timer_thread+0x1f0>)
		if (timer_thd_stop) {
 8012ff6:	4e7b      	ldr	r6, [pc, #492]	; (80131e4 <timer_thread+0x1f4>)
 8012ff8:	699a      	ldr	r2, [r3, #24]
 8012ffa:	7833      	ldrb	r3, [r6, #0]
 8012ffc:	497a      	ldr	r1, [pc, #488]	; (80131e8 <timer_thread+0x1f8>)
static THD_FUNCTION(timer_thread, arg) {
 8012ffe:	ed2d 8b06 	vpush	{d8-d10}
 8013002:	6191      	str	r1, [r2, #24]
		if (timer_thd_stop) {
 8013004:	2b00      	cmp	r3, #0
 8013006:	d15d      	bne.n	80130c4 <timer_thread+0xd4>
 8013008:	4d78      	ldr	r5, [pc, #480]	; (80131ec <timer_thread+0x1fc>)
 801300a:	4c79      	ldr	r4, [pc, #484]	; (80131f0 <timer_thread+0x200>)
			tachometer_for_direction = 0;
 801300c:	4f79      	ldr	r7, [pc, #484]	; (80131f4 <timer_thread+0x204>)
					max_s = 0.0;
 801300e:	ed9f aa7a 	vldr	s20, [pc, #488]	; 80131f8 <timer_thread+0x208>
					min_s = 9999999999999.0;
 8013012:	eddf 9a7a 	vldr	s19, [pc, #488]	; 80131fc <timer_thread+0x20c>
					if ((max_s - min_s) / ((max_s + min_s) / 2.0) > 1.2) {
 8013016:	ed9f 9a7a 	vldr	s18, [pc, #488]	; 8013200 <timer_thread+0x210>
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 801301a:	eddf 8a7a 	vldr	s17, [pc, #488]	; 8013204 <timer_thread+0x214>
 801301e:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 8013208 <timer_thread+0x218>
 8013022:	e006      	b.n	8013032 <timer_thread+0x42>
		cnt_tmp++;
 8013024:	6023      	str	r3, [r4, #0]
		chThdSleepMilliseconds(1);
 8013026:	200a      	movs	r0, #10
 8013028:	f7fa fcda 	bl	800d9e0 <chThdSleep>
		if (timer_thd_stop) {
 801302c:	7833      	ldrb	r3, [r6, #0]
 801302e:	2b00      	cmp	r3, #0
 8013030:	d148      	bne.n	80130c4 <timer_thread+0xd4>
		if (state == MC_STATE_OFF) {
 8013032:	782b      	ldrb	r3, [r5, #0]
 8013034:	f003 08ff 	and.w	r8, r3, #255	; 0xff
 8013038:	b323      	cbz	r3, 8013084 <timer_thread+0x94>
			tachometer_for_direction = 0;
 801303a:	2300      	movs	r3, #0
 801303c:	603b      	str	r3, [r7, #0]
		cnt_tmp++;
 801303e:	6823      	ldr	r3, [r4, #0]
 8013040:	3301      	adds	r3, #1
		if (cnt_tmp >= 10) {
 8013042:	2b09      	cmp	r3, #9
 8013044:	ddee      	ble.n	8013024 <timer_thread+0x34>
			if (state == MC_STATE_RUNNING) {
 8013046:	782b      	ldrb	r3, [r5, #0]
			cnt_tmp = 0;
 8013048:	2200      	movs	r2, #0
			if (state == MC_STATE_RUNNING) {
 801304a:	2b02      	cmp	r3, #2
			cnt_tmp = 0;
 801304c:	6022      	str	r2, [r4, #0]
			if (state == MC_STATE_RUNNING) {
 801304e:	d064      	beq.n	801311a <timer_thread+0x12a>
			} else if (state == MC_STATE_OFF) {
 8013050:	782b      	ldrb	r3, [r5, #0]
 8013052:	2b00      	cmp	r3, #0
 8013054:	d1e7      	bne.n	8013026 <timer_thread+0x36>
				if (dutycycle_now >= conf->l_min_duty) {
 8013056:	4a6d      	ldr	r2, [pc, #436]	; (801320c <timer_thread+0x21c>)
 8013058:	4b6d      	ldr	r3, [pc, #436]	; (8013210 <timer_thread+0x220>)
 801305a:	6812      	ldr	r2, [r2, #0]
 801305c:	ed92 7a15 	vldr	s14, [r2, #84]	; 0x54
 8013060:	edd3 7a00 	vldr	s15, [r3]
 8013064:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013068:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801306c:	d8db      	bhi.n	8013026 <timer_thread+0x36>
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 801306e:	4969      	ldr	r1, [pc, #420]	; (8013214 <timer_thread+0x224>)
 8013070:	4a69      	ldr	r2, [pc, #420]	; (8013218 <timer_thread+0x228>)
 8013072:	ed91 0a00 	vldr	s0, [r1]
 8013076:	8a12      	ldrh	r2, [r2, #16]
 8013078:	ed93 7a00 	vldr	s14, [r3]
 801307c:	ee07 2a90 	vmov	s15, r2
					filter_add_sample((float*)kv_fir_samples, mcpwm_get_kv(),
 8013080:	4a66      	ldr	r2, [pc, #408]	; (801321c <timer_thread+0x22c>)
 8013082:	e055      	b.n	8013130 <timer_thread+0x140>
			amp = filter_run_fir_iteration((float*)amp_fir_samples,
 8013084:	4b66      	ldr	r3, [pc, #408]	; (8013220 <timer_thread+0x230>)
 8013086:	4967      	ldr	r1, [pc, #412]	; (8013224 <timer_thread+0x234>)
 8013088:	681b      	ldr	r3, [r3, #0]
 801308a:	4867      	ldr	r0, [pc, #412]	; (8013228 <timer_thread+0x238>)
 801308c:	2207      	movs	r2, #7
 801308e:	f7ff f957 	bl	8012340 <filter_run_fir_iteration>
			if (conf->motor_type == MOTOR_TYPE_DC) {
 8013092:	4b5e      	ldr	r3, [pc, #376]	; (801320c <timer_thread+0x21c>)
 8013094:	6819      	ldr	r1, [r3, #0]
 8013096:	788b      	ldrb	r3, [r1, #2]
 8013098:	b2db      	uxtb	r3, r3
 801309a:	2b01      	cmp	r3, #1
 801309c:	d018      	beq.n	80130d0 <timer_thread+0xe0>
				if (sensorless_now) {
 801309e:	4b63      	ldr	r3, [pc, #396]	; (801322c <timer_thread+0x23c>)
 80130a0:	781b      	ldrb	r3, [r3, #0]
 80130a2:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80130a6:	2b00      	cmp	r3, #0
 80130a8:	d159      	bne.n	801315e <timer_thread+0x16e>
					if (tachometer_for_direction < -3) {
 80130aa:	683b      	ldr	r3, [r7, #0]
 80130ac:	3303      	adds	r3, #3
 80130ae:	da50      	bge.n	8013152 <timer_thread+0x162>
						if (direction == 1) {
 80130b0:	4a5f      	ldr	r2, [pc, #380]	; (8013230 <timer_thread+0x240>)
 80130b2:	6813      	ldr	r3, [r2, #0]
 80130b4:	2b01      	cmp	r3, #1
 80130b6:	f000 8090 	beq.w	80131da <timer_thread+0x1ea>
							direction = 1;
 80130ba:	2301      	movs	r3, #1
 80130bc:	6013      	str	r3, [r2, #0]
						tachometer_for_direction = 0;
 80130be:	2300      	movs	r3, #0
 80130c0:	603b      	str	r3, [r7, #0]
 80130c2:	e010      	b.n	80130e6 <timer_thread+0xf6>
}
 80130c4:	ecbd 8b06 	vpop	{d8-d10}
			timer_thd_stop = false;
 80130c8:	2300      	movs	r3, #0
 80130ca:	7033      	strb	r3, [r6, #0]
}
 80130cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (amp > 0) {
 80130d0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
					direction = 0;
 80130d4:	4a56      	ldr	r2, [pc, #344]	; (8013230 <timer_thread+0x240>)
				if (amp > 0) {
 80130d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					direction = 0;
 80130da:	bfce      	itee	gt
 80130dc:	f8c2 8000 	strgt.w	r8, [r2]
					amp = -amp;
 80130e0:	eeb1 0a40 	vnegle.f32	s0, s0
					direction = 1;
 80130e4:	6013      	strle	r3, [r2, #0]
			if (direction == 1) {
 80130e6:	6813      	ldr	r3, [r2, #0]
				dutycycle_now = amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 80130e8:	4a4b      	ldr	r2, [pc, #300]	; (8013218 <timer_thread+0x228>)
			utils_truncate_number((float*)&dutycycle_now, -conf->l_max_duty, conf->l_max_duty);
 80130ea:	4849      	ldr	r0, [pc, #292]	; (8013210 <timer_thread+0x220>)
				dutycycle_now = amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 80130ec:	8a12      	ldrh	r2, [r2, #16]
 80130ee:	ee07 2a90 	vmov	s15, r2
			if (direction == 1) {
 80130f2:	2b01      	cmp	r3, #1
				dutycycle_now = amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 80130f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
				dutycycle_now = -amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 80130f8:	bf18      	it	ne
 80130fa:	eeb1 0a40 	vnegne.f32	s0, s0
 80130fe:	ee80 7a27 	vdiv.f32	s14, s0, s15
				dutycycle_now = amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 8013102:	4b43      	ldr	r3, [pc, #268]	; (8013210 <timer_thread+0x220>)
				dutycycle_now = -amp / (float)ADC_Value[ADC_IND_VIN_SENS];
 8013104:	ed83 7a00 	vstr	s14, [r3]
			utils_truncate_number((float*)&dutycycle_now, -conf->l_max_duty, conf->l_max_duty);
 8013108:	ed91 0a16 	vldr	s0, [r1, #88]	; 0x58
 801310c:	edd1 0a16 	vldr	s1, [r1, #88]	; 0x58
 8013110:	eeb1 0a40 	vneg.f32	s0, s0
 8013114:	f002 fcb4 	bl	8015a80 <utils_truncate_number>
 8013118:	e791      	b.n	801303e <timer_thread+0x4e>
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 801311a:	4a3e      	ldr	r2, [pc, #248]	; (8013214 <timer_thread+0x224>)
 801311c:	4b3e      	ldr	r3, [pc, #248]	; (8013218 <timer_thread+0x228>)
 801311e:	ed92 0a00 	vldr	s0, [r2]
 8013122:	8a1b      	ldrh	r3, [r3, #16]
				filter_add_sample((float*)kv_fir_samples, mcpwm_get_kv(),
 8013124:	4a3d      	ldr	r2, [pc, #244]	; (801321c <timer_thread+0x22c>)
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 8013126:	ee07 3a90 	vmov	s15, r3
 801312a:	4b39      	ldr	r3, [pc, #228]	; (8013210 <timer_thread+0x220>)
 801312c:	ed93 7a00 	vldr	s14, [r3]
					filter_add_sample((float*)kv_fir_samples, mcpwm_get_kv(),
 8013130:	4840      	ldr	r0, [pc, #256]	; (8013234 <timer_thread+0x244>)
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 8013132:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013136:	eeb0 7ac7 	vabs.f32	s14, s14
 801313a:	ee67 7aa8 	vmul.f32	s15, s15, s17
					filter_add_sample((float*)kv_fir_samples, mcpwm_get_kv(),
 801313e:	2107      	movs	r1, #7
	return rpm_now / (GET_INPUT_VOLTAGE() * fabsf(dutycycle_now));
 8013140:	ee67 7a88 	vmul.f32	s15, s15, s16
 8013144:	ee67 7a87 	vmul.f32	s15, s15, s14
					filter_add_sample((float*)kv_fir_samples, mcpwm_get_kv(),
 8013148:	ee80 0a27 	vdiv.f32	s0, s0, s15
 801314c:	f7ff f920 	bl	8012390 <filter_add_sample>
 8013150:	e769      	b.n	8013026 <timer_thread+0x36>
					} else if (tachometer_for_direction > 0) {
 8013152:	683b      	ldr	r3, [r7, #0]
 8013154:	4a36      	ldr	r2, [pc, #216]	; (8013230 <timer_thread+0x240>)
 8013156:	2b00      	cmp	r3, #0
						tachometer_for_direction = 0;
 8013158:	bfc8      	it	gt
 801315a:	6038      	strgt	r0, [r7, #0]
 801315c:	e7c3      	b.n	80130e6 <timer_thread+0xf6>
 801315e:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 8013238 <timer_thread+0x248>
					max_s = 0.0;
 8013162:	eef0 7a4a 	vmov.f32	s15, s20
					min_s = 9999999999999.0;
 8013166:	eef0 6a69 	vmov.f32	s13, s19
					for (int i = 0;i < 6;i++) {
 801316a:	4643      	mov	r3, r8
						if (last_pwm_cycles_sums[i] < min_s) {
 801316c:	009a      	lsls	r2, r3, #2
 801316e:	eb0c 0002 	add.w	r0, ip, r2
 8013172:	ed90 7a00 	vldr	s14, [r0]
 8013176:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801317a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
							min_s = last_pwm_cycles_sums[i];
 801317e:	bf48      	it	mi
 8013180:	edd0 6a00 	vldrmi	s13, [r0]
						if (last_pwm_cycles_sums[i] > max_s) {
 8013184:	ed90 7a00 	vldr	s14, [r0]
 8013188:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801318c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					for (int i = 0;i < 6;i++) {
 8013190:	f103 0301 	add.w	r3, r3, #1
							max_s = last_pwm_cycles_sums[i];
 8013194:	bfc8      	it	gt
 8013196:	edd0 7a00 	vldrgt	s15, [r0]
					for (int i = 0;i < 6;i++) {
 801319a:	2b06      	cmp	r3, #6
 801319c:	d1e6      	bne.n	801316c <timer_thread+0x17c>
					if ((max_s - min_s) / ((max_s + min_s) / 2.0) > 1.2) {
 801319e:	ee36 7aa7 	vadd.f32	s14, s13, s15
 80131a2:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 80131a6:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80131aa:	ee27 7a06 	vmul.f32	s14, s14, s12
 80131ae:	eec7 6a87 	vdiv.f32	s13, s15, s14
 80131b2:	eef4 6ac9 	vcmpe.f32	s13, s18
 80131b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80131ba:	dd0a      	ble.n	80131d2 <timer_thread+0x1e2>
						if (tachometer_for_direction > 12) {
 80131bc:	683b      	ldr	r3, [r7, #0]
							if (direction == 1) {
 80131be:	4a1c      	ldr	r2, [pc, #112]	; (8013230 <timer_thread+0x240>)
						if (tachometer_for_direction > 12) {
 80131c0:	2b0c      	cmp	r3, #12
 80131c2:	dd90      	ble.n	80130e6 <timer_thread+0xf6>
							if (direction == 1) {
 80131c4:	6813      	ldr	r3, [r2, #0]
 80131c6:	2b01      	cmp	r3, #1
 80131c8:	f47f af77 	bne.w	80130ba <timer_thread+0xca>
								direction = 0;
 80131cc:	2300      	movs	r3, #0
 80131ce:	6013      	str	r3, [r2, #0]
 80131d0:	e775      	b.n	80130be <timer_thread+0xce>
						tachometer_for_direction = 0;
 80131d2:	2300      	movs	r3, #0
 80131d4:	603b      	str	r3, [r7, #0]
 80131d6:	4a16      	ldr	r2, [pc, #88]	; (8013230 <timer_thread+0x240>)
 80131d8:	e785      	b.n	80130e6 <timer_thread+0xf6>
							direction = 0;
 80131da:	6010      	str	r0, [r2, #0]
 80131dc:	e76f      	b.n	80130be <timer_thread+0xce>
 80131de:	bf00      	nop
 80131e0:	20001a48 	.word	0x20001a48
 80131e4:	20005a20 	.word	0x20005a20
 80131e8:	0802dff0 	.word	0x0802dff0
 80131ec:	200059f4 	.word	0x200059f4
 80131f0:	20004d44 	.word	0x20004d44
 80131f4:	20005a04 	.word	0x20005a04
 80131f8:	00000000 	.word	0x00000000
 80131fc:	551184e7 	.word	0x551184e7
 8013200:	3f99999a 	.word	0x3f99999a
 8013204:	3a534067 	.word	0x3a534067
 8013208:	4195d174 	.word	0x4195d174
 801320c:	20004d50 	.word	0x20004d50
 8013210:	20004e1c 	.word	0x20004e1c
 8013214:	20005444 	.word	0x20005444
 8013218:	2000c03c 	.word	0x2000c03c
 801321c:	20005158 	.word	0x20005158
 8013220:	20004b40 	.word	0x20004b40
 8013224:	20004940 	.word	0x20004940
 8013228:	20004b44 	.word	0x20004b44
 801322c:	200059e8 	.word	0x200059e8
 8013230:	20004e18 	.word	0x20004e18
 8013234:	2000515c 	.word	0x2000515c
 8013238:	20005370 	.word	0x20005370
 801323c:	00000000 	.word	0x00000000

08013240 <mcpwm_deinit>:
void mcpwm_deinit(void) {
 8013240:	b538      	push	{r3, r4, r5, lr}
	init_done = false;
 8013242:	4b17      	ldr	r3, [pc, #92]	; (80132a0 <mcpwm_deinit+0x60>)
	timer_thd_stop = true;
 8013244:	4c17      	ldr	r4, [pc, #92]	; (80132a4 <mcpwm_deinit+0x64>)
	rpm_thd_stop = true;
 8013246:	4d18      	ldr	r5, [pc, #96]	; (80132a8 <mcpwm_deinit+0x68>)
	init_done = false;
 8013248:	2200      	movs	r2, #0
 801324a:	701a      	strb	r2, [r3, #0]
	WWDG_DeInit();
 801324c:	f011 fbe0 	bl	8024a10 <WWDG_DeInit>
	timer_thd_stop = true;
 8013250:	2301      	movs	r3, #1
 8013252:	7023      	strb	r3, [r4, #0]
	rpm_thd_stop = true;
 8013254:	702b      	strb	r3, [r5, #0]
	while (timer_thd_stop || rpm_thd_stop) {
 8013256:	e001      	b.n	801325c <mcpwm_deinit+0x1c>
		chThdSleepMilliseconds(1);
 8013258:	f7fa fbc2 	bl	800d9e0 <chThdSleep>
	while (timer_thd_stop || rpm_thd_stop) {
 801325c:	7823      	ldrb	r3, [r4, #0]
		chThdSleepMilliseconds(1);
 801325e:	200a      	movs	r0, #10
	while (timer_thd_stop || rpm_thd_stop) {
 8013260:	2b00      	cmp	r3, #0
 8013262:	d1f9      	bne.n	8013258 <mcpwm_deinit+0x18>
 8013264:	782b      	ldrb	r3, [r5, #0]
 8013266:	2b00      	cmp	r3, #0
 8013268:	d1f6      	bne.n	8013258 <mcpwm_deinit+0x18>
	TIM_DeInit(TIM1);
 801326a:	4810      	ldr	r0, [pc, #64]	; (80132ac <mcpwm_deinit+0x6c>)
 801326c:	f011 f838 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM2);
 8013270:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8013274:	f011 f834 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM8);
 8013278:	480d      	ldr	r0, [pc, #52]	; (80132b0 <mcpwm_deinit+0x70>)
 801327a:	f011 f831 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM12);
 801327e:	480d      	ldr	r0, [pc, #52]	; (80132b4 <mcpwm_deinit+0x74>)
 8013280:	f011 f82e 	bl	80242e0 <TIM_DeInit>
	ADC_DeInit();
 8013284:	f010 fc64 	bl	8023b50 <ADC_DeInit>
	DMA_DeInit(DMA2_Stream4);
 8013288:	480b      	ldr	r0, [pc, #44]	; (80132b8 <mcpwm_deinit+0x78>)
 801328a:	f010 fda1 	bl	8023dd0 <DMA_DeInit>
	nvicDisableVector(ADC_IRQn);
 801328e:	2012      	movs	r0, #18
 8013290:	f7fb ff6e 	bl	800f170 <nvicDisableVector>
	dmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));
 8013294:	4809      	ldr	r0, [pc, #36]	; (80132bc <mcpwm_deinit+0x7c>)
}
 8013296:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	dmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));
 801329a:	f7fc b981 	b.w	800f5a0 <dmaStreamRelease>
 801329e:	bf00      	nop
 80132a0:	20004f54 	.word	0x20004f54
 80132a4:	20005a20 	.word	0x20005a20
 80132a8:	20005448 	.word	0x20005448
 80132ac:	40010000 	.word	0x40010000
 80132b0:	40010400 	.word	0x40010400
 80132b4:	40001800 	.word	0x40001800
 80132b8:	40026470 	.word	0x40026470
 80132bc:	0802da40 	.word	0x0802da40

080132c0 <mcpwm_init_done>:
	return init_done;
 80132c0:	4b01      	ldr	r3, [pc, #4]	; (80132c8 <mcpwm_init_done+0x8>)
 80132c2:	7818      	ldrb	r0, [r3, #0]
}
 80132c4:	4770      	bx	lr
 80132c6:	bf00      	nop
 80132c8:	20004f54 	.word	0x20004f54
 80132cc:	00000000 	.word	0x00000000

080132d0 <mcpwm_init_hall_table>:
void mcpwm_init_hall_table(int8_t *table) {
 80132d0:	b4f0      	push	{r4, r5, r6, r7}
	const int fwd_to_rev[7] = {-1,1,6,5,4,3,2};
 80132d2:	4f0f      	ldr	r7, [pc, #60]	; (8013310 <mcpwm_init_hall_table+0x40>)
 80132d4:	4c0f      	ldr	r4, [pc, #60]	; (8013314 <mcpwm_init_hall_table+0x44>)
void mcpwm_init_hall_table(int8_t *table) {
 80132d6:	4605      	mov	r5, r0
	const int fwd_to_rev[7] = {-1,1,6,5,4,3,2};
 80132d8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
void mcpwm_init_hall_table(int8_t *table) {
 80132da:	b088      	sub	sp, #32
	const int fwd_to_rev[7] = {-1,1,6,5,4,3,2};
 80132dc:	ae01      	add	r6, sp, #4
 80132de:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80132e0:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 80132e4:	e886 0007 	stmia.w	r6, {r0, r1, r2}
 80132e8:	1e6a      	subs	r2, r5, #1
 80132ea:	1de8      	adds	r0, r5, #7
		hall_to_phase_table[8 + i] = table[i];
 80132ec:	f912 3f01 	ldrsb.w	r3, [r2, #1]!
 80132f0:	f844 3b04 	str.w	r3, [r4], #4
		hall_to_phase_table[i] = fwd_to_rev[ind_now];
 80132f4:	a908      	add	r1, sp, #32
 80132f6:	eb01 0183 	add.w	r1, r1, r3, lsl #2
		if (ind_now < 1) {
 80132fa:	2b00      	cmp	r3, #0
		hall_to_phase_table[i] = fwd_to_rev[ind_now];
 80132fc:	bfc8      	it	gt
 80132fe:	f851 3c1c 	ldrgt.w	r3, [r1, #-28]
 8013302:	f844 3c24 	str.w	r3, [r4, #-36]
	for (int i = 0;i < 8;i++) {
 8013306:	4282      	cmp	r2, r0
 8013308:	d1f0      	bne.n	80132ec <mcpwm_init_hall_table+0x1c>
}
 801330a:	b008      	add	sp, #32
 801330c:	bcf0      	pop	{r4, r5, r6, r7}
 801330e:	4770      	bx	lr
 8013310:	0802d900 	.word	0x0802d900
 8013314:	20004f24 	.word	0x20004f24
	...

08013320 <mcpwm_init>:
void mcpwm_init(volatile mc_configuration *configuration) {
 8013320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conf = configuration;
 8013324:	4cc7      	ldr	r4, [pc, #796]	; (8013644 <mcpwm_init+0x324>)
	init_done= false;
 8013326:	f8df b3cc 	ldr.w	fp, [pc, #972]	; 80136f4 <mcpwm_init+0x3d4>
	detect_step = 0;
 801332a:	f8df a3cc 	ldr.w	sl, [pc, #972]	; 80136f8 <mcpwm_init+0x3d8>
	switching_frequency_now = conf->m_bldc_f_sw_max;
 801332e:	f8df 93cc 	ldr.w	r9, [pc, #972]	; 80136fc <mcpwm_init+0x3dc>
	TIM_DeInit(TIM1);
 8013332:	4ec5      	ldr	r6, [pc, #788]	; (8013648 <mcpwm_init+0x328>)
	TIM_DeInit(TIM8);
 8013334:	4fc5      	ldr	r7, [pc, #788]	; (801364c <mcpwm_init+0x32c>)
void mcpwm_init(volatile mc_configuration *configuration) {
 8013336:	b0af      	sub	sp, #188	; 0xbc
 8013338:	4680      	mov	r8, r0
	utils_sys_lock_cnt();
 801333a:	f002 feb1 	bl	80160a0 <utils_sys_lock_cnt>
	comm_step = 1;
 801333e:	4bc4      	ldr	r3, [pc, #784]	; (8013650 <mcpwm_init+0x330>)
	conf = configuration;
 8013340:	f8c4 8000 	str.w	r8, [r4]
	comm_step = 1;
 8013344:	2501      	movs	r5, #1
	init_done= false;
 8013346:	2400      	movs	r4, #0
 8013348:	f88b 4000 	strb.w	r4, [fp]
	rpm_now = 0.0;
 801334c:	eddf 7ac1 	vldr	s15, [pc, #772]	; 8013654 <mcpwm_init+0x334>
	comm_step = 1;
 8013350:	601d      	str	r5, [r3, #0]
	direction = 1;
 8013352:	f8df e3ac 	ldr.w	lr, [pc, #940]	; 8013700 <mcpwm_init+0x3e0>
	rpm_now = 0.0;
 8013356:	f8df c3ac 	ldr.w	ip, [pc, #940]	; 8013704 <mcpwm_init+0x3e4>
	dutycycle_set = 0.0;
 801335a:	48bf      	ldr	r0, [pc, #764]	; (8013658 <mcpwm_init+0x338>)
	dutycycle_now = 0.0;
 801335c:	49bf      	ldr	r1, [pc, #764]	; (801365c <mcpwm_init+0x33c>)
	speed_pid_set_rpm = 0.0;
 801335e:	4ac0      	ldr	r2, [pc, #768]	; (8013660 <mcpwm_init+0x340>)
	pos_pid_set_pos = 0.0;
 8013360:	4bc0      	ldr	r3, [pc, #768]	; (8013664 <mcpwm_init+0x344>)
	detect_step = 0;
 8013362:	f8ca 4000 	str.w	r4, [sl]
	direction = 1;
 8013366:	f8ce 5000 	str.w	r5, [lr]
	rpm_now = 0.0;
 801336a:	edcc 7a00 	vstr	s15, [ip]
	current_set = 0.0;
 801336e:	f8df e398 	ldr.w	lr, [pc, #920]	; 8013708 <mcpwm_init+0x3e8>
	dutycycle_set = 0.0;
 8013372:	edc0 7a00 	vstr	s15, [r0]
	dutycycle_now = 0.0;
 8013376:	edc1 7a00 	vstr	s15, [r1]
	speed_pid_set_rpm = 0.0;
 801337a:	edc2 7a00 	vstr	s15, [r2]
	pos_pid_set_pos = 0.0;
 801337e:	edc3 7a00 	vstr	s15, [r3]
	tachometer = 0;
 8013382:	4bb9      	ldr	r3, [pc, #740]	; (8013668 <mcpwm_init+0x348>)
	current_set = 0.0;
 8013384:	edce 7a00 	vstr	s15, [lr]
	tachometer = 0;
 8013388:	601c      	str	r4, [r3, #0]
	tachometer_abs = 0;
 801338a:	4bb8      	ldr	r3, [pc, #736]	; (801366c <mcpwm_init+0x34c>)
	tachometer_for_direction = 0;
 801338c:	f8df c37c 	ldr.w	ip, [pc, #892]	; 801370c <mcpwm_init+0x3ec>
	tachometer_abs = 0;
 8013390:	601c      	str	r4, [r3, #0]
	state = MC_STATE_OFF;
 8013392:	48b7      	ldr	r0, [pc, #732]	; (8013670 <mcpwm_init+0x350>)
	control_mode = CONTROL_MODE_NONE;
 8013394:	49b7      	ldr	r1, [pc, #732]	; (8013674 <mcpwm_init+0x354>)
	last_current_sample = 0.0;
 8013396:	4ab8      	ldr	r2, [pc, #736]	; (8013678 <mcpwm_init+0x358>)
	last_current_sample_filtered = 0.0;
 8013398:	4bb8      	ldr	r3, [pc, #736]	; (801367c <mcpwm_init+0x35c>)
	tachometer_for_direction = 0;
 801339a:	f8cc 4000 	str.w	r4, [ip]
	control_mode = CONTROL_MODE_NONE;
 801339e:	f04f 0a07 	mov.w	sl, #7
	state = MC_STATE_OFF;
 80133a2:	7004      	strb	r4, [r0, #0]
	control_mode = CONTROL_MODE_NONE;
 80133a4:	f881 a000 	strb.w	sl, [r1]
	last_current_sample = 0.0;
 80133a8:	edc2 7a00 	vstr	s15, [r2]
	last_current_sample_filtered = 0.0;
 80133ac:	edc3 7a00 	vstr	s15, [r3]
	switching_frequency_now = conf->m_bldc_f_sw_max;
 80133b0:	f8d8 3168 	ldr.w	r3, [r8, #360]	; 0x168
 80133b4:	f8c9 3000 	str.w	r3, [r9]
	ignore_iterations = 0;
 80133b8:	f8df c354 	ldr.w	ip, [pc, #852]	; 8013710 <mcpwm_init+0x3f0>
	memset((void*)&rpm_dep, 0, sizeof(rpm_dep));
 80133bc:	4bb0      	ldr	r3, [pc, #704]	; (8013680 <mcpwm_init+0x360>)
	curr_samp_volt = 0;
 80133be:	49b1      	ldr	r1, [pc, #708]	; (8013684 <mcpwm_init+0x364>)
	slow_ramping_cycles = 0;
 80133c0:	4ab1      	ldr	r2, [pc, #708]	; (8013688 <mcpwm_init+0x368>)
	has_commutated = 0;
 80133c2:	48b2      	ldr	r0, [pc, #712]	; (801368c <mcpwm_init+0x36c>)
	cycle_integrator_sum = 0.0;
 80133c4:	f8df e34c 	ldr.w	lr, [pc, #844]	; 8013714 <mcpwm_init+0x3f4>
	ignore_iterations = 0;
 80133c8:	f8cc 4000 	str.w	r4, [ip]
	last_pwm_cycles_sum = 0.0;
 80133cc:	f8df c348 	ldr.w	ip, [pc, #840]	; 8013718 <mcpwm_init+0x3f8>
	curr_samp_volt = 0;
 80133d0:	600c      	str	r4, [r1, #0]
	slow_ramping_cycles = 0;
 80133d2:	6014      	str	r4, [r2, #0]
	cycle_integrator_iterations = 0.0;
 80133d4:	49ae      	ldr	r1, [pc, #696]	; (8013690 <mcpwm_init+0x370>)
	has_commutated = 0;
 80133d6:	6004      	str	r4, [r0, #0]
	pwm_cycles_sum = 0.0;
 80133d8:	4aae      	ldr	r2, [pc, #696]	; (8013694 <mcpwm_init+0x374>)
	memset((void*)&rpm_dep, 0, sizeof(rpm_dep));
 80133da:	601c      	str	r4, [r3, #0]
	pwm_cycles = 0;
 80133dc:	48ae      	ldr	r0, [pc, #696]	; (8013698 <mcpwm_init+0x378>)
	memset((void*)&rpm_dep, 0, sizeof(rpm_dep));
 80133de:	605c      	str	r4, [r3, #4]
 80133e0:	609c      	str	r4, [r3, #8]
 80133e2:	60dc      	str	r4, [r3, #12]
 80133e4:	611c      	str	r4, [r3, #16]
 80133e6:	615c      	str	r4, [r3, #20]
 80133e8:	619c      	str	r4, [r3, #24]
	memset((float*)last_pwm_cycles_sums, 0, sizeof(last_pwm_cycles_sums));
 80133ea:	4bac      	ldr	r3, [pc, #688]	; (801369c <mcpwm_init+0x37c>)
	cycle_integrator_sum = 0.0;
 80133ec:	edce 7a00 	vstr	s15, [lr]
	cycle_integrator_iterations = 0.0;
 80133f0:	edc1 7a00 	vstr	s15, [r1]
	pwm_cycles_sum = 0.0;
 80133f4:	edc2 7a00 	vstr	s15, [r2]
	pwm_cycles = 0;
 80133f8:	6004      	str	r4, [r0, #0]
	last_pwm_cycles_sum = 0.0;
 80133fa:	edcc 7a00 	vstr	s15, [ip]
	memset((float*)last_pwm_cycles_sums, 0, sizeof(last_pwm_cycles_sums));
 80133fe:	601c      	str	r4, [r3, #0]
 8013400:	605c      	str	r4, [r3, #4]
 8013402:	609c      	str	r4, [r3, #8]
 8013404:	60dc      	str	r4, [r3, #12]
 8013406:	611c      	str	r4, [r3, #16]
 8013408:	615c      	str	r4, [r3, #20]
	dccal_done = false;
 801340a:	4ba5      	ldr	r3, [pc, #660]	; (80136a0 <mcpwm_init+0x380>)
	memset((void*)hall_detect_table, 0, sizeof(hall_detect_table[0][0]) * 8 * 7);
 801340c:	48a5      	ldr	r0, [pc, #660]	; (80136a4 <mcpwm_init+0x384>)
	dccal_done = false;
 801340e:	701c      	strb	r4, [r3, #0]
	memset((void*)hall_detect_table, 0, sizeof(hall_detect_table[0][0]) * 8 * 7);
 8013410:	4621      	mov	r1, r4
 8013412:	22e0      	movs	r2, #224	; 0xe0
 8013414:	f013 fc04 	bl	8026c20 <memset>
	update_sensor_mode();
 8013418:	f7ff f982 	bl	8012720 <update_sensor_mode>
	comm_mode_next = conf->comm_mode;
 801341c:	f898 3001 	ldrb.w	r3, [r8, #1]
 8013420:	4aa1      	ldr	r2, [pc, #644]	; (80136a8 <mcpwm_init+0x388>)
 8013422:	b2db      	uxtb	r3, r3
	mcpwm_init_hall_table((int8_t*)conf->hall_table);
 8013424:	f108 0098 	add.w	r0, r8, #152	; 0x98
	comm_mode_next = conf->comm_mode;
 8013428:	7013      	strb	r3, [r2, #0]
	mcpwm_init_hall_table((int8_t*)conf->hall_table);
 801342a:	f7ff ff51 	bl	80132d0 <mcpwm_init_hall_table>
	filter_create_fir_lowpass((float*)kv_fir_coeffs, KV_FIR_FCUT, KV_FIR_TAPS_BITS, 1);
 801342e:	462a      	mov	r2, r5
 8013430:	4651      	mov	r1, sl
 8013432:	ed9f 0a9e 	vldr	s0, [pc, #632]	; 80136ac <mcpwm_init+0x38c>
 8013436:	489e      	ldr	r0, [pc, #632]	; (80136b0 <mcpwm_init+0x390>)
 8013438:	f7fe ff1a 	bl	8012270 <filter_create_fir_lowpass>
	filter_create_fir_lowpass((float*)amp_fir_coeffs, AMP_FIR_FCUT, AMP_FIR_TAPS_BITS, 1);
 801343c:	462a      	mov	r2, r5
 801343e:	4651      	mov	r1, sl
 8013440:	ed9f 0a9a 	vldr	s0, [pc, #616]	; 80136ac <mcpwm_init+0x38c>
 8013444:	489b      	ldr	r0, [pc, #620]	; (80136b4 <mcpwm_init+0x394>)
 8013446:	f7fe ff13 	bl	8012270 <filter_create_fir_lowpass>
	filter_create_fir_lowpass((float*)current_fir_coeffs, CURR_FIR_FCUT, CURR_FIR_TAPS_BITS, 1);
 801344a:	ed9f 0a9b 	vldr	s0, [pc, #620]	; 80136b8 <mcpwm_init+0x398>
 801344e:	489b      	ldr	r0, [pc, #620]	; (80136bc <mcpwm_init+0x39c>)
 8013450:	462a      	mov	r2, r5
 8013452:	2104      	movs	r1, #4
 8013454:	f7fe ff0c 	bl	8012270 <filter_create_fir_lowpass>
	TIM_DeInit(TIM1);
 8013458:	4630      	mov	r0, r6
 801345a:	f010 ff41 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM8);
 801345e:	4638      	mov	r0, r7
 8013460:	f010 ff3e 	bl	80242e0 <TIM_DeInit>
	TIM1->CNT = 0;
 8013464:	6274      	str	r4, [r6, #36]	; 0x24
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 8013466:	4629      	mov	r1, r5
 8013468:	4628      	mov	r0, r5
	TIM8->CNT = 0;
 801346a:	627c      	str	r4, [r7, #36]	; 0x24
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 801346c:	f010 fef0 	bl	8024250 <RCC_APB2PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 8013470:	edd9 7a00 	vldr	s15, [r9]
 8013474:	4a92      	ldr	r2, [pc, #584]	; (80136c0 <mcpwm_init+0x3a0>)
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 8013476:	9403      	str	r4, [sp, #12]
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 8013478:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 801347c:	4630      	mov	r0, r6
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 801347e:	ee17 3a90 	vmov	r3, s15
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 8013482:	a903      	add	r1, sp, #12
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 8013484:	fb92 f3f3 	sdiv	r3, r2, r3
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8013488:	f8ad 4014 	strh.w	r4, [sp, #20]
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 801348c:	f88d 4016 	strb.w	r4, [sp, #22]
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)switching_frequency_now;
 8013490:	9304      	str	r3, [sp, #16]
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 8013492:	f011 f805 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_OCInitStructure.TIM_Pulse = TIM1->ARR / 2;
 8013496:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8013498:	4a8a      	ldr	r2, [pc, #552]	; (80136c4 <mcpwm_init+0x3a4>)
 801349a:	920e      	str	r2, [sp, #56]	; 0x38
	TIM_OCInitStructure.TIM_Pulse = TIM1->ARR / 2;
 801349c:	40eb      	lsrs	r3, r5
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 801349e:	f04f 0804 	mov.w	r8, #4
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 80134a2:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 80134a6:	4630      	mov	r0, r6
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 80134a8:	4b87      	ldr	r3, [pc, #540]	; (80136c8 <mcpwm_init+0x3a8>)
 80134aa:	9312      	str	r3, [sp, #72]	; 0x48
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 80134ac:	a90e      	add	r1, sp, #56	; 0x38
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80134ae:	f8ad 803c 	strh.w	r8, [sp, #60]	; 0x3c
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 80134b2:	f011 f86d 	bl	8024590 <TIM_OC1Init>
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
 80134b6:	a90e      	add	r1, sp, #56	; 0x38
 80134b8:	4630      	mov	r0, r6
 80134ba:	f011 f8a9 	bl	8024610 <TIM_OC2Init>
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 80134be:	a90e      	add	r1, sp, #56	; 0x38
 80134c0:	4630      	mov	r0, r6
 80134c2:	f011 f8e5 	bl	8024690 <TIM_OC3Init>
	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
 80134c6:	a90e      	add	r1, sp, #56	; 0x38
 80134c8:	4630      	mov	r0, r6
 80134ca:	f011 f929 	bl	8024720 <TIM_OC4Init>
	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
 80134ce:	4630      	mov	r0, r6
 80134d0:	2108      	movs	r1, #8
 80134d2:	f011 f985 	bl	80247e0 <TIM_OC1PreloadConfig>
	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
 80134d6:	4630      	mov	r0, r6
 80134d8:	2108      	movs	r1, #8
 80134da:	f011 f989 	bl	80247f0 <TIM_OC2PreloadConfig>
	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
 80134de:	4630      	mov	r0, r6
 80134e0:	2108      	movs	r1, #8
 80134e2:	f011 f995 	bl	8024810 <TIM_OC3PreloadConfig>
	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
 80134e6:	4630      	mov	r0, r6
 80134e8:	2108      	movs	r1, #8
 80134ea:	f011 f999 	bl	8024820 <TIM_OC4PreloadConfig>
	TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
 80134ee:	4a77      	ldr	r2, [pc, #476]	; (80136cc <mcpwm_init+0x3ac>)
	TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
 80134f0:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
	TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
 80134f4:	f44f 1370 	mov.w	r3, #3932160	; 0x3c0000
	TIM_BDTRInitStructure.TIM_DeadTime = HW_DEAD_TIME_VALUE;
 80134f8:	f04f 5900 	mov.w	r9, #536870912	; 0x20000000
	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 80134fc:	4630      	mov	r0, r6
 80134fe:	a906      	add	r1, sp, #24
	TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
 8013500:	e9cd 2306 	strd	r2, r3, [sp, #24]
	TIM_BDTRInitStructure.TIM_DeadTime = HW_DEAD_TIME_VALUE;
 8013504:	f8cd 9020 	str.w	r9, [sp, #32]
	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 8013508:	f011 f9ba 	bl	8024880 <TIM_BDTRConfig>
	TIM_CCPreloadControl(TIM1, ENABLE);
 801350c:	4629      	mov	r1, r5
 801350e:	4630      	mov	r0, r6
 8013510:	f011 f9de 	bl	80248d0 <TIM_CCPreloadControl>
	TIM_ARRPreloadConfig(TIM1, ENABLE);
 8013514:	4629      	mov	r1, r5
 8013516:	4630      	mov	r0, r6
 8013518:	f011 f81a 	bl	8024550 <TIM_ARRPreloadConfig>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC, ENABLE);
 801351c:	4629      	mov	r1, r5
 801351e:	486c      	ldr	r0, [pc, #432]	; (80136d0 <mcpwm_init+0x3b0>)
 8013520:	f010 fe76 	bl	8024210 <RCC_AHB1PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2 | RCC_APB2Periph_ADC3, ENABLE);
 8013524:	4629      	mov	r1, r5
 8013526:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 801352a:	f010 fe91 	bl	8024250 <RCC_APB2PeriphClockCmd>
	dmaStreamAllocate(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)),
 801352e:	4623      	mov	r3, r4
 8013530:	4a68      	ldr	r2, [pc, #416]	; (80136d4 <mcpwm_init+0x3b4>)
 8013532:	4869      	ldr	r0, [pc, #420]	; (80136d8 <mcpwm_init+0x3b8>)
 8013534:	2103      	movs	r1, #3
 8013536:	f7fb ffeb 	bl	800f510 <dmaStreamAllocate>
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;
 801353a:	4b68      	ldr	r3, [pc, #416]	; (80136dc <mcpwm_init+0x3bc>)
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC->CDR;
 801353c:	4968      	ldr	r1, [pc, #416]	; (80136e0 <mcpwm_init+0x3c0>)
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;
 801353e:	9321      	str	r3, [sp, #132]	; 0x84
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8013540:	f44f 6a80 	mov.w	sl, #1024	; 0x400
	DMA_InitStructure.DMA_BufferSize = HW_ADC_CHANNELS;
 8013544:	220c      	movs	r2, #12
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 8013546:	f44f 6300 	mov.w	r3, #2048	; 0x800
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC->CDR;
 801354a:	9120      	str	r1, [sp, #128]	; 0x80
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 801354c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 8013550:	4864      	ldr	r0, [pc, #400]	; (80136e4 <mcpwm_init+0x3c4>)
	DMA_InitStructure.DMA_BufferSize = HW_ADC_CHANNELS;
 8013552:	9223      	str	r2, [sp, #140]	; 0x8c
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 8013554:	e9cd a325 	strd	sl, r3, [sp, #148]	; 0x94
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8013558:	f44f 7280 	mov.w	r2, #256	; 0x100
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 801355c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 8013560:	9127      	str	r1, [sp, #156]	; 0x9c
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 8013562:	a91f      	add	r1, sp, #124	; 0x7c
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8013564:	e9cd 2328 	strd	r2, r3, [sp, #160]	; 0xa0
	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
 8013568:	941f      	str	r4, [sp, #124]	; 0x7c
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 801356a:	9422      	str	r4, [sp, #136]	; 0x88
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 801356c:	9424      	str	r4, [sp, #144]	; 0x90
	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 801356e:	e9cd 442a 	strd	r4, r4, [sp, #168]	; 0xa8
	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8013572:	e9cd 442c 	strd	r4, r4, [sp, #176]	; 0xb0
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 8013576:	f010 fcc3 	bl	8023f00 <DMA_Init>
	DMA_Cmd(DMA2_Stream4, ENABLE);
 801357a:	4629      	mov	r1, r5
 801357c:	4859      	ldr	r0, [pc, #356]	; (80136e4 <mcpwm_init+0x3c4>)
 801357e:	f010 fcef 	bl	8023f60 <DMA_Cmd>
	DMA_ITConfig(DMA2_Stream4, DMA_IT_TC, ENABLE);
 8013582:	462a      	mov	r2, r5
 8013584:	2110      	movs	r1, #16
 8013586:	4857      	ldr	r0, [pc, #348]	; (80136e4 <mcpwm_init+0x3c4>)
 8013588:	f010 fcfa 	bl	8023f80 <DMA_ITConfig>
	ADC_CommonInitStructure.ADC_Mode = ADC_TripleMode_RegSimult;
 801358c:	2216      	movs	r2, #22
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 801358e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	ADC_CommonInit(&ADC_CommonInitStructure);
 8013592:	a80a      	add	r0, sp, #40	; 0x28
	ADC_CommonInitStructure.ADC_Mode = ADC_TripleMode_RegSimult;
 8013594:	920a      	str	r2, [sp, #40]	; 0x28
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 8013596:	940b      	str	r4, [sp, #44]	; 0x2c
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 8013598:	940d      	str	r4, [sp, #52]	; 0x34
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 801359a:	930c      	str	r3, [sp, #48]	; 0x30
	ADC_CommonInit(&ADC_CommonInitStructure);
 801359c:	f010 fb10 	bl	8023bc0 <ADC_CommonInit>
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T8_CC1;
 80135a0:	f04f 6350 	mov.w	r3, #218103808	; 0xd000000
	ADC_Init(ADC1, &ADC_InitStructure);
 80135a4:	a913      	add	r1, sp, #76	; 0x4c
 80135a6:	4850      	ldr	r0, [pc, #320]	; (80136e8 <mcpwm_init+0x3c8>)
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T8_CC1;
 80135a8:	9316      	str	r3, [sp, #88]	; 0x58
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 80135aa:	9413      	str	r4, [sp, #76]	; 0x4c
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 80135ac:	f88d 5050 	strb.w	r5, [sp, #80]	; 0x50
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 80135b0:	f88d 4051 	strb.w	r4, [sp, #81]	; 0x51
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 80135b4:	9417      	str	r4, [sp, #92]	; 0x5c
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Falling;
 80135b6:	f8cd 9054 	str.w	r9, [sp, #84]	; 0x54
	ADC_InitStructure.ADC_NbrOfConversion = HW_ADC_NBR_CONV;
 80135ba:	f88d 8060 	strb.w	r8, [sp, #96]	; 0x60
	ADC_Init(ADC1, &ADC_InitStructure);
 80135be:	f010 fad7 	bl	8023b70 <ADC_Init>
	ADC_Init(ADC2, &ADC_InitStructure);
 80135c2:	a913      	add	r1, sp, #76	; 0x4c
 80135c4:	4849      	ldr	r0, [pc, #292]	; (80136ec <mcpwm_init+0x3cc>)
	ADC_InitStructure.ADC_ExternalTrigConv = 0;
 80135c6:	e9cd 4415 	strd	r4, r4, [sp, #84]	; 0x54
	ADC_Init(ADC2, &ADC_InitStructure);
 80135ca:	f010 fad1 	bl	8023b70 <ADC_Init>
	ADC_Init(ADC3, &ADC_InitStructure);
 80135ce:	a913      	add	r1, sp, #76	; 0x4c
 80135d0:	4847      	ldr	r0, [pc, #284]	; (80136f0 <mcpwm_init+0x3d0>)
 80135d2:	f010 facd 	bl	8023b70 <ADC_Init>
	ADC_TempSensorVrefintCmd(ENABLE);
 80135d6:	4628      	mov	r0, r5
 80135d8:	f010 fb1a 	bl	8023c10 <ADC_TempSensorVrefintCmd>
	ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);
 80135dc:	4628      	mov	r0, r5
 80135de:	f010 fb77 	bl	8023cd0 <ADC_MultiModeDMARequestAfterLastTransferCmd>
	ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_CC4);
 80135e2:	4621      	mov	r1, r4
 80135e4:	4840      	ldr	r0, [pc, #256]	; (80136e8 <mcpwm_init+0x3c8>)
 80135e6:	f010 fbbb 	bl	8023d60 <ADC_ExternalTrigInjectedConvConfig>
	ADC_ExternalTrigInjectedConvConfig(ADC2, ADC_ExternalTrigInjecConv_T8_CC2);
 80135ea:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
 80135ee:	483f      	ldr	r0, [pc, #252]	; (80136ec <mcpwm_init+0x3cc>)
 80135f0:	f010 fbb6 	bl	8023d60 <ADC_ExternalTrigInjectedConvConfig>
	ADC_ExternalTrigInjectedConvEdgeConfig(ADC1, ADC_ExternalTrigInjecConvEdge_Falling);
 80135f4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80135f8:	483b      	ldr	r0, [pc, #236]	; (80136e8 <mcpwm_init+0x3c8>)
 80135fa:	f010 fbb9 	bl	8023d70 <ADC_ExternalTrigInjectedConvEdgeConfig>
	ADC_ExternalTrigInjectedConvEdgeConfig(ADC2, ADC_ExternalTrigInjecConvEdge_Falling);
 80135fe:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8013602:	483a      	ldr	r0, [pc, #232]	; (80136ec <mcpwm_init+0x3cc>)
 8013604:	f010 fbb4 	bl	8023d70 <ADC_ExternalTrigInjectedConvEdgeConfig>
	ADC_InjectedSequencerLengthConfig(ADC1, HW_ADC_INJ_CHANNELS);
 8013608:	2102      	movs	r1, #2
 801360a:	4837      	ldr	r0, [pc, #220]	; (80136e8 <mcpwm_init+0x3c8>)
 801360c:	f010 fba0 	bl	8023d50 <ADC_InjectedSequencerLengthConfig>
	ADC_InjectedSequencerLengthConfig(ADC2, HW_ADC_INJ_CHANNELS);
 8013610:	2102      	movs	r1, #2
 8013612:	4836      	ldr	r0, [pc, #216]	; (80136ec <mcpwm_init+0x3cc>)
 8013614:	f010 fb9c 	bl	8023d50 <ADC_InjectedSequencerLengthConfig>
	hw_setup_adc_channels();
 8013618:	f00c fea2 	bl	8020360 <hw_setup_adc_channels>
	ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE);
 801361c:	462a      	mov	r2, r5
 801361e:	f240 4107 	movw	r1, #1031	; 0x407
 8013622:	4831      	ldr	r0, [pc, #196]	; (80136e8 <mcpwm_init+0x3c8>)
 8013624:	f010 fbbc 	bl	8023da0 <ADC_ITConfig>
	nvicEnableVector(ADC_IRQn, 6);
 8013628:	2106      	movs	r1, #6
 801362a:	2012      	movs	r0, #18
 801362c:	f7fb fd80 	bl	800f130 <nvicEnableVector>
	ADC_Cmd(ADC1, ENABLE);
 8013630:	4629      	mov	r1, r5
 8013632:	482d      	ldr	r0, [pc, #180]	; (80136e8 <mcpwm_init+0x3c8>)
 8013634:	f010 fadc 	bl	8023bf0 <ADC_Cmd>
	ADC_Cmd(ADC2, ENABLE);
 8013638:	4629      	mov	r1, r5
 801363a:	482c      	ldr	r0, [pc, #176]	; (80136ec <mcpwm_init+0x3cc>)
 801363c:	f010 fad8 	bl	8023bf0 <ADC_Cmd>
	ADC_Cmd(ADC3, ENABLE);
 8013640:	4629      	mov	r1, r5
 8013642:	e06b      	b.n	801371c <mcpwm_init+0x3fc>
 8013644:	20004d50 	.word	0x20004d50
 8013648:	40010000 	.word	0x40010000
 801364c:	40010400 	.word	0x40010400
 8013650:	20004d4c 	.word	0x20004d4c
 8013654:	00000000 	.word	0x00000000
 8013658:	20004e20 	.word	0x20004e20
 801365c:	20004e1c 	.word	0x20004e1c
 8013660:	200059f0 	.word	0x200059f0
 8013664:	2000540c 	.word	0x2000540c
 8013668:	200059fc 	.word	0x200059fc
 801366c:	20005a00 	.word	0x20005a00
 8013670:	200059f4 	.word	0x200059f4
 8013674:	20004d54 	.word	0x20004d54
 8013678:	20005360 	.word	0x20005360
 801367c:	20005364 	.word	0x20005364
 8013680:	20005424 	.word	0x20005424
 8013684:	20004d68 	.word	0x20004d68
 8013688:	200059ec 	.word	0x200059ec
 801368c:	20004f44 	.word	0x20004f44
 8013690:	20004dfc 	.word	0x20004dfc
 8013694:	20005420 	.word	0x20005420
 8013698:	2000541c 	.word	0x2000541c
 801369c:	20005370 	.word	0x20005370
 80136a0:	20004e0c 	.word	0x20004e0c
 80136a4:	20004e24 	.word	0x20004e24
 80136a8:	20004d48 	.word	0x20004d48
 80136ac:	3ca3d70a 	.word	0x3ca3d70a
 80136b0:	20004f58 	.word	0x20004f58
 80136b4:	20004940 	.word	0x20004940
 80136b8:	3e19999a 	.word	0x3e19999a
 80136bc:	20004d70 	.word	0x20004d70
 80136c0:	0a037a00 	.word	0x0a037a00
 80136c4:	00010060 	.word	0x00010060
 80136c8:	02000100 	.word	0x02000100
 80136cc:	04000800 	.word	0x04000800
 80136d0:	00400005 	.word	0x00400005
 80136d4:	08014b21 	.word	0x08014b21
 80136d8:	0802da40 	.word	0x0802da40
 80136dc:	2000c03c 	.word	0x2000c03c
 80136e0:	40012308 	.word	0x40012308
 80136e4:	40026470 	.word	0x40026470
 80136e8:	40012000 	.word	0x40012000
 80136ec:	40012100 	.word	0x40012100
 80136f0:	40012200 	.word	0x40012200
 80136f4:	20004f54 	.word	0x20004f54
 80136f8:	20004e14 	.word	0x20004e14
 80136fc:	200059f8 	.word	0x200059f8
 8013700:	20004e18 	.word	0x20004e18
 8013704:	20005444 	.word	0x20005444
 8013708:	20004df4 	.word	0x20004df4
 801370c:	20005a04 	.word	0x20005a04
 8013710:	20004f50 	.word	0x20004f50
 8013714:	20004e00 	.word	0x20004e00
 8013718:	2000536c 	.word	0x2000536c
 801371c:	4879      	ldr	r0, [pc, #484]	; (8013904 <mcpwm_init+0x5e4>)
 801371e:	f010 fa67 	bl	8023bf0 <ADC_Cmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
 8013722:	4629      	mov	r1, r5
 8013724:	2002      	movs	r0, #2
 8013726:	f010 fd93 	bl	8024250 <RCC_APB2PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801372a:	f64f 73ff 	movw	r3, #65535	; 0xffff
	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
 801372e:	a903      	add	r1, sp, #12
 8013730:	4638      	mov	r0, r7
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 8013732:	9403      	str	r4, [sp, #12]
	TIM_TimeBaseStructure.TIM_Period = 0xFFFF;
 8013734:	f8ad 4014 	strh.w	r4, [sp, #20]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8013738:	f88d 4016 	strb.w	r4, [sp, #22]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801373c:	9304      	str	r3, [sp, #16]
	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
 801373e:	f010 feaf 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8013742:	4a71      	ldr	r2, [pc, #452]	; (8013908 <mcpwm_init+0x5e8>)
 8013744:	920e      	str	r2, [sp, #56]	; 0x38
	TIM_OCInitStructure.TIM_Pulse = 500;
 8013746:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 801374a:	4a70      	ldr	r2, [pc, #448]	; (801390c <mcpwm_init+0x5ec>)
 801374c:	9212      	str	r2, [sp, #72]	; 0x48
	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
 801374e:	a90e      	add	r1, sp, #56	; 0x38
 8013750:	4638      	mov	r0, r7
	TIM_OCInitStructure.TIM_Pulse = 500;
 8013752:	9310      	str	r3, [sp, #64]	; 0x40
 8013754:	9411      	str	r4, [sp, #68]	; 0x44
	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
 8013756:	f010 ff1b 	bl	8024590 <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801375a:	4638      	mov	r0, r7
 801375c:	2108      	movs	r1, #8
 801375e:	f011 f83f 	bl	80247e0 <TIM_OC1PreloadConfig>
	TIM_OC2Init(TIM8, &TIM_OCInitStructure);
 8013762:	a90e      	add	r1, sp, #56	; 0x38
 8013764:	4638      	mov	r0, r7
 8013766:	f010 ff53 	bl	8024610 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801376a:	4638      	mov	r0, r7
 801376c:	2108      	movs	r1, #8
 801376e:	f011 f83f 	bl	80247f0 <TIM_OC2PreloadConfig>
	TIM_OC3Init(TIM8, &TIM_OCInitStructure);
 8013772:	a90e      	add	r1, sp, #56	; 0x38
 8013774:	4638      	mov	r0, r7
 8013776:	f010 ff8b 	bl	8024690 <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801377a:	4638      	mov	r0, r7
 801377c:	2108      	movs	r1, #8
 801377e:	f011 f847 	bl	8024810 <TIM_OC3PreloadConfig>
	TIM_ARRPreloadConfig(TIM8, ENABLE);
 8013782:	4629      	mov	r1, r5
 8013784:	4638      	mov	r0, r7
 8013786:	f010 fee3 	bl	8024550 <TIM_ARRPreloadConfig>
	TIM_CCPreloadControl(TIM8, ENABLE);
 801378a:	4629      	mov	r1, r5
 801378c:	4638      	mov	r0, r7
 801378e:	f011 f89f 	bl	80248d0 <TIM_CCPreloadControl>
	TIM_CtrlPWMOutputs(TIM8, ENABLE);
 8013792:	4629      	mov	r1, r5
 8013794:	4638      	mov	r0, r7
 8013796:	f011 f88b 	bl	80248b0 <TIM_CtrlPWMOutputs>
	TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);
 801379a:	4630      	mov	r0, r6
 801379c:	2120      	movs	r1, #32
 801379e:	f011 f8e7 	bl	8024970 <TIM_SelectOutputTrigger>
	TIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);
 80137a2:	4630      	mov	r0, r6
 80137a4:	2180      	movs	r1, #128	; 0x80
 80137a6:	f011 f903 	bl	80249b0 <TIM_SelectMasterSlaveMode>
	TIM_SelectInputTrigger(TIM8, TIM_TS_ITR0);
 80137aa:	4621      	mov	r1, r4
 80137ac:	4638      	mov	r0, r7
 80137ae:	f011 f8d7 	bl	8024960 <TIM_SelectInputTrigger>
	TIM_SelectSlaveMode(TIM8, TIM_SlaveMode_Reset);
 80137b2:	4641      	mov	r1, r8
 80137b4:	4638      	mov	r0, r7
 80137b6:	f011 f8eb 	bl	8024990 <TIM_SelectSlaveMode>
	TIM_Cmd(TIM1, ENABLE);
 80137ba:	4629      	mov	r1, r5
 80137bc:	4630      	mov	r0, r6
 80137be:	f010 fed7 	bl	8024570 <TIM_Cmd>
	TIM_Cmd(TIM8, ENABLE);
 80137c2:	4629      	mov	r1, r5
 80137c4:	4638      	mov	r0, r7
 80137c6:	f010 fed3 	bl	8024570 <TIM_Cmd>
	TIM_CtrlPWMOutputs(TIM1, ENABLE);
 80137ca:	4629      	mov	r1, r5
 80137cc:	4630      	mov	r0, r6
 80137ce:	f011 f86f 	bl	80248b0 <TIM_CtrlPWMOutputs>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 80137d2:	4629      	mov	r1, r5
 80137d4:	4628      	mov	r0, r5
 80137d6:	f010 fd2b 	bl	8024230 <RCC_APB1PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80137da:	2253      	movs	r2, #83	; 0x53
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80137dc:	f04f 33ff 	mov.w	r3, #4294967295
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80137e0:	a903      	add	r1, sp, #12
 80137e2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80137e6:	e9cd 2303 	strd	r2, r3, [sp, #12]
	TIM_TimeBaseStructure.TIM_Period = 0xFFFFFFFF;
 80137ea:	f8ad 4014 	strh.w	r4, [sp, #20]
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80137ee:	f010 fe57 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_Cmd(TIM2, ENABLE);
 80137f2:	4629      	mov	r1, r5
 80137f4:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80137f8:	f010 feba 	bl	8024570 <TIM_Cmd>
	stop_pwm_hw();
 80137fc:	f7ff fb40 	bl	8012e80 <stop_pwm_hw>
	timer_tmp.top = TIM1->ARR;
 8013800:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8013802:	931a      	str	r3, [sp, #104]	; 0x68
	timer_tmp.duty = TIM1->ARR / 2;
 8013804:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	update_adc_sample_pos(&timer_tmp);
 8013806:	a819      	add	r0, sp, #100	; 0x64
	timer_tmp.duty = TIM1->ARR / 2;
 8013808:	40eb      	lsrs	r3, r5
 801380a:	931b      	str	r3, [sp, #108]	; 0x6c
	update_adc_sample_pos(&timer_tmp);
 801380c:	f7fe fe58 	bl	80124c0 <update_adc_sample_pos>
	set_next_timer_settings(&timer_tmp);
 8013810:	a819      	add	r0, sp, #100	; 0x64
 8013812:	f7fe ffed 	bl	80127f0 <set_next_timer_settings>
	ENABLE_GATE();
 8013816:	4d3e      	ldr	r5, [pc, #248]	; (8013910 <mcpwm_init+0x5f0>)
	utils_sys_unlock_cnt();
 8013818:	f002 fc52 	bl	80160c0 <utils_sys_unlock_cnt>
	DCCAL_OFF();
 801381c:	4b3d      	ldr	r3, [pc, #244]	; (8013914 <mcpwm_init+0x5f4>)
	ENABLE_GATE();
 801381e:	f8a5 a018 	strh.w	sl, [r5, #24]
	DCCAL_OFF();
 8013822:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013826:	835a      	strh	r2, [r3, #26]
	DCCAL_ON();
 8013828:	f241 3489 	movw	r4, #5001	; 0x1389
 801382c:	831a      	strh	r2, [r3, #24]
 801382e:	e003      	b.n	8013838 <mcpwm_init+0x518>
		chThdSleepMilliseconds(1);
 8013830:	f7fa f8d6 	bl	800d9e0 <chThdSleep>
		if (cnt > 5000) {
 8013834:	3c01      	subs	r4, #1
 8013836:	d004      	beq.n	8013842 <mcpwm_init+0x522>
	while(IS_DRV_FAULT()){
 8013838:	692b      	ldr	r3, [r5, #16]
 801383a:	04db      	lsls	r3, r3, #19
		chThdSleepMilliseconds(1);
 801383c:	f04f 000a 	mov.w	r0, #10
	while(IS_DRV_FAULT()){
 8013840:	d5f6      	bpl.n	8013830 <mcpwm_init+0x510>
	chThdSleepMilliseconds(1000);
 8013842:	f242 7010 	movw	r0, #10000	; 0x2710
 8013846:	f7fa f8cb 	bl	800d9e0 <chThdSleep>
	curr0_sum = 0;
 801384a:	4833      	ldr	r0, [pc, #204]	; (8013918 <mcpwm_init+0x5f8>)
	curr1_sum = 0;
 801384c:	4933      	ldr	r1, [pc, #204]	; (801391c <mcpwm_init+0x5fc>)
	curr_start_samples = 0;
 801384e:	4a34      	ldr	r2, [pc, #208]	; (8013920 <mcpwm_init+0x600>)
	curr0_sum = 0;
 8013850:	2300      	movs	r3, #0
 8013852:	6003      	str	r3, [r0, #0]
	curr1_sum = 0;
 8013854:	600b      	str	r3, [r1, #0]
	curr_start_samples = 0;
 8013856:	6013      	str	r3, [r2, #0]
	while(curr_start_samples < 4000) {};
 8013858:	6813      	ldr	r3, [r2, #0]
 801385a:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
 801385e:	dbfb      	blt.n	8013858 <mcpwm_init+0x538>
	curr0_offset = curr0_sum / curr_start_samples;
 8013860:	4d30      	ldr	r5, [pc, #192]	; (8013924 <mcpwm_init+0x604>)
	curr1_offset = curr1_sum / curr_start_samples;
 8013862:	4c31      	ldr	r4, [pc, #196]	; (8013928 <mcpwm_init+0x608>)
	curr0_offset = curr0_sum / curr_start_samples;
 8013864:	6803      	ldr	r3, [r0, #0]
 8013866:	6810      	ldr	r0, [r2, #0]
 8013868:	fb93 f3f0 	sdiv	r3, r3, r0
	DCCAL_OFF();
 801386c:	4829      	ldr	r0, [pc, #164]	; (8013914 <mcpwm_init+0x5f4>)
	curr0_offset = curr0_sum / curr_start_samples;
 801386e:	602b      	str	r3, [r5, #0]
	curr1_offset = curr1_sum / curr_start_samples;
 8013870:	680b      	ldr	r3, [r1, #0]
 8013872:	6812      	ldr	r2, [r2, #0]
 8013874:	fb93 f3f2 	sdiv	r3, r3, r2
	dccal_done = true;
 8013878:	2501      	movs	r5, #1
	curr1_offset = curr1_sum / curr_start_samples;
 801387a:	6023      	str	r3, [r4, #0]
	DCCAL_OFF();
 801387c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	dccal_done = true;
 8013880:	4b2a      	ldr	r3, [pc, #168]	; (801392c <mcpwm_init+0x60c>)
	DCCAL_OFF();
 8013882:	8342      	strh	r2, [r0, #26]
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12, ENABLE);
 8013884:	4629      	mov	r1, r5
 8013886:	2040      	movs	r0, #64	; 0x40
	TIM_TimeBaseStructure.TIM_Period = 0xFFFFFFFF;
 8013888:	2400      	movs	r4, #0
	dccal_done = true;
 801388a:	701d      	strb	r5, [r3, #0]
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12, ENABLE);
 801388c:	f010 fcd0 	bl	8024230 <RCC_APB1PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 8013890:	2207      	movs	r2, #7
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8013892:	f04f 33ff 	mov.w	r3, #4294967295
	TIM_TimeBaseInit(TIM12, &TIM_TimeBaseStructure);
 8013896:	a903      	add	r1, sp, #12
 8013898:	4825      	ldr	r0, [pc, #148]	; (8013930 <mcpwm_init+0x610>)
	TIM_TimeBaseStructure.TIM_Period = 0xFFFFFFFF;
 801389a:	f8ad 4014 	strh.w	r4, [sp, #20]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801389e:	e9cd 2303 	strd	r2, r3, [sp, #12]
	TIM_TimeBaseInit(TIM12, &TIM_TimeBaseStructure);
 80138a2:	f010 fdfd 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_Cmd(TIM12, ENABLE);
 80138a6:	4629      	mov	r1, r5
 80138a8:	4821      	ldr	r0, [pc, #132]	; (8013930 <mcpwm_init+0x610>)
	rpm_thd_stop = false;
 80138aa:	4e22      	ldr	r6, [pc, #136]	; (8013934 <mcpwm_init+0x614>)
	TIM_Cmd(TIM12, ENABLE);
 80138ac:	f010 fe60 	bl	8024570 <TIM_Cmd>
	timer_thd_stop = false;
 80138b0:	4a21      	ldr	r2, [pc, #132]	; (8013938 <mcpwm_init+0x618>)
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 80138b2:	9400      	str	r4, [sp, #0]
 80138b4:	4b21      	ldr	r3, [pc, #132]	; (801393c <mcpwm_init+0x61c>)
	timer_thd_stop = false;
 80138b6:	7014      	strb	r4, [r2, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 80138b8:	f640 1198 	movw	r1, #2456	; 0x998
 80138bc:	2240      	movs	r2, #64	; 0x40
	rpm_thd_stop = false;
 80138be:	7034      	strb	r4, [r6, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 80138c0:	481f      	ldr	r0, [pc, #124]	; (8013940 <mcpwm_init+0x620>)
 80138c2:	f7fa f855 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(rpm_thread_wa, sizeof(rpm_thread_wa), NORMALPRIO, rpm_thread, NULL);
 80138c6:	4b1f      	ldr	r3, [pc, #124]	; (8013944 <mcpwm_init+0x624>)
 80138c8:	9400      	str	r4, [sp, #0]
 80138ca:	2240      	movs	r2, #64	; 0x40
 80138cc:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 80138d0:	481d      	ldr	r0, [pc, #116]	; (8013948 <mcpwm_init+0x628>)
 80138d2:	f7fa f84d 	bl	800d970 <chThdCreateStatic>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 80138d6:	4629      	mov	r1, r5
 80138d8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80138dc:	f010 fca8 	bl	8024230 <RCC_APB1PeriphClockCmd>
	WWDG_SetPrescaler(WWDG_Prescaler_1);
 80138e0:	4620      	mov	r0, r4
 80138e2:	f011 f8a5 	bl	8024a30 <WWDG_SetPrescaler>
	WWDG_SetWindowValue(255);
 80138e6:	20ff      	movs	r0, #255	; 0xff
 80138e8:	f011 f8b2 	bl	8024a50 <WWDG_SetWindowValue>
	WWDG_Enable(100);
 80138ec:	2064      	movs	r0, #100	; 0x64
 80138ee:	f011 f8cf 	bl	8024a90 <WWDG_Enable>
	tachometer = 0;
 80138f2:	4b16      	ldr	r3, [pc, #88]	; (801394c <mcpwm_init+0x62c>)
 80138f4:	601c      	str	r4, [r3, #0]
	tachometer_abs = 0;
 80138f6:	4b16      	ldr	r3, [pc, #88]	; (8013950 <mcpwm_init+0x630>)
 80138f8:	601c      	str	r4, [r3, #0]
	init_done = true;
 80138fa:	f88b 5000 	strb.w	r5, [fp]
}
 80138fe:	b02f      	add	sp, #188	; 0xbc
 8013900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013904:	40012200 	.word	0x40012200
 8013908:	00010060 	.word	0x00010060
 801390c:	02000100 	.word	0x02000100
 8013910:	40020800 	.word	0x40020800
 8013914:	40020400 	.word	0x40020400
 8013918:	20004d5c 	.word	0x20004d5c
 801391c:	20004d64 	.word	0x20004d64
 8013920:	20004d6c 	.word	0x20004d6c
 8013924:	20004d58 	.word	0x20004d58
 8013928:	20004d60 	.word	0x20004d60
 801392c:	20004e0c 	.word	0x20004e0c
 8013930:	40001800 	.word	0x40001800
 8013934:	20005448 	.word	0x20005448
 8013938:	20005a20 	.word	0x20005a20
 801393c:	08012ff1 	.word	0x08012ff1
 8013940:	20005a28 	.word	0x20005a28
 8013944:	08014671 	.word	0x08014671
 8013948:	20005450 	.word	0x20005450
 801394c:	200059fc 	.word	0x200059fc
 8013950:	20005a00 	.word	0x20005a00
	...

08013960 <mcpwm_set_configuration>:
void mcpwm_set_configuration(volatile mc_configuration *configuration) {
 8013960:	b538      	push	{r3, r4, r5, lr}
	state = MC_STATE_OFF;
 8013962:	490e      	ldr	r1, [pc, #56]	; (801399c <mcpwm_set_configuration+0x3c>)
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013964:	4a0e      	ldr	r2, [pc, #56]	; (80139a0 <mcpwm_set_configuration+0x40>)
void mcpwm_set_configuration(volatile mc_configuration *configuration) {
 8013966:	4604      	mov	r4, r0
	control_mode = CONTROL_MODE_NONE;
 8013968:	480e      	ldr	r0, [pc, #56]	; (80139a4 <mcpwm_set_configuration+0x44>)
	state = MC_STATE_OFF;
 801396a:	2300      	movs	r3, #0
	control_mode = CONTROL_MODE_NONE;
 801396c:	2507      	movs	r5, #7
 801396e:	7005      	strb	r5, [r0, #0]
	state = MC_STATE_OFF;
 8013970:	700b      	strb	r3, [r1, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013972:	6013      	str	r3, [r2, #0]
	stop_pwm_hw();
 8013974:	f7ff fa84 	bl	8012e80 <stop_pwm_hw>
	utils_sys_lock_cnt();
 8013978:	f002 fb92 	bl	80160a0 <utils_sys_lock_cnt>
	comm_mode_next = conf->comm_mode;
 801397c:	7863      	ldrb	r3, [r4, #1]
	conf = configuration;
 801397e:	490a      	ldr	r1, [pc, #40]	; (80139a8 <mcpwm_set_configuration+0x48>)
	comm_mode_next = conf->comm_mode;
 8013980:	4a0a      	ldr	r2, [pc, #40]	; (80139ac <mcpwm_set_configuration+0x4c>)
	conf = configuration;
 8013982:	600c      	str	r4, [r1, #0]
	comm_mode_next = conf->comm_mode;
 8013984:	b2db      	uxtb	r3, r3
	mcpwm_init_hall_table((int8_t*)conf->hall_table);
 8013986:	f104 0098 	add.w	r0, r4, #152	; 0x98
	comm_mode_next = conf->comm_mode;
 801398a:	7013      	strb	r3, [r2, #0]
	mcpwm_init_hall_table((int8_t*)conf->hall_table);
 801398c:	f7ff fca0 	bl	80132d0 <mcpwm_init_hall_table>
	update_sensor_mode();
 8013990:	f7fe fec6 	bl	8012720 <update_sensor_mode>
}
 8013994:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	utils_sys_unlock_cnt();
 8013998:	f002 bb92 	b.w	80160c0 <utils_sys_unlock_cnt>
 801399c:	200059f4 	.word	0x200059f4
 80139a0:	20004f50 	.word	0x20004f50
 80139a4:	20004d54 	.word	0x20004d54
 80139a8:	20004d50 	.word	0x20004d50
 80139ac:	20004d48 	.word	0x20004d48

080139b0 <mcpwm_set_pid_speed>:
	control_mode = CONTROL_MODE_SPEED;
 80139b0:	4a03      	ldr	r2, [pc, #12]	; (80139c0 <mcpwm_set_pid_speed+0x10>)
	speed_pid_set_rpm = rpm;
 80139b2:	4b04      	ldr	r3, [pc, #16]	; (80139c4 <mcpwm_set_pid_speed+0x14>)
	control_mode = CONTROL_MODE_SPEED;
 80139b4:	2101      	movs	r1, #1
 80139b6:	7011      	strb	r1, [r2, #0]
	speed_pid_set_rpm = rpm;
 80139b8:	ed83 0a00 	vstr	s0, [r3]
}
 80139bc:	4770      	bx	lr
 80139be:	bf00      	nop
 80139c0:	20004d54 	.word	0x20004d54
 80139c4:	200059f0 	.word	0x200059f0
	...

080139d0 <mcpwm_set_brake_current>:
void mcpwm_set_brake_current(float current) {
 80139d0:	b530      	push	{r4, r5, lr}
	if (fabsf(current) < conf->cc_min_current) {
 80139d2:	4c2d      	ldr	r4, [pc, #180]	; (8013a88 <mcpwm_set_brake_current+0xb8>)
 80139d4:	6823      	ldr	r3, [r4, #0]
 80139d6:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 80139da:	eeb0 7ac0 	vabs.f32	s14, s0
 80139de:	eeb4 7ae7 	vcmpe.f32	s14, s15
void mcpwm_set_brake_current(float current) {
 80139e2:	b083      	sub	sp, #12
	if (fabsf(current) < conf->cc_min_current) {
 80139e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
void mcpwm_set_brake_current(float current) {
 80139e8:	ed8d 0a01 	vstr	s0, [sp, #4]
	if (fabsf(current) < conf->cc_min_current) {
 80139ec:	d42d      	bmi.n	8013a4a <mcpwm_set_brake_current+0x7a>
	utils_truncate_number(&current, -fabsf(conf->l_current_min), fabsf(conf->l_current_min));
 80139ee:	ed93 0a02 	vldr	s0, [r3, #8]
 80139f2:	edd3 0a02 	vldr	s1, [r3, #8]
	control_mode = CONTROL_MODE_CURRENT_BRAKE;
 80139f6:	4d25      	ldr	r5, [pc, #148]	; (8013a8c <mcpwm_set_brake_current+0xbc>)
	utils_truncate_number(&current, -fabsf(conf->l_current_min), fabsf(conf->l_current_min));
 80139f8:	eeb0 0ac0 	vabs.f32	s0, s0
 80139fc:	eeb1 0a40 	vneg.f32	s0, s0
 8013a00:	eef0 0ae0 	vabs.f32	s1, s1
 8013a04:	a801      	add	r0, sp, #4
 8013a06:	f002 f83b 	bl	8015a80 <utils_truncate_number>
	current_set = current;
 8013a0a:	4921      	ldr	r1, [pc, #132]	; (8013a90 <mcpwm_set_brake_current+0xc0>)
 8013a0c:	9801      	ldr	r0, [sp, #4]
	if (state != MC_STATE_RUNNING && state != MC_STATE_FULL_BRAKE) {
 8013a0e:	4b21      	ldr	r3, [pc, #132]	; (8013a94 <mcpwm_set_brake_current+0xc4>)
	control_mode = CONTROL_MODE_CURRENT_BRAKE;
 8013a10:	2203      	movs	r2, #3
 8013a12:	702a      	strb	r2, [r5, #0]
	current_set = current;
 8013a14:	6008      	str	r0, [r1, #0]
	if (state != MC_STATE_RUNNING && state != MC_STATE_FULL_BRAKE) {
 8013a16:	7819      	ldrb	r1, [r3, #0]
 8013a18:	2902      	cmp	r1, #2
 8013a1a:	d014      	beq.n	8013a46 <mcpwm_set_brake_current+0x76>
 8013a1c:	7819      	ldrb	r1, [r3, #0]
 8013a1e:	4291      	cmp	r1, r2
 8013a20:	d011      	beq.n	8013a46 <mcpwm_set_brake_current+0x76>
		if (conf->motor_type == MOTOR_TYPE_DC) {
 8013a22:	6821      	ldr	r1, [r4, #0]
 8013a24:	7888      	ldrb	r0, [r1, #2]
 8013a26:	2801      	cmp	r0, #1
 8013a28:	d01b      	beq.n	8013a62 <mcpwm_set_brake_current+0x92>
			if (fabsf(rpm_now) > conf->l_max_erpm_fbrake) {
 8013a2a:	481b      	ldr	r0, [pc, #108]	; (8013a98 <mcpwm_set_brake_current+0xc8>)
 8013a2c:	edd0 7a00 	vldr	s15, [r0]
 8013a30:	ed91 7a09 	vldr	s14, [r1, #36]	; 0x24
 8013a34:	eef0 7ae7 	vabs.f32	s15, s15
 8013a38:	eef4 7ac7 	vcmpe.f32	s15, s14
 8013a3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013a40:	dd1b      	ble.n	8013a7a <mcpwm_set_brake_current+0xaa>
				state = MC_STATE_RUNNING;
 8013a42:	2202      	movs	r2, #2
 8013a44:	701a      	strb	r2, [r3, #0]
}
 8013a46:	b003      	add	sp, #12
 8013a48:	bd30      	pop	{r4, r5, pc}
		control_mode = CONTROL_MODE_NONE;
 8013a4a:	4810      	ldr	r0, [pc, #64]	; (8013a8c <mcpwm_set_brake_current+0xbc>)
	state = MC_STATE_OFF;
 8013a4c:	4911      	ldr	r1, [pc, #68]	; (8013a94 <mcpwm_set_brake_current+0xc4>)
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013a4e:	4a13      	ldr	r2, [pc, #76]	; (8013a9c <mcpwm_set_brake_current+0xcc>)
	state = MC_STATE_OFF;
 8013a50:	2300      	movs	r3, #0
		control_mode = CONTROL_MODE_NONE;
 8013a52:	2407      	movs	r4, #7
 8013a54:	7004      	strb	r4, [r0, #0]
	state = MC_STATE_OFF;
 8013a56:	700b      	strb	r3, [r1, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013a58:	6013      	str	r3, [r2, #0]
	stop_pwm_hw();
 8013a5a:	f7ff fa11 	bl	8012e80 <stop_pwm_hw>
}
 8013a5e:	b003      	add	sp, #12
 8013a60:	bd30      	pop	{r4, r5, pc}
			if (fabsf(dutycycle_now) > 0.1) {
 8013a62:	490f      	ldr	r1, [pc, #60]	; (8013aa0 <mcpwm_set_brake_current+0xd0>)
 8013a64:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 8013aa4 <mcpwm_set_brake_current+0xd4>
 8013a68:	edd1 7a00 	vldr	s15, [r1]
 8013a6c:	eef0 7ae7 	vabs.f32	s15, s15
 8013a70:	eef4 7ac7 	vcmpe.f32	s15, s14
 8013a74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013a78:	dce3      	bgt.n	8013a42 <mcpwm_set_brake_current+0x72>
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013a7a:	4908      	ldr	r1, [pc, #32]	; (8013a9c <mcpwm_set_brake_current+0xcc>)
	state = MC_STATE_FULL_BRAKE;
 8013a7c:	701a      	strb	r2, [r3, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013a7e:	2300      	movs	r3, #0
 8013a80:	600b      	str	r3, [r1, #0]
	full_brake_hw();
 8013a82:	f7ff f9bd 	bl	8012e00 <full_brake_hw>
 8013a86:	e7de      	b.n	8013a46 <mcpwm_set_brake_current+0x76>
 8013a88:	20004d50 	.word	0x20004d50
 8013a8c:	20004d54 	.word	0x20004d54
 8013a90:	20004df4 	.word	0x20004df4
 8013a94:	200059f4 	.word	0x200059f4
 8013a98:	20005444 	.word	0x20005444
 8013a9c:	20004f50 	.word	0x20004f50
 8013aa0:	20004e1c 	.word	0x20004e1c
 8013aa4:	3dcccccd 	.word	0x3dcccccd
	...

08013ab0 <mcpwm_get_comm_step>:
	return comm_step;
 8013ab0:	4b01      	ldr	r3, [pc, #4]	; (8013ab8 <mcpwm_get_comm_step+0x8>)
 8013ab2:	6818      	ldr	r0, [r3, #0]
}
 8013ab4:	4770      	bx	lr
 8013ab6:	bf00      	nop
 8013ab8:	20004d4c 	.word	0x20004d4c
 8013abc:	00000000 	.word	0x00000000

08013ac0 <mcpwm_get_duty_cycle_now>:
	return dutycycle_now;
 8013ac0:	4b01      	ldr	r3, [pc, #4]	; (8013ac8 <mcpwm_get_duty_cycle_now+0x8>)
 8013ac2:	ed93 0a00 	vldr	s0, [r3]
}
 8013ac6:	4770      	bx	lr
 8013ac8:	20004e1c 	.word	0x20004e1c
 8013acc:	00000000 	.word	0x00000000

08013ad0 <mcpwm_get_switching_frequency_now>:
	return switching_frequency_now;
 8013ad0:	4b01      	ldr	r3, [pc, #4]	; (8013ad8 <mcpwm_get_switching_frequency_now+0x8>)
 8013ad2:	ed93 0a00 	vldr	s0, [r3]
}
 8013ad6:	4770      	bx	lr
 8013ad8:	200059f8 	.word	0x200059f8
 8013adc:	00000000 	.word	0x00000000

08013ae0 <mcpwm_get_rpm>:
	return direction ? rpm_now : -rpm_now;
 8013ae0:	4b06      	ldr	r3, [pc, #24]	; (8013afc <mcpwm_get_rpm+0x1c>)
 8013ae2:	681b      	ldr	r3, [r3, #0]
 8013ae4:	b11b      	cbz	r3, 8013aee <mcpwm_get_rpm+0xe>
 8013ae6:	4b06      	ldr	r3, [pc, #24]	; (8013b00 <mcpwm_get_rpm+0x20>)
 8013ae8:	ed93 0a00 	vldr	s0, [r3]
}
 8013aec:	4770      	bx	lr
	return direction ? rpm_now : -rpm_now;
 8013aee:	4b04      	ldr	r3, [pc, #16]	; (8013b00 <mcpwm_get_rpm+0x20>)
 8013af0:	ed93 0a00 	vldr	s0, [r3]
 8013af4:	eeb1 0a40 	vneg.f32	s0, s0
 8013af8:	4770      	bx	lr
 8013afa:	bf00      	nop
 8013afc:	20004e18 	.word	0x20004e18
 8013b00:	20005444 	.word	0x20005444
	...

08013b10 <mcpwm_get_state>:
	return state;
 8013b10:	4b01      	ldr	r3, [pc, #4]	; (8013b18 <mcpwm_get_state+0x8>)
 8013b12:	7818      	ldrb	r0, [r3, #0]
}
 8013b14:	4770      	bx	lr
 8013b16:	bf00      	nop
 8013b18:	200059f4 	.word	0x200059f4
 8013b1c:	00000000 	.word	0x00000000

08013b20 <mcpwm_get_kv_filtered>:
	float value = filter_run_fir_iteration((float*)kv_fir_samples,
 8013b20:	4b03      	ldr	r3, [pc, #12]	; (8013b30 <mcpwm_get_kv_filtered+0x10>)
 8013b22:	4904      	ldr	r1, [pc, #16]	; (8013b34 <mcpwm_get_kv_filtered+0x14>)
 8013b24:	681b      	ldr	r3, [r3, #0]
 8013b26:	4804      	ldr	r0, [pc, #16]	; (8013b38 <mcpwm_get_kv_filtered+0x18>)
 8013b28:	2207      	movs	r2, #7
 8013b2a:	f7fe bc09 	b.w	8012340 <filter_run_fir_iteration>
 8013b2e:	bf00      	nop
 8013b30:	20005158 	.word	0x20005158
 8013b34:	20004f58 	.word	0x20004f58
 8013b38:	2000515c 	.word	0x2000515c
 8013b3c:	00000000 	.word	0x00000000

08013b40 <mcpwm_get_tot_current>:
	return last_current_sample;
 8013b40:	4b01      	ldr	r3, [pc, #4]	; (8013b48 <mcpwm_get_tot_current+0x8>)
 8013b42:	ed93 0a00 	vldr	s0, [r3]
}
 8013b46:	4770      	bx	lr
 8013b48:	20005360 	.word	0x20005360
 8013b4c:	00000000 	.word	0x00000000

08013b50 <mcpwm_get_tot_current_filtered>:
	return last_current_sample_filtered;
 8013b50:	4b01      	ldr	r3, [pc, #4]	; (8013b58 <mcpwm_get_tot_current_filtered+0x8>)
 8013b52:	ed93 0a00 	vldr	s0, [r3]
}
 8013b56:	4770      	bx	lr
 8013b58:	20005364 	.word	0x20005364
 8013b5c:	00000000 	.word	0x00000000

08013b60 <mcpwm_get_tot_current_directional>:
	return last_current_sample;
 8013b60:	4a06      	ldr	r2, [pc, #24]	; (8013b7c <mcpwm_get_tot_current_directional+0x1c>)
	return dutycycle_now > 0.0 ? retval : -retval;
 8013b62:	4b07      	ldr	r3, [pc, #28]	; (8013b80 <mcpwm_get_tot_current_directional+0x20>)
	return last_current_sample;
 8013b64:	ed92 0a00 	vldr	s0, [r2]
	return dutycycle_now > 0.0 ? retval : -retval;
 8013b68:	edd3 7a00 	vldr	s15, [r3]
 8013b6c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013b70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013b74:	bfd8      	it	le
 8013b76:	eeb1 0a40 	vnegle.f32	s0, s0
}
 8013b7a:	4770      	bx	lr
 8013b7c:	20005360 	.word	0x20005360
 8013b80:	20004e1c 	.word	0x20004e1c
	...

08013b90 <mcpwm_get_tot_current_directional_filtered>:
	return last_current_sample_filtered;
 8013b90:	4a06      	ldr	r2, [pc, #24]	; (8013bac <mcpwm_get_tot_current_directional_filtered+0x1c>)
	return dutycycle_now > 0.0 ? retval : -retval;
 8013b92:	4b07      	ldr	r3, [pc, #28]	; (8013bb0 <mcpwm_get_tot_current_directional_filtered+0x20>)
	return last_current_sample_filtered;
 8013b94:	ed92 0a00 	vldr	s0, [r2]
	return dutycycle_now > 0.0 ? retval : -retval;
 8013b98:	edd3 7a00 	vldr	s15, [r3]
 8013b9c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8013ba0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013ba4:	bfd8      	it	le
 8013ba6:	eeb1 0a40 	vnegle.f32	s0, s0
}
 8013baa:	4770      	bx	lr
 8013bac:	20005364 	.word	0x20005364
 8013bb0:	20004e1c 	.word	0x20004e1c
	...

08013bc0 <mcpwm_get_tot_current_in_filtered>:
	return last_current_sample_filtered;
 8013bc0:	4a05      	ldr	r2, [pc, #20]	; (8013bd8 <mcpwm_get_tot_current_in_filtered+0x18>)
	return mcpwm_get_tot_current_filtered() * fabsf(dutycycle_now);
 8013bc2:	4b06      	ldr	r3, [pc, #24]	; (8013bdc <mcpwm_get_tot_current_in_filtered+0x1c>)
	return last_current_sample_filtered;
 8013bc4:	ed92 0a00 	vldr	s0, [r2]
	return mcpwm_get_tot_current_filtered() * fabsf(dutycycle_now);
 8013bc8:	edd3 7a00 	vldr	s15, [r3]
 8013bcc:	eef0 7ae7 	vabs.f32	s15, s15
}
 8013bd0:	ee27 0a80 	vmul.f32	s0, s15, s0
 8013bd4:	4770      	bx	lr
 8013bd6:	bf00      	nop
 8013bd8:	20005364 	.word	0x20005364
 8013bdc:	20004e1c 	.word	0x20004e1c

08013be0 <mcpwm_get_tachometer_value>:
	int val = tachometer;
 8013be0:	4b03      	ldr	r3, [pc, #12]	; (8013bf0 <mcpwm_get_tachometer_value+0x10>)
 8013be2:	681a      	ldr	r2, [r3, #0]
	if (reset) {
 8013be4:	b108      	cbz	r0, 8013bea <mcpwm_get_tachometer_value+0xa>
		tachometer = 0;
 8013be6:	2100      	movs	r1, #0
 8013be8:	6019      	str	r1, [r3, #0]
}
 8013bea:	4610      	mov	r0, r2
 8013bec:	4770      	bx	lr
 8013bee:	bf00      	nop
 8013bf0:	200059fc 	.word	0x200059fc
	...

08013c00 <mcpwm_get_tachometer_abs_value>:
	int val = tachometer_abs;
 8013c00:	4b03      	ldr	r3, [pc, #12]	; (8013c10 <mcpwm_get_tachometer_abs_value+0x10>)
 8013c02:	681a      	ldr	r2, [r3, #0]
	if (reset) {
 8013c04:	b108      	cbz	r0, 8013c0a <mcpwm_get_tachometer_abs_value+0xa>
		tachometer_abs = 0;
 8013c06:	2100      	movs	r1, #0
 8013c08:	6019      	str	r1, [r3, #0]
}
 8013c0a:	4610      	mov	r0, r2
 8013c0c:	4770      	bx	lr
 8013c0e:	bf00      	nop
 8013c10:	20005a00 	.word	0x20005a00
	...

08013c20 <mcpwm_stop_pwm>:
	control_mode = CONTROL_MODE_NONE;
 8013c20:	4806      	ldr	r0, [pc, #24]	; (8013c3c <mcpwm_stop_pwm+0x1c>)
	state = MC_STATE_OFF;
 8013c22:	4907      	ldr	r1, [pc, #28]	; (8013c40 <mcpwm_stop_pwm+0x20>)
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013c24:	4a07      	ldr	r2, [pc, #28]	; (8013c44 <mcpwm_stop_pwm+0x24>)
void mcpwm_stop_pwm(void) {
 8013c26:	b410      	push	{r4}
	control_mode = CONTROL_MODE_NONE;
 8013c28:	2407      	movs	r4, #7
 8013c2a:	7004      	strb	r4, [r0, #0]
	state = MC_STATE_OFF;
 8013c2c:	2300      	movs	r3, #0
}
 8013c2e:	f85d 4b04 	ldr.w	r4, [sp], #4
	state = MC_STATE_OFF;
 8013c32:	700b      	strb	r3, [r1, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8013c34:	6013      	str	r3, [r2, #0]
	stop_pwm_hw();
 8013c36:	f7ff b923 	b.w	8012e80 <stop_pwm_hw>
 8013c3a:	bf00      	nop
 8013c3c:	20004d54 	.word	0x20004d54
 8013c40:	200059f4 	.word	0x200059f4
 8013c44:	20004f50 	.word	0x20004f50
	...

08013c50 <mcpwm_adc_inj_int_handler>:
void mcpwm_adc_inj_int_handler(void) {
 8013c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TIM12->CNT = 0;
 8013c52:	4ba8      	ldr	r3, [pc, #672]	; (8013ef4 <mcpwm_adc_inj_int_handler+0x2a4>)
	int curr0 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8013c54:	48a8      	ldr	r0, [pc, #672]	; (8013ef8 <mcpwm_adc_inj_int_handler+0x2a8>)
	TIM12->CNT = 0;
 8013c56:	2200      	movs	r2, #0
void mcpwm_adc_inj_int_handler(void) {
 8013c58:	ed2d 8b02 	vpush	{d8}
	int curr0 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8013c5c:	2114      	movs	r1, #20
	TIM12->CNT = 0;
 8013c5e:	625a      	str	r2, [r3, #36]	; 0x24
	int curr0 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8013c60:	f010 f88e 	bl	8023d80 <ADC_GetInjectedConversionValue>
	int curr1 = ADC_GetInjectedConversionValue(ADC2, ADC_InjectedChannel_1);
 8013c64:	2114      	movs	r1, #20
	int curr0 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8013c66:	4606      	mov	r6, r0
	int curr1 = ADC_GetInjectedConversionValue(ADC2, ADC_InjectedChannel_1);
 8013c68:	48a4      	ldr	r0, [pc, #656]	; (8013efc <mcpwm_adc_inj_int_handler+0x2ac>)
 8013c6a:	f010 f889 	bl	8023d80 <ADC_GetInjectedConversionValue>
	int curr0_2 = ADC_GetInjectedConversionValue(ADC2, ADC_InjectedChannel_2);
 8013c6e:	2118      	movs	r1, #24
	int curr1 = ADC_GetInjectedConversionValue(ADC2, ADC_InjectedChannel_1);
 8013c70:	4605      	mov	r5, r0
	int curr0_2 = ADC_GetInjectedConversionValue(ADC2, ADC_InjectedChannel_2);
 8013c72:	48a2      	ldr	r0, [pc, #648]	; (8013efc <mcpwm_adc_inj_int_handler+0x2ac>)
 8013c74:	f010 f884 	bl	8023d80 <ADC_GetInjectedConversionValue>
	int curr1_2 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_2);
 8013c78:	2118      	movs	r1, #24
 8013c7a:	489f      	ldr	r0, [pc, #636]	; (8013ef8 <mcpwm_adc_inj_int_handler+0x2a8>)
 8013c7c:	f010 f880 	bl	8023d80 <ADC_GetInjectedConversionValue>
	if (curr_samp_volt & (1 << 0)) {
 8013c80:	4b9f      	ldr	r3, [pc, #636]	; (8013f00 <mcpwm_adc_inj_int_handler+0x2b0>)
 8013c82:	681a      	ldr	r2, [r3, #0]
 8013c84:	07d2      	lsls	r2, r2, #31
 8013c86:	d502      	bpl.n	8013c8e <mcpwm_adc_inj_int_handler+0x3e>
		curr0 = ADC_Value[ADC_IND_CURR1];
 8013c88:	4a9e      	ldr	r2, [pc, #632]	; (8013f04 <mcpwm_adc_inj_int_handler+0x2b4>)
 8013c8a:	8916      	ldrh	r6, [r2, #8]
 8013c8c:	b2b6      	uxth	r6, r6
	if (curr_samp_volt & (1 << 1)) {
 8013c8e:	681b      	ldr	r3, [r3, #0]
 8013c90:	079b      	lsls	r3, r3, #30
 8013c92:	d502      	bpl.n	8013c9a <mcpwm_adc_inj_int_handler+0x4a>
		curr1 = ADC_Value[ADC_IND_CURR2];
 8013c94:	4b9b      	ldr	r3, [pc, #620]	; (8013f04 <mcpwm_adc_inj_int_handler+0x2b4>)
 8013c96:	88dd      	ldrh	r5, [r3, #6]
 8013c98:	b2ad      	uxth	r5, r5
	curr0_sum += curr0;
 8013c9a:	489b      	ldr	r0, [pc, #620]	; (8013f08 <mcpwm_adc_inj_int_handler+0x2b8>)
	curr1_sum += curr1;
 8013c9c:	4c9b      	ldr	r4, [pc, #620]	; (8013f0c <mcpwm_adc_inj_int_handler+0x2bc>)
	curr0_sum += curr0;
 8013c9e:	6803      	ldr	r3, [r0, #0]
	curr_start_samples++;
 8013ca0:	4a9b      	ldr	r2, [pc, #620]	; (8013f10 <mcpwm_adc_inj_int_handler+0x2c0>)
	curr0_currsamp -= curr0_offset;
 8013ca2:	499c      	ldr	r1, [pc, #624]	; (8013f14 <mcpwm_adc_inj_int_handler+0x2c4>)
	curr0_sum += curr0;
 8013ca4:	4433      	add	r3, r6
 8013ca6:	6003      	str	r3, [r0, #0]
	curr1_sum += curr1;
 8013ca8:	6823      	ldr	r3, [r4, #0]
	curr1_currsamp -= curr1_offset;
 8013caa:	489b      	ldr	r0, [pc, #620]	; (8013f18 <mcpwm_adc_inj_int_handler+0x2c8>)
	curr1_sum += curr1;
 8013cac:	442b      	add	r3, r5
 8013cae:	6023      	str	r3, [r4, #0]
	curr_start_samples++;
 8013cb0:	6813      	ldr	r3, [r2, #0]
	ADC_curr_norm_value[0] = curr0;
 8013cb2:	4c9a      	ldr	r4, [pc, #616]	; (8013f1c <mcpwm_adc_inj_int_handler+0x2cc>)
	curr_start_samples++;
 8013cb4:	3301      	adds	r3, #1
 8013cb6:	6013      	str	r3, [r2, #0]
	curr0_currsamp -= curr0_offset;
 8013cb8:	680b      	ldr	r3, [r1, #0]
	curr1_currsamp -= curr1_offset;
 8013cba:	6803      	ldr	r3, [r0, #0]
	curr0 -= curr0_offset;
 8013cbc:	680a      	ldr	r2, [r1, #0]
	curr1 -= curr1_offset;
 8013cbe:	6803      	ldr	r3, [r0, #0]
	curr0_2 -= curr0_offset;
 8013cc0:	680f      	ldr	r7, [r1, #0]
	curr1_2 -= curr1_offset;
 8013cc2:	6807      	ldr	r7, [r0, #0]
	curr1 -= curr1_offset;
 8013cc4:	1aed      	subs	r5, r5, r3
	curr0 -= curr0_offset;
 8013cc6:	1ab6      	subs	r6, r6, r2
	ADC_curr_norm_value[0] = curr0;
 8013cc8:	6026      	str	r6, [r4, #0]
	ADC_curr_norm_value[1] = curr1;
 8013cca:	6065      	str	r5, [r4, #4]
	ADC_curr_norm_value[2] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);
 8013ccc:	6823      	ldr	r3, [r4, #0]
 8013cce:	6862      	ldr	r2, [r4, #4]
	if (conf->motor_type == MOTOR_TYPE_DC) {
 8013cd0:	4d93      	ldr	r5, [pc, #588]	; (8013f20 <mcpwm_adc_inj_int_handler+0x2d0>)
	ADC_curr_norm_value[2] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);
 8013cd2:	4413      	add	r3, r2
 8013cd4:	425b      	negs	r3, r3
	if (conf->motor_type == MOTOR_TYPE_DC) {
 8013cd6:	682a      	ldr	r2, [r5, #0]
	ADC_curr_norm_value[2] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);
 8013cd8:	60a3      	str	r3, [r4, #8]
	if (conf->motor_type == MOTOR_TYPE_DC) {
 8013cda:	7893      	ldrb	r3, [r2, #2]
 8013cdc:	2b01      	cmp	r3, #1
 8013cde:	d023      	beq.n	8013d28 <mcpwm_adc_inj_int_handler+0xd8>
		if (state == MC_STATE_FULL_BRAKE) {
 8013ce0:	4e90      	ldr	r6, [pc, #576]	; (8013f24 <mcpwm_adc_inj_int_handler+0x2d4>)
 8013ce2:	7833      	ldrb	r3, [r6, #0]
 8013ce4:	2b03      	cmp	r3, #3
 8013ce6:	f000 8191 	beq.w	801400c <mcpwm_adc_inj_int_handler+0x3bc>
			if (direction) {
 8013cea:	4b8f      	ldr	r3, [pc, #572]	; (8013f28 <mcpwm_adc_inj_int_handler+0x2d8>)
 8013cec:	681b      	ldr	r3, [r3, #0]
 8013cee:	b16b      	cbz	r3, 8013d0c <mcpwm_adc_inj_int_handler+0xbc>
				switch (comm_step) {
 8013cf0:	4b8e      	ldr	r3, [pc, #568]	; (8013f2c <mcpwm_adc_inj_int_handler+0x2dc>)
 8013cf2:	681a      	ldr	r2, [r3, #0]
 8013cf4:	3a01      	subs	r2, #1
 8013cf6:	2a05      	cmp	r2, #5
 8013cf8:	f200 81bb 	bhi.w	8014072 <mcpwm_adc_inj_int_handler+0x422>
 8013cfc:	e8df f012 	tbh	[pc, r2, lsl #1]
 8013d00:	00780078 	.word	0x00780078
 8013d04:	00f400ef 	.word	0x00f400ef
 8013d08:	00e800e8 	.word	0x00e800e8
				switch (comm_step) {
 8013d0c:	4b87      	ldr	r3, [pc, #540]	; (8013f2c <mcpwm_adc_inj_int_handler+0x2dc>)
 8013d0e:	681a      	ldr	r2, [r3, #0]
 8013d10:	3a01      	subs	r2, #1
 8013d12:	2a05      	cmp	r2, #5
 8013d14:	f200 81ad 	bhi.w	8014072 <mcpwm_adc_inj_int_handler+0x422>
 8013d18:	e8df f012 	tbh	[pc, r2, lsl #1]
 8013d1c:	00e100e6 	.word	0x00e100e6
 8013d20:	006a006a 	.word	0x006a006a
 8013d24:	00da00da 	.word	0x00da00da
		if (direction) {
 8013d28:	4b7f      	ldr	r3, [pc, #508]	; (8013f28 <mcpwm_adc_inj_int_handler+0x2d8>)
 8013d2a:	681b      	ldr	r3, [r3, #0]
 8013d2c:	2b00      	cmp	r3, #0
 8013d2e:	d154      	bne.n	8013dda <mcpwm_adc_inj_int_handler+0x18a>
			curr_tot_sample = -(float)(ADC_Value[ADC_IND_CURR1] - curr0_offset);
 8013d30:	4b74      	ldr	r3, [pc, #464]	; (8013f04 <mcpwm_adc_inj_int_handler+0x2b4>)
 8013d32:	891b      	ldrh	r3, [r3, #8]
 8013d34:	6809      	ldr	r1, [r1, #0]
 8013d36:	1a5b      	subs	r3, r3, r1
 8013d38:	ee07 3a90 	vmov	s15, r3
 8013d3c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013d40:	eeb1 8a67 	vneg.f32	s16, s15
	last_current_sample = curr_tot_sample * FAC_CURRENT;
 8013d44:	eddf 7a7a 	vldr	s15, [pc, #488]	; 8013f30 <mcpwm_adc_inj_int_handler+0x2e0>
 8013d48:	4b7a      	ldr	r3, [pc, #488]	; (8013f34 <mcpwm_adc_inj_int_handler+0x2e4>)
	if (fabsf(last_current_sample) > (conf->l_abs_current_max * 1.2)) {
 8013d4a:	eddf 6a7b 	vldr	s13, [pc, #492]	; 8013f38 <mcpwm_adc_inj_int_handler+0x2e8>
	last_current_sample = curr_tot_sample * FAC_CURRENT;
 8013d4e:	ee68 7a27 	vmul.f32	s15, s16, s15
 8013d52:	edc3 7a00 	vstr	s15, [r3]
	if (fabsf(last_current_sample) > (conf->l_abs_current_max * 1.2)) {
 8013d56:	ed93 7a00 	vldr	s14, [r3]
 8013d5a:	edd2 7a05 	vldr	s15, [r2, #20]
 8013d5e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8013d62:	eeb0 7ac7 	vabs.f32	s14, s14
 8013d66:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013d6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013d6e:	dd14      	ble.n	8013d9a <mcpwm_adc_inj_int_handler+0x14a>
		last_current_sample = SIGN(last_current_sample) * conf->l_abs_current_max * 1.2;
 8013d70:	ed93 7a00 	vldr	s14, [r3]
 8013d74:	edd2 7a05 	vldr	s15, [r2, #20]
 8013d78:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8013d7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013d80:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8013d84:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8013d88:	bf58      	it	pl
 8013d8a:	eeb0 7a46 	vmovpl.f32	s14, s12
 8013d8e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8013d92:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8013d96:	edc3 7a00 	vstr	s15, [r3]
	filter_add_sample((float*) current_fir_samples, last_current_sample,
 8013d9a:	4c68      	ldr	r4, [pc, #416]	; (8013f3c <mcpwm_adc_inj_int_handler+0x2ec>)
 8013d9c:	ed93 0a00 	vldr	s0, [r3]
 8013da0:	4867      	ldr	r0, [pc, #412]	; (8013f40 <mcpwm_adc_inj_int_handler+0x2f0>)
 8013da2:	4622      	mov	r2, r4
 8013da4:	2104      	movs	r1, #4
 8013da6:	f7fe faf3 	bl	8012390 <filter_add_sample>
	last_current_sample_filtered = filter_run_fir_iteration(
 8013daa:	6823      	ldr	r3, [r4, #0]
 8013dac:	4965      	ldr	r1, [pc, #404]	; (8013f44 <mcpwm_adc_inj_int_handler+0x2f4>)
 8013dae:	4864      	ldr	r0, [pc, #400]	; (8013f40 <mcpwm_adc_inj_int_handler+0x2f0>)
 8013db0:	2204      	movs	r2, #4
 8013db2:	f7fe fac5 	bl	8012340 <filter_run_fir_iteration>
 8013db6:	4a64      	ldr	r2, [pc, #400]	; (8013f48 <mcpwm_adc_inj_int_handler+0x2f8>)
	last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0;
 8013db8:	4b4e      	ldr	r3, [pc, #312]	; (8013ef4 <mcpwm_adc_inj_int_handler+0x2a4>)
	last_current_sample_filtered = filter_run_fir_iteration(
 8013dba:	ed82 0a00 	vstr	s0, [r2]
	last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0;
 8013dbe:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8013dc2:	eddf 6a62 	vldr	s13, [pc, #392]	; 8013f4c <mcpwm_adc_inj_int_handler+0x2fc>
 8013dc6:	4b62      	ldr	r3, [pc, #392]	; (8013f50 <mcpwm_adc_inj_int_handler+0x300>)
 8013dc8:	eef8 7a67 	vcvt.f32.u32	s15, s15
}
 8013dcc:	ecbd 8b02 	vpop	{d8}
	last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0;
 8013dd0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8013dd4:	ed83 7a00 	vstr	s14, [r3]
}
 8013dd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			curr_tot_sample = -(float)(ADC_Value[ADC_IND_CURR2] - curr1_offset);
 8013dda:	4b4a      	ldr	r3, [pc, #296]	; (8013f04 <mcpwm_adc_inj_int_handler+0x2b4>)
 8013ddc:	88db      	ldrh	r3, [r3, #6]
 8013dde:	6801      	ldr	r1, [r0, #0]
 8013de0:	1a5b      	subs	r3, r3, r1
 8013de2:	ee07 3a90 	vmov	s15, r3
 8013de6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013dea:	eeb1 8a67 	vneg.f32	s16, s15
 8013dee:	e7a9      	b.n	8013d44 <mcpwm_adc_inj_int_handler+0xf4>
				case 4: curr_tot_sample = -(float)ADC_curr_norm_value[1]; break;
 8013df0:	edd4 7a01 	vldr	s15, [r4, #4]
 8013df4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013df8:	eef1 7a67 	vneg.f32	s15, s15
			if (comm_step != comm_step_prev) {
 8013dfc:	4a55      	ldr	r2, [pc, #340]	; (8013f54 <mcpwm_adc_inj_int_handler+0x304>)
 8013dfe:	6818      	ldr	r0, [r3, #0]
 8013e00:	6811      	ldr	r1, [r2, #0]
			comm_step_prev = comm_step;
 8013e02:	681b      	ldr	r3, [r3, #0]
 8013e04:	6013      	str	r3, [r2, #0]
			if (comm_step != comm_step_prev) {
 8013e06:	4288      	cmp	r0, r1
				curr_tot_sample = prev_tot_sample;
 8013e08:	bf16      	itet	ne
 8013e0a:	4953      	ldrne	r1, [pc, #332]	; (8013f58 <mcpwm_adc_inj_int_handler+0x308>)
 8013e0c:	4952      	ldreq	r1, [pc, #328]	; (8013f58 <mcpwm_adc_inj_int_handler+0x308>)
 8013e0e:	ed91 8a00 	vldrne	s16, [r1]
			prev_tot_sample = tot_sample_tmp;
 8013e12:	edc1 7a00 	vstr	s15, [r1]
 8013e16:	bf08      	it	eq
 8013e18:	eeb0 8a67 	vmoveq.f32	s16, s15
		if (detect_now == 4) {
 8013e1c:	4f4f      	ldr	r7, [pc, #316]	; (8013f5c <mcpwm_adc_inj_int_handler+0x30c>)
 8013e1e:	683b      	ldr	r3, [r7, #0]
 8013e20:	2b04      	cmp	r3, #4
 8013e22:	d00a      	beq.n	8013e3a <mcpwm_adc_inj_int_handler+0x1ea>
		if (detect_now) {
 8013e24:	2b00      	cmp	r3, #0
 8013e26:	f000 80a3 	beq.w	8013f70 <mcpwm_adc_inj_int_handler+0x320>
		if (IS_DETECTING() && detect_now == 0) {
 8013e2a:	7832      	ldrb	r2, [r6, #0]
			detect_now--;
 8013e2c:	3b01      	subs	r3, #1
		if (IS_DETECTING() && detect_now == 0) {
 8013e2e:	2a01      	cmp	r2, #1
			detect_now--;
 8013e30:	603b      	str	r3, [r7, #0]
		if (IS_DETECTING() && detect_now == 0) {
 8013e32:	f000 80e7 	beq.w	8014004 <mcpwm_adc_inj_int_handler+0x3b4>
 8013e36:	682a      	ldr	r2, [r5, #0]
 8013e38:	e784      	b.n	8013d44 <mcpwm_adc_inj_int_handler+0xf4>
			const float a = fabsf(ADC_curr_norm_value[0]);
 8013e3a:	ed94 7a00 	vldr	s14, [r4]
			const float b = fabsf(ADC_curr_norm_value[1]);
 8013e3e:	edd4 7a01 	vldr	s15, [r4, #4]
				mcpwm_detect_currents[detect_step] = a;
 8013e42:	4b47      	ldr	r3, [pc, #284]	; (8013f60 <mcpwm_adc_inj_int_handler+0x310>)
 8013e44:	4a47      	ldr	r2, [pc, #284]	; (8013f64 <mcpwm_adc_inj_int_handler+0x314>)
 8013e46:	6819      	ldr	r1, [r3, #0]
			const float a = fabsf(ADC_curr_norm_value[0]);
 8013e48:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
			const float b = fabsf(ADC_curr_norm_value[1]);
 8013e4c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			const float a = fabsf(ADC_curr_norm_value[0]);
 8013e50:	eeb0 7ac7 	vabs.f32	s14, s14
			const float b = fabsf(ADC_curr_norm_value[1]);
 8013e54:	eef0 7ae7 	vabs.f32	s15, s15
			if (a > b) {
 8013e58:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8013e5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				mcpwm_detect_currents[detect_step] = a;
 8013e60:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8013e64:	bfcc      	ite	gt
 8013e66:	ed81 7a00 	vstrgt	s14, [r1]
				mcpwm_detect_currents[detect_step] = b;
 8013e6a:	edc1 7a00 	vstrle	s15, [r1]
			if (detect_step > 0) {
 8013e6e:	6819      	ldr	r1, [r3, #0]
 8013e70:	2900      	cmp	r1, #0
 8013e72:	f340 80ec 	ble.w	801404e <mcpwm_adc_inj_int_handler+0x3fe>
						mcpwm_detect_currents[detect_step - 1] - mcpwm_detect_currents[detect_step];
 8013e76:	6819      	ldr	r1, [r3, #0]
				mcpwm_detect_currents_diff[detect_step] =
 8013e78:	483b      	ldr	r0, [pc, #236]	; (8013f68 <mcpwm_adc_inj_int_handler+0x318>)
						mcpwm_detect_currents[detect_step - 1] - mcpwm_detect_currents[detect_step];
 8013e7a:	3901      	subs	r1, #1
 8013e7c:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8013e80:	edd1 7a00 	vldr	s15, [r1]
 8013e84:	6819      	ldr	r1, [r3, #0]
 8013e86:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8013e8a:	ed91 7a00 	vldr	s14, [r1]
				mcpwm_detect_currents_diff[detect_step] =
 8013e8e:	6819      	ldr	r1, [r3, #0]
						mcpwm_detect_currents[detect_step - 1] - mcpwm_detect_currents[detect_step];
 8013e90:	ee77 7ac7 	vsub.f32	s15, s15, s14
				mcpwm_detect_currents_diff[detect_step] =
 8013e94:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8013e98:	edc1 7a00 	vstr	s15, [r1]
			const int vzero = ADC_V_ZERO;
 8013e9c:	4c19      	ldr	r4, [pc, #100]	; (8013f04 <mcpwm_adc_inj_int_handler+0x2b4>)
			switch (comm_step) {
 8013e9e:	4823      	ldr	r0, [pc, #140]	; (8013f2c <mcpwm_adc_inj_int_handler+0x2dc>)
			const int vzero = ADC_V_ZERO;
 8013ea0:	8a21      	ldrh	r1, [r4, #16]
			switch (comm_step) {
 8013ea2:	6800      	ldr	r0, [r0, #0]
 8013ea4:	2806      	cmp	r0, #6
			const int vzero = ADC_V_ZERO;
 8013ea6:	b289      	uxth	r1, r1
 8013ea8:	f200 808d 	bhi.w	8013fc6 <mcpwm_adc_inj_int_handler+0x376>
 8013eac:	f04f 0c01 	mov.w	ip, #1
 8013eb0:	fa0c f000 	lsl.w	r0, ip, r0
 8013eb4:	f010 0f48 	tst.w	r0, #72	; 0x48
 8013eb8:	fa21 f10c 	lsr.w	r1, r1, ip
 8013ebc:	d177      	bne.n	8013fae <mcpwm_adc_inj_int_handler+0x35e>
 8013ebe:	f010 0f24 	tst.w	r0, #36	; 0x24
 8013ec2:	f040 80d4 	bne.w	801406e <mcpwm_adc_inj_int_handler+0x41e>
 8013ec6:	f010 0f12 	tst.w	r0, #18
 8013eca:	d07c      	beq.n	8013fc6 <mcpwm_adc_inj_int_handler+0x376>
				mcpwm_detect_voltages[detect_step] = ADC_V_L1 - vzero;
 8013ecc:	88a0      	ldrh	r0, [r4, #4]
 8013ece:	e06f      	b.n	8013fb0 <mcpwm_adc_inj_int_handler+0x360>
				case 6: curr_tot_sample = -(float)ADC_curr_norm_value[0]; break;
 8013ed0:	edd4 7a00 	vldr	s15, [r4]
 8013ed4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013ed8:	eef1 7a67 	vneg.f32	s15, s15
 8013edc:	e78e      	b.n	8013dfc <mcpwm_adc_inj_int_handler+0x1ac>
				case 2: curr_tot_sample = (float)ADC_curr_norm_value[0]; break;
 8013ede:	edd4 7a00 	vldr	s15, [r4]
 8013ee2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013ee6:	e789      	b.n	8013dfc <mcpwm_adc_inj_int_handler+0x1ac>
				case 1: curr_tot_sample = (float)ADC_curr_norm_value[1]; break;
 8013ee8:	edd4 7a01 	vldr	s15, [r4, #4]
 8013eec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013ef0:	e784      	b.n	8013dfc <mcpwm_adc_inj_int_handler+0x1ac>
 8013ef2:	bf00      	nop
 8013ef4:	40001800 	.word	0x40001800
 8013ef8:	40012000 	.word	0x40012000
 8013efc:	40012100 	.word	0x40012100
 8013f00:	20004d68 	.word	0x20004d68
 8013f04:	2000c03c 	.word	0x2000c03c
 8013f08:	20004d5c 	.word	0x20004d5c
 8013f0c:	20004d64 	.word	0x20004d64
 8013f10:	20004d6c 	.word	0x20004d6c
 8013f14:	20004d58 	.word	0x20004d58
 8013f18:	20004d60 	.word	0x20004d60
 8013f1c:	2000c054 	.word	0x2000c054
 8013f20:	20004d50 	.word	0x20004d50
 8013f24:	200059f4 	.word	0x200059f4
 8013f28:	20004e18 	.word	0x20004e18
 8013f2c:	20004d4c 	.word	0x20004d4c
 8013f30:	3da50a50 	.word	0x3da50a50
 8013f34:	20005360 	.word	0x20005360
 8013f38:	3f99999a 	.word	0x3f99999a
 8013f3c:	20004db0 	.word	0x20004db0
 8013f40:	20004db4 	.word	0x20004db4
 8013f44:	20004d70 	.word	0x20004d70
 8013f48:	20005364 	.word	0x20005364
 8013f4c:	4b189680 	.word	0x4b189680
 8013f50:	20005368 	.word	0x20005368
 8013f54:	20001008 	.word	0x20001008
 8013f58:	20005418 	.word	0x20005418
 8013f5c:	20004e10 	.word	0x20004e10
 8013f60:	20004e14 	.word	0x20004e14
 8013f64:	200053a8 	.word	0x200053a8
 8013f68:	200053d8 	.word	0x200053d8
 8013f6c:	3e4ccccd 	.word	0x3e4ccccd
		if (IS_DETECTING() && detect_now == 0) {
 8013f70:	7833      	ldrb	r3, [r6, #0]
 8013f72:	2b01      	cmp	r3, #1
 8013f74:	f47f af5f 	bne.w	8013e36 <mcpwm_adc_inj_int_handler+0x1e6>
			detect_now = 5;
 8013f78:	2305      	movs	r3, #5
			set_duty_cycle_hw(0.2);
 8013f7a:	ed1f 0a04 	vldr	s0, [pc, #-16]	; 8013f6c <mcpwm_adc_inj_int_handler+0x31c>
			detect_now = 5;
 8013f7e:	603b      	str	r3, [r7, #0]
			set_duty_cycle_hw(0.2);
 8013f80:	f7fe fc7e 	bl	8012880 <set_duty_cycle_hw>
			detect_step++;
 8013f84:	4b3c      	ldr	r3, [pc, #240]	; (8014078 <mcpwm_adc_inj_int_handler+0x428>)
 8013f86:	681a      	ldr	r2, [r3, #0]
 8013f88:	3201      	adds	r2, #1
 8013f8a:	601a      	str	r2, [r3, #0]
			if (detect_step > 5) {
 8013f8c:	681a      	ldr	r2, [r3, #0]
 8013f8e:	2a05      	cmp	r2, #5
				detect_step = 0;
 8013f90:	bfc4      	itt	gt
 8013f92:	2200      	movgt	r2, #0
 8013f94:	601a      	strgt	r2, [r3, #0]
			comm_step = detect_step + 1;
 8013f96:	681b      	ldr	r3, [r3, #0]
 8013f98:	4a38      	ldr	r2, [pc, #224]	; (801407c <mcpwm_adc_inj_int_handler+0x42c>)
 8013f9a:	3301      	adds	r3, #1
 8013f9c:	6013      	str	r3, [r2, #0]
			set_next_comm_step(comm_step);
 8013f9e:	6810      	ldr	r0, [r2, #0]
 8013fa0:	f7fe fcfe 	bl	80129a0 <set_next_comm_step>
			TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 8013fa4:	2120      	movs	r1, #32
 8013fa6:	4836      	ldr	r0, [pc, #216]	; (8014080 <mcpwm_adc_inj_int_handler+0x430>)
 8013fa8:	f010 fca2 	bl	80248f0 <TIM_GenerateEvent>
 8013fac:	e743      	b.n	8013e36 <mcpwm_adc_inj_int_handler+0x1e6>
				mcpwm_detect_voltages[detect_step] = ADC_V_L3 - vzero;
 8013fae:	8820      	ldrh	r0, [r4, #0]
 8013fb0:	4c34      	ldr	r4, [pc, #208]	; (8014084 <mcpwm_adc_inj_int_handler+0x434>)
 8013fb2:	1a41      	subs	r1, r0, r1
 8013fb4:	ee07 1a90 	vmov	s15, r1
 8013fb8:	6818      	ldr	r0, [r3, #0]
 8013fba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013fbe:	eb04 0180 	add.w	r1, r4, r0, lsl #2
 8013fc2:	edc1 7a00 	vstr	s15, [r1]
			mcpwm_detect_currents_avg[detect_step] += mcpwm_detect_currents[detect_step];
 8013fc6:	6818      	ldr	r0, [r3, #0]
 8013fc8:	492f      	ldr	r1, [pc, #188]	; (8014088 <mcpwm_adc_inj_int_handler+0x438>)
 8013fca:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8013fce:	edd2 7a00 	vldr	s15, [r2]
 8013fd2:	6818      	ldr	r0, [r3, #0]
			mcpwm_detect_avg_samples[detect_step]++;
 8013fd4:	4a2d      	ldr	r2, [pc, #180]	; (801408c <mcpwm_adc_inj_int_handler+0x43c>)
			mcpwm_detect_currents_avg[detect_step] += mcpwm_detect_currents[detect_step];
 8013fd6:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8013fda:	ed91 7a00 	vldr	s14, [r1]
 8013fde:	ee37 7a27 	vadd.f32	s14, s14, s15
			mcpwm_detect_avg_samples[detect_step]++;
 8013fe2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
			mcpwm_detect_currents_avg[detect_step] += mcpwm_detect_currents[detect_step];
 8013fe6:	ed81 7a00 	vstr	s14, [r1]
			mcpwm_detect_avg_samples[detect_step]++;
 8013fea:	681b      	ldr	r3, [r3, #0]
 8013fec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8013ff0:	edd3 7a00 	vldr	s15, [r3]
 8013ff4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8013ff8:	edc3 7a00 	vstr	s15, [r3]
			stop_pwm_hw();
 8013ffc:	f7fe ff40 	bl	8012e80 <stop_pwm_hw>
 8014000:	683b      	ldr	r3, [r7, #0]
 8014002:	e70f      	b.n	8013e24 <mcpwm_adc_inj_int_handler+0x1d4>
		if (IS_DETECTING() && detect_now == 0) {
 8014004:	2b00      	cmp	r3, #0
 8014006:	f47f af16 	bne.w	8013e36 <mcpwm_adc_inj_int_handler+0x1e6>
 801400a:	e7b5      	b.n	8013f78 <mcpwm_adc_inj_int_handler+0x328>
			float c0 = (float)ADC_curr_norm_value[0];
 801400c:	edd4 6a00 	vldr	s13, [r4]
			float c1 = (float)ADC_curr_norm_value[1];
 8014010:	edd4 7a01 	vldr	s15, [r4, #4]
			float c2 = (float)ADC_curr_norm_value[2];
 8014014:	ed94 7a02 	vldr	s14, [r4, #8]
			float c1 = (float)ADC_curr_norm_value[1];
 8014018:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			float c0 = (float)ADC_curr_norm_value[0];
 801401c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
			curr_tot_sample = sqrtf((c0*c0 + c1*c1 + c2*c2) / 1.5);
 8014020:	ee67 7aa7 	vmul.f32	s15, s15, s15
			float c2 = (float)ADC_curr_norm_value[2];
 8014024:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
			curr_tot_sample = sqrtf((c0*c0 + c1*c1 + c2*c2) / 1.5);
 8014028:	eee6 7aa6 	vfma.f32	s15, s13, s13
 801402c:	eef7 6a08 	vmov.f32	s13, #120	; 0x3fc00000  1.5
 8014030:	eee7 7a07 	vfma.f32	s15, s14, s14
 8014034:	ee87 0aa6 	vdiv.f32	s0, s15, s13
 8014038:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801403c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014040:	eeb1 8ac0 	vsqrt.f32	s16, s0
 8014044:	f57f aeea 	bpl.w	8013e1c <mcpwm_adc_inj_int_handler+0x1cc>
 8014048:	f011 fb6a 	bl	8025720 <sqrtf>
 801404c:	e6e6      	b.n	8013e1c <mcpwm_adc_inj_int_handler+0x1cc>
						mcpwm_detect_currents[5] - mcpwm_detect_currents[detect_step];
 801404e:	edd2 7a05 	vldr	s15, [r2, #20]
 8014052:	6818      	ldr	r0, [r3, #0]
				mcpwm_detect_currents_diff[detect_step] =
 8014054:	490e      	ldr	r1, [pc, #56]	; (8014090 <mcpwm_adc_inj_int_handler+0x440>)
						mcpwm_detect_currents[5] - mcpwm_detect_currents[detect_step];
 8014056:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 801405a:	ed90 7a00 	vldr	s14, [r0]
				mcpwm_detect_currents_diff[detect_step] =
 801405e:	6818      	ldr	r0, [r3, #0]
						mcpwm_detect_currents[5] - mcpwm_detect_currents[detect_step];
 8014060:	ee77 7ac7 	vsub.f32	s15, s15, s14
				mcpwm_detect_currents_diff[detect_step] =
 8014064:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8014068:	edc1 7a00 	vstr	s15, [r1]
 801406c:	e716      	b.n	8013e9c <mcpwm_adc_inj_int_handler+0x24c>
				mcpwm_detect_voltages[detect_step] = ADC_V_L2 - vzero;
 801406e:	8860      	ldrh	r0, [r4, #2]
 8014070:	e79e      	b.n	8013fb0 <mcpwm_adc_inj_int_handler+0x360>
	float curr_tot_sample = 0;
 8014072:	eddf 7a08 	vldr	s15, [pc, #32]	; 8014094 <mcpwm_adc_inj_int_handler+0x444>
 8014076:	e6c1      	b.n	8013dfc <mcpwm_adc_inj_int_handler+0x1ac>
 8014078:	20004e14 	.word	0x20004e14
 801407c:	20004d4c 	.word	0x20004d4c
 8014080:	40010000 	.word	0x40010000
 8014084:	200053f0 	.word	0x200053f0
 8014088:	200053c0 	.word	0x200053c0
 801408c:	20005390 	.word	0x20005390
 8014090:	200053d8 	.word	0x200053d8
	...

080140a0 <mcpwm_set_detect>:
void mcpwm_set_detect(void) {
 80140a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (mc_interface_try_input()) {
 80140a2:	f008 f835 	bl	801c110 <mc_interface_try_input>
 80140a6:	b100      	cbz	r0, 80140aa <mcpwm_set_detect+0xa>
}
 80140a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	control_mode = CONTROL_MODE_NONE;
 80140aa:	4b0f      	ldr	r3, [pc, #60]	; (80140e8 <mcpwm_set_detect+0x48>)
 80140ac:	4f0f      	ldr	r7, [pc, #60]	; (80140ec <mcpwm_set_detect+0x4c>)
 80140ae:	4e10      	ldr	r6, [pc, #64]	; (80140f0 <mcpwm_set_detect+0x50>)
 80140b0:	4d10      	ldr	r5, [pc, #64]	; (80140f4 <mcpwm_set_detect+0x54>)
 80140b2:	2207      	movs	r2, #7
 80140b4:	701a      	strb	r2, [r3, #0]
 80140b6:	4604      	mov	r4, r0
	stop_pwm_hw();
 80140b8:	f7fe fee2 	bl	8012e80 <stop_pwm_hw>
	set_switching_frequency(conf->m_bldc_f_sw_max);
 80140bc:	4b0e      	ldr	r3, [pc, #56]	; (80140f8 <mcpwm_set_detect+0x58>)
 80140be:	681b      	ldr	r3, [r3, #0]
 80140c0:	ed93 0a5a 	vldr	s0, [r3, #360]	; 0x168
 80140c4:	f7fe fbac 	bl	8012820 <set_switching_frequency>
		mcpwm_detect_currents[i] = 0;
 80140c8:	2200      	movs	r2, #0
 80140ca:	00a3      	lsls	r3, r4, #2
 80140cc:	18f8      	adds	r0, r7, r3
		mcpwm_detect_currents_avg[i] = 0;
 80140ce:	18f1      	adds	r1, r6, r3
	for(int i = 0;i < 6;i++) {
 80140d0:	3401      	adds	r4, #1
		mcpwm_detect_avg_samples[i] = 0;
 80140d2:	442b      	add	r3, r5
	for(int i = 0;i < 6;i++) {
 80140d4:	2c06      	cmp	r4, #6
		mcpwm_detect_currents[i] = 0;
 80140d6:	6002      	str	r2, [r0, #0]
		mcpwm_detect_currents_avg[i] = 0;
 80140d8:	600a      	str	r2, [r1, #0]
		mcpwm_detect_avg_samples[i] = 0;
 80140da:	601a      	str	r2, [r3, #0]
	for(int i = 0;i < 6;i++) {
 80140dc:	d1f5      	bne.n	80140ca <mcpwm_set_detect+0x2a>
	state = MC_STATE_DETECTING;
 80140de:	4b07      	ldr	r3, [pc, #28]	; (80140fc <mcpwm_set_detect+0x5c>)
 80140e0:	2201      	movs	r2, #1
 80140e2:	701a      	strb	r2, [r3, #0]
}
 80140e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80140e6:	bf00      	nop
 80140e8:	20004d54 	.word	0x20004d54
 80140ec:	200053a8 	.word	0x200053a8
 80140f0:	200053c0 	.word	0x200053c0
 80140f4:	20005390 	.word	0x20005390
 80140f8:	20004d50 	.word	0x20004d50
 80140fc:	200059f4 	.word	0x200059f4

08014100 <mcpwm_get_detect_pos>:
float mcpwm_get_detect_pos(void) {
 8014100:	b530      	push	{r4, r5, lr}
	v[0] = mcpwm_detect_currents_avg[0] / mcpwm_detect_avg_samples[0];
 8014102:	483f      	ldr	r0, [pc, #252]	; (8014200 <mcpwm_get_detect_pos+0x100>)
 8014104:	4c3f      	ldr	r4, [pc, #252]	; (8014204 <mcpwm_get_detect_pos+0x104>)
 8014106:	ed94 2a00 	vldr	s4, [r4]
 801410a:	edd0 2a00 	vldr	s5, [r0]
	v[1] = mcpwm_detect_currents_avg[1] / mcpwm_detect_avg_samples[1];
 801410e:	ed94 3a01 	vldr	s6, [r4, #4]
 8014112:	edd0 3a01 	vldr	s7, [r0, #4]
	v[2] = mcpwm_detect_currents_avg[2] / mcpwm_detect_avg_samples[2];
 8014116:	ed94 4a02 	vldr	s8, [r4, #8]
 801411a:	edd0 6a02 	vldr	s13, [r0, #8]
	v[3] = mcpwm_detect_currents_avg[3] / mcpwm_detect_avg_samples[3];
 801411e:	edd4 4a03 	vldr	s9, [r4, #12]
 8014122:	ed90 7a03 	vldr	s14, [r0, #12]
	v[4] = mcpwm_detect_currents_avg[4] / mcpwm_detect_avg_samples[4];
 8014126:	ed94 5a04 	vldr	s10, [r4, #16]
 801412a:	edd0 7a04 	vldr	s15, [r0, #16]
	v[5] = mcpwm_detect_currents_avg[5] / mcpwm_detect_avg_samples[5];
 801412e:	edd4 5a05 	vldr	s11, [r4, #20]
 8014132:	ed90 6a05 	vldr	s12, [r0, #20]
float mcpwm_get_detect_pos(void) {
 8014136:	ed2d 8b04 	vpush	{d8-d9}
	v[2] = mcpwm_detect_currents_avg[2] / mcpwm_detect_avg_samples[2];
 801413a:	ee84 8a26 	vdiv.f32	s16, s8, s13
float mcpwm_get_detect_pos(void) {
 801413e:	b083      	sub	sp, #12
		mcpwm_detect_currents_avg[i] = 0;
 8014140:	2100      	movs	r1, #0
	for(int i = 0;i < 6;i++) {
 8014142:	2200      	movs	r2, #0
	v[3] = mcpwm_detect_currents_avg[3] / mcpwm_detect_avg_samples[3];
 8014144:	eec4 6a87 	vdiv.f32	s13, s9, s14
	v[0] = mcpwm_detect_currents_avg[0] / mcpwm_detect_avg_samples[0];
 8014148:	ee82 9a22 	vdiv.f32	s18, s4, s5
	v[4] = mcpwm_detect_currents_avg[4] / mcpwm_detect_avg_samples[4];
 801414c:	ee85 7a27 	vdiv.f32	s14, s10, s15
	v[1] = mcpwm_detect_currents_avg[1] / mcpwm_detect_avg_samples[1];
 8014150:	eec3 8a23 	vdiv.f32	s17, s6, s7
	v[5] = mcpwm_detect_currents_avg[5] / mcpwm_detect_avg_samples[5];
 8014154:	eec5 7a86 	vdiv.f32	s15, s11, s12
		mcpwm_detect_currents_avg[i] = 0;
 8014158:	0093      	lsls	r3, r2, #2
 801415a:	18e5      	adds	r5, r4, r3
	for(int i = 0;i < 6;i++) {
 801415c:	3201      	adds	r2, #1
		mcpwm_detect_avg_samples[i] = 0;
 801415e:	4403      	add	r3, r0
	for(int i = 0;i < 6;i++) {
 8014160:	2a06      	cmp	r2, #6
		mcpwm_detect_currents_avg[i] = 0;
 8014162:	6029      	str	r1, [r5, #0]
		mcpwm_detect_avg_samples[i] = 0;
 8014164:	6019      	str	r1, [r3, #0]
	for(int i = 0;i < 6;i++) {
 8014166:	d1f7      	bne.n	8014158 <mcpwm_get_detect_pos+0x58>
	float v0 = v[0] + v[3];
 8014168:	ee39 9a26 	vadd.f32	s18, s18, s13
	float v1 = v[1] + v[4];
 801416c:	ee78 8a87 	vadd.f32	s17, s17, s14
	float v2 = v[2] + v[5];
 8014170:	ee38 8a27 	vadd.f32	s16, s16, s15
	float offset = (v0 + v1 + v2) / 3.0;
 8014174:	ee79 7a28 	vadd.f32	s15, s18, s17
 8014178:	eeb0 6a08 	vmov.f32	s12, #8	; 0x40400000  3.0
 801417c:	ee77 7a88 	vadd.f32	s15, s15, s16
	float amp = sqrtf((v0*v0 + v1*v1 + v2*v2) / 1.5);
 8014180:	eef7 6a08 	vmov.f32	s13, #120	; 0x3fc00000  1.5
	float offset = (v0 + v1 + v2) / 3.0;
 8014184:	ee87 7a86 	vdiv.f32	s14, s15, s12
	v1 -= offset;
 8014188:	ee78 8ac7 	vsub.f32	s17, s17, s14
	v0 -= offset;
 801418c:	ee39 9a47 	vsub.f32	s18, s18, s14
	float amp = sqrtf((v0*v0 + v1*v1 + v2*v2) / 1.5);
 8014190:	ee68 7aa8 	vmul.f32	s15, s17, s17
	v2 -= offset;
 8014194:	ee38 8a47 	vsub.f32	s16, s16, s14
	float amp = sqrtf((v0*v0 + v1*v1 + v2*v2) / 1.5);
 8014198:	eee9 7a09 	vfma.f32	s15, s18, s18
 801419c:	eee8 7a08 	vfma.f32	s15, s16, s16
 80141a0:	ee87 0aa6 	vdiv.f32	s0, s15, s13
 80141a4:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80141a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80141ac:	eef1 9ac0 	vsqrt.f32	s19, s0
 80141b0:	d423      	bmi.n	80141fa <mcpwm_get_detect_pos+0xfa>
	ph[0] = asinf(v0) * 180.0 / M_PI;
 80141b2:	ee89 0a29 	vdiv.f32	s0, s18, s19
 80141b6:	f011 f9d3 	bl	8025560 <asinf>
	utils_norm_angle(&res);
 80141ba:	a801      	add	r0, sp, #4
	ph[0] = asinf(v0) * 180.0 / M_PI;
 80141bc:	eddf 7a12 	vldr	s15, [pc, #72]	; 8014208 <mcpwm_get_detect_pos+0x108>
 80141c0:	eddf 5a12 	vldr	s11, [pc, #72]	; 801420c <mcpwm_get_detect_pos+0x10c>
 80141c4:	ee20 0a27 	vmul.f32	s0, s0, s15
	v1 /= amp;
 80141c8:	ee88 6aa9 	vdiv.f32	s12, s17, s19
	v2 /= amp;
 80141cc:	eec8 6a29 	vdiv.f32	s13, s16, s19
	ph[0] = asinf(v0) * 180.0 / M_PI;
 80141d0:	ee80 7a25 	vdiv.f32	s14, s0, s11
	if (v1 < v2) {
 80141d4:	eeb4 6ae6 	vcmpe.f32	s12, s13
 80141d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		res = 180 - ph[0];
 80141dc:	bf4a      	itet	mi
 80141de:	ee77 7ac7 	vsubmi.f32	s15, s15, s14
	float res = ph[0];
 80141e2:	ed8d 7a01 	vstrpl	s14, [sp, #4]
		res = 180 - ph[0];
 80141e6:	edcd 7a01 	vstrmi	s15, [sp, #4]
	utils_norm_angle(&res);
 80141ea:	f001 fbf9 	bl	80159e0 <utils_norm_angle>
}
 80141ee:	ed9d 0a01 	vldr	s0, [sp, #4]
 80141f2:	b003      	add	sp, #12
 80141f4:	ecbd 8b04 	vpop	{d8-d9}
 80141f8:	bd30      	pop	{r4, r5, pc}
	float amp = sqrtf((v0*v0 + v1*v1 + v2*v2) / 1.5);
 80141fa:	f011 fa91 	bl	8025720 <sqrtf>
 80141fe:	e7d8      	b.n	80141b2 <mcpwm_get_detect_pos+0xb2>
 8014200:	20005390 	.word	0x20005390
 8014204:	200053c0 	.word	0x200053c0
 8014208:	43340000 	.word	0x43340000
 801420c:	40490fdb 	.word	0x40490fdb

08014210 <mcpwm_read_reset_avg_cycle_integrator>:
	float res = cycle_integrator_sum / cycle_integrator_iterations;
 8014210:	4905      	ldr	r1, [pc, #20]	; (8014228 <mcpwm_read_reset_avg_cycle_integrator+0x18>)
 8014212:	4b06      	ldr	r3, [pc, #24]	; (801422c <mcpwm_read_reset_avg_cycle_integrator+0x1c>)
 8014214:	ed91 0a00 	vldr	s0, [r1]
 8014218:	edd3 7a00 	vldr	s15, [r3]
	cycle_integrator_sum = 0;
 801421c:	2200      	movs	r2, #0
 801421e:	600a      	str	r2, [r1, #0]
}
 8014220:	ee80 0a27 	vdiv.f32	s0, s0, s15
	cycle_integrator_iterations = 0;
 8014224:	601a      	str	r2, [r3, #0]
}
 8014226:	4770      	bx	lr
 8014228:	20004e00 	.word	0x20004e00
 801422c:	20004dfc 	.word	0x20004dfc

08014230 <mcpwm_get_last_adc_isr_duration>:
	return last_adc_isr_duration;
 8014230:	4b01      	ldr	r3, [pc, #4]	; (8014238 <mcpwm_get_last_adc_isr_duration+0x8>)
 8014232:	ed93 0a00 	vldr	s0, [r3]
}
 8014236:	4770      	bx	lr
 8014238:	2000535c 	.word	0x2000535c
 801423c:	00000000 	.word	0x00000000

08014240 <mcpwm_get_last_inj_adc_isr_duration>:
	return last_inj_adc_isr_duration;
 8014240:	4b01      	ldr	r3, [pc, #4]	; (8014248 <mcpwm_get_last_inj_adc_isr_duration+0x8>)
 8014242:	ed93 0a00 	vldr	s0, [r3]
}
 8014246:	4770      	bx	lr
 8014248:	20005368 	.word	0x20005368
 801424c:	00000000 	.word	0x00000000

08014250 <mcpwm_get_rpm_dep>:
mc_rpm_dep_struct mcpwm_get_rpm_dep(void) {
 8014250:	b470      	push	{r4, r5, r6}
	return rpm_dep;
 8014252:	4d06      	ldr	r5, [pc, #24]	; (801426c <mcpwm_get_rpm_dep+0x1c>)
mc_rpm_dep_struct mcpwm_get_rpm_dep(void) {
 8014254:	4606      	mov	r6, r0
	return rpm_dep;
 8014256:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8014258:	4634      	mov	r4, r6
 801425a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801425c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8014260:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8014264:	4630      	mov	r0, r6
 8014266:	bc70      	pop	{r4, r5, r6}
 8014268:	4770      	bx	lr
 801426a:	bf00      	nop
 801426c:	20005424 	.word	0x20005424

08014270 <mcpwm_is_dccal_done>:
	return dccal_done;
 8014270:	4b01      	ldr	r3, [pc, #4]	; (8014278 <mcpwm_is_dccal_done+0x8>)
 8014272:	7818      	ldrb	r0, [r3, #0]
}
 8014274:	4770      	bx	lr
 8014276:	bf00      	nop
 8014278:	20004e0c 	.word	0x20004e0c
 801427c:	00000000 	.word	0x00000000

08014280 <mcpwm_switch_comm_mode>:
	comm_mode_next = next;
 8014280:	4b01      	ldr	r3, [pc, #4]	; (8014288 <mcpwm_switch_comm_mode+0x8>)
 8014282:	7018      	strb	r0, [r3, #0]
}
 8014284:	4770      	bx	lr
 8014286:	bf00      	nop
 8014288:	20004d48 	.word	0x20004d48
 801428c:	00000000 	.word	0x00000000

08014290 <mcpwm_reset_hall_detect_table>:
	memset((void*)hall_detect_table, 0, sizeof(hall_detect_table[0][0]) * 8 * 7);
 8014290:	22e0      	movs	r2, #224	; 0xe0
 8014292:	2100      	movs	r1, #0
 8014294:	4801      	ldr	r0, [pc, #4]	; (801429c <mcpwm_reset_hall_detect_table+0xc>)
 8014296:	f012 bcc3 	b.w	8026c20 <memset>
 801429a:	bf00      	nop
 801429c:	20004e24 	.word	0x20004e24

080142a0 <mcpwm_get_hall_detect_result>:
	} else if (conf->m_sensor_port_mode != SENSOR_PORT_MODE_HALL) {
 80142a0:	4b2b      	ldr	r3, [pc, #172]	; (8014350 <mcpwm_get_hall_detect_result+0xb0>)
 80142a2:	681b      	ldr	r3, [r3, #0]
 80142a4:	f893 315c 	ldrb.w	r3, [r3, #348]	; 0x15c
 80142a8:	2b00      	cmp	r3, #0
 80142aa:	d14d      	bne.n	8014348 <mcpwm_get_hall_detect_result+0xa8>
int mcpwm_get_hall_detect_result(int8_t *table) {
 80142ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80142ae:	4e29      	ldr	r6, [pc, #164]	; (8014354 <mcpwm_get_hall_detect_result+0xb4>)
 80142b0:	b089      	sub	sp, #36	; 0x24
 80142b2:	f003 0eff 	and.w	lr, r3, #255	; 0xff
	} else if (conf->m_sensor_port_mode != SENSOR_PORT_MODE_HALL) {
 80142b6:	4607      	mov	r7, r0
		for (int j = 1;j < 7;j++) {
 80142b8:	2301      	movs	r3, #1
		int res = -1;
 80142ba:	f04f 34ff 	mov.w	r4, #4294967295
		int samples = 0;
 80142be:	2100      	movs	r1, #0
			if (hall_detect_table[i][j] > samples) {
 80142c0:	ebce 0cce 	rsb	ip, lr, lr, lsl #3
 80142c4:	eb0c 0203 	add.w	r2, ip, r3
 80142c8:	f856 5022 	ldr.w	r5, [r6, r2, lsl #2]
 80142cc:	428d      	cmp	r5, r1
 80142ce:	dd04      	ble.n	80142da <mcpwm_get_hall_detect_result+0x3a>
				samples = hall_detect_table[i][j];
 80142d0:	f856 1022 	ldr.w	r1, [r6, r2, lsl #2]
 80142d4:	290f      	cmp	r1, #15
 80142d6:	bfc8      	it	gt
 80142d8:	461c      	movgt	r4, r3
		for (int j = 1;j < 7;j++) {
 80142da:	3301      	adds	r3, #1
 80142dc:	2b07      	cmp	r3, #7
			table[i] = res;
 80142de:	703c      	strb	r4, [r7, #0]
		for (int j = 1;j < 7;j++) {
 80142e0:	d1f0      	bne.n	80142c4 <mcpwm_get_hall_detect_result+0x24>
	for (int i = 0;i < 8;i++) {
 80142e2:	f10e 0e01 	add.w	lr, lr, #1
 80142e6:	f1be 0f08 	cmp.w	lr, #8
 80142ea:	f107 0701 	add.w	r7, r7, #1
 80142ee:	d1e3      	bne.n	80142b8 <mcpwm_get_hall_detect_result+0x18>
	int nums[7] = {0, 0, 0, 0, 0, 0, 0};
 80142f0:	2300      	movs	r3, #0
	int tot_nums = 0;
 80142f2:	461c      	mov	r4, r3
	int nums[7] = {0, 0, 0, 0, 0, 0, 0};
 80142f4:	9301      	str	r3, [sp, #4]
	int invalid_samp_num = 0;
 80142f6:	461d      	mov	r5, r3
	int nums[7] = {0, 0, 0, 0, 0, 0, 0};
 80142f8:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80142fc:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8014300:	e9cd 3306 	strd	r3, r3, [sp, #24]
				nums[table[i]] = 1;
 8014304:	2601      	movs	r6, #1
 8014306:	1e43      	subs	r3, r0, #1
 8014308:	3007      	adds	r0, #7
 801430a:	e007      	b.n	801431c <mcpwm_get_hall_detect_result+0x7c>
			if (!nums[table[i]]) {
 801430c:	f851 2c1c 	ldr.w	r2, [r1, #-28]
 8014310:	b912      	cbnz	r2, 8014318 <mcpwm_get_hall_detect_result+0x78>
				nums[table[i]] = 1;
 8014312:	f841 6c1c 	str.w	r6, [r1, #-28]
				tot_nums++;
 8014316:	3401      	adds	r4, #1
	for (int i = 0;i < 8;i++) {
 8014318:	4298      	cmp	r0, r3
 801431a:	d00a      	beq.n	8014332 <mcpwm_get_hall_detect_result+0x92>
		if (table[i] == -1) {
 801431c:	f913 2f01 	ldrsb.w	r2, [r3, #1]!
			if (!nums[table[i]]) {
 8014320:	a908      	add	r1, sp, #32
 8014322:	eb01 0182 	add.w	r1, r1, r2, lsl #2
		if (table[i] == -1) {
 8014326:	3201      	adds	r2, #1
 8014328:	d1f0      	bne.n	801430c <mcpwm_get_hall_detect_result+0x6c>
	for (int i = 0;i < 8;i++) {
 801432a:	4298      	cmp	r0, r3
			invalid_samp_num++;
 801432c:	f105 0501 	add.w	r5, r5, #1
	for (int i = 0;i < 8;i++) {
 8014330:	d1f4      	bne.n	801431c <mcpwm_get_hall_detect_result+0x7c>
	if (invalid_samp_num == 2 && tot_nums == 6) {
 8014332:	2d02      	cmp	r5, #2
 8014334:	d105      	bne.n	8014342 <mcpwm_get_hall_detect_result+0xa2>
 8014336:	1fa0      	subs	r0, r4, #6
 8014338:	bf18      	it	ne
 801433a:	f04f 30ff 	movne.w	r0, #4294967295
}
 801433e:	b009      	add	sp, #36	; 0x24
 8014340:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
 8014342:	f04f 30ff 	mov.w	r0, #4294967295
 8014346:	e7fa      	b.n	801433e <mcpwm_get_hall_detect_result+0x9e>
		return -3;
 8014348:	f06f 0002 	mvn.w	r0, #2
}
 801434c:	4770      	bx	lr
 801434e:	bf00      	nop
 8014350:	20004d50 	.word	0x20004d50
 8014354:	20004e24 	.word	0x20004e24
	...

08014360 <mcpwm_read_hall_phase>:
	return READ_HALL1() | (READ_HALL2() << 1) | (READ_HALL3() << 2);
 8014360:	4b0b      	ldr	r3, [pc, #44]	; (8014390 <mcpwm_read_hall_phase+0x30>)
 8014362:	4a0c      	ldr	r2, [pc, #48]	; (8014394 <mcpwm_read_hall_phase+0x34>)
 8014364:	6919      	ldr	r1, [r3, #16]
 8014366:	691b      	ldr	r3, [r3, #16]
 8014368:	6912      	ldr	r2, [r2, #16]
	return hall_to_phase_table[read_hall() + (direction ? 8 : 0)];
 801436a:	480b      	ldr	r0, [pc, #44]	; (8014398 <mcpwm_read_hall_phase+0x38>)
	return READ_HALL1() | (READ_HALL2() << 1) | (READ_HALL3() << 2);
 801436c:	099b      	lsrs	r3, r3, #6
 801436e:	0a52      	lsrs	r2, r2, #9
 8014370:	f003 0302 	and.w	r3, r3, #2
 8014374:	f002 0204 	and.w	r2, r2, #4
	return hall_to_phase_table[read_hall() + (direction ? 8 : 0)];
 8014378:	6800      	ldr	r0, [r0, #0]
	return READ_HALL1() | (READ_HALL2() << 1) | (READ_HALL3() << 2);
 801437a:	f3c1 1180 	ubfx	r1, r1, #6, #1
 801437e:	4313      	orrs	r3, r2
 8014380:	430b      	orrs	r3, r1
	return hall_to_phase_table[read_hall() + (direction ? 8 : 0)];
 8014382:	b100      	cbz	r0, 8014386 <mcpwm_read_hall_phase+0x26>
 8014384:	3308      	adds	r3, #8
 8014386:	4a05      	ldr	r2, [pc, #20]	; (801439c <mcpwm_read_hall_phase+0x3c>)
}
 8014388:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 801438c:	4770      	bx	lr
 801438e:	bf00      	nop
 8014390:	40020400 	.word	0x40020400
 8014394:	40020800 	.word	0x40020800
 8014398:	20004e18 	.word	0x20004e18
 801439c:	20004f04 	.word	0x20004f04

080143a0 <set_duty_cycle_ll>:
static void set_duty_cycle_ll(float dutyCycle) {
 80143a0:	b538      	push	{r3, r4, r5, lr}
	if (dutyCycle >= conf->l_min_duty) {
 80143a2:	4d5f      	ldr	r5, [pc, #380]	; (8014520 <set_duty_cycle_ll+0x180>)
 80143a4:	682b      	ldr	r3, [r5, #0]
 80143a6:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80143aa:	eef4 7ac0 	vcmpe.f32	s15, s0
 80143ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80143b2:	d822      	bhi.n	80143fa <set_duty_cycle_ll+0x5a>
		direction = 1;
 80143b4:	4a5b      	ldr	r2, [pc, #364]	; (8014524 <set_duty_cycle_ll+0x184>)
 80143b6:	2101      	movs	r1, #1
 80143b8:	6011      	str	r1, [r2, #0]
	if (dutyCycle < conf->l_min_duty) {
 80143ba:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80143be:	eef4 7ac0 	vcmpe.f32	s15, s0
 80143c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80143c6:	dd2d      	ble.n	8014424 <set_duty_cycle_ll+0x84>
		if (control_mode == CONTROL_MODE_CURRENT ||
 80143c8:	4a57      	ldr	r2, [pc, #348]	; (8014528 <set_duty_cycle_ll+0x188>)
 80143ca:	7811      	ldrb	r1, [r2, #0]
 80143cc:	2902      	cmp	r1, #2
 80143ce:	d063      	beq.n	8014498 <set_duty_cycle_ll+0xf8>
				control_mode == CONTROL_MODE_CURRENT_BRAKE ||
 80143d0:	7811      	ldrb	r1, [r2, #0]
		if (control_mode == CONTROL_MODE_CURRENT ||
 80143d2:	2903      	cmp	r1, #3
 80143d4:	d060      	beq.n	8014498 <set_duty_cycle_ll+0xf8>
				control_mode == CONTROL_MODE_SPEED) {
 80143d6:	7812      	ldrb	r2, [r2, #0]
				control_mode == CONTROL_MODE_CURRENT_BRAKE ||
 80143d8:	2a01      	cmp	r2, #1
 80143da:	d05d      	beq.n	8014498 <set_duty_cycle_ll+0xf8>
		switch (state) {
 80143dc:	4c53      	ldr	r4, [pc, #332]	; (801452c <set_duty_cycle_ll+0x18c>)
			max_erpm_fbrake = conf->l_max_erpm_fbrake;
 80143de:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
		switch (state) {
 80143e2:	7822      	ldrb	r2, [r4, #0]
 80143e4:	b2d2      	uxtb	r2, r2
 80143e6:	2a01      	cmp	r2, #1
 80143e8:	d15d      	bne.n	80144a6 <set_duty_cycle_ll+0x106>
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 80143ea:	4a51      	ldr	r2, [pc, #324]	; (8014530 <set_duty_cycle_ll+0x190>)
	state = MC_STATE_OFF;
 80143ec:	2300      	movs	r3, #0
 80143ee:	7023      	strb	r3, [r4, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 80143f0:	6013      	str	r3, [r2, #0]
}
 80143f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	stop_pwm_hw();
 80143f6:	f7fe bd43 	b.w	8012e80 <stop_pwm_hw>
	} else if (dutyCycle <= -conf->l_min_duty) {
 80143fa:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80143fe:	eef1 7a67 	vneg.f32	s15, s15
 8014402:	eef4 7ac0 	vcmpe.f32	s15, s0
 8014406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801440a:	dbd6      	blt.n	80143ba <set_duty_cycle_ll+0x1a>
		direction = 0;
 801440c:	4a45      	ldr	r2, [pc, #276]	; (8014524 <set_duty_cycle_ll+0x184>)
 801440e:	2100      	movs	r1, #0
 8014410:	6011      	str	r1, [r2, #0]
	if (dutyCycle < conf->l_min_duty) {
 8014412:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
		dutyCycle = -dutyCycle;
 8014416:	eeb1 0a40 	vneg.f32	s0, s0
	if (dutyCycle < conf->l_min_duty) {
 801441a:	eef4 7ac0 	vcmpe.f32	s15, s0
 801441e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014422:	dcd1      	bgt.n	80143c8 <set_duty_cycle_ll+0x28>
	} else if (dutyCycle > conf->l_max_duty) {
 8014424:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 8014428:	4c40      	ldr	r4, [pc, #256]	; (801452c <set_duty_cycle_ll+0x18c>)
 801442a:	eef4 7ac0 	vcmpe.f32	s15, s0
 801442e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		dutyCycle = conf->l_max_duty;
 8014432:	bf48      	it	mi
 8014434:	ed93 0a16 	vldrmi	s0, [r3, #88]	; 0x58
	set_duty_cycle_hw(dutyCycle);
 8014438:	f7fe fa22 	bl	8012880 <set_duty_cycle_hw>
	if (conf->motor_type == MOTOR_TYPE_DC) {
 801443c:	682b      	ldr	r3, [r5, #0]
 801443e:	789d      	ldrb	r5, [r3, #2]
 8014440:	b2ed      	uxtb	r5, r5
 8014442:	2d01      	cmp	r5, #1
 8014444:	d03e      	beq.n	80144c4 <set_duty_cycle_ll+0x124>
		if (sensorless_now) {
 8014446:	4a3b      	ldr	r2, [pc, #236]	; (8014534 <set_duty_cycle_ll+0x194>)
 8014448:	7812      	ldrb	r2, [r2, #0]
 801444a:	b1a2      	cbz	r2, 8014476 <set_duty_cycle_ll+0xd6>
			if (state != MC_STATE_RUNNING) {
 801444c:	7822      	ldrb	r2, [r4, #0]
 801444e:	2a02      	cmp	r2, #2
 8014450:	d010      	beq.n	8014474 <set_duty_cycle_ll+0xd4>
				if (state == MC_STATE_OFF) {
 8014452:	7822      	ldrb	r2, [r4, #0]
 8014454:	2a00      	cmp	r2, #0
 8014456:	d139      	bne.n	80144cc <set_duty_cycle_ll+0x12c>
					state = MC_STATE_RUNNING;
 8014458:	2102      	movs	r1, #2
					if (fabsf(rpm_now) < conf->sl_min_erpm) {
 801445a:	4a37      	ldr	r2, [pc, #220]	; (8014538 <set_duty_cycle_ll+0x198>)
					state = MC_STATE_RUNNING;
 801445c:	7021      	strb	r1, [r4, #0]
					if (fabsf(rpm_now) < conf->sl_min_erpm) {
 801445e:	edd2 7a00 	vldr	s15, [r2]
 8014462:	ed93 7a1f 	vldr	s14, [r3, #124]	; 0x7c
 8014466:	eef0 7ae7 	vabs.f32	s15, s15
 801446a:	eef4 7ac7 	vcmpe.f32	s15, s14
 801446e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014472:	d40c      	bmi.n	801448e <set_duty_cycle_ll+0xee>
}
 8014474:	bd38      	pop	{r3, r4, r5, pc}
			if (state != MC_STATE_RUNNING) {
 8014476:	7823      	ldrb	r3, [r4, #0]
 8014478:	2b02      	cmp	r3, #2
 801447a:	d0fb      	beq.n	8014474 <set_duty_cycle_ll+0xd4>
				state = MC_STATE_RUNNING;
 801447c:	2302      	movs	r3, #2
 801447e:	7023      	strb	r3, [r4, #0]
				comm_step = mcpwm_read_hall_phase();
 8014480:	f7ff ff6e 	bl	8014360 <mcpwm_read_hall_phase>
 8014484:	4b2d      	ldr	r3, [pc, #180]	; (801453c <set_duty_cycle_ll+0x19c>)
 8014486:	6018      	str	r0, [r3, #0]
				set_next_comm_step(comm_step);
 8014488:	6818      	ldr	r0, [r3, #0]
 801448a:	f7fe fa89 	bl	80129a0 <set_next_comm_step>
				commutate(1);
 801448e:	2001      	movs	r0, #1
}
 8014490:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				commutate(1);
 8014494:	f7fe bd34 	b.w	8012f00 <commutate>
		switch (state) {
 8014498:	4c24      	ldr	r4, [pc, #144]	; (801452c <set_duty_cycle_ll+0x18c>)
			max_erpm_fbrake = conf->l_max_erpm_fbrake_cc;
 801449a:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
		switch (state) {
 801449e:	7822      	ldrb	r2, [r4, #0]
 80144a0:	b2d2      	uxtb	r2, r2
 80144a2:	2a01      	cmp	r2, #1
 80144a4:	d0a1      	beq.n	80143ea <set_duty_cycle_ll+0x4a>
 80144a6:	2a02      	cmp	r2, #2
 80144a8:	d1e4      	bne.n	8014474 <set_duty_cycle_ll+0xd4>
			if (fabsf(rpm_now) > max_erpm_fbrake) {
 80144aa:	4a23      	ldr	r2, [pc, #140]	; (8014538 <set_duty_cycle_ll+0x198>)
 80144ac:	ed92 7a00 	vldr	s14, [r2]
 80144b0:	eeb0 7ac7 	vabs.f32	s14, s14
 80144b4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80144b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144bc:	dd26      	ble.n	801450c <set_duty_cycle_ll+0x16c>
				dutyCycle = conf->l_min_duty;
 80144be:	ed93 0a15 	vldr	s0, [r3, #84]	; 0x54
			break;
 80144c2:	e7b9      	b.n	8014438 <set_duty_cycle_ll+0x98>
		state = MC_STATE_RUNNING;
 80144c4:	2202      	movs	r2, #2
		set_next_comm_step(comm_step);
 80144c6:	4b1d      	ldr	r3, [pc, #116]	; (801453c <set_duty_cycle_ll+0x19c>)
		state = MC_STATE_RUNNING;
 80144c8:	7022      	strb	r2, [r4, #0]
 80144ca:	e7dd      	b.n	8014488 <set_duty_cycle_ll+0xe8>
				} else if (state == MC_STATE_FULL_BRAKE) {
 80144cc:	7822      	ldrb	r2, [r4, #0]
 80144ce:	2a03      	cmp	r2, #3
 80144d0:	d1d0      	bne.n	8014474 <set_duty_cycle_ll+0xd4>
					if (fabsf(rpm_now) < conf->sl_min_erpm && mcpwm_get_tot_current_filtered() < conf->sl_max_fullbreak_current_dir_change) {
 80144d2:	4a19      	ldr	r2, [pc, #100]	; (8014538 <set_duty_cycle_ll+0x198>)
 80144d4:	edd2 7a00 	vldr	s15, [r2]
 80144d8:	ed93 7a1f 	vldr	s14, [r3, #124]	; 0x7c
 80144dc:	eef0 7ae7 	vabs.f32	s15, s15
 80144e0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80144e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144e8:	d5c4      	bpl.n	8014474 <set_duty_cycle_ll+0xd4>
	return last_current_sample_filtered;
 80144ea:	4a15      	ldr	r2, [pc, #84]	; (8014540 <set_duty_cycle_ll+0x1a0>)
 80144ec:	edd2 7a00 	vldr	s15, [r2]
					if (fabsf(rpm_now) < conf->sl_min_erpm && mcpwm_get_tot_current_filtered() < conf->sl_max_fullbreak_current_dir_change) {
 80144f0:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 80144f4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80144f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144fc:	ddba      	ble.n	8014474 <set_duty_cycle_ll+0xd4>
						state = MC_STATE_RUNNING;
 80144fe:	2302      	movs	r3, #2
 8014500:	7023      	strb	r3, [r4, #0]
						commutate(1);
 8014502:	2001      	movs	r0, #1
}
 8014504:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
						commutate(1);
 8014508:	f7fe bcfa 	b.w	8012f00 <commutate>
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 801450c:	4b08      	ldr	r3, [pc, #32]	; (8014530 <set_duty_cycle_ll+0x190>)
	state = MC_STATE_FULL_BRAKE;
 801450e:	2103      	movs	r1, #3
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014510:	2200      	movs	r2, #0
	state = MC_STATE_FULL_BRAKE;
 8014512:	7021      	strb	r1, [r4, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014514:	601a      	str	r2, [r3, #0]
}
 8014516:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	full_brake_hw();
 801451a:	f7fe bc71 	b.w	8012e00 <full_brake_hw>
 801451e:	bf00      	nop
 8014520:	20004d50 	.word	0x20004d50
 8014524:	20004e18 	.word	0x20004e18
 8014528:	20004d54 	.word	0x20004d54
 801452c:	200059f4 	.word	0x200059f4
 8014530:	20004f50 	.word	0x20004f50
 8014534:	200059e8 	.word	0x200059e8
 8014538:	20005444 	.word	0x20005444
 801453c:	20004d4c 	.word	0x20004d4c
 8014540:	20005364 	.word	0x20005364
	...

08014550 <set_duty_cycle_hl>:
static void set_duty_cycle_hl(float dutyCycle) {
 8014550:	b510      	push	{r4, lr}
	utils_truncate_number(&dutyCycle, -conf->l_max_duty, conf->l_max_duty);
 8014552:	4c3b      	ldr	r4, [pc, #236]	; (8014640 <set_duty_cycle_hl+0xf0>)
 8014554:	6823      	ldr	r3, [r4, #0]
static void set_duty_cycle_hl(float dutyCycle) {
 8014556:	b082      	sub	sp, #8
	utils_truncate_number(&dutyCycle, -conf->l_max_duty, conf->l_max_duty);
 8014558:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 801455c:	edd3 0a16 	vldr	s1, [r3, #88]	; 0x58
static void set_duty_cycle_hl(float dutyCycle) {
 8014560:	a802      	add	r0, sp, #8
 8014562:	ed20 0a01 	vstmdb	r0!, {s0}
	utils_truncate_number(&dutyCycle, -conf->l_max_duty, conf->l_max_duty);
 8014566:	eeb1 0a67 	vneg.f32	s0, s15
 801456a:	f001 fa89 	bl	8015a80 <utils_truncate_number>
	if (state == MC_STATE_DETECTING) {
 801456e:	4b35      	ldr	r3, [pc, #212]	; (8014644 <set_duty_cycle_hl+0xf4>)
 8014570:	781a      	ldrb	r2, [r3, #0]
 8014572:	2a01      	cmp	r2, #1
 8014574:	d05c      	beq.n	8014630 <set_duty_cycle_hl+0xe0>
	dutycycle_set = dutyCycle;
 8014576:	4a34      	ldr	r2, [pc, #208]	; (8014648 <set_duty_cycle_hl+0xf8>)
 8014578:	eddd 7a01 	vldr	s15, [sp, #4]
 801457c:	edc2 7a00 	vstr	s15, [r2]
	if (state != MC_STATE_RUNNING) {
 8014580:	781a      	ldrb	r2, [r3, #0]
 8014582:	2a02      	cmp	r2, #2
 8014584:	d02a      	beq.n	80145dc <set_duty_cycle_hl+0x8c>
		if (fabsf(dutyCycle) >= conf->l_min_duty) {
 8014586:	6822      	ldr	r2, [r4, #0]
 8014588:	ed92 7a15 	vldr	s14, [r2, #84]	; 0x54
 801458c:	eef0 6ae7 	vabs.f32	s13, s15
 8014590:	eef4 6ac7 	vcmpe.f32	s13, s14
 8014594:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014598:	db22      	blt.n	80145e0 <set_duty_cycle_hl+0x90>
			if (fabsf(dutycycle_now) < conf->l_min_duty) {
 801459a:	4b2c      	ldr	r3, [pc, #176]	; (801464c <set_duty_cycle_hl+0xfc>)
 801459c:	ed93 7a00 	vldr	s14, [r3]
 80145a0:	edd2 6a15 	vldr	s13, [r2, #84]	; 0x54
 80145a4:	eeb0 7ac7 	vabs.f32	s14, s14
 80145a8:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80145ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80145b0:	d510      	bpl.n	80145d4 <set_duty_cycle_hl+0x84>
				dutycycle_now = SIGN(dutyCycle) * conf->l_min_duty;
 80145b2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80145b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80145ba:	edd2 7a15 	vldr	s15, [r2, #84]	; 0x54
 80145be:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80145c2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80145c6:	bf58      	it	pl
 80145c8:	eeb0 7a66 	vmovpl.f32	s14, s13
 80145cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80145d0:	edc3 7a00 	vstr	s15, [r3]
			set_duty_cycle_ll(dutycycle_now);
 80145d4:	ed93 0a00 	vldr	s0, [r3]
 80145d8:	f7ff fee2 	bl	80143a0 <set_duty_cycle_ll>
}
 80145dc:	b002      	add	sp, #8
 80145de:	bd10      	pop	{r4, pc}
			if (conf->motor_type == MOTOR_TYPE_DC) {
 80145e0:	7891      	ldrb	r1, [r2, #2]
 80145e2:	2901      	cmp	r1, #1
 80145e4:	d00f      	beq.n	8014606 <set_duty_cycle_hl+0xb6>
				if (fabsf(rpm_now) > conf->l_max_erpm_fbrake) {
 80145e6:	491a      	ldr	r1, [pc, #104]	; (8014650 <set_duty_cycle_hl+0x100>)
 80145e8:	edd1 7a00 	vldr	s15, [r1]
 80145ec:	ed92 7a09 	vldr	s14, [r2, #36]	; 0x24
 80145f0:	eef0 7ae7 	vabs.f32	s15, s15
 80145f4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80145f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80145fc:	dd0f      	ble.n	801461e <set_duty_cycle_hl+0xce>
					state = MC_STATE_RUNNING;
 80145fe:	2202      	movs	r2, #2
 8014600:	701a      	strb	r2, [r3, #0]
}
 8014602:	b002      	add	sp, #8
 8014604:	bd10      	pop	{r4, pc}
				if (fabsf(dutycycle_now) > 0.1) {
 8014606:	4a11      	ldr	r2, [pc, #68]	; (801464c <set_duty_cycle_hl+0xfc>)
 8014608:	ed9f 7a12 	vldr	s14, [pc, #72]	; 8014654 <set_duty_cycle_hl+0x104>
 801460c:	edd2 7a00 	vldr	s15, [r2]
 8014610:	eef0 7ae7 	vabs.f32	s15, s15
 8014614:	eef4 7ac7 	vcmpe.f32	s15, s14
 8014618:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801461c:	dcef      	bgt.n	80145fe <set_duty_cycle_hl+0xae>
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 801461e:	4a0e      	ldr	r2, [pc, #56]	; (8014658 <set_duty_cycle_hl+0x108>)
	state = MC_STATE_FULL_BRAKE;
 8014620:	2003      	movs	r0, #3
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014622:	2100      	movs	r1, #0
	state = MC_STATE_FULL_BRAKE;
 8014624:	7018      	strb	r0, [r3, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014626:	6011      	str	r1, [r2, #0]
	full_brake_hw();
 8014628:	f7fe fbea 	bl	8012e00 <full_brake_hw>
}
 801462c:	b002      	add	sp, #8
 801462e:	bd10      	pop	{r4, pc}
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014630:	4909      	ldr	r1, [pc, #36]	; (8014658 <set_duty_cycle_hl+0x108>)
	state = MC_STATE_OFF;
 8014632:	2200      	movs	r2, #0
 8014634:	701a      	strb	r2, [r3, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014636:	600a      	str	r2, [r1, #0]
	stop_pwm_hw();
 8014638:	f7fe fc22 	bl	8012e80 <stop_pwm_hw>
}
 801463c:	b002      	add	sp, #8
 801463e:	bd10      	pop	{r4, pc}
 8014640:	20004d50 	.word	0x20004d50
 8014644:	200059f4 	.word	0x200059f4
 8014648:	20004e20 	.word	0x20004e20
 801464c:	20004e1c 	.word	0x20004e1c
 8014650:	20005444 	.word	0x20005444
 8014654:	3dcccccd 	.word	0x3dcccccd
 8014658:	20004f50 	.word	0x20004f50
 801465c:	00000000 	.word	0x00000000

08014660 <mcpwm_set_duty>:
	control_mode = CONTROL_MODE_DUTY;
 8014660:	4b02      	ldr	r3, [pc, #8]	; (801466c <mcpwm_set_duty+0xc>)
 8014662:	2200      	movs	r2, #0
 8014664:	701a      	strb	r2, [r3, #0]
	set_duty_cycle_hl(dutyCycle);
 8014666:	f7ff bf73 	b.w	8014550 <set_duty_cycle_hl>
 801466a:	bf00      	nop
 801466c:	20004d54 	.word	0x20004d54

08014670 <rpm_thread>:
static THD_FUNCTION(rpm_thread, arg) {
 8014670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014674:	4bd7      	ldr	r3, [pc, #860]	; (80149d4 <rpm_thread+0x364>)
		if (rpm_thd_stop) {
 8014676:	f8df 83b0 	ldr.w	r8, [pc, #944]	; 8014a28 <rpm_thread+0x3b8>
 801467a:	699a      	ldr	r2, [r3, #24]
 801467c:	f898 3000 	ldrb.w	r3, [r8]
 8014680:	49d5      	ldr	r1, [pc, #852]	; (80149d8 <rpm_thread+0x368>)
static THD_FUNCTION(rpm_thread, arg) {
 8014682:	ed2d 8b0c 	vpush	{d8-d13}
 8014686:	6191      	str	r1, [r2, #24]
 8014688:	b083      	sub	sp, #12
		if (rpm_thd_stop) {
 801468a:	2b00      	cmp	r3, #0
 801468c:	f040 80f7 	bne.w	801487e <rpm_thread+0x20e>
 8014690:	f8df a398 	ldr.w	sl, [pc, #920]	; 8014a2c <rpm_thread+0x3bc>
 8014694:	4cd1      	ldr	r4, [pc, #836]	; (80149dc <rpm_thread+0x36c>)
 8014696:	4fd2      	ldr	r7, [pc, #840]	; (80149e0 <rpm_thread+0x370>)
 8014698:	4dd2      	ldr	r5, [pc, #840]	; (80149e4 <rpm_thread+0x374>)
 801469a:	4ed3      	ldr	r6, [pc, #844]	; (80149e8 <rpm_thread+0x378>)
 801469c:	f8df 9378 	ldr.w	r9, [pc, #888]	; 8014a18 <rpm_thread+0x3a8>
 80146a0:	f8df b38c 	ldr.w	fp, [pc, #908]	; 8014a30 <rpm_thread+0x3c0>
			float rpm_tmp = (MCPWM_RPM_TIMER_FREQ * 60.0) / ((float) TIM2 ->CNT * 6.0);
 80146a4:	ed9f aad1 	vldr	s20, [pc, #836]	; 80149ec <rpm_thread+0x37c>
			rpm_now = (comms * MCPWM_RPM_TIMER_FREQ * 60.0) / (time_at_comm * 6.0);
 80146a8:	ed9f bad1 	vldr	s22, [pc, #836]	; 80149f0 <rpm_thread+0x380>
 80146ac:	ed9f 9ad1 	vldr	s18, [pc, #836]	; 80149f4 <rpm_thread+0x384>
		UTILS_LP_FAST(rpm_filtered, rpm_now, 0.1);
 80146b0:	eddf 9ad1 	vldr	s19, [pc, #836]	; 80149f8 <rpm_thread+0x388>
		rpm_dep.cycle_int_limit_running = utils_map(rpm_abs, 0,
 80146b4:	eddf 8ad1 	vldr	s17, [pc, #836]	; 80149fc <rpm_thread+0x38c>
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80146b8:	eddf aad1 	vldr	s21, [pc, #836]	; 8014a00 <rpm_thread+0x390>
 80146bc:	e00b      	b.n	80146d6 <rpm_thread+0x66>
		i_term = 0.0;
 80146be:	edc9 8a00 	vstr	s17, [r9]
		prev_error = 0.0;
 80146c2:	edcb 8a00 	vstr	s17, [fp]
		chThdSleepMilliseconds(1);
 80146c6:	200a      	movs	r0, #10
 80146c8:	f7f9 f98a 	bl	800d9e0 <chThdSleep>
		if (rpm_thd_stop) {
 80146cc:	f898 2000 	ldrb.w	r2, [r8]
 80146d0:	2a00      	cmp	r2, #0
 80146d2:	f040 80d4 	bne.w	801487e <rpm_thread+0x20e>
		if (rpm_dep.comms != 0) {
 80146d6:	f8da 2014 	ldr.w	r2, [sl, #20]
 80146da:	2a00      	cmp	r2, #0
 80146dc:	f040 80d7 	bne.w	801488e <rpm_thread+0x21e>
			float rpm_tmp = (MCPWM_RPM_TIMER_FREQ * 60.0) / ((float) TIM2 ->CNT * 6.0);
 80146e0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80146e4:	edd2 7a09 	vldr	s15, [r2, #36]	; 0x24
			if (fabsf(rpm_tmp) < fabsf(rpm_now)) {
 80146e8:	ed94 7a00 	vldr	s14, [r4]
			float rpm_tmp = (MCPWM_RPM_TIMER_FREQ * 60.0) / ((float) TIM2 ->CNT * 6.0);
 80146ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80146f0:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 80146f4:	ee67 7aa6 	vmul.f32	s15, s15, s13
			if (fabsf(rpm_tmp) < fabsf(rpm_now)) {
 80146f8:	eeb0 7ac7 	vabs.f32	s14, s14
			float rpm_tmp = (MCPWM_RPM_TIMER_FREQ * 60.0) / ((float) TIM2 ->CNT * 6.0);
 80146fc:	eeca 6a27 	vdiv.f32	s13, s20, s15
			if (fabsf(rpm_tmp) < fabsf(rpm_now)) {
 8014700:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8014704:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				rpm_now = rpm_tmp;
 8014708:	bfc8      	it	gt
 801470a:	edc4 6a00 	vstrgt	s13, [r4]
		UTILS_LP_FAST(rpm_filtered, rpm_now, 0.1);
 801470e:	ed94 7a00 	vldr	s14, [r4]
 8014712:	edd7 7a00 	vldr	s15, [r7]
		rpm_dep.cycle_int_limit = conf->sl_cycle_int_limit;
 8014716:	682a      	ldr	r2, [r5, #0]
		UTILS_LP_FAST(rpm_filtered, rpm_now, 0.1);
 8014718:	ee37 7ac7 	vsub.f32	s14, s15, s14
		rpm_dep.cycle_int_limit_running = utils_map(rpm_abs, 0,
 801471c:	eef0 0a68 	vmov.f32	s1, s17
		UTILS_LP_FAST(rpm_filtered, rpm_now, 0.1);
 8014720:	eee7 7a69 	vfms.f32	s15, s14, s19
		rpm_now = rpm_filtered;
 8014724:	edc4 7a00 	vstr	s15, [r4]
		const float rpm_abs = fabsf(rpm_now);
 8014728:	ed94 8a00 	vldr	s16, [r4]
		rpm_dep.cycle_int_limit = conf->sl_cycle_int_limit;
 801472c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8014730:	f8ca 1000 	str.w	r1, [sl]
		rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 8014734:	edda 6a00 	vldr	s13, [sl]
 8014738:	8a33      	ldrh	r3, [r6, #16]
		UTILS_LP_FAST(rpm_filtered, rpm_now, 0.1);
 801473a:	edc7 7a00 	vstr	s15, [r7]
				conf->sl_bemf_coupling_k / (rpm_abs > conf->sl_min_erpm ? rpm_abs : conf->sl_min_erpm);
 801473e:	ed92 6a25 	vldr	s12, [r2, #148]	; 0x94
 8014742:	ed92 7a1f 	vldr	s14, [r2, #124]	; 0x7c
		rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 8014746:	ee07 3a90 	vmov	s15, r3
		const float rpm_abs = fabsf(rpm_now);
 801474a:	eeb0 8ac8 	vabs.f32	s16, s16
				conf->sl_bemf_coupling_k / (rpm_abs > conf->sl_min_erpm ? rpm_abs : conf->sl_min_erpm);
 801474e:	eeb4 7ac8 	vcmpe.f32	s14, s16
		rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 8014752:	eef8 7a67 	vcvt.f32.u32	s15, s15
				conf->sl_bemf_coupling_k / (rpm_abs > conf->sl_min_erpm ? rpm_abs : conf->sl_min_erpm);
 8014756:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 801475a:	ee67 7a86 	vmul.f32	s15, s15, s12
				conf->sl_bemf_coupling_k / (rpm_abs > conf->sl_min_erpm ? rpm_abs : conf->sl_min_erpm);
 801475e:	bf54      	ite	pl
 8014760:	ed92 6a1f 	vldrpl	s12, [r2, #124]	; 0x7c
 8014764:	eeb0 6a48 	vmovmi.f32	s12, s16
 8014768:	ee87 7a86 	vdiv.f32	s14, s15, s12
		rpm_dep.cycle_int_limit_running = utils_map(rpm_abs, 0,
 801476c:	eeb0 0a48 	vmov.f32	s0, s16
		rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 8014770:	ee77 7a26 	vadd.f32	s15, s14, s13
 8014774:	edca 7a01 	vstr	s15, [sl, #4]
		rpm_dep.cycle_int_limit_running = utils_map(rpm_abs, 0,
 8014778:	ed92 1a24 	vldr	s2, [r2, #144]	; 0x90
 801477c:	edda 1a01 	vldr	s3, [sl, #4]
				rpm_dep.cycle_int_limit_running * conf->sl_phase_advance_at_br);
 8014780:	ed9a 2a01 	vldr	s4, [sl, #4]
 8014784:	edd2 7a23 	vldr	s15, [r2, #140]	; 0x8c
		rpm_dep.cycle_int_limit_running = utils_map(rpm_abs, 0,
 8014788:	ee22 2a27 	vmul.f32	s4, s4, s15
 801478c:	f001 f9b8 	bl	8015b00 <utils_map>
 8014790:	ed8a 0a01 	vstr	s0, [sl, #4]
		rpm_dep.cycle_int_limit_max = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 8014794:	ed9a 6a00 	vldr	s12, [sl]
 8014798:	8a33      	ldrh	r3, [r6, #16]
				conf->sl_bemf_coupling_k / conf->sl_min_erpm_cycle_int_limit;
 801479a:	682a      	ldr	r2, [r5, #0]
		rpm_dep.cycle_int_limit_max = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 801479c:	ee07 3a90 	vmov	s15, r3
				conf->sl_bemf_coupling_k / conf->sl_min_erpm_cycle_int_limit;
 80147a0:	ed92 7a25 	vldr	s14, [r2, #148]	; 0x94
 80147a4:	edd2 5a20 	vldr	s11, [r2, #128]	; 0x80
	if (control_mode != CONTROL_MODE_SPEED) {
 80147a8:	4b96      	ldr	r3, [pc, #600]	; (8014a04 <rpm_thread+0x394>)
		rpm_dep.cycle_int_limit_max = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 80147aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
		if (rpm_dep.cycle_int_limit_running < 1.0) {
 80147ae:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
		rpm_dep.cycle_int_limit_max = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 80147b2:	ee67 7a87 	vmul.f32	s15, s15, s14
				conf->sl_bemf_coupling_k / conf->sl_min_erpm_cycle_int_limit;
 80147b6:	ee87 7aa5 	vdiv.f32	s14, s15, s11
		rpm_dep.cycle_int_limit_max = rpm_dep.cycle_int_limit + (float)ADC_Value[ADC_IND_VIN_SENS] *
 80147ba:	ee77 7a06 	vadd.f32	s15, s14, s12
 80147be:	edca 7a02 	vstr	s15, [sl, #8]
		if (rpm_dep.cycle_int_limit_running < 1.0) {
 80147c2:	edda 7a01 	vldr	s15, [sl, #4]
 80147c6:	eef4 7ae6 	vcmpe.f32	s15, s13
 80147ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			rpm_dep.cycle_int_limit_running = 1.0;
 80147ce:	bf48      	it	mi
 80147d0:	edca 6a01 	vstrmi	s13, [sl, #4]
		if (rpm_dep.cycle_int_limit_running > rpm_dep.cycle_int_limit_max) {
 80147d4:	ed9a 7a01 	vldr	s14, [sl, #4]
 80147d8:	edda 7a02 	vldr	s15, [sl, #8]
 80147dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
		rpm_dep.comm_time_sum = conf->m_bldc_f_sw_max / ((rpm_abs / 60.0) * 6.0);
 80147e0:	ee88 7a09 	vdiv.f32	s14, s16, s18
		if (rpm_dep.cycle_int_limit_running > rpm_dep.cycle_int_limit_max) {
 80147e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			rpm_dep.cycle_int_limit_running = rpm_dep.cycle_int_limit_max;
 80147e8:	bfc4      	itt	gt
 80147ea:	f8da 1008 	ldrgt.w	r1, [sl, #8]
 80147ee:	f8ca 1004 	strgt.w	r1, [sl, #4]
		rpm_dep.comm_time_sum = conf->m_bldc_f_sw_max / ((rpm_abs / 60.0) * 6.0);
 80147f2:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 80147f6:	ed92 6a5a 	vldr	s12, [r2, #360]	; 0x168
 80147fa:	ee27 7a26 	vmul.f32	s14, s14, s13
 80147fe:	eec6 7a07 	vdiv.f32	s15, s12, s14
 8014802:	edca 7a03 	vstr	s15, [sl, #12]
		rpm_dep.comm_time_sum_min_rpm = conf->m_bldc_f_sw_max / ((conf->sl_min_erpm / 60.0) * 6.0);
 8014806:	ed92 6a5a 	vldr	s12, [r2, #360]	; 0x168
 801480a:	ed92 7a1f 	vldr	s14, [r2, #124]	; 0x7c
 801480e:	eec7 7a09 	vdiv.f32	s15, s14, s18
 8014812:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8014816:	ee86 7a27 	vdiv.f32	s14, s12, s15
 801481a:	ed8a 7a04 	vstr	s14, [sl, #16]
	if (control_mode != CONTROL_MODE_SPEED) {
 801481e:	7819      	ldrb	r1, [r3, #0]
 8014820:	2901      	cmp	r1, #1
 8014822:	f47f af4c 	bne.w	80146be <rpm_thread+0x4e>
	return direction ? rpm_now : -rpm_now;
 8014826:	4978      	ldr	r1, [pc, #480]	; (8014a08 <rpm_thread+0x398>)
 8014828:	6809      	ldr	r1, [r1, #0]
 801482a:	edd4 ba00 	vldr	s23, [r4]
 801482e:	b909      	cbnz	r1, 8014834 <rpm_thread+0x1c4>
 8014830:	eef1 ba6b 	vneg.f32	s23, s23
	float error = speed_pid_set_rpm - rpm;
 8014834:	4975      	ldr	r1, [pc, #468]	; (8014a0c <rpm_thread+0x39c>)
 8014836:	ed91 8a00 	vldr	s16, [r1]
	if (fabsf(speed_pid_set_rpm) < conf->s_pid_min_erpm) {
 801483a:	edd1 7a00 	vldr	s15, [r1]
 801483e:	ed92 7a49 	vldr	s14, [r2, #292]	; 0x124
 8014842:	eef0 7ae7 	vabs.f32	s15, s15
 8014846:	eef4 7ac7 	vcmpe.f32	s15, s14
 801484a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	float error = speed_pid_set_rpm - rpm;
 801484e:	ee38 8a6b 	vsub.f32	s16, s16, s23
	if (fabsf(speed_pid_set_rpm) < conf->s_pid_min_erpm) {
 8014852:	d53a      	bpl.n	80148ca <rpm_thread+0x25a>
		i_term = dutycycle_now;
 8014854:	4a6e      	ldr	r2, [pc, #440]	; (8014a10 <rpm_thread+0x3a0>)
	control_mode = CONTROL_MODE_DUTY;
 8014856:	4b6b      	ldr	r3, [pc, #428]	; (8014a04 <rpm_thread+0x394>)
		i_term = dutycycle_now;
 8014858:	6811      	ldr	r1, [r2, #0]
 801485a:	f8c9 1000 	str.w	r1, [r9]
	control_mode = CONTROL_MODE_DUTY;
 801485e:	2200      	movs	r2, #0
	set_duty_cycle_hl(dutyCycle);
 8014860:	eeb0 0a68 	vmov.f32	s0, s17
	control_mode = CONTROL_MODE_DUTY;
 8014864:	701a      	strb	r2, [r3, #0]
		prev_error = error;
 8014866:	ed8b 8a00 	vstr	s16, [fp]
	set_duty_cycle_hl(dutyCycle);
 801486a:	f7ff fe71 	bl	8014550 <set_duty_cycle_hl>
		chThdSleepMilliseconds(1);
 801486e:	200a      	movs	r0, #10
 8014870:	f7f9 f8b6 	bl	800d9e0 <chThdSleep>
		if (rpm_thd_stop) {
 8014874:	f898 2000 	ldrb.w	r2, [r8]
 8014878:	2a00      	cmp	r2, #0
 801487a:	f43f af2c 	beq.w	80146d6 <rpm_thread+0x66>
			rpm_thd_stop = false;
 801487e:	2300      	movs	r3, #0
 8014880:	f888 3000 	strb.w	r3, [r8]
}
 8014884:	b003      	add	sp, #12
 8014886:	ecbd 8b0c 	vpop	{d8-d13}
 801488a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			utils_sys_lock_cnt();
 801488e:	f001 fc07 	bl	80160a0 <utils_sys_lock_cnt>
			const float comms = (float)rpm_dep.comms;
 8014892:	ed9a 8a05 	vldr	s16, [sl, #20]
			const float time_at_comm = (float)rpm_dep.time_at_comm;
 8014896:	edda ba06 	vldr	s23, [sl, #24]
			rpm_dep.comms = 0;
 801489a:	2200      	movs	r2, #0
 801489c:	f8ca 2014 	str.w	r2, [sl, #20]
			rpm_dep.time_at_comm = 0;
 80148a0:	f8ca 2018 	str.w	r2, [sl, #24]
			utils_sys_unlock_cnt();
 80148a4:	f001 fc0c 	bl	80160c0 <utils_sys_unlock_cnt>
			const float comms = (float)rpm_dep.comms;
 80148a8:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
			const float time_at_comm = (float)rpm_dep.time_at_comm;
 80148ac:	eef8 ba6b 	vcvt.f32.u32	s23, s23
			rpm_now = (comms * MCPWM_RPM_TIMER_FREQ * 60.0) / (time_at_comm * 6.0);
 80148b0:	ee28 8a0b 	vmul.f32	s16, s16, s22
 80148b4:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 80148b8:	ee28 8a09 	vmul.f32	s16, s16, s18
 80148bc:	ee6b baa7 	vmul.f32	s23, s23, s15
 80148c0:	eec8 7a2b 	vdiv.f32	s15, s16, s23
 80148c4:	edc4 7a00 	vstr	s15, [r4]
 80148c8:	e721      	b.n	801470e <rpm_thread+0x9e>
	p_term = error * conf->s_pid_kp * (1.0 / 20.0);
 80148ca:	ed92 da46 	vldr	s26, [r2, #280]	; 0x118
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148ce:	edd2 7a47 	vldr	s15, [r2, #284]	; 0x11c
	d_term = (error - prev_error) * (conf->s_pid_kd / MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148d2:	ed92 6a48 	vldr	s12, [r2, #288]	; 0x120
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148d6:	eddf ca4f 	vldr	s25, [pc, #316]	; 8014a14 <rpm_thread+0x3a4>
 80148da:	ed99 7a00 	vldr	s14, [r9]
	d_term = (error - prev_error) * (conf->s_pid_kd / MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148de:	ed9b ca00 	vldr	s24, [fp]
	utils_truncate_number(&i_term, -1.0, 1.0);
 80148e2:	484d      	ldr	r0, [pc, #308]	; (8014a18 <rpm_thread+0x3a8>)
	d_term = (error - prev_error) * (conf->s_pid_kd / MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148e4:	eec6 6a2a 	vdiv.f32	s13, s12, s21
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148e8:	ee67 7aaa 	vmul.f32	s15, s15, s21
	d_term = (error - prev_error) * (conf->s_pid_kd / MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148ec:	ee38 ca4c 	vsub.f32	s24, s16, s24
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148f0:	ee67 7a88 	vmul.f32	s15, s15, s16
	utils_truncate_number(&i_term, -1.0, 1.0);
 80148f4:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 80148f8:	eea7 7aac 	vfma.f32	s14, s15, s25
	utils_truncate_number(&i_term, -1.0, 1.0);
 80148fc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	d_term = (error - prev_error) * (conf->s_pid_kd / MCPWM_PID_TIME_K) * (1.0 / 20.0);
 8014900:	ee2c ca26 	vmul.f32	s24, s24, s13
	i_term += error * (conf->s_pid_ki * MCPWM_PID_TIME_K) * (1.0 / 20.0);
 8014904:	ed89 7a00 	vstr	s14, [r9]
	utils_truncate_number(&i_term, -1.0, 1.0);
 8014908:	f001 f8ba 	bl	8015a80 <utils_truncate_number>
	UTILS_LP_FAST(d_filtered, d_term, 0.1);
 801490c:	4a43      	ldr	r2, [pc, #268]	; (8014a1c <rpm_thread+0x3ac>)
	float output = p_term + i_term + d_term;
 801490e:	ed99 7a00 	vldr	s14, [r9]
	UTILS_LP_FAST(d_filtered, d_term, 0.1);
 8014912:	edd2 7a00 	vldr	s15, [r2]
	prev_error = error;
 8014916:	ed8b 8a00 	vstr	s16, [fp]
	UTILS_LP_FAST(d_filtered, d_term, 0.1);
 801491a:	eef0 6a67 	vmov.f32	s13, s15
 801491e:	eeec 6a6c 	vfms.f32	s13, s24, s25
	float output = p_term + i_term + d_term;
 8014922:	a802      	add	r0, sp, #8
	p_term = error * conf->s_pid_kp * (1.0 / 20.0);
 8014924:	ee28 da0d 	vmul.f32	s26, s16, s26
	UTILS_LP_FAST(d_filtered, d_term, 0.1);
 8014928:	eee6 7ae9 	vfms.f32	s15, s13, s19
	float output = p_term + i_term + d_term;
 801492c:	eead 7a2c 	vfma.f32	s14, s26, s25
	utils_truncate_number(&output, -1.0, 1.0);
 8014930:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
	float output = p_term + i_term + d_term;
 8014934:	ee37 7a27 	vadd.f32	s14, s14, s15
	utils_truncate_number(&output, -1.0, 1.0);
 8014938:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	float output = p_term + i_term + d_term;
 801493c:	ed20 7a01 	vstmdb	r0!, {s14}
	UTILS_LP_FAST(d_filtered, d_term, 0.1);
 8014940:	edc2 7a00 	vstr	s15, [r2]
	utils_truncate_number(&output, -1.0, 1.0);
 8014944:	f001 f89c 	bl	8015a80 <utils_truncate_number>
	if (!conf->s_pid_allow_braking) {
 8014948:	682a      	ldr	r2, [r5, #0]
 801494a:	ed9d 7a01 	vldr	s14, [sp, #4]
 801494e:	f892 1128 	ldrb.w	r1, [r2, #296]	; 0x128
 8014952:	b971      	cbnz	r1, 8014972 <rpm_thread+0x302>
		if (rpm > 0.0 && output < 0.0) {
 8014954:	eef5 bac0 	vcmpe.f32	s23, #0.0
 8014958:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801495c:	dd04      	ble.n	8014968 <rpm_thread+0x2f8>
 801495e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8014962:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014966:	d426      	bmi.n	80149b6 <rpm_thread+0x346>
		if (rpm < 0.0 && output > 0.0) {
 8014968:	eef5 bac0 	vcmpe.f32	s23, #0.0
 801496c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014970:	d41c      	bmi.n	80149ac <rpm_thread+0x33c>
	current_set = output * conf->lo_current_max;
 8014972:	edd2 7a19 	vldr	s15, [r2, #100]	; 0x64
 8014976:	482a      	ldr	r0, [pc, #168]	; (8014a20 <rpm_thread+0x3b0>)
	if (state != MC_STATE_RUNNING) {
 8014978:	492a      	ldr	r1, [pc, #168]	; (8014a24 <rpm_thread+0x3b4>)
	current_set = output * conf->lo_current_max;
 801497a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801497e:	edc0 7a00 	vstr	s15, [r0]
	if (state != MC_STATE_RUNNING) {
 8014982:	7809      	ldrb	r1, [r1, #0]
 8014984:	2902      	cmp	r1, #2
 8014986:	f43f ae9e 	beq.w	80146c6 <rpm_thread+0x56>
		set_duty_cycle_hl(SIGN(output) * conf->l_min_duty);
 801498a:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 801498e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014992:	d408      	bmi.n	80149a6 <rpm_thread+0x336>
 8014994:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014998:	ed92 0a15 	vldr	s0, [r2, #84]	; 0x54
 801499c:	ee20 0a27 	vmul.f32	s0, s0, s15
 80149a0:	f7ff fdd6 	bl	8014550 <set_duty_cycle_hl>
 80149a4:	e68f      	b.n	80146c6 <rpm_thread+0x56>
 80149a6:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 80149aa:	e7f5      	b.n	8014998 <rpm_thread+0x328>
		if (rpm < 0.0 && output > 0.0) {
 80149ac:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 80149b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80149b4:	dddd      	ble.n	8014972 <rpm_thread+0x302>
	current_set = output * conf->lo_current_max;
 80149b6:	edd2 7a19 	vldr	s15, [r2, #100]	; 0x64
 80149ba:	4819      	ldr	r0, [pc, #100]	; (8014a20 <rpm_thread+0x3b0>)
	if (state != MC_STATE_RUNNING) {
 80149bc:	4919      	ldr	r1, [pc, #100]	; (8014a24 <rpm_thread+0x3b4>)
			output = 0.0;
 80149be:	edcd 8a01 	vstr	s17, [sp, #4]
	current_set = output * conf->lo_current_max;
 80149c2:	ee67 7aa8 	vmul.f32	s15, s15, s17
 80149c6:	edc0 7a00 	vstr	s15, [r0]
	if (state != MC_STATE_RUNNING) {
 80149ca:	7809      	ldrb	r1, [r1, #0]
 80149cc:	2902      	cmp	r1, #2
 80149ce:	d1e1      	bne.n	8014994 <rpm_thread+0x324>
 80149d0:	e679      	b.n	80146c6 <rpm_thread+0x56>
 80149d2:	bf00      	nop
 80149d4:	20001a48 	.word	0x20001a48
 80149d8:	0802dfe0 	.word	0x0802dfe0
 80149dc:	20005444 	.word	0x20005444
 80149e0:	20005440 	.word	0x20005440
 80149e4:	20004d50 	.word	0x20004d50
 80149e8:	2000c03c 	.word	0x2000c03c
 80149ec:	4c64e1c0 	.word	0x4c64e1c0
 80149f0:	49742400 	.word	0x49742400
 80149f4:	42700000 	.word	0x42700000
 80149f8:	3dcccccd 	.word	0x3dcccccd
 80149fc:	00000000 	.word	0x00000000
 8014a00:	3a83126f 	.word	0x3a83126f
 8014a04:	20004d54 	.word	0x20004d54
 8014a08:	20004e18 	.word	0x20004e18
 8014a0c:	200059f0 	.word	0x200059f0
 8014a10:	20004e1c 	.word	0x20004e1c
 8014a14:	3d4ccccd 	.word	0x3d4ccccd
 8014a18:	20004f48 	.word	0x20004f48
 8014a1c:	20004e08 	.word	0x20004e08
 8014a20:	20004df4 	.word	0x20004df4
 8014a24:	200059f4 	.word	0x200059f4
 8014a28:	20005448 	.word	0x20005448
 8014a2c:	20005424 	.word	0x20005424
 8014a30:	20005410 	.word	0x20005410
	...

08014a40 <mcpwm_set_pid_pos>:
	control_mode = CONTROL_MODE_POS;
 8014a40:	4908      	ldr	r1, [pc, #32]	; (8014a64 <mcpwm_set_pid_pos+0x24>)
	pos_pid_set_pos = pos;
 8014a42:	4a09      	ldr	r2, [pc, #36]	; (8014a68 <mcpwm_set_pid_pos+0x28>)
	if (state != MC_STATE_RUNNING) {
 8014a44:	4b09      	ldr	r3, [pc, #36]	; (8014a6c <mcpwm_set_pid_pos+0x2c>)
	control_mode = CONTROL_MODE_POS;
 8014a46:	2004      	movs	r0, #4
 8014a48:	7008      	strb	r0, [r1, #0]
	pos_pid_set_pos = pos;
 8014a4a:	ed82 0a00 	vstr	s0, [r2]
	if (state != MC_STATE_RUNNING) {
 8014a4e:	781b      	ldrb	r3, [r3, #0]
 8014a50:	2b02      	cmp	r3, #2
 8014a52:	d005      	beq.n	8014a60 <mcpwm_set_pid_pos+0x20>
		set_duty_cycle_hl(conf->l_min_duty);
 8014a54:	4b06      	ldr	r3, [pc, #24]	; (8014a70 <mcpwm_set_pid_pos+0x30>)
 8014a56:	681b      	ldr	r3, [r3, #0]
 8014a58:	ed93 0a15 	vldr	s0, [r3, #84]	; 0x54
 8014a5c:	f7ff bd78 	b.w	8014550 <set_duty_cycle_hl>
}
 8014a60:	4770      	bx	lr
 8014a62:	bf00      	nop
 8014a64:	20004d54 	.word	0x20004d54
 8014a68:	2000540c 	.word	0x2000540c
 8014a6c:	200059f4 	.word	0x200059f4
 8014a70:	20004d50 	.word	0x20004d50
	...

08014a80 <mcpwm_set_current>:
void mcpwm_set_current(float current) {
 8014a80:	b510      	push	{r4, lr}
	if (fabsf(current) < conf->cc_min_current) {
 8014a82:	4c21      	ldr	r4, [pc, #132]	; (8014b08 <mcpwm_set_current+0x88>)
 8014a84:	6823      	ldr	r3, [r4, #0]
 8014a86:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 8014a8a:	eeb0 7ac0 	vabs.f32	s14, s0
 8014a8e:	eeb4 7ae7 	vcmpe.f32	s14, s15
void mcpwm_set_current(float current) {
 8014a92:	b082      	sub	sp, #8
	if (fabsf(current) < conf->cc_min_current) {
 8014a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
void mcpwm_set_current(float current) {
 8014a98:	ed8d 0a01 	vstr	s0, [sp, #4]
	if (fabsf(current) < conf->cc_min_current) {
 8014a9c:	d428      	bmi.n	8014af0 <mcpwm_set_current+0x70>
	utils_truncate_number(&current, -conf->l_current_max, conf->l_current_max);
 8014a9e:	ed93 0a01 	vldr	s0, [r3, #4]
 8014aa2:	edd3 0a01 	vldr	s1, [r3, #4]
 8014aa6:	eeb1 0a40 	vneg.f32	s0, s0
 8014aaa:	a801      	add	r0, sp, #4
 8014aac:	f000 ffe8 	bl	8015a80 <utils_truncate_number>
	control_mode = CONTROL_MODE_CURRENT;
 8014ab0:	4916      	ldr	r1, [pc, #88]	; (8014b0c <mcpwm_set_current+0x8c>)
	current_set = current;
 8014ab2:	eddd 7a01 	vldr	s15, [sp, #4]
 8014ab6:	4a16      	ldr	r2, [pc, #88]	; (8014b10 <mcpwm_set_current+0x90>)
	if (state != MC_STATE_RUNNING) {
 8014ab8:	4b16      	ldr	r3, [pc, #88]	; (8014b14 <mcpwm_set_current+0x94>)
	control_mode = CONTROL_MODE_CURRENT;
 8014aba:	2002      	movs	r0, #2
 8014abc:	7008      	strb	r0, [r1, #0]
	current_set = current;
 8014abe:	edc2 7a00 	vstr	s15, [r2]
	if (state != MC_STATE_RUNNING) {
 8014ac2:	781b      	ldrb	r3, [r3, #0]
 8014ac4:	4283      	cmp	r3, r0
 8014ac6:	d011      	beq.n	8014aec <mcpwm_set_current+0x6c>
		set_duty_cycle_hl(SIGN(current) * conf->l_min_duty);
 8014ac8:	6823      	ldr	r3, [r4, #0]
 8014aca:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8014ace:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014ad2:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8014ad6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8014ada:	ed93 0a15 	vldr	s0, [r3, #84]	; 0x54
 8014ade:	bf58      	it	pl
 8014ae0:	eef0 7a47 	vmovpl.f32	s15, s14
 8014ae4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8014ae8:	f7ff fd32 	bl	8014550 <set_duty_cycle_hl>
}
 8014aec:	b002      	add	sp, #8
 8014aee:	bd10      	pop	{r4, pc}
		control_mode = CONTROL_MODE_NONE;
 8014af0:	4806      	ldr	r0, [pc, #24]	; (8014b0c <mcpwm_set_current+0x8c>)
	state = MC_STATE_OFF;
 8014af2:	4908      	ldr	r1, [pc, #32]	; (8014b14 <mcpwm_set_current+0x94>)
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014af4:	4a08      	ldr	r2, [pc, #32]	; (8014b18 <mcpwm_set_current+0x98>)
	state = MC_STATE_OFF;
 8014af6:	2300      	movs	r3, #0
		control_mode = CONTROL_MODE_NONE;
 8014af8:	2407      	movs	r4, #7
 8014afa:	7004      	strb	r4, [r0, #0]
	state = MC_STATE_OFF;
 8014afc:	700b      	strb	r3, [r1, #0]
	ignore_iterations = MCPWM_CMD_STOP_TIME;
 8014afe:	6013      	str	r3, [r2, #0]
	stop_pwm_hw();
 8014b00:	f7fe f9be 	bl	8012e80 <stop_pwm_hw>
}
 8014b04:	b002      	add	sp, #8
 8014b06:	bd10      	pop	{r4, pc}
 8014b08:	20004d50 	.word	0x20004d50
 8014b0c:	20004d54 	.word	0x20004d54
 8014b10:	20004df4 	.word	0x20004df4
 8014b14:	200059f4 	.word	0x200059f4
 8014b18:	20004f50 	.word	0x20004f50
 8014b1c:	00000000 	.word	0x00000000

08014b20 <mcpwm_adc_int_handler>:
void mcpwm_adc_int_handler(void *p, uint32_t flags) {
 8014b20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014b24:	ed2d 8b06 	vpush	{d8-d10}
	TIM12->CNT = 0;
 8014b28:	4b9b      	ldr	r3, [pc, #620]	; (8014d98 <mcpwm_adc_int_handler+0x278>)
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014b2a:	4c9c      	ldr	r4, [pc, #624]	; (8014d9c <mcpwm_adc_int_handler+0x27c>)
	if (!(state == MC_STATE_RUNNING && direction == direction_before)) {
 8014b2c:	4d9c      	ldr	r5, [pc, #624]	; (8014da0 <mcpwm_adc_int_handler+0x280>)
 8014b2e:	f8df a2c0 	ldr.w	sl, [pc, #704]	; 8014df0 <mcpwm_adc_int_handler+0x2d0>
	TIM12->CNT = 0;
 8014b32:	2200      	movs	r2, #0
 8014b34:	625a      	str	r2, [r3, #36]	; 0x24
void mcpwm_adc_int_handler(void *p, uint32_t flags) {
 8014b36:	b08b      	sub	sp, #44	; 0x2c
	update_timer_attempt();
 8014b38:	f7fd fe1a 	bl	8012770 <update_timer_attempt>
	WWDG_SetCounter(100);
 8014b3c:	2064      	movs	r0, #100	; 0x64
 8014b3e:	f00f ff9f 	bl	8024a80 <WWDG_SetCounter>
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014b42:	8a22      	ldrh	r2, [r4, #16]
	if (!(state == MC_STATE_RUNNING && direction == direction_before)) {
 8014b44:	782b      	ldrb	r3, [r5, #0]
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014b46:	b292      	uxth	r2, r2
	if (!(state == MC_STATE_RUNNING && direction == direction_before)) {
 8014b48:	2b02      	cmp	r3, #2
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014b4a:	9201      	str	r2, [sp, #4]
 8014b4c:	4b95      	ldr	r3, [pc, #596]	; (8014da4 <mcpwm_adc_int_handler+0x284>)
	if (!(state == MC_STATE_RUNNING && direction == direction_before)) {
 8014b4e:	f000 81aa 	beq.w	8014ea6 <mcpwm_adc_int_handler+0x386>
		has_commutated = 0;
 8014b52:	4e95      	ldr	r6, [pc, #596]	; (8014da8 <mcpwm_adc_int_handler+0x288>)
 8014b54:	2200      	movs	r2, #0
 8014b56:	6032      	str	r2, [r6, #0]
	if (conf->motor_type == MOTOR_TYPE_BLDC) {
 8014b58:	f8df 8298 	ldr.w	r8, [pc, #664]	; 8014df4 <mcpwm_adc_int_handler+0x2d4>
	direction_before = direction;
 8014b5c:	f8da 1000 	ldr.w	r1, [sl]
	if (conf->motor_type == MOTOR_TYPE_BLDC) {
 8014b60:	f8d8 2000 	ldr.w	r2, [r8]
	direction_before = direction;
 8014b64:	6019      	str	r1, [r3, #0]
	if (conf->motor_type == MOTOR_TYPE_BLDC) {
 8014b66:	7893      	ldrb	r3, [r2, #2]
 8014b68:	2b00      	cmp	r3, #0
 8014b6a:	f040 808e 	bne.w	8014c8a <mcpwm_adc_int_handler+0x16a>
		if (has_commutated && fabsf(dutycycle_now) > 0.2) {
 8014b6e:	6833      	ldr	r3, [r6, #0]
 8014b70:	4f8e      	ldr	r7, [pc, #568]	; (8014dac <mcpwm_adc_int_handler+0x28c>)
 8014b72:	2b00      	cmp	r3, #0
 8014b74:	f040 80bd 	bne.w	8014cf2 <mcpwm_adc_int_handler+0x1d2>
			mcpwm_vzero = (ADC_V_L1 + ADC_V_L2 + ADC_V_L3) / 3;
 8014b78:	88a3      	ldrh	r3, [r4, #4]
 8014b7a:	8862      	ldrh	r2, [r4, #2]
 8014b7c:	8821      	ldrh	r1, [r4, #0]
 8014b7e:	441a      	add	r2, r3
 8014b80:	4b8b      	ldr	r3, [pc, #556]	; (8014db0 <mcpwm_adc_int_handler+0x290>)
 8014b82:	440a      	add	r2, r1
 8014b84:	fba3 3202 	umull	r3, r2, r3, r2
 8014b88:	4b8a      	ldr	r3, [pc, #552]	; (8014db4 <mcpwm_adc_int_handler+0x294>)
 8014b8a:	0852      	lsrs	r2, r2, #1
 8014b8c:	601a      	str	r2, [r3, #0]
		if (direction) {
 8014b8e:	f8da 2000 	ldr.w	r2, [sl]
			ph1 = ADC_V_L1 - mcpwm_vzero;
 8014b92:	f8b4 c004 	ldrh.w	ip, [r4, #4]
 8014b96:	f8d3 9000 	ldr.w	r9, [r3]
		if (direction) {
 8014b9a:	2a00      	cmp	r2, #0
 8014b9c:	f000 80c2 	beq.w	8014d24 <mcpwm_adc_int_handler+0x204>
			ph2 = ADC_V_L2 - mcpwm_vzero;
 8014ba0:	f8b4 e002 	ldrh.w	lr, [r4, #2]
 8014ba4:	681a      	ldr	r2, [r3, #0]
			ph3 = ADC_V_L3 - mcpwm_vzero;
 8014ba6:	8820      	ldrh	r0, [r4, #0]
 8014ba8:	f8d3 b000 	ldr.w	fp, [r3]
			ph1_raw = ADC_V_L1;
 8014bac:	88a1      	ldrh	r1, [r4, #4]
			ph2_raw = ADC_V_L2;
 8014bae:	8863      	ldrh	r3, [r4, #2]
 8014bb0:	f8ad 3010 	strh.w	r3, [sp, #16]
			ph3_raw = ADC_V_L3;
 8014bb4:	8823      	ldrh	r3, [r4, #0]
			ph2 = ADC_V_L2 - mcpwm_vzero;
 8014bb6:	9203      	str	r2, [sp, #12]
			ph2 = ADC_V_L3 - mcpwm_vzero;
 8014bb8:	9a03      	ldr	r2, [sp, #12]
 8014bba:	ebae 0202 	sub.w	r2, lr, r2
 8014bbe:	9203      	str	r2, [sp, #12]
			ph1_raw = ADC_V_L1;
 8014bc0:	b28a      	uxth	r2, r1
			ph3_raw = ADC_V_L2;
 8014bc2:	b29b      	uxth	r3, r3
			ph1 = ADC_V_L1 - mcpwm_vzero;
 8014bc4:	ebac 0c09 	sub.w	ip, ip, r9
			ph1_raw = ADC_V_L1;
 8014bc8:	9206      	str	r2, [sp, #24]
			ph2_raw = ADC_V_L3;
 8014bca:	f8bd 2010 	ldrh.w	r2, [sp, #16]
			ph3_raw = ADC_V_L2;
 8014bce:	9305      	str	r3, [sp, #20]
			ph1 = ADC_V_L1 - mcpwm_vzero;
 8014bd0:	f8cd c008 	str.w	ip, [sp, #8]
			ph3 = ADC_V_L2 - mcpwm_vzero;
 8014bd4:	eba0 0b0b 	sub.w	fp, r0, fp
			ph2_raw = ADC_V_L3;
 8014bd8:	9207      	str	r2, [sp, #28]
		update_timer_attempt();
 8014bda:	f7fd fdc9 	bl	8012770 <update_timer_attempt>
		if (has_commutated) {
 8014bde:	6833      	ldr	r3, [r6, #0]
 8014be0:	2b00      	cmp	r3, #0
 8014be2:	f000 82fb 	beq.w	80151dc <mcpwm_adc_int_handler+0x6bc>
			amp = fabsf(dutycycle_now) * (float)ADC_Value[ADC_IND_VIN_SENS];
 8014be6:	ed97 0a00 	vldr	s0, [r7]
 8014bea:	8a23      	ldrh	r3, [r4, #16]
 8014bec:	ee07 3a90 	vmov	s15, r3
 8014bf0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014bf4:	eeb0 0ac0 	vabs.f32	s0, s0
 8014bf8:	ee20 0a27 	vmul.f32	s0, s0, s15
		filter_add_sample((float*)amp_fir_samples, amp,
 8014bfc:	4a6e      	ldr	r2, [pc, #440]	; (8014db8 <mcpwm_adc_int_handler+0x298>)
 8014bfe:	486f      	ldr	r0, [pc, #444]	; (8014dbc <mcpwm_adc_int_handler+0x29c>)
 8014c00:	2107      	movs	r1, #7
 8014c02:	f7fd fbc5 	bl	8012390 <filter_add_sample>
		if (sensorless_now) {
 8014c06:	4b6e      	ldr	r3, [pc, #440]	; (8014dc0 <mcpwm_adc_int_handler+0x2a0>)
 8014c08:	781b      	ldrb	r3, [r3, #0]
 8014c0a:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 8014c0e:	2b00      	cmp	r3, #0
 8014c10:	f000 82fd 	beq.w	801520e <mcpwm_adc_int_handler+0x6ee>
			if (pwm_cycles_sum >= rpm_dep.comm_time_sum_min_rpm) {
 8014c14:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 8014df8 <mcpwm_adc_int_handler+0x2d8>
 8014c18:	4b6a      	ldr	r3, [pc, #424]	; (8014dc4 <mcpwm_adc_int_handler+0x2a4>)
 8014c1a:	f8d8 2000 	ldr.w	r2, [r8]
 8014c1e:	ed93 7a04 	vldr	s14, [r3, #16]
 8014c22:	edd9 7a00 	vldr	s15, [r9]
 8014c26:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8014c2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014c2e:	d80f      	bhi.n	8014c50 <mcpwm_adc_int_handler+0x130>
				if (state == MC_STATE_RUNNING) {
 8014c30:	7828      	ldrb	r0, [r5, #0]
 8014c32:	b2c0      	uxtb	r0, r0
 8014c34:	2802      	cmp	r0, #2
 8014c36:	d10b      	bne.n	8014c50 <mcpwm_adc_int_handler+0x130>
					if (conf->comm_mode == COMM_MODE_INTEGRATE) {
 8014c38:	7853      	ldrb	r3, [r2, #1]
 8014c3a:	2b00      	cmp	r3, #0
 8014c3c:	f000 847a 	beq.w	8015534 <mcpwm_adc_int_handler+0xa14>
					} else if (conf->comm_mode == COMM_MODE_DELAY) {
 8014c40:	7850      	ldrb	r0, [r2, #1]
 8014c42:	b2c0      	uxtb	r0, r0
 8014c44:	2801      	cmp	r0, #1
 8014c46:	f000 8475 	beq.w	8015534 <mcpwm_adc_int_handler+0xa14>
					cycle_integrator = 0.0;
 8014c4a:	4b5f      	ldr	r3, [pc, #380]	; (8014dc8 <mcpwm_adc_int_handler+0x2a8>)
 8014c4c:	2100      	movs	r1, #0
 8014c4e:	6019      	str	r1, [r3, #0]
			if ((state == MC_STATE_RUNNING && pwm_cycles >= 2) || state == MC_STATE_OFF) {
 8014c50:	782b      	ldrb	r3, [r5, #0]
 8014c52:	2b02      	cmp	r3, #2
 8014c54:	4b5d      	ldr	r3, [pc, #372]	; (8014dcc <mcpwm_adc_int_handler+0x2ac>)
 8014c56:	9304      	str	r3, [sp, #16]
 8014c58:	d07c      	beq.n	8014d54 <mcpwm_adc_int_handler+0x234>
 8014c5a:	782b      	ldrb	r3, [r5, #0]
 8014c5c:	2b00      	cmp	r3, #0
 8014c5e:	d07d      	beq.n	8014d5c <mcpwm_adc_int_handler+0x23c>
				cycle_integrator = 0.0;
 8014c60:	4b59      	ldr	r3, [pc, #356]	; (8014dc8 <mcpwm_adc_int_handler+0x2a8>)
 8014c62:	4c5b      	ldr	r4, [pc, #364]	; (8014dd0 <mcpwm_adc_int_handler+0x2b0>)
 8014c64:	2100      	movs	r1, #0
 8014c66:	6019      	str	r1, [r3, #0]
			pwm_cycles_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8014c68:	ed92 6a5a 	vldr	s12, [r2, #360]	; 0x168
 8014c6c:	edd4 6a00 	vldr	s13, [r4]
 8014c70:	ed99 7a00 	vldr	s14, [r9]
			pwm_cycles++;
 8014c74:	9a04      	ldr	r2, [sp, #16]
			pwm_cycles_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8014c76:	eec6 7a26 	vdiv.f32	s15, s12, s13
 8014c7a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8014c7e:	edc9 7a00 	vstr	s15, [r9]
			pwm_cycles++;
 8014c82:	6813      	ldr	r3, [r2, #0]
 8014c84:	3301      	adds	r3, #1
 8014c86:	6013      	str	r3, [r2, #0]
 8014c88:	e013      	b.n	8014cb2 <mcpwm_adc_int_handler+0x192>
		if (has_commutated) {
 8014c8a:	6833      	ldr	r3, [r6, #0]
 8014c8c:	2b00      	cmp	r3, #0
 8014c8e:	d156      	bne.n	8014d3e <mcpwm_adc_int_handler+0x21e>
			amp = ADC_V_L3 - ADC_V_L1;
 8014c90:	8823      	ldrh	r3, [r4, #0]
 8014c92:	88a2      	ldrh	r2, [r4, #4]
 8014c94:	4f45      	ldr	r7, [pc, #276]	; (8014dac <mcpwm_adc_int_handler+0x28c>)
 8014c96:	1a9b      	subs	r3, r3, r2
 8014c98:	ee00 3a10 	vmov	s0, r3
 8014c9c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
		filter_add_sample((float*)amp_fir_samples, amp,
 8014ca0:	4a45      	ldr	r2, [pc, #276]	; (8014db8 <mcpwm_adc_int_handler+0x298>)
 8014ca2:	4846      	ldr	r0, [pc, #280]	; (8014dbc <mcpwm_adc_int_handler+0x29c>)
 8014ca4:	2107      	movs	r1, #7
 8014ca6:	f7fd fb73 	bl	8012390 <filter_add_sample>
		if (state == MC_STATE_RUNNING && !has_commutated) {
 8014caa:	782b      	ldrb	r3, [r5, #0]
 8014cac:	2b02      	cmp	r3, #2
 8014cae:	f000 8289 	beq.w	80151c4 <mcpwm_adc_int_handler+0x6a4>
	return last_current_sample;
 8014cb2:	4b48      	ldr	r3, [pc, #288]	; (8014dd4 <mcpwm_adc_int_handler+0x2b4>)
 8014cb4:	ed93 8a00 	vldr	s16, [r3]
	const float current_in_nofilter = current_nofilter * fabsf(dutycycle_now);
 8014cb8:	edd7 8a00 	vldr	s17, [r7]
	if (state == MC_STATE_RUNNING && has_commutated) {
 8014cbc:	782b      	ldrb	r3, [r5, #0]
 8014cbe:	2b02      	cmp	r3, #2
 8014cc0:	f000 809e 	beq.w	8014e00 <mcpwm_adc_int_handler+0x2e0>
	mc_interface_mc_timer_isr();
 8014cc4:	f007 fbc4 	bl	801c450 <mc_interface_mc_timer_isr>
	if (encoder_is_configured()) {
 8014cc8:	f005 fff2 	bl	801acb0 <encoder_is_configured>
 8014ccc:	2800      	cmp	r0, #0
 8014cce:	d155      	bne.n	8014d7c <mcpwm_adc_int_handler+0x25c>
	last_adc_isr_duration = (float)TIM12->CNT / 10000000.0;
 8014cd0:	4b31      	ldr	r3, [pc, #196]	; (8014d98 <mcpwm_adc_int_handler+0x278>)
 8014cd2:	eddf 6a41 	vldr	s13, [pc, #260]	; 8014dd8 <mcpwm_adc_int_handler+0x2b8>
 8014cd6:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8014cda:	4b40      	ldr	r3, [pc, #256]	; (8014ddc <mcpwm_adc_int_handler+0x2bc>)
 8014cdc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014ce0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8014ce4:	ed83 7a00 	vstr	s14, [r3]
}
 8014ce8:	b00b      	add	sp, #44	; 0x2c
 8014cea:	ecbd 8b06 	vpop	{d8-d10}
 8014cee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (has_commutated && fabsf(dutycycle_now) > 0.2) {
 8014cf2:	edd7 7a00 	vldr	s15, [r7]
 8014cf6:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 8014de0 <mcpwm_adc_int_handler+0x2c0>
 8014cfa:	eef0 7ae7 	vabs.f32	s15, s15
 8014cfe:	eef4 7ac7 	vcmpe.f32	s15, s14
 8014d02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d06:	f77f af37 	ble.w	8014b78 <mcpwm_adc_int_handler+0x58>
			mcpwm_vzero = ADC_V_ZERO;
 8014d0a:	8a22      	ldrh	r2, [r4, #16]
 8014d0c:	4b29      	ldr	r3, [pc, #164]	; (8014db4 <mcpwm_adc_int_handler+0x294>)
 8014d0e:	0852      	lsrs	r2, r2, #1
 8014d10:	601a      	str	r2, [r3, #0]
		if (direction) {
 8014d12:	f8da 2000 	ldr.w	r2, [sl]
			ph1 = ADC_V_L1 - mcpwm_vzero;
 8014d16:	f8b4 c004 	ldrh.w	ip, [r4, #4]
 8014d1a:	f8d3 9000 	ldr.w	r9, [r3]
		if (direction) {
 8014d1e:	2a00      	cmp	r2, #0
 8014d20:	f47f af3e 	bne.w	8014ba0 <mcpwm_adc_int_handler+0x80>
			ph2 = ADC_V_L3 - mcpwm_vzero;
 8014d24:	f8b4 e000 	ldrh.w	lr, [r4]
 8014d28:	681a      	ldr	r2, [r3, #0]
			ph3 = ADC_V_L2 - mcpwm_vzero;
 8014d2a:	8860      	ldrh	r0, [r4, #2]
 8014d2c:	f8d3 b000 	ldr.w	fp, [r3]
			ph1_raw = ADC_V_L1;
 8014d30:	88a1      	ldrh	r1, [r4, #4]
			ph2_raw = ADC_V_L3;
 8014d32:	8823      	ldrh	r3, [r4, #0]
 8014d34:	f8ad 3010 	strh.w	r3, [sp, #16]
			ph2 = ADC_V_L3 - mcpwm_vzero;
 8014d38:	9203      	str	r2, [sp, #12]
			ph3_raw = ADC_V_L2;
 8014d3a:	8863      	ldrh	r3, [r4, #2]
 8014d3c:	e73c      	b.n	8014bb8 <mcpwm_adc_int_handler+0x98>
			amp = dutycycle_now * (float)ADC_Value[ADC_IND_VIN_SENS];
 8014d3e:	8a23      	ldrh	r3, [r4, #16]
 8014d40:	4f1a      	ldr	r7, [pc, #104]	; (8014dac <mcpwm_adc_int_handler+0x28c>)
 8014d42:	ee00 3a10 	vmov	s0, r3
 8014d46:	edd7 7a00 	vldr	s15, [r7]
 8014d4a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8014d4e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8014d52:	e7a5      	b.n	8014ca0 <mcpwm_adc_int_handler+0x180>
			if ((state == MC_STATE_RUNNING && pwm_cycles >= 2) || state == MC_STATE_OFF) {
 8014d54:	681b      	ldr	r3, [r3, #0]
 8014d56:	2b01      	cmp	r3, #1
 8014d58:	f77f af7f 	ble.w	8014c5a <mcpwm_adc_int_handler+0x13a>
				switch (comm_step) {
 8014d5c:	f8df c09c 	ldr.w	ip, [pc, #156]	; 8014dfc <mcpwm_adc_int_handler+0x2dc>
 8014d60:	f8dc 3000 	ldr.w	r3, [ip]
 8014d64:	3b01      	subs	r3, #1
 8014d66:	2b05      	cmp	r3, #5
 8014d68:	f200 84ba 	bhi.w	80156e0 <mcpwm_adc_int_handler+0xbc0>
 8014d6c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8014d70:	03c103bc 	.word	0x03c103bc
 8014d74:	03c700a5 	.word	0x03c700a5
 8014d78:	00a303cd 	.word	0x00a303cd
		run_pid_control_pos(1.0 / switching_frequency_now);
 8014d7c:	4a14      	ldr	r2, [pc, #80]	; (8014dd0 <mcpwm_adc_int_handler+0x2b0>)
	if (control_mode != CONTROL_MODE_POS) {
 8014d7e:	4b19      	ldr	r3, [pc, #100]	; (8014de4 <mcpwm_adc_int_handler+0x2c4>)
		run_pid_control_pos(1.0 / switching_frequency_now);
 8014d80:	edd2 7a00 	vldr	s15, [r2]
	if (control_mode != CONTROL_MODE_POS) {
 8014d84:	781b      	ldrb	r3, [r3, #0]
 8014d86:	2b04      	cmp	r3, #4
 8014d88:	f000 830a 	beq.w	80153a0 <mcpwm_adc_int_handler+0x880>
		i_term = 0;
 8014d8c:	4916      	ldr	r1, [pc, #88]	; (8014de8 <mcpwm_adc_int_handler+0x2c8>)
		prev_error = 0;
 8014d8e:	4a17      	ldr	r2, [pc, #92]	; (8014dec <mcpwm_adc_int_handler+0x2cc>)
		i_term = 0;
 8014d90:	2300      	movs	r3, #0
 8014d92:	600b      	str	r3, [r1, #0]
		prev_error = 0;
 8014d94:	6013      	str	r3, [r2, #0]
 8014d96:	e79b      	b.n	8014cd0 <mcpwm_adc_int_handler+0x1b0>
 8014d98:	40001800 	.word	0x40001800
 8014d9c:	2000c03c 	.word	0x2000c03c
 8014da0:	200059f4 	.word	0x200059f4
 8014da4:	2000100c 	.word	0x2000100c
 8014da8:	20004f44 	.word	0x20004f44
 8014dac:	20004e1c 	.word	0x20004e1c
 8014db0:	aaaaaaab 	.word	0xaaaaaaab
 8014db4:	20005408 	.word	0x20005408
 8014db8:	20004b40 	.word	0x20004b40
 8014dbc:	20004b44 	.word	0x20004b44
 8014dc0:	200059e8 	.word	0x200059e8
 8014dc4:	20005424 	.word	0x20005424
 8014dc8:	20004df8 	.word	0x20004df8
 8014dcc:	2000541c 	.word	0x2000541c
 8014dd0:	200059f8 	.word	0x200059f8
 8014dd4:	20005360 	.word	0x20005360
 8014dd8:	4b189680 	.word	0x4b189680
 8014ddc:	2000535c 	.word	0x2000535c
 8014de0:	3e4ccccd 	.word	0x3e4ccccd
 8014de4:	20004d54 	.word	0x20004d54
 8014de8:	20004f4c 	.word	0x20004f4c
 8014dec:	20005414 	.word	0x20005414
 8014df0:	20004e18 	.word	0x20004e18
 8014df4:	20004d50 	.word	0x20004d50
 8014df8:	20005420 	.word	0x20005420
 8014dfc:	20004d4c 	.word	0x20004d4c
	if (state == MC_STATE_RUNNING && has_commutated) {
 8014e00:	6833      	ldr	r3, [r6, #0]
 8014e02:	2b00      	cmp	r3, #0
 8014e04:	f43f af5e 	beq.w	8014cc4 <mcpwm_adc_int_handler+0x1a4>
		float ramp_step = conf->m_duty_ramp_step / (switching_frequency_now / 1000.0);
 8014e08:	f8d8 3000 	ldr.w	r3, [r8]
 8014e0c:	4c56      	ldr	r4, [pc, #344]	; (8014f68 <mcpwm_adc_int_handler+0x448>)
 8014e0e:	edd3 5a54 	vldr	s11, [r3, #336]	; 0x150
 8014e12:	eddf 7a56 	vldr	s15, [pc, #344]	; 8014f6c <mcpwm_adc_int_handler+0x44c>
 8014e16:	edd4 6a00 	vldr	s13, [r4]
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014e1a:	ed9f 5a55 	vldr	s10, [pc, #340]	; 8014f70 <mcpwm_adc_int_handler+0x450>
 8014e1e:	ed9f 7a55 	vldr	s14, [pc, #340]	; 8014f74 <mcpwm_adc_int_handler+0x454>
	return direction ? rpm_now : -rpm_now;
 8014e22:	f8da 2000 	ldr.w	r2, [sl]
 8014e26:	4e54      	ldr	r6, [pc, #336]	; (8014f78 <mcpwm_adc_int_handler+0x458>)
		float ramp_step = conf->m_duty_ramp_step / (switching_frequency_now / 1000.0);
 8014e28:	ee86 6aa7 	vdiv.f32	s12, s13, s15
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014e2c:	eddd 7a01 	vldr	s15, [sp, #4]
	return direction ? rpm_now : -rpm_now;
 8014e30:	ed96 9a00 	vldr	s18, [r6]
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014e34:	eef8 7a67 	vcvt.f32.u32	s15, s15
		const float voltage_scale = 20.0 / input_voltage;
 8014e38:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014e3c:	ee67 7a85 	vmul.f32	s15, s15, s10
		float ramp_step = conf->m_duty_ramp_step / (switching_frequency_now / 1000.0);
 8014e40:	eec5 9a86 	vdiv.f32	s19, s11, s12
	const float input_voltage = GET_INPUT_VOLTAGE();
 8014e44:	ee67 7a87 	vmul.f32	s15, s15, s14
		const float voltage_scale = 20.0 / input_voltage;
 8014e48:	ee86 7aa7 	vdiv.f32	s14, s13, s15
	return direction ? rpm_now : -rpm_now;
 8014e4c:	b90a      	cbnz	r2, 8014e52 <mcpwm_adc_int_handler+0x332>
 8014e4e:	eeb1 9a49 	vneg.f32	s18, s18
		if (slow_ramping_cycles) {
 8014e52:	4d4a      	ldr	r5, [pc, #296]	; (8014f7c <mcpwm_adc_int_handler+0x45c>)
 8014e54:	682a      	ldr	r2, [r5, #0]
 8014e56:	2a00      	cmp	r2, #0
 8014e58:	f000 828e 	beq.w	8015378 <mcpwm_adc_int_handler+0x858>
			slow_ramping_cycles--;
 8014e5c:	682a      	ldr	r2, [r5, #0]
			ramp_step *= 0.1;
 8014e5e:	eddf aa48 	vldr	s21, [pc, #288]	; 8014f80 <mcpwm_adc_int_handler+0x460>
			slow_ramping_cycles--;
 8014e62:	3a01      	subs	r2, #1
			ramp_step *= 0.1;
 8014e64:	ee69 aaaa 	vmul.f32	s21, s19, s21
			slow_ramping_cycles--;
 8014e68:	602a      	str	r2, [r5, #0]
		if (control_mode == CONTROL_MODE_CURRENT ||
 8014e6a:	4a46      	ldr	r2, [pc, #280]	; (8014f84 <mcpwm_adc_int_handler+0x464>)
		float dutycycle_now_tmp = dutycycle_now;
 8014e6c:	6838      	ldr	r0, [r7, #0]
		if (control_mode == CONTROL_MODE_CURRENT ||
 8014e6e:	7811      	ldrb	r1, [r2, #0]
		float dutycycle_now_tmp = dutycycle_now;
 8014e70:	9008      	str	r0, [sp, #32]
		if (control_mode == CONTROL_MODE_CURRENT ||
 8014e72:	2902      	cmp	r1, #2
 8014e74:	f000 809a 	beq.w	8014fac <mcpwm_adc_int_handler+0x48c>
				control_mode == CONTROL_MODE_POS ||
 8014e78:	7811      	ldrb	r1, [r2, #0]
		if (control_mode == CONTROL_MODE_CURRENT ||
 8014e7a:	2904      	cmp	r1, #4
 8014e7c:	f000 8096 	beq.w	8014fac <mcpwm_adc_int_handler+0x48c>
				control_mode == CONTROL_MODE_SPEED) {
 8014e80:	7811      	ldrb	r1, [r2, #0]
				control_mode == CONTROL_MODE_POS ||
 8014e82:	2901      	cmp	r1, #1
 8014e84:	f000 8092 	beq.w	8014fac <mcpwm_adc_int_handler+0x48c>
		} else if (control_mode == CONTROL_MODE_CURRENT_BRAKE) {
 8014e88:	7812      	ldrb	r2, [r2, #0]
 8014e8a:	2a03      	cmp	r2, #3
 8014e8c:	f000 8386 	beq.w	801559c <mcpwm_adc_int_handler+0xa7c>
			utils_step_towards((float*)&dutycycle_now_tmp, dutycycle_set, ramp_step);
 8014e90:	4b3d      	ldr	r3, [pc, #244]	; (8014f88 <mcpwm_adc_int_handler+0x468>)
 8014e92:	eef0 0a6a 	vmov.f32	s1, s21
 8014e96:	ed93 0a00 	vldr	s0, [r3]
 8014e9a:	a808      	add	r0, sp, #32
 8014e9c:	f000 fd80 	bl	80159a0 <utils_step_towards>
 8014ea0:	f8d8 3000 	ldr.w	r3, [r8]
 8014ea4:	e110      	b.n	80150c8 <mcpwm_adc_int_handler+0x5a8>
	if (!(state == MC_STATE_RUNNING && direction == direction_before)) {
 8014ea6:	f8da 1000 	ldr.w	r1, [sl]
 8014eaa:	681a      	ldr	r2, [r3, #0]
 8014eac:	4291      	cmp	r1, r2
 8014eae:	f47f ae50 	bne.w	8014b52 <mcpwm_adc_int_handler+0x32>
 8014eb2:	4e36      	ldr	r6, [pc, #216]	; (8014f8c <mcpwm_adc_int_handler+0x46c>)
 8014eb4:	e650      	b.n	8014b58 <mcpwm_adc_int_handler+0x38>
					v_diff = -ph3;
 8014eb6:	f1cb 0b00 	rsb	fp, fp, #0
 8014eba:	f10b 0309 	add.w	r3, fp, #9
				if (v_diff < 50) {
 8014ebe:	f1bb 0f31 	cmp.w	fp, #49	; 0x31
 8014ec2:	9302      	str	r3, [sp, #8]
 8014ec4:	dc1a      	bgt.n	8014efc <mcpwm_adc_int_handler+0x3dc>
	return READ_HALL1() | (READ_HALL2() << 1) | (READ_HALL3() << 2);
 8014ec6:	4b32      	ldr	r3, [pc, #200]	; (8014f90 <mcpwm_adc_int_handler+0x470>)
 8014ec8:	4932      	ldr	r1, [pc, #200]	; (8014f94 <mcpwm_adc_int_handler+0x474>)
 8014eca:	6918      	ldr	r0, [r3, #16]
 8014ecc:	691b      	ldr	r3, [r3, #16]
 8014ece:	6909      	ldr	r1, [r1, #16]
					hall_detect_table[read_hall()][comm_step]++;
 8014ed0:	f8dc e000 	ldr.w	lr, [ip]
 8014ed4:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 8014fa4 <mcpwm_adc_int_handler+0x484>
	return READ_HALL1() | (READ_HALL2() << 1) | (READ_HALL3() << 2);
 8014ed8:	099b      	lsrs	r3, r3, #6
 8014eda:	0a49      	lsrs	r1, r1, #9
 8014edc:	f003 0302 	and.w	r3, r3, #2
 8014ee0:	f001 0104 	and.w	r1, r1, #4
 8014ee4:	f3c0 1080 	ubfx	r0, r0, #6, #1
 8014ee8:	430b      	orrs	r3, r1
 8014eea:	4303      	orrs	r3, r0
					hall_detect_table[read_hall()][comm_step]++;
 8014eec:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8014ef0:	449e      	add	lr, r3
 8014ef2:	f85c 302e 	ldr.w	r3, [ip, lr, lsl #2]
 8014ef6:	3301      	adds	r3, #1
 8014ef8:	f84c 302e 	str.w	r3, [ip, lr, lsl #2]
				if (abs(v_diff) < 10) {
 8014efc:	9b02      	ldr	r3, [sp, #8]
 8014efe:	2b12      	cmp	r3, #18
 8014f00:	f200 8194 	bhi.w	801522c <mcpwm_adc_int_handler+0x70c>
				if (conf->comm_mode == COMM_MODE_INTEGRATE) {
 8014f04:	7853      	ldrb	r3, [r2, #1]
 8014f06:	2b00      	cmp	r3, #0
 8014f08:	f040 82d8 	bne.w	80154bc <mcpwm_adc_int_handler+0x99c>
 8014f0c:	4c16      	ldr	r4, [pc, #88]	; (8014f68 <mcpwm_adc_int_handler+0x448>)
					if (has_commutated) {
 8014f0e:	6833      	ldr	r3, [r6, #0]
 8014f10:	2b00      	cmp	r3, #0
 8014f12:	f000 82cb 	beq.w	80154ac <mcpwm_adc_int_handler+0x98c>
						limit = rpm_dep.cycle_int_limit_running * (0.0005 * VDIV_CORR);
 8014f16:	4b20      	ldr	r3, [pc, #128]	; (8014f98 <mcpwm_adc_int_handler+0x478>)
 8014f18:	eddf 7a20 	vldr	s15, [pc, #128]	; 8014f9c <mcpwm_adc_int_handler+0x47c>
 8014f1c:	ed93 7a01 	vldr	s14, [r3, #4]
 8014f20:	ee27 7a27 	vmul.f32	s14, s14, s15
					if (cycle_integrator >= (rpm_dep.cycle_int_limit_max * (0.0005 * VDIV_CORR)) ||
 8014f24:	4b1c      	ldr	r3, [pc, #112]	; (8014f98 <mcpwm_adc_int_handler+0x478>)
 8014f26:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8014f9c <mcpwm_adc_int_handler+0x47c>
 8014f2a:	edd3 7a02 	vldr	s15, [r3, #8]
 8014f2e:	f8df b078 	ldr.w	fp, [pc, #120]	; 8014fa8 <mcpwm_adc_int_handler+0x488>
 8014f32:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8014f36:	eddb 6a00 	vldr	s13, [fp]
 8014f3a:	eef4 7ae6 	vcmpe.f32	s15, s13
 8014f3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f42:	d905      	bls.n	8014f50 <mcpwm_adc_int_handler+0x430>
 8014f44:	eef4 6ac7 	vcmpe.f32	s13, s14
 8014f48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f4c:	f6ff ae8c 	blt.w	8014c68 <mcpwm_adc_int_handler+0x148>
						commutate(1);
 8014f50:	2001      	movs	r0, #1
 8014f52:	f7fd ffd5 	bl	8012f00 <commutate>
						cycle_sum = 0.0;
 8014f56:	4a12      	ldr	r2, [pc, #72]	; (8014fa0 <mcpwm_adc_int_handler+0x480>)
						cycle_integrator = 0.0;
 8014f58:	2300      	movs	r3, #0
						cycle_sum = 0.0;
 8014f5a:	6013      	str	r3, [r2, #0]
						cycle_integrator = 0.0;
 8014f5c:	f8cb 3000 	str.w	r3, [fp]
 8014f60:	f8d8 2000 	ldr.w	r2, [r8]
 8014f64:	e680      	b.n	8014c68 <mcpwm_adc_int_handler+0x148>
 8014f66:	bf00      	nop
 8014f68:	200059f8 	.word	0x200059f8
 8014f6c:	447a0000 	.word	0x447a0000
 8014f70:	3a534067 	.word	0x3a534067
 8014f74:	4195d174 	.word	0x4195d174
 8014f78:	20005444 	.word	0x20005444
 8014f7c:	200059ec 	.word	0x200059ec
 8014f80:	3dcccccd 	.word	0x3dcccccd
 8014f84:	20004d54 	.word	0x20004d54
 8014f88:	20004e20 	.word	0x20004e20
 8014f8c:	20004f44 	.word	0x20004f44
 8014f90:	40020400 	.word	0x40020400
 8014f94:	40020800 	.word	0x40020800
 8014f98:	20005424 	.word	0x20005424
 8014f9c:	39dff7bb 	.word	0x39dff7bb
 8014fa0:	20004e04 	.word	0x20004e04
 8014fa4:	20004e24 	.word	0x20004e24
 8014fa8:	20004df8 	.word	0x20004df8
			const float error = current_set - (direction ? current_nofilter : -current_nofilter);
 8014fac:	4ebd      	ldr	r6, [pc, #756]	; (80152a4 <mcpwm_adc_int_handler+0x784>)
 8014fae:	edd6 7a00 	vldr	s15, [r6]
 8014fb2:	f8da 2000 	ldr.w	r2, [sl]
 8014fb6:	2a00      	cmp	r2, #0
 8014fb8:	f040 823b 	bne.w	8015432 <mcpwm_adc_int_handler+0x912>
 8014fbc:	eef1 6a48 	vneg.f32	s13, s16
 8014fc0:	ee77 7ae6 	vsub.f32	s15, s15, s13
			float step = error * conf->cc_gain * voltage_scale;
 8014fc4:	edd3 6a51 	vldr	s13, [r3, #324]	; 0x144
 8014fc8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8014fcc:	a80a      	add	r0, sp, #40	; 0x28
 8014fce:	ee67 7a87 	vmul.f32	s15, s15, s14
 8014fd2:	ed60 7a01 	vstmdb	r0!, {s15}
			const float start_boost = conf->cc_startup_boost_duty * voltage_scale;
 8014fd6:	ed93 aa4f 	vldr	s20, [r3, #316]	; 0x13c
			utils_truncate_number(&step, -conf->cc_ramp_step_max, conf->cc_ramp_step_max);
 8014fda:	ed93 0a52 	vldr	s0, [r3, #328]	; 0x148
 8014fde:	edd3 0a52 	vldr	s1, [r3, #328]	; 0x148
 8014fe2:	eeb1 0a40 	vneg.f32	s0, s0
			const float start_boost = conf->cc_startup_boost_duty * voltage_scale;
 8014fe6:	ee2a aa07 	vmul.f32	s20, s20, s14
			utils_truncate_number(&step, -conf->cc_ramp_step_max, conf->cc_ramp_step_max);
 8014fea:	f000 fd49 	bl	8015a80 <utils_truncate_number>
			step /= switching_frequency_now / 1000.0;
 8014fee:	ed94 6a00 	vldr	s12, [r4]
 8014ff2:	eddf 7aad 	vldr	s15, [pc, #692]	; 80152a8 <mcpwm_adc_int_handler+0x788>
 8014ff6:	eddd 6a09 	vldr	s13, [sp, #36]	; 0x24
			if (slow_ramping_cycles) {
 8014ffa:	682b      	ldr	r3, [r5, #0]
			step /= switching_frequency_now / 1000.0;
 8014ffc:	ee86 7a27 	vdiv.f32	s14, s12, s15
 8015000:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8015004:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
			if (slow_ramping_cycles) {
 8015008:	b143      	cbz	r3, 801501c <mcpwm_adc_int_handler+0x4fc>
				step *= 0.1;
 801500a:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 80152ac <mcpwm_adc_int_handler+0x78c>
				slow_ramping_cycles--;
 801500e:	682b      	ldr	r3, [r5, #0]
				step *= 0.1;
 8015010:	ee67 7a87 	vmul.f32	s15, s15, s14
				slow_ramping_cycles--;
 8015014:	3b01      	subs	r3, #1
				step *= 0.1;
 8015016:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
				slow_ramping_cycles--;
 801501a:	602b      	str	r3, [r5, #0]
			if (fabsf(dutycycle_now_tmp) < start_boost) {
 801501c:	eddd 7a08 	vldr	s15, [sp, #32]
 8015020:	eeb0 7ae7 	vabs.f32	s14, s15
 8015024:	eeb4 7aca 	vcmpe.f32	s14, s20
 8015028:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801502c:	f140 8204 	bpl.w	8015438 <mcpwm_adc_int_handler+0x918>
						current_set > 0.0 ?
 8015030:	edd6 7a00 	vldr	s15, [r6]
				utils_step_towards(&dutycycle_now_tmp,
 8015034:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801503c:	bfd8      	it	le
 801503e:	eeb1 aa4a 	vnegle.f32	s20, s20
 8015042:	ac08      	add	r4, sp, #32
 8015044:	eef0 0a6a 	vmov.f32	s1, s21
 8015048:	eeb0 0a4a 	vmov.f32	s0, s20
 801504c:	4620      	mov	r0, r4
 801504e:	f000 fca7 	bl	80159a0 <utils_step_towards>
			utils_truncate_number((float*)&dutycycle_now_tmp, -conf->l_max_duty, conf->l_max_duty);
 8015052:	f8d8 3000 	ldr.w	r3, [r8]
 8015056:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
 801505a:	edd3 0a16 	vldr	s1, [r3, #88]	; 0x58
 801505e:	4620      	mov	r0, r4
 8015060:	eeb1 0a40 	vneg.f32	s0, s0
 8015064:	f000 fd0c 	bl	8015a80 <utils_truncate_number>
			if (fabsf(dutycycle_now_tmp) < conf->l_min_duty) {
 8015068:	f8d8 3000 	ldr.w	r3, [r8]
 801506c:	eddd 7a08 	vldr	s15, [sp, #32]
 8015070:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8015074:	eef0 6ae7 	vabs.f32	s13, s15
 8015078:	eef4 6ac7 	vcmpe.f32	s13, s14
 801507c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015080:	d517      	bpl.n	80150b2 <mcpwm_adc_int_handler+0x592>
				if (dutycycle_now_tmp < 0.0 && current_set > 0.0) {
 8015082:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015086:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801508a:	f100 8246 	bmi.w	801551a <mcpwm_adc_int_handler+0x9fa>
				} else if (dutycycle_now_tmp > 0.0 && current_set < 0.0) {
 801508e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015096:	dd0c      	ble.n	80150b2 <mcpwm_adc_int_handler+0x592>
 8015098:	edd6 7a00 	vldr	s15, [r6]
 801509c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80150a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150a4:	d50b      	bpl.n	80150be <mcpwm_adc_int_handler+0x59e>
					dutycycle_now_tmp = -conf->l_min_duty;
 80150a6:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80150aa:	eef1 7a67 	vneg.f32	s15, s15
 80150ae:	edcd 7a08 	vstr	s15, [sp, #32]
			dutycycle_set = dutycycle_now_tmp >= 0.0 ? conf->l_min_duty : -conf->l_min_duty;
 80150b2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80150b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150ba:	f2c0 8248 	blt.w	801554e <mcpwm_adc_int_handler+0xa2e>
 80150be:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80150c2:	4a7b      	ldr	r2, [pc, #492]	; (80152b0 <mcpwm_adc_int_handler+0x790>)
 80150c4:	edc2 7a00 	vstr	s15, [r2]
		if (current_nofilter > conf->lo_current_max) {
 80150c8:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 80150cc:	eef4 7ac8 	vcmpe.f32	s15, s16
 80150d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150d4:	f100 81e3 	bmi.w	801549e <mcpwm_adc_int_handler+0x97e>
		} else if (current_nofilter < conf->lo_current_min) {
 80150d8:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 80150dc:	eef4 7ac8 	vcmpe.f32	s15, s16
 80150e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150e4:	f340 81b2 	ble.w	801544c <mcpwm_adc_int_handler+0x92c>
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 80150e8:	f8da 2000 	ldr.w	r2, [sl]
 80150ec:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
 80150f0:	2a00      	cmp	r2, #0
 80150f2:	f000 820f 	beq.w	8015514 <mcpwm_adc_int_handler+0x9f4>
					ramp_step_no_lim * fabsf(current_nofilter - conf->lo_current_min) * conf->m_current_backoff_gain);
 80150f6:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 80150fa:	edd3 0a55 	vldr	s1, [r3, #340]	; 0x154
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 80150fe:	486d      	ldr	r0, [pc, #436]	; (80152b4 <mcpwm_adc_int_handler+0x794>)
					ramp_step_no_lim * fabsf(current_nofilter - conf->lo_current_min) * conf->m_current_backoff_gain);
 8015100:	ee78 7a67 	vsub.f32	s15, s16, s15
 8015104:	eef0 7ae7 	vabs.f32	s15, s15
 8015108:	ee67 7aa9 	vmul.f32	s15, s15, s19
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 801510c:	ee67 0aa0 	vmul.f32	s1, s15, s1
 8015110:	f000 fc46 	bl	80159a0 <utils_step_towards>
 8015114:	4968      	ldr	r1, [pc, #416]	; (80152b8 <mcpwm_adc_int_handler+0x798>)
					dutycycle_now_tmp = SIGN(dutycycle_now_tmp) * conf->l_min_duty;
 8015116:	2200      	movs	r2, #0
 8015118:	f8d8 3000 	ldr.w	r3, [r8]
			limit_delay--;
 801511c:	600a      	str	r2, [r1, #0]
		if (fabsf(dutycycle_now) < conf->l_min_duty) {
 801511e:	edd7 7a00 	vldr	s15, [r7]
 8015122:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8015126:	eef0 7ae7 	vabs.f32	s15, s15
 801512a:	eef4 7ac7 	vcmpe.f32	s15, s14
 801512e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015132:	d51b      	bpl.n	801516c <mcpwm_adc_int_handler+0x64c>
			if (dutycycle_set >= conf->l_min_duty) {
 8015134:	4a5e      	ldr	r2, [pc, #376]	; (80152b0 <mcpwm_adc_int_handler+0x790>)
 8015136:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 801513a:	edd2 7a00 	vldr	s15, [r2]
 801513e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015146:	f240 81cc 	bls.w	80154e2 <mcpwm_adc_int_handler+0x9c2>
			} else if (dutycycle_set <= -conf->l_min_duty) {
 801514a:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801514e:	ed92 7a00 	vldr	s14, [r2]
 8015152:	eef1 7a67 	vneg.f32	s15, s15
 8015156:	eef4 7ac7 	vcmpe.f32	s15, s14
 801515a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801515e:	db05      	blt.n	801516c <mcpwm_adc_int_handler+0x64c>
				dutycycle_now = -conf->l_min_duty;
 8015160:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8015164:	eef1 7a67 	vneg.f32	s15, s15
 8015168:	edc7 7a00 	vstr	s15, [r7]
		if (dutycycle_now >= conf->l_min_duty && rpm < -conf->l_max_erpm_fbrake) {
 801516c:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 8015170:	edd7 7a00 	vldr	s15, [r7]
 8015174:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015178:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801517c:	d809      	bhi.n	8015192 <mcpwm_adc_int_handler+0x672>
 801517e:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8015182:	eef1 7a67 	vneg.f32	s15, s15
 8015186:	eef4 7ac9 	vcmpe.f32	s15, s18
 801518a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801518e:	f300 81a1 	bgt.w	80154d4 <mcpwm_adc_int_handler+0x9b4>
		} else if (dutycycle_now <= -conf->l_min_duty && rpm > conf->l_max_erpm_fbrake) {
 8015192:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8015196:	ed97 7a00 	vldr	s14, [r7]
 801519a:	eef1 7a67 	vneg.f32	s15, s15
 801519e:	eef4 7ac7 	vcmpe.f32	s15, s14
 80151a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80151a6:	db08      	blt.n	80151ba <mcpwm_adc_int_handler+0x69a>
 80151a8:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 80151ac:	eef4 7ac9 	vcmpe.f32	s15, s18
 80151b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			dutycycle_now = conf->l_min_duty;
 80151b4:	bf44      	itt	mi
 80151b6:	6d5b      	ldrmi	r3, [r3, #84]	; 0x54
 80151b8:	603b      	strmi	r3, [r7, #0]
		set_duty_cycle_ll(dutycycle_now);
 80151ba:	ed97 0a00 	vldr	s0, [r7]
 80151be:	f7ff f8ef 	bl	80143a0 <set_duty_cycle_ll>
 80151c2:	e57f      	b.n	8014cc4 <mcpwm_adc_int_handler+0x1a4>
		if (state == MC_STATE_RUNNING && !has_commutated) {
 80151c4:	6834      	ldr	r4, [r6, #0]
 80151c6:	2c00      	cmp	r4, #0
 80151c8:	f47f ad73 	bne.w	8014cb2 <mcpwm_adc_int_handler+0x192>
			set_next_comm_step(comm_step);
 80151cc:	4b3b      	ldr	r3, [pc, #236]	; (80152bc <mcpwm_adc_int_handler+0x79c>)
 80151ce:	6818      	ldr	r0, [r3, #0]
 80151d0:	f7fd fbe6 	bl	80129a0 <set_next_comm_step>
			commutate(0);
 80151d4:	4620      	mov	r0, r4
 80151d6:	f7fd fe93 	bl	8012f00 <commutate>
 80151da:	e56a      	b.n	8014cb2 <mcpwm_adc_int_handler+0x192>
			amp = sqrtf((float)(ph1*ph1 + ph2*ph2 + ph3*ph3)) * sqrtf(2.0);
 80151dc:	9b03      	ldr	r3, [sp, #12]
 80151de:	9a02      	ldr	r2, [sp, #8]
 80151e0:	fb03 f303 	mul.w	r3, r3, r3
 80151e4:	fb02 3302 	mla	r3, r2, r2, r3
 80151e8:	fb0b 330b 	mla	r3, fp, fp, r3
 80151ec:	ee00 3a10 	vmov	s0, r3
 80151f0:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80151f4:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80151f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80151fc:	eeb1 8ac0 	vsqrt.f32	s16, s0
 8015200:	f100 8269 	bmi.w	80156d6 <mcpwm_adc_int_handler+0xbb6>
 8015204:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 80152c0 <mcpwm_adc_int_handler+0x7a0>
 8015208:	ee28 0a00 	vmul.f32	s0, s16, s0
 801520c:	e4f6      	b.n	8014bfc <mcpwm_adc_int_handler+0xdc>
			if (comm_step != hall_phase) {
 801520e:	4c2b      	ldr	r4, [pc, #172]	; (80152bc <mcpwm_adc_int_handler+0x79c>)
			const int hall_phase = mcpwm_read_hall_phase();
 8015210:	f7ff f8a6 	bl	8014360 <mcpwm_read_hall_phase>
			if (comm_step != hall_phase) {
 8015214:	6823      	ldr	r3, [r4, #0]
 8015216:	4283      	cmp	r3, r0
 8015218:	f000 80b1 	beq.w	801537e <mcpwm_adc_int_handler+0x85e>
				comm_step = hall_phase;
 801521c:	6020      	str	r0, [r4, #0]
				update_rpm_tacho();
 801521e:	f7fd fa2f 	bl	8012680 <update_rpm_tacho>
				if (state == MC_STATE_RUNNING) {
 8015222:	782b      	ldrb	r3, [r5, #0]
 8015224:	2b02      	cmp	r3, #2
 8015226:	f47f ad44 	bne.w	8014cb2 <mcpwm_adc_int_handler+0x192>
 801522a:	e0b2      	b.n	8015392 <mcpwm_adc_int_handler+0x872>
				if (v_diff > 0) {
 801522c:	f1bb 0f00 	cmp.w	fp, #0
 8015230:	dd35      	ble.n	801529e <mcpwm_adc_int_handler+0x77e>
					int min = (int)((1.0 - fabsf(dutycycle_now)) * (float)ADC_Value[ADC_IND_VIN_SENS] * 0.3);
 8015232:	ed97 7a00 	vldr	s14, [r7]
 8015236:	8a23      	ldrh	r3, [r4, #16]
 8015238:	ed9f 6a22 	vldr	s12, [pc, #136]	; 80152c4 <mcpwm_adc_int_handler+0x7a4>
					if (min > ADC_Value[ADC_IND_VIN_SENS] / 4) {
 801523c:	8a21      	ldrh	r1, [r4, #16]
					int min = (int)((1.0 - fabsf(dutycycle_now)) * (float)ADC_Value[ADC_IND_VIN_SENS] * 0.3);
 801523e:	ee07 3a90 	vmov	s15, r3
 8015242:	eef0 6ac7 	vabs.f32	s13, s14
 8015246:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801524a:	ee37 7a66 	vsub.f32	s14, s14, s13
 801524e:	eef8 7a67 	vcvt.f32.u32	s15, s15
					if (pwm_cycles_sum > (last_pwm_cycles_sum / 2.0) ||
 8015252:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
					int min = (int)((1.0 - fabsf(dutycycle_now)) * (float)ADC_Value[ADC_IND_VIN_SENS] * 0.3);
 8015256:	ee67 7a27 	vmul.f32	s15, s14, s15
 801525a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801525e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8015262:	ee17 3a90 	vmov	r3, s15
					if (min > ADC_Value[ADC_IND_VIN_SENS] / 4) {
 8015266:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
					if (pwm_cycles_sum > (last_pwm_cycles_sum / 2.0) ||
 801526a:	4917      	ldr	r1, [pc, #92]	; (80152c8 <mcpwm_adc_int_handler+0x7a8>)
						min = ADC_Value[ADC_IND_VIN_SENS] / 4;
 801526c:	bfc8      	it	gt
 801526e:	8a23      	ldrhgt	r3, [r4, #16]
					if (pwm_cycles_sum > (last_pwm_cycles_sum / 2.0) ||
 8015270:	edd1 7a00 	vldr	s15, [r1]
 8015274:	ed99 7a00 	vldr	s14, [r9]
 8015278:	ee67 7aa6 	vmul.f32	s15, s15, s13
						min = ADC_Value[ADC_IND_VIN_SENS] / 4;
 801527c:	bfc8      	it	gt
 801527e:	089b      	lsrgt	r3, r3, #2
					if (pwm_cycles_sum > (last_pwm_cycles_sum / 2.0) ||
 8015280:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015284:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015288:	d422      	bmi.n	80152d0 <mcpwm_adc_int_handler+0x7b0>
							!has_commutated || (ph_now_raw > min && ph_now_raw < (ADC_Value[ADC_IND_VIN_SENS] - min))) {
 801528a:	6831      	ldr	r1, [r6, #0]
					if (pwm_cycles_sum > (last_pwm_cycles_sum / 2.0) ||
 801528c:	b301      	cbz	r1, 80152d0 <mcpwm_adc_int_handler+0x7b0>
							!has_commutated || (ph_now_raw > min && ph_now_raw < (ADC_Value[ADC_IND_VIN_SENS] - min))) {
 801528e:	9905      	ldr	r1, [sp, #20]
 8015290:	428b      	cmp	r3, r1
 8015292:	da04      	bge.n	801529e <mcpwm_adc_int_handler+0x77e>
 8015294:	8a21      	ldrh	r1, [r4, #16]
 8015296:	1acb      	subs	r3, r1, r3
 8015298:	9905      	ldr	r1, [sp, #20]
 801529a:	428b      	cmp	r3, r1
 801529c:	dc18      	bgt.n	80152d0 <mcpwm_adc_int_handler+0x7b0>
 801529e:	4c0b      	ldr	r4, [pc, #44]	; (80152cc <mcpwm_adc_int_handler+0x7ac>)
 80152a0:	e026      	b.n	80152f0 <mcpwm_adc_int_handler+0x7d0>
 80152a2:	bf00      	nop
 80152a4:	20004df4 	.word	0x20004df4
 80152a8:	447a0000 	.word	0x447a0000
 80152ac:	3dcccccd 	.word	0x3dcccccd
 80152b0:	20004e20 	.word	0x20004e20
 80152b4:	20004e1c 	.word	0x20004e1c
 80152b8:	2000538c 	.word	0x2000538c
 80152bc:	20004d4c 	.word	0x20004d4c
 80152c0:	3fb504f3 	.word	0x3fb504f3
 80152c4:	3e99999a 	.word	0x3e99999a
 80152c8:	2000536c 	.word	0x2000536c
 80152cc:	200059f8 	.word	0x200059f8
						cycle_integrator += (float)v_diff / switching_frequency_now;
 80152d0:	ee07 ba90 	vmov	s15, fp
 80152d4:	4ca4      	ldr	r4, [pc, #656]	; (8015568 <mcpwm_adc_int_handler+0xa48>)
 80152d6:	4ba5      	ldr	r3, [pc, #660]	; (801556c <mcpwm_adc_int_handler+0xa4c>)
 80152d8:	edd4 6a00 	vldr	s13, [r4]
 80152dc:	ed93 7a00 	vldr	s14, [r3]
 80152e0:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 80152e4:	eec6 7a26 	vdiv.f32	s15, s12, s13
 80152e8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80152ec:	edc3 7a00 	vstr	s15, [r3]
				if (conf->comm_mode == COMM_MODE_INTEGRATE) {
 80152f0:	7853      	ldrb	r3, [r2, #1]
 80152f2:	2b00      	cmp	r3, #0
 80152f4:	f43f ae0b 	beq.w	8014f0e <mcpwm_adc_int_handler+0x3ee>
				} else if (conf->comm_mode == COMM_MODE_DELAY) {
 80152f8:	7850      	ldrb	r0, [r2, #1]
 80152fa:	b2c0      	uxtb	r0, r0
 80152fc:	2801      	cmp	r0, #1
 80152fe:	f47f acb3 	bne.w	8014c68 <mcpwm_adc_int_handler+0x148>
					if (v_diff > 0) {
 8015302:	f1bb 0f00 	cmp.w	fp, #0
 8015306:	9002      	str	r0, [sp, #8]
 8015308:	f340 80dd 	ble.w	80154c6 <mcpwm_adc_int_handler+0x9a6>
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 801530c:	edd2 5a5a 	vldr	s11, [r2, #360]	; 0x168
 8015310:	edd4 6a00 	vldr	s13, [r4]
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 8015314:	4b96      	ldr	r3, [pc, #600]	; (8015570 <mcpwm_adc_int_handler+0xa50>)
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8015316:	f8df b27c 	ldr.w	fp, [pc, #636]	; 8015594 <mcpwm_adc_int_handler+0xa74>
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 801531a:	ed93 0a00 	vldr	s0, [r3]
								conf->sl_cycle_int_rpm_br, rpm_dep.comm_time_sum / 2.0,
 801531e:	4b95      	ldr	r3, [pc, #596]	; (8015574 <mcpwm_adc_int_handler+0xa54>)
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 8015320:	ed92 1a24 	vldr	s2, [r2, #144]	; 0x90
								conf->sl_cycle_int_rpm_br, rpm_dep.comm_time_sum / 2.0,
 8015324:	edd3 1a03 	vldr	s3, [r3, #12]
								(rpm_dep.comm_time_sum / 2.0) * conf->sl_phase_advance_at_br)) {
 8015328:	ed93 7a03 	vldr	s14, [r3, #12]
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 801532c:	eddb 7a00 	vldr	s15, [fp]
								(rpm_dep.comm_time_sum / 2.0) * conf->sl_phase_advance_at_br)) {
 8015330:	ed92 2a23 	vldr	s4, [r2, #140]	; 0x8c
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 8015334:	ed9f 8a90 	vldr	s16, [pc, #576]	; 8015578 <mcpwm_adc_int_handler+0xa58>
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8015338:	ee85 6aa6 	vdiv.f32	s12, s11, s13
								(rpm_dep.comm_time_sum / 2.0) * conf->sl_phase_advance_at_br)) {
 801533c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8015340:	ee27 7a26 	vmul.f32	s14, s14, s13
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8015344:	ee77 7a86 	vadd.f32	s15, s15, s12
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 8015348:	eeb0 0ac0 	vabs.f32	s0, s0
 801534c:	ee61 1aa6 	vmul.f32	s3, s3, s13
 8015350:	ee27 2a02 	vmul.f32	s4, s14, s4
 8015354:	eef0 0a48 	vmov.f32	s1, s16
						cycle_sum += conf->m_bldc_f_sw_max / switching_frequency_now;
 8015358:	edcb 7a00 	vstr	s15, [fp]
						if (cycle_sum >= utils_map(fabsf(rpm_now), 0,
 801535c:	f000 fbd0 	bl	8015b00 <utils_map>
 8015360:	eddb 7a00 	vldr	s15, [fp]
 8015364:	9802      	ldr	r0, [sp, #8]
 8015366:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801536a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801536e:	f240 817e 	bls.w	801566e <mcpwm_adc_int_handler+0xb4e>
 8015372:	f8d8 2000 	ldr.w	r2, [r8]
 8015376:	e477      	b.n	8014c68 <mcpwm_adc_int_handler+0x148>
		float ramp_step = conf->m_duty_ramp_step / (switching_frequency_now / 1000.0);
 8015378:	eef0 aa69 	vmov.f32	s21, s19
 801537c:	e575      	b.n	8014e6a <mcpwm_adc_int_handler+0x34a>
			} else if (state == MC_STATE_RUNNING && !has_commutated) {
 801537e:	782b      	ldrb	r3, [r5, #0]
 8015380:	2b02      	cmp	r3, #2
 8015382:	f47f ac96 	bne.w	8014cb2 <mcpwm_adc_int_handler+0x192>
 8015386:	f8d6 9000 	ldr.w	r9, [r6]
 801538a:	f1b9 0f00 	cmp.w	r9, #0
 801538e:	f47f ac90 	bne.w	8014cb2 <mcpwm_adc_int_handler+0x192>
				set_next_comm_step(comm_step);
 8015392:	6820      	ldr	r0, [r4, #0]
 8015394:	f7fd fb04 	bl	80129a0 <set_next_comm_step>
				commutate(0);
 8015398:	4648      	mov	r0, r9
 801539a:	f7fd fdb1 	bl	8012f00 <commutate>
 801539e:	e488      	b.n	8014cb2 <mcpwm_adc_int_handler+0x192>
		run_pid_control_pos(1.0 / switching_frequency_now);
 80153a0:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 80153a4:	eec9 8a27 	vdiv.f32	s17, s18, s15
	float error = utils_angle_difference(encoder_read_deg(), pos_pid_set_pos);
 80153a8:	f005 fc8a 	bl	801acc0 <encoder_read_deg>
 80153ac:	4b73      	ldr	r3, [pc, #460]	; (801557c <mcpwm_adc_int_handler+0xa5c>)
	i_term += error * (conf->p_pid_ki * dt);
 80153ae:	4c74      	ldr	r4, [pc, #464]	; (8015580 <mcpwm_adc_int_handler+0xa60>)
	d_term = (error - prev_error) * (conf->p_pid_kd / dt);
 80153b0:	4d74      	ldr	r5, [pc, #464]	; (8015584 <mcpwm_adc_int_handler+0xa64>)
	float error = utils_angle_difference(encoder_read_deg(), pos_pid_set_pos);
 80153b2:	edd3 0a00 	vldr	s1, [r3]
 80153b6:	f000 fbdb 	bl	8015b70 <utils_angle_difference>
	p_term = error * conf->p_pid_kp;
 80153ba:	f8d8 3000 	ldr.w	r3, [r8]
	i_term += error * (conf->p_pid_ki * dt);
 80153be:	ed94 7a00 	vldr	s14, [r4]
	p_term = error * conf->p_pid_kp;
 80153c2:	ed93 aa4b 	vldr	s20, [r3, #300]	; 0x12c
	i_term += error * (conf->p_pid_ki * dt);
 80153c6:	edd3 6a4c 	vldr	s13, [r3, #304]	; 0x130
	d_term = (error - prev_error) * (conf->p_pid_kd / dt);
 80153ca:	ed93 6a4d 	vldr	s12, [r3, #308]	; 0x134
 80153ce:	edd5 7a00 	vldr	s15, [r5]
 80153d2:	eec6 9a28 	vdiv.f32	s19, s12, s17
	utils_truncate_number(&i_term, -1.0, 1.0);
 80153d6:	4620      	mov	r0, r4
	i_term += error * (conf->p_pid_ki * dt);
 80153d8:	ee68 8aa6 	vmul.f32	s17, s17, s13
	float error = utils_angle_difference(encoder_read_deg(), pos_pid_set_pos);
 80153dc:	eeb0 8a40 	vmov.f32	s16, s0
	i_term += error * (conf->p_pid_ki * dt);
 80153e0:	eea0 7a28 	vfma.f32	s14, s0, s17
	utils_truncate_number(&i_term, -1.0, 1.0);
 80153e4:	eef0 0a49 	vmov.f32	s1, s18
 80153e8:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	i_term += error * (conf->p_pid_ki * dt);
 80153ec:	ed84 7a00 	vstr	s14, [r4]
	d_term = (error - prev_error) * (conf->p_pid_kd / dt);
 80153f0:	ee78 8a67 	vsub.f32	s17, s16, s15
	utils_truncate_number(&i_term, -1.0, 1.0);
 80153f4:	f000 fb44 	bl	8015a80 <utils_truncate_number>
	float output = p_term + i_term + d_term;
 80153f8:	edd4 7a00 	vldr	s15, [r4]
	prev_error = error;
 80153fc:	ed85 8a00 	vstr	s16, [r5]
	float output = p_term + i_term + d_term;
 8015400:	eee8 7a0a 	vfma.f32	s15, s16, s20
 8015404:	a80a      	add	r0, sp, #40	; 0x28
	utils_truncate_number(&output, -1.0, 1.0);
 8015406:	eef0 0a49 	vmov.f32	s1, s18
	float output = p_term + i_term + d_term;
 801540a:	eee8 7aa9 	vfma.f32	s15, s17, s19
	utils_truncate_number(&output, -1.0, 1.0);
 801540e:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	float output = p_term + i_term + d_term;
 8015412:	ed60 7a01 	vstmdb	r0!, {s15}
	utils_truncate_number(&output, -1.0, 1.0);
 8015416:	f000 fb33 	bl	8015a80 <utils_truncate_number>
	current_set = output * conf->lo_current_max;
 801541a:	f8d8 3000 	ldr.w	r3, [r8]
 801541e:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
 8015422:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 8015426:	4b58      	ldr	r3, [pc, #352]	; (8015588 <mcpwm_adc_int_handler+0xa68>)
 8015428:	ee67 7a87 	vmul.f32	s15, s15, s14
 801542c:	edc3 7a00 	vstr	s15, [r3]
 8015430:	e44e      	b.n	8014cd0 <mcpwm_adc_int_handler+0x1b0>
			const float error = current_set - (direction ? current_nofilter : -current_nofilter);
 8015432:	eef0 6a48 	vmov.f32	s13, s16
 8015436:	e5c3      	b.n	8014fc0 <mcpwm_adc_int_handler+0x4a0>
				dutycycle_now_tmp += step;
 8015438:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
 801543c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8015440:	ac0a      	add	r4, sp, #40	; 0x28
 8015442:	ee17 3a90 	vmov	r3, s15
 8015446:	f844 3d08 	str.w	r3, [r4, #-8]!
 801544a:	e602      	b.n	8015052 <mcpwm_adc_int_handler+0x532>
	const float current_in_nofilter = current_nofilter * fabsf(dutycycle_now);
 801544c:	eef0 8ae8 	vabs.f32	s17, s17
 8015450:	ee28 8a88 	vmul.f32	s16, s17, s16
		} else if (current_in_nofilter > conf->lo_in_current_max) {
 8015454:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 8015458:	eef4 7ac8 	vcmpe.f32	s15, s16
 801545c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015460:	d46e      	bmi.n	8015540 <mcpwm_adc_int_handler+0xa20>
		} else if (current_in_nofilter < conf->lo_in_current_min) {
 8015462:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 8015466:	eef4 7ac8 	vcmpe.f32	s15, s16
 801546a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801546e:	dd73      	ble.n	8015558 <mcpwm_adc_int_handler+0xa38>
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 8015470:	f8da 2000 	ldr.w	r2, [sl]
 8015474:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
 8015478:	b90a      	cbnz	r2, 801547e <mcpwm_adc_int_handler+0x95e>
 801547a:	eeb1 0a40 	vneg.f32	s0, s0
					ramp_step_no_lim * fabsf(current_in_nofilter - conf->lo_in_current_min) * conf->m_current_backoff_gain);
 801547e:	edd3 7a1c 	vldr	s15, [r3, #112]	; 0x70
 8015482:	edd3 0a55 	vldr	s1, [r3, #340]	; 0x154
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 8015486:	4841      	ldr	r0, [pc, #260]	; (801558c <mcpwm_adc_int_handler+0xa6c>)
					ramp_step_no_lim * fabsf(current_in_nofilter - conf->lo_in_current_min) * conf->m_current_backoff_gain);
 8015488:	ee38 8a67 	vsub.f32	s16, s16, s15
 801548c:	eef0 7ac8 	vabs.f32	s15, s16
 8015490:	ee67 7aa9 	vmul.f32	s15, s15, s19
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 8015494:	ee67 0aa0 	vmul.f32	s1, s15, s1
 8015498:	f000 fa82 	bl	80159a0 <utils_step_towards>
 801549c:	e63a      	b.n	8015114 <mcpwm_adc_int_handler+0x5f4>
					ramp_step_no_lim * fabsf(current_nofilter - conf->lo_current_max) * conf->m_current_backoff_gain);
 801549e:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
			utils_step_towards((float*) &dutycycle_now, 0.0,
 80154a2:	ed9f 0a35 	vldr	s0, [pc, #212]	; 8015578 <mcpwm_adc_int_handler+0xa58>
					ramp_step_no_lim * fabsf(current_nofilter - conf->lo_current_max) * conf->m_current_backoff_gain);
 80154a6:	edd3 0a55 	vldr	s1, [r3, #340]	; 0x154
 80154aa:	e628      	b.n	80150fe <mcpwm_adc_int_handler+0x5de>
						limit = rpm_dep.cycle_int_limit * (0.0005 * VDIV_CORR);
 80154ac:	4b31      	ldr	r3, [pc, #196]	; (8015574 <mcpwm_adc_int_handler+0xa54>)
 80154ae:	eddf 7a38 	vldr	s15, [pc, #224]	; 8015590 <mcpwm_adc_int_handler+0xa70>
 80154b2:	ed93 7a00 	vldr	s14, [r3]
 80154b6:	ee27 7a27 	vmul.f32	s14, s14, s15
 80154ba:	e533      	b.n	8014f24 <mcpwm_adc_int_handler+0x404>
				} else if (conf->comm_mode == COMM_MODE_DELAY) {
 80154bc:	7853      	ldrb	r3, [r2, #1]
 80154be:	4c2a      	ldr	r4, [pc, #168]	; (8015568 <mcpwm_adc_int_handler+0xa48>)
 80154c0:	2b01      	cmp	r3, #1
 80154c2:	f47f abd1 	bne.w	8014c68 <mcpwm_adc_int_handler+0x148>
						cycle_integrator = 0.0;
 80154c6:	4829      	ldr	r0, [pc, #164]	; (801556c <mcpwm_adc_int_handler+0xa4c>)
						cycle_sum = 0.0;
 80154c8:	4932      	ldr	r1, [pc, #200]	; (8015594 <mcpwm_adc_int_handler+0xa74>)
						cycle_integrator = 0.0;
 80154ca:	2300      	movs	r3, #0
 80154cc:	6003      	str	r3, [r0, #0]
						cycle_sum = 0.0;
 80154ce:	600b      	str	r3, [r1, #0]
 80154d0:	f7ff bbca 	b.w	8014c68 <mcpwm_adc_int_handler+0x148>
			dutycycle_now = -conf->l_min_duty;
 80154d4:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80154d8:	eef1 7a67 	vneg.f32	s15, s15
 80154dc:	edc7 7a00 	vstr	s15, [r7]
 80154e0:	e66b      	b.n	80151ba <mcpwm_adc_int_handler+0x69a>
				dutycycle_now = conf->l_min_duty;
 80154e2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80154e4:	603a      	str	r2, [r7, #0]
 80154e6:	e641      	b.n	801516c <mcpwm_adc_int_handler+0x64c>
					ph_now_raw = ph1_raw;
 80154e8:	9b06      	ldr	r3, [sp, #24]
 80154ea:	9305      	str	r3, [sp, #20]
					v_diff = ph1;
 80154ec:	f8dd b008 	ldr.w	fp, [sp, #8]
 80154f0:	e4e3      	b.n	8014eba <mcpwm_adc_int_handler+0x39a>
					v_diff = -ph2;
 80154f2:	9b03      	ldr	r3, [sp, #12]
 80154f4:	f1c3 0b00 	rsb	fp, r3, #0
					ph_now_raw = ph2_raw;
 80154f8:	9b07      	ldr	r3, [sp, #28]
 80154fa:	9305      	str	r3, [sp, #20]
					break;
 80154fc:	e4dd      	b.n	8014eba <mcpwm_adc_int_handler+0x39a>
					v_diff = -ph1;
 80154fe:	9b02      	ldr	r3, [sp, #8]
 8015500:	f1c3 0b00 	rsb	fp, r3, #0
					ph_now_raw = ph1_raw;
 8015504:	9b06      	ldr	r3, [sp, #24]
 8015506:	9305      	str	r3, [sp, #20]
					break;
 8015508:	e4d7      	b.n	8014eba <mcpwm_adc_int_handler+0x39a>
					ph_now_raw = ph2_raw;
 801550a:	9b07      	ldr	r3, [sp, #28]
 801550c:	9305      	str	r3, [sp, #20]
					v_diff = ph2;
 801550e:	f8dd b00c 	ldr.w	fp, [sp, #12]
					break;
 8015512:	e4d2      	b.n	8014eba <mcpwm_adc_int_handler+0x39a>
			utils_step_towards((float*) &dutycycle_now, direction ? conf->l_max_duty : -conf->l_max_duty,
 8015514:	eeb1 0a40 	vneg.f32	s0, s0
 8015518:	e5ed      	b.n	80150f6 <mcpwm_adc_int_handler+0x5d6>
				if (dutycycle_now_tmp < 0.0 && current_set > 0.0) {
 801551a:	ed96 7a00 	vldr	s14, [r6]
 801551e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8015522:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015526:	f77f adb2 	ble.w	801508e <mcpwm_adc_int_handler+0x56e>
					dutycycle_now_tmp = conf->l_min_duty;
 801552a:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801552e:	edcd 7a08 	vstr	s15, [sp, #32]
 8015532:	e5be      	b.n	80150b2 <mcpwm_adc_int_handler+0x592>
						commutate(1);
 8015534:	f7fd fce4 	bl	8012f00 <commutate>
 8015538:	f8d8 2000 	ldr.w	r2, [r8]
 801553c:	f7ff bb85 	b.w	8014c4a <mcpwm_adc_int_handler+0x12a>
					ramp_step_no_lim * fabsf(current_in_nofilter - conf->lo_in_current_max) * conf->m_current_backoff_gain);
 8015540:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
			utils_step_towards((float*) &dutycycle_now, 0.0,
 8015544:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 8015578 <mcpwm_adc_int_handler+0xa58>
					ramp_step_no_lim * fabsf(current_in_nofilter - conf->lo_in_current_max) * conf->m_current_backoff_gain);
 8015548:	edd3 0a55 	vldr	s1, [r3, #340]	; 0x154
 801554c:	e79b      	b.n	8015486 <mcpwm_adc_int_handler+0x966>
			dutycycle_set = dutycycle_now_tmp >= 0.0 ? conf->l_min_duty : -conf->l_min_duty;
 801554e:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8015552:	eef1 7a67 	vneg.f32	s15, s15
 8015556:	e5b4      	b.n	80150c2 <mcpwm_adc_int_handler+0x5a2>
		if (limit_delay > 0) {
 8015558:	490f      	ldr	r1, [pc, #60]	; (8015598 <mcpwm_adc_int_handler+0xa78>)
 801555a:	680a      	ldr	r2, [r1, #0]
 801555c:	2a00      	cmp	r2, #0
 801555e:	f300 80bd 	bgt.w	80156dc <mcpwm_adc_int_handler+0xbbc>
			dutycycle_now = dutycycle_now_tmp;
 8015562:	9a08      	ldr	r2, [sp, #32]
 8015564:	603a      	str	r2, [r7, #0]
 8015566:	e5da      	b.n	801511e <mcpwm_adc_int_handler+0x5fe>
 8015568:	200059f8 	.word	0x200059f8
 801556c:	20004df8 	.word	0x20004df8
 8015570:	20005444 	.word	0x20005444
 8015574:	20005424 	.word	0x20005424
 8015578:	00000000 	.word	0x00000000
 801557c:	2000540c 	.word	0x2000540c
 8015580:	20004f4c 	.word	0x20004f4c
 8015584:	20005414 	.word	0x20005414
 8015588:	20004df4 	.word	0x20004df4
 801558c:	20004e1c 	.word	0x20004e1c
 8015590:	39dff7bb 	.word	0x39dff7bb
 8015594:	20004e04 	.word	0x20004e04
 8015598:	2000538c 	.word	0x2000538c
			const float error = -fabsf(current_set) - current_nofilter;
 801559c:	4a54      	ldr	r2, [pc, #336]	; (80156f0 <mcpwm_adc_int_handler+0xbd0>)
 801559e:	ed92 aa00 	vldr	s20, [r2]
			float step = error * conf->cc_gain * voltage_scale;
 80155a2:	edd3 7a51 	vldr	s15, [r3, #324]	; 0x144
			const float error = -fabsf(current_set) - current_nofilter;
 80155a6:	eeb0 aaca 	vabs.f32	s20, s20
 80155aa:	eeb1 aa4a 	vneg.f32	s20, s20
 80155ae:	ee3a aa48 	vsub.f32	s20, s20, s16
			float step = error * conf->cc_gain * voltage_scale;
 80155b2:	a80a      	add	r0, sp, #40	; 0x28
 80155b4:	ee2a aa27 	vmul.f32	s20, s20, s15
 80155b8:	ee2a aa07 	vmul.f32	s20, s20, s14
 80155bc:	ed20 aa01 	vstmdb	r0!, {s20}
			utils_truncate_number(&step, -conf->cc_ramp_step_max, conf->cc_ramp_step_max);
 80155c0:	ed93 0a52 	vldr	s0, [r3, #328]	; 0x148
 80155c4:	edd3 0a52 	vldr	s1, [r3, #328]	; 0x148
 80155c8:	eeb1 0a40 	vneg.f32	s0, s0
 80155cc:	f000 fa58 	bl	8015a80 <utils_truncate_number>
			step /= switching_frequency_now / 1000.0;
 80155d0:	ed94 6a00 	vldr	s12, [r4]
 80155d4:	eddf 7a47 	vldr	s15, [pc, #284]	; 80156f4 <mcpwm_adc_int_handler+0xbd4>
 80155d8:	eddd 6a09 	vldr	s13, [sp, #36]	; 0x24
			if (slow_ramping_cycles) {
 80155dc:	682b      	ldr	r3, [r5, #0]
			step /= switching_frequency_now / 1000.0;
 80155de:	ee86 7a27 	vdiv.f32	s14, s12, s15
 80155e2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80155e6:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
			if (slow_ramping_cycles) {
 80155ea:	b143      	cbz	r3, 80155fe <mcpwm_adc_int_handler+0xade>
				step *= 0.1;
 80155ec:	ed9f 7a42 	vldr	s14, [pc, #264]	; 80156f8 <mcpwm_adc_int_handler+0xbd8>
				slow_ramping_cycles--;
 80155f0:	682b      	ldr	r3, [r5, #0]
				step *= 0.1;
 80155f2:	ee67 7a87 	vmul.f32	s15, s15, s14
				slow_ramping_cycles--;
 80155f6:	3b01      	subs	r3, #1
				step *= 0.1;
 80155f8:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
				slow_ramping_cycles--;
 80155fc:	602b      	str	r3, [r5, #0]
			dutycycle_now_tmp += SIGN(dutycycle_now_tmp) * step;
 80155fe:	ed9d 7a08 	vldr	s14, [sp, #32]
			utils_truncate_number((float*)&dutycycle_now_tmp, -conf->l_max_duty, conf->l_max_duty);
 8015602:	f8d8 3000 	ldr.w	r3, [r8]
			dutycycle_now_tmp += SIGN(dutycycle_now_tmp) * step;
 8015606:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 801560a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801560e:	bf48      	it	mi
 8015610:	eef1 7a67 	vnegmi.f32	s15, s15
 8015614:	ee77 7a27 	vadd.f32	s15, s14, s15
			utils_truncate_number((float*)&dutycycle_now_tmp, -conf->l_max_duty, conf->l_max_duty);
 8015618:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
 801561c:	edd3 0a16 	vldr	s1, [r3, #88]	; 0x58
			dutycycle_now_tmp += SIGN(dutycycle_now_tmp) * step;
 8015620:	ee17 2a90 	vmov	r2, s15
 8015624:	a80a      	add	r0, sp, #40	; 0x28
			utils_truncate_number((float*)&dutycycle_now_tmp, -conf->l_max_duty, conf->l_max_duty);
 8015626:	eeb1 0a40 	vneg.f32	s0, s0
			dutycycle_now_tmp += SIGN(dutycycle_now_tmp) * step;
 801562a:	f840 2d08 	str.w	r2, [r0, #-8]!
			utils_truncate_number((float*)&dutycycle_now_tmp, -conf->l_max_duty, conf->l_max_duty);
 801562e:	f000 fa27 	bl	8015a80 <utils_truncate_number>
			if (fabsf(dutycycle_now_tmp) < conf->l_min_duty) {
 8015632:	f8d8 3000 	ldr.w	r3, [r8]
 8015636:	eddd 7a08 	vldr	s15, [sp, #32]
 801563a:	ed93 7a15 	vldr	s14, [r3, #84]	; 0x54
 801563e:	eef0 6ae7 	vabs.f32	s13, s15
 8015642:	eef4 6ac7 	vcmpe.f32	s13, s14
 8015646:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801564a:	f57f ad3d 	bpl.w	80150c8 <mcpwm_adc_int_handler+0x5a8>
				if (fabsf(rpm_now) < conf->l_max_erpm_fbrake_cc) {
 801564e:	ed96 7a00 	vldr	s14, [r6]
 8015652:	edd3 6a0a 	vldr	s13, [r3, #40]	; 0x28
 8015656:	eeb0 7ac7 	vabs.f32	s14, s14
 801565a:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801565e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015662:	d523      	bpl.n	80156ac <mcpwm_adc_int_handler+0xb8c>
					dutycycle_set = dutycycle_now_tmp;
 8015664:	4925      	ldr	r1, [pc, #148]	; (80156fc <mcpwm_adc_int_handler+0xbdc>)
					dutycycle_now_tmp = 0.0;
 8015666:	2200      	movs	r2, #0
 8015668:	9208      	str	r2, [sp, #32]
					dutycycle_set = dutycycle_now_tmp;
 801566a:	600a      	str	r2, [r1, #0]
 801566c:	e52c      	b.n	80150c8 <mcpwm_adc_int_handler+0x5a8>
							commutate(1);
 801566e:	f7fd fc47 	bl	8012f00 <commutate>
							cycle_integrator_sum += cycle_integrator * (1.0 / (0.0005 * VDIV_CORR));
 8015672:	4a23      	ldr	r2, [pc, #140]	; (8015700 <mcpwm_adc_int_handler+0xbe0>)
 8015674:	4923      	ldr	r1, [pc, #140]	; (8015704 <mcpwm_adc_int_handler+0xbe4>)
 8015676:	edd2 6a00 	vldr	s13, [r2]
 801567a:	edd1 7a00 	vldr	s15, [r1]
 801567e:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8015708 <mcpwm_adc_int_handler+0xbe8>
							cycle_integrator_iterations += 1.0;
 8015682:	4b22      	ldr	r3, [pc, #136]	; (801570c <mcpwm_adc_int_handler+0xbec>)
							cycle_integrator = 0.0;
 8015684:	ed82 8a00 	vstr	s16, [r2]
							cycle_integrator_sum += cycle_integrator * (1.0 / (0.0005 * VDIV_CORR));
 8015688:	eee6 7a87 	vfma.f32	s15, s13, s14
 801568c:	f8d8 2000 	ldr.w	r2, [r8]
							cycle_integrator_iterations += 1.0;
 8015690:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
							cycle_integrator_sum += cycle_integrator * (1.0 / (0.0005 * VDIV_CORR));
 8015694:	edc1 7a00 	vstr	s15, [r1]
							cycle_integrator_iterations += 1.0;
 8015698:	edd3 7a00 	vldr	s15, [r3]
							cycle_sum = 0.0;
 801569c:	ed8b 8a00 	vstr	s16, [fp]
							cycle_integrator_iterations += 1.0;
 80156a0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80156a4:	edc3 7a00 	vstr	s15, [r3]
 80156a8:	f7ff bade 	b.w	8014c68 <mcpwm_adc_int_handler+0x148>
					dutycycle_now_tmp = SIGN(dutycycle_now_tmp) * conf->l_min_duty;
 80156ac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80156b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80156b4:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
					dutycycle_set = dutycycle_now_tmp;
 80156b8:	4a10      	ldr	r2, [pc, #64]	; (80156fc <mcpwm_adc_int_handler+0xbdc>)
					dutycycle_now_tmp = SIGN(dutycycle_now_tmp) * conf->l_min_duty;
 80156ba:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80156be:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80156c2:	bf58      	it	pl
 80156c4:	eeb0 7a66 	vmovpl.f32	s14, s13
 80156c8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80156cc:	edcd 7a08 	vstr	s15, [sp, #32]
					dutycycle_set = dutycycle_now_tmp;
 80156d0:	edc2 7a00 	vstr	s15, [r2]
 80156d4:	e4f8      	b.n	80150c8 <mcpwm_adc_int_handler+0x5a8>
			amp = sqrtf((float)(ph1*ph1 + ph2*ph2 + ph3*ph3)) * sqrtf(2.0);
 80156d6:	f010 f823 	bl	8025720 <sqrtf>
 80156da:	e593      	b.n	8015204 <mcpwm_adc_int_handler+0x6e4>
 80156dc:	3a01      	subs	r2, #1
 80156de:	e51b      	b.n	8015118 <mcpwm_adc_int_handler+0x5f8>
				int ph_now_raw = 0;
 80156e0:	2300      	movs	r3, #0
 80156e2:	9305      	str	r3, [sp, #20]
				int v_diff = 0;
 80156e4:	469b      	mov	fp, r3
				switch (comm_step) {
 80156e6:	2309      	movs	r3, #9
 80156e8:	9302      	str	r3, [sp, #8]
 80156ea:	f7ff bbec 	b.w	8014ec6 <mcpwm_adc_int_handler+0x3a6>
 80156ee:	bf00      	nop
 80156f0:	20004df4 	.word	0x20004df4
 80156f4:	447a0000 	.word	0x447a0000
 80156f8:	3dcccccd 	.word	0x3dcccccd
 80156fc:	20004e20 	.word	0x20004e20
 8015700:	20004df8 	.word	0x20004df8
 8015704:	20004e00 	.word	0x20004e00
 8015708:	45124e8b 	.word	0x45124e8b
 801570c:	20004dfc 	.word	0x20004dfc

08015710 <icuperiodcb>:
	}
}

static void icuperiodcb(ICUDriver *icup) {
	(void)icup;
}
 8015710:	4770      	bx	lr
 8015712:	bf00      	nop
	...

08015720 <icuwidthcb>:
	last_len_received[0] = ((float)icuGetWidthX(icup) / ((float)TIMER_FREQ / 1000.0));
 8015720:	6903      	ldr	r3, [r0, #16]
 8015722:	eddf 6a40 	vldr	s13, [pc, #256]	; 8015824 <icuwidthcb+0x104>
 8015726:	681b      	ldr	r3, [r3, #0]
 8015728:	493f      	ldr	r1, [pc, #252]	; (8015828 <icuwidthcb+0x108>)
	float len = last_len_received[0] - pulse_start;
 801572a:	4a40      	ldr	r2, [pc, #256]	; (801582c <icuwidthcb+0x10c>)
	const float len_set = (pulse_end - pulse_start);
 801572c:	4840      	ldr	r0, [pc, #256]	; (8015830 <icuwidthcb+0x110>)
	last_len_received[0] = ((float)icuGetWidthX(icup) / ((float)TIMER_FREQ / 1000.0));
 801572e:	3301      	adds	r3, #1
 8015730:	ee07 3a90 	vmov	s15, r3
 8015734:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8015738:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801573c:	ed81 7a00 	vstr	s14, [r1]
	float len = last_len_received[0] - pulse_start;
 8015740:	edd1 7a00 	vldr	s15, [r1]
 8015744:	ed92 6a00 	vldr	s12, [r2]
	const float len_set = (pulse_end - pulse_start);
 8015748:	ed90 7a00 	vldr	s14, [r0]
 801574c:	edd2 6a00 	vldr	s13, [r2]
	float len = last_len_received[0] - pulse_start;
 8015750:	ee77 7ac6 	vsub.f32	s15, s15, s12
	const float len_set = (pulse_end - pulse_start);
 8015754:	ee37 7a66 	vsub.f32	s14, s14, s13
	if (len > len_set) {
 8015758:	eef4 7ac7 	vcmpe.f32	s15, s14
 801575c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015760:	dd30      	ble.n	80157c4 <icuwidthcb+0xa4>
		if (len < (len_set * 1.2)) {
 8015762:	eddf 6a34 	vldr	s13, [pc, #208]	; 8015834 <icuwidthcb+0x114>
 8015766:	ee67 6a26 	vmul.f32	s13, s14, s13
 801576a:	eef4 6ae7 	vcmpe.f32	s13, s15
 801576e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015772:	dd3c      	ble.n	80157ee <icuwidthcb+0xce>
			len = len_set;
 8015774:	eef0 7a47 	vmov.f32	s15, s14
	if (len >= 0.0) {
 8015778:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801577c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015780:	db4e      	blt.n	8015820 <icuwidthcb+0x100>
 8015782:	ee77 7aa7 	vadd.f32	s15, s15, s15
static void icuwidthcb(ICUDriver *icup) {
 8015786:	b570      	push	{r4, r5, r6, lr}
		if (use_median_filter) {
 8015788:	4b2b      	ldr	r3, [pc, #172]	; (8015838 <icuwidthcb+0x118>)
 801578a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801578e:	781b      	ldrb	r3, [r3, #0]
static void icuwidthcb(ICUDriver *icup) {
 8015790:	ed2d 8b02 	vpush	{d8}
 8015794:	ee87 8a87 	vdiv.f32	s16, s15, s14
		if (use_median_filter) {
 8015798:	bb53      	cbnz	r3, 80157f0 <icuwidthcb+0xd0>
			servo_pos[0] = (len * 2.0 - len_set) / len_set;
 801579a:	4b28      	ldr	r3, [pc, #160]	; (801583c <icuwidthcb+0x11c>)
 801579c:	ed83 8a00 	vstr	s16, [r3]
 80157a0:	2320      	movs	r3, #32
 80157a2:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.vt_systime;
 80157a6:	4a26      	ldr	r2, [pc, #152]	; (8015840 <icuwidthcb+0x120>)
 80157a8:	2300      	movs	r3, #0
 80157aa:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80157ac:	f383 8811 	msr	BASEPRI, r3
		if (done_func) {
 80157b0:	4b24      	ldr	r3, [pc, #144]	; (8015844 <icuwidthcb+0x124>)
		last_update_time = chVTGetSystemTime();
 80157b2:	4a25      	ldr	r2, [pc, #148]	; (8015848 <icuwidthcb+0x128>)
		if (done_func) {
 80157b4:	681b      	ldr	r3, [r3, #0]
		last_update_time = chVTGetSystemTime();
 80157b6:	6011      	str	r1, [r2, #0]
		if (done_func) {
 80157b8:	b363      	cbz	r3, 8015814 <icuwidthcb+0xf4>
}
 80157ba:	ecbd 8b02 	vpop	{d8}
 80157be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			done_func();
 80157c2:	4718      	bx	r3
	} else if (len < 0.0) {
 80157c4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80157c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80157cc:	d5d4      	bpl.n	8015778 <icuwidthcb+0x58>
		if ((len + pulse_start) > (pulse_start * 0.8)) {
 80157ce:	ed92 6a00 	vldr	s12, [r2]
 80157d2:	eddf 5a1e 	vldr	s11, [pc, #120]	; 801584c <icuwidthcb+0x12c>
 80157d6:	edd2 6a00 	vldr	s13, [r2]
 80157da:	ee76 7a27 	vadd.f32	s15, s12, s15
 80157de:	ee66 6aa5 	vmul.f32	s13, s13, s11
 80157e2:	eef4 7ae6 	vcmpe.f32	s15, s13
 80157e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80157ea:	dc16      	bgt.n	801581a <icuwidthcb+0xfa>
 80157ec:	4770      	bx	lr
 80157ee:	4770      	bx	lr
			float med = utils_middle_of_3(c, c1, c2);
 80157f0:	4c17      	ldr	r4, [pc, #92]	; (8015850 <icuwidthcb+0x130>)
 80157f2:	4d18      	ldr	r5, [pc, #96]	; (8015854 <icuwidthcb+0x134>)
 80157f4:	edd4 0a00 	vldr	s1, [r4]
 80157f8:	ed95 1a00 	vldr	s2, [r5]
 80157fc:	eeb0 0a48 	vmov.f32	s0, s16
 8015800:	f000 fa16 	bl	8015c30 <utils_middle_of_3>
			servo_pos[0] = med;
 8015804:	4b0d      	ldr	r3, [pc, #52]	; (801583c <icuwidthcb+0x11c>)
			c2 = c1;
 8015806:	6822      	ldr	r2, [r4, #0]
 8015808:	602a      	str	r2, [r5, #0]
			c1 = c;
 801580a:	ed84 8a00 	vstr	s16, [r4]
			servo_pos[0] = med;
 801580e:	ed83 0a00 	vstr	s0, [r3]
 8015812:	e7c5      	b.n	80157a0 <icuwidthcb+0x80>
}
 8015814:	ecbd 8b02 	vpop	{d8}
 8015818:	bd70      	pop	{r4, r5, r6, pc}
 801581a:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8015858 <icuwidthcb+0x138>
 801581e:	e7b2      	b.n	8015786 <icuwidthcb+0x66>
 8015820:	4770      	bx	lr
 8015822:	bf00      	nop
 8015824:	447a0000 	.word	0x447a0000
 8015828:	200063c8 	.word	0x200063c8
 801582c:	20001038 	.word	0x20001038
 8015830:	20001034 	.word	0x20001034
 8015834:	3f99999a 	.word	0x3f99999a
 8015838:	200063d4 	.word	0x200063d4
 801583c:	200063d0 	.word	0x200063d0
 8015840:	20001a48 	.word	0x20001a48
 8015844:	200063c0 	.word	0x200063c0
 8015848:	200063cc 	.word	0x200063cc
 801584c:	3f4ccccd 	.word	0x3f4ccccd
 8015850:	20001010 	.word	0x20001010
 8015854:	20001014 	.word	0x20001014
	...

08015860 <servodec_init>:
 *
 * @param d_func
 * A function that should be called every time the servo signals have been
 * decoded. Can be NULL.
 */
void servodec_init(void (*d_func)(void)) {
 8015860:	b538      	push	{r3, r4, r5, lr}
	icuStart(&HW_ICU_DEV, &icucfg);
 8015862:	4c0e      	ldr	r4, [pc, #56]	; (801589c <servodec_init+0x3c>)
 8015864:	490e      	ldr	r1, [pc, #56]	; (80158a0 <servodec_init+0x40>)
void servodec_init(void (*d_func)(void)) {
 8015866:	4605      	mov	r5, r0
	icuStart(&HW_ICU_DEV, &icucfg);
 8015868:	4620      	mov	r0, r4
 801586a:	f7f8 fef9 	bl	800e660 <icuStart>
	palSetPadMode(HW_ICU_GPIO, HW_ICU_PIN, PAL_MODE_ALTERNATE(HW_ICU_GPIO_AF));
 801586e:	f44f 7281 	mov.w	r2, #258	; 0x102
 8015872:	2120      	movs	r1, #32
 8015874:	480b      	ldr	r0, [pc, #44]	; (80158a4 <servodec_init+0x44>)
 8015876:	f7fa faf3 	bl	800fe60 <_pal_lld_setgroupmode>
	icuStartCapture(&HW_ICU_DEV);
 801587a:	4620      	mov	r0, r4
 801587c:	f7f8 ff10 	bl	800e6a0 <icuStartCapture>
	icuEnableNotifications(&HW_ICU_DEV);
 8015880:	4620      	mov	r0, r4
 8015882:	f7f8 ff1d 	bl	800e6c0 <icuEnableNotifications>
		servo_pos[i] = 0.0;
		last_len_received[i] = 0.0;
	}

	// Set our function pointer
	done_func = d_func;
 8015886:	4908      	ldr	r1, [pc, #32]	; (80158a8 <servodec_init+0x48>)
		servo_pos[i] = 0.0;
 8015888:	4c08      	ldr	r4, [pc, #32]	; (80158ac <servodec_init+0x4c>)
		last_len_received[i] = 0.0;
 801588a:	4809      	ldr	r0, [pc, #36]	; (80158b0 <servodec_init+0x50>)

	is_running = true;
 801588c:	4a09      	ldr	r2, [pc, #36]	; (80158b4 <servodec_init+0x54>)
	done_func = d_func;
 801588e:	600d      	str	r5, [r1, #0]
		servo_pos[i] = 0.0;
 8015890:	2300      	movs	r3, #0
	is_running = true;
 8015892:	2101      	movs	r1, #1
		servo_pos[i] = 0.0;
 8015894:	6023      	str	r3, [r4, #0]
		last_len_received[i] = 0.0;
 8015896:	6003      	str	r3, [r0, #0]
	is_running = true;
 8015898:	7011      	strb	r1, [r2, #0]
}
 801589a:	bd38      	pop	{r3, r4, r5, pc}
 801589c:	20002088 	.word	0x20002088
 80158a0:	20001018 	.word	0x20001018
 80158a4:	40020400 	.word	0x40020400
 80158a8:	200063c0 	.word	0x200063c0
 80158ac:	200063d0 	.word	0x200063d0
 80158b0:	200063c8 	.word	0x200063c8
 80158b4:	200063c4 	.word	0x200063c4
	...

080158c0 <servodec_stop>:

/**
 * Stop the servo decoding driver
 */
void servodec_stop(void) {
 80158c0:	b538      	push	{r3, r4, r5, lr}
	if (is_running) {
 80158c2:	4c0d      	ldr	r4, [pc, #52]	; (80158f8 <servodec_stop+0x38>)
 80158c4:	7823      	ldrb	r3, [r4, #0]
 80158c6:	b1a3      	cbz	r3, 80158f2 <servodec_stop+0x32>
		icuStop(&HW_ICU_DEV);
 80158c8:	480c      	ldr	r0, [pc, #48]	; (80158fc <servodec_stop+0x3c>)
 80158ca:	f7f8 fed9 	bl	800e680 <icuStop>
		palSetPadMode(HW_ICU_GPIO, HW_ICU_PIN, PAL_MODE_INPUT);
 80158ce:	2200      	movs	r2, #0
 80158d0:	2120      	movs	r1, #32
 80158d2:	480b      	ldr	r0, [pc, #44]	; (8015900 <servodec_stop+0x40>)
 80158d4:	f7fa fac4 	bl	800fe60 <_pal_lld_setgroupmode>
		pulse_start = 1.0;
 80158d8:	4b0a      	ldr	r3, [pc, #40]	; (8015904 <servodec_stop+0x44>)
		pulse_end = 2.0;
 80158da:	480b      	ldr	r0, [pc, #44]	; (8015908 <servodec_stop+0x48>)
		use_median_filter = false;
 80158dc:	4a0b      	ldr	r2, [pc, #44]	; (801590c <servodec_stop+0x4c>)
		done_func = 0;
 80158de:	490c      	ldr	r1, [pc, #48]	; (8015910 <servodec_stop+0x50>)
		pulse_start = 1.0;
 80158e0:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
 80158e4:	601d      	str	r5, [r3, #0]
		use_median_filter = false;
 80158e6:	2300      	movs	r3, #0
		pulse_end = 2.0;
 80158e8:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80158ec:	6005      	str	r5, [r0, #0]
		done_func = 0;
 80158ee:	600b      	str	r3, [r1, #0]
		use_median_filter = false;
 80158f0:	7013      	strb	r3, [r2, #0]
	}

	is_running = false;
 80158f2:	2300      	movs	r3, #0
 80158f4:	7023      	strb	r3, [r4, #0]
}
 80158f6:	bd38      	pop	{r3, r4, r5, pc}
 80158f8:	200063c4 	.word	0x200063c4
 80158fc:	20002088 	.word	0x20002088
 8015900:	40020400 	.word	0x40020400
 8015904:	20001038 	.word	0x20001038
 8015908:	20001034 	.word	0x20001034
 801590c:	200063d4 	.word	0x200063d4
 8015910:	200063c0 	.word	0x200063c0
	...

08015920 <servodec_set_pulse_options>:
 *
 * @param end
 * he amount of milliseconds the pulse ends at (default is 2.0)
 */
void servodec_set_pulse_options(float start, float end, bool median_filter) {
	pulse_start = start;
 8015920:	4904      	ldr	r1, [pc, #16]	; (8015934 <servodec_set_pulse_options+0x14>)
	pulse_end = end;
 8015922:	4a05      	ldr	r2, [pc, #20]	; (8015938 <servodec_set_pulse_options+0x18>)
	use_median_filter = median_filter;
 8015924:	4b05      	ldr	r3, [pc, #20]	; (801593c <servodec_set_pulse_options+0x1c>)
	pulse_start = start;
 8015926:	ed81 0a00 	vstr	s0, [r1]
	pulse_end = end;
 801592a:	edc2 0a00 	vstr	s1, [r2]
	use_median_filter = median_filter;
 801592e:	7018      	strb	r0, [r3, #0]
}
 8015930:	4770      	bx	lr
 8015932:	bf00      	nop
 8015934:	20001038 	.word	0x20001038
 8015938:	20001034 	.word	0x20001034
 801593c:	200063d4 	.word	0x200063d4

08015940 <servodec_get_servo>:
 *
 * @return
 * The servo value in the range [-1.0 1.0].
 */
float servodec_get_servo(int servo_num) {
	if (servo_num < SERVO_NUM) {
 8015940:	2800      	cmp	r0, #0
		return servo_pos[servo_num];
 8015942:	bfdd      	ittte	le
 8015944:	4b03      	ldrle	r3, [pc, #12]	; (8015954 <servodec_get_servo+0x14>)
 8015946:	eb03 0080 	addle.w	r0, r3, r0, lsl #2
 801594a:	ed90 0a00 	vldrle	s0, [r0]
	} else {
		return 0.0;
 801594e:	ed9f 0a02 	vldrgt	s0, [pc, #8]	; 8015958 <servodec_get_servo+0x18>
	}
}
 8015952:	4770      	bx	lr
 8015954:	200063d0 	.word	0x200063d0
	...

08015960 <servodec_get_time_since_update>:
 8015960:	4b04      	ldr	r3, [pc, #16]	; (8015974 <servodec_get_time_since_update+0x14>)
 *
 * @return
 * The amount of milliseconds that have passed since an update.
 */
uint32_t servodec_get_time_since_update(void) {
	return chVTTimeElapsedSinceX(last_update_time) / (CH_CFG_ST_FREQUENCY / 1000);
 8015962:	4a05      	ldr	r2, [pc, #20]	; (8015978 <servodec_get_time_since_update+0x18>)
 8015964:	6812      	ldr	r2, [r2, #0]
 8015966:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8015968:	4b04      	ldr	r3, [pc, #16]	; (801597c <servodec_get_time_since_update+0x1c>)
  return chVTGetSystemTimeX() - start;
 801596a:	1a80      	subs	r0, r0, r2
 801596c:	fba3 3000 	umull	r3, r0, r3, r0
}
 8015970:	08c0      	lsrs	r0, r0, #3
 8015972:	4770      	bx	lr
 8015974:	20001a48 	.word	0x20001a48
 8015978:	200063cc 	.word	0x200063cc
 801597c:	cccccccd 	.word	0xcccccccd

08015980 <servodec_get_last_pulse_len>:
 *
 * @return
 * The length of the last received pulse.
 */
float servodec_get_last_pulse_len(int servo_num) {
	if (servo_num < SERVO_NUM) {
 8015980:	2800      	cmp	r0, #0
		return last_len_received[servo_num];
 8015982:	bfdd      	ittte	le
 8015984:	4b03      	ldrle	r3, [pc, #12]	; (8015994 <servodec_get_last_pulse_len+0x14>)
 8015986:	eb03 0080 	addle.w	r0, r3, r0, lsl #2
 801598a:	ed90 0a00 	vldrle	s0, [r0]
	} else {
		return 0.0;
 801598e:	ed9f 0a02 	vldrgt	s0, [pc, #8]	; 8015998 <servodec_get_last_pulse_len+0x18>
	}
}
 8015992:	4770      	bx	lr
 8015994:	200063c8 	.word	0x200063c8
	...

080159a0 <utils_step_towards>:

// Private variables
static volatile int sys_lock_cnt = 0;

void utils_step_towards(float *value, float goal, float step) {
    if (*value < goal) {
 80159a0:	edd0 7a00 	vldr	s15, [r0]
 80159a4:	eef4 7ac0 	vcmpe.f32	s15, s0
 80159a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80159ac:	d509      	bpl.n	80159c2 <utils_step_towards+0x22>
        if ((*value + step) < goal) {
 80159ae:	ee77 7aa0 	vadd.f32	s15, s15, s1
 80159b2:	eef4 7ac0 	vcmpe.f32	s15, s0
 80159b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80159ba:	d50a      	bpl.n	80159d2 <utils_step_towards+0x32>
        } else {
            *value = goal;
        }
    } else if (*value > goal) {
        if ((*value - step) > goal) {
            *value -= step;
 80159bc:	edc0 7a00 	vstr	s15, [r0]
        } else {
            *value = goal;
        }
    }
}
 80159c0:	4770      	bx	lr
    } else if (*value > goal) {
 80159c2:	ddfd      	ble.n	80159c0 <utils_step_towards+0x20>
        if ((*value - step) > goal) {
 80159c4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80159c8:	eef4 7ac0 	vcmpe.f32	s15, s0
 80159cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80159d0:	dcf4      	bgt.n	80159bc <utils_step_towards+0x1c>
            *value = goal;
 80159d2:	ed80 0a00 	vstr	s0, [r0]
 80159d6:	4770      	bx	lr
	...

080159e0 <utils_norm_angle>:
 * Make sure that 0 <= angle < 360
 *
 * @param angle
 * The angle to normalize.
 */
void utils_norm_angle(float *angle) {
 80159e0:	b510      	push	{r4, lr}
 80159e2:	ed2d 8b02 	vpush	{d8}
	*angle = fmodf(*angle, 360.0);
 80159e6:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 8015a10 <utils_norm_angle+0x30>
 80159ea:	ed90 0a00 	vldr	s0, [r0]
 80159ee:	eef0 0a48 	vmov.f32	s1, s16
void utils_norm_angle(float *angle) {
 80159f2:	4604      	mov	r4, r0
	*angle = fmodf(*angle, 360.0);
 80159f4:	f00f fe1c 	bl	8025630 <fmodf>

	if (*angle < 0.0) {
 80159f8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80159fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		*angle += 360.0;
 8015a00:	bf48      	it	mi
 8015a02:	ee30 0a08 	vaddmi.f32	s0, s0, s16
	}
}
 8015a06:	ecbd 8b02 	vpop	{d8}
		*angle += 360.0;
 8015a0a:	ed84 0a00 	vstr	s0, [r4]
}
 8015a0e:	bd10      	pop	{r4, pc}
 8015a10:	43b40000 	.word	0x43b40000
	...

08015a20 <utils_norm_angle_rad>:
 * @param angle
 * The angle to normalize in radians.
 * WARNING: Don't use too large angles.
 */
void utils_norm_angle_rad(float *angle) {
	while (*angle < -M_PI) {
 8015a20:	edd0 7a00 	vldr	s15, [r0]
 8015a24:	ed9f 7a12 	vldr	s14, [pc, #72]	; 8015a70 <utils_norm_angle_rad+0x50>
 8015a28:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a30:	d50a      	bpl.n	8015a48 <utils_norm_angle_rad+0x28>
		*angle += 2.0 * M_PI;
 8015a32:	eddf 6a10 	vldr	s13, [pc, #64]	; 8015a74 <utils_norm_angle_rad+0x54>
 8015a36:	ee77 7aa6 	vadd.f32	s15, s15, s13
	while (*angle < -M_PI) {
 8015a3a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015a3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a42:	d4f8      	bmi.n	8015a36 <utils_norm_angle_rad+0x16>
 8015a44:	edc0 7a00 	vstr	s15, [r0]
	}

	while (*angle >  M_PI) {
 8015a48:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8015a78 <utils_norm_angle_rad+0x58>
 8015a4c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015a50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a54:	dd0a      	ble.n	8015a6c <utils_norm_angle_rad+0x4c>
		*angle -= 2.0 * M_PI;
 8015a56:	eddf 6a07 	vldr	s13, [pc, #28]	; 8015a74 <utils_norm_angle_rad+0x54>
 8015a5a:	ee77 7ae6 	vsub.f32	s15, s15, s13
	while (*angle >  M_PI) {
 8015a5e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015a62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a66:	dcf8      	bgt.n	8015a5a <utils_norm_angle_rad+0x3a>
 8015a68:	edc0 7a00 	vstr	s15, [r0]
	}
}
 8015a6c:	4770      	bx	lr
 8015a6e:	bf00      	nop
 8015a70:	c0490fdb 	.word	0xc0490fdb
 8015a74:	40c90fdb 	.word	0x40c90fdb
 8015a78:	40490fdb 	.word	0x40490fdb
 8015a7c:	00000000 	.word	0x00000000

08015a80 <utils_truncate_number>:

int utils_truncate_number(float *number, float min, float max) {
	int did_trunc = 0;

	if (*number > max) {
 8015a80:	edd0 7a00 	vldr	s15, [r0]
 8015a84:	eef4 7ae0 	vcmpe.f32	s15, s1
 8015a88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a8c:	dc09      	bgt.n	8015aa2 <utils_truncate_number+0x22>
		*number = max;
		did_trunc = 1;
	} else if (*number < min) {
 8015a8e:	eef4 7ac0 	vcmpe.f32	s15, s0
 8015a92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		*number = min;
 8015a96:	bf46      	itte	mi
 8015a98:	ed80 0a00 	vstrmi	s0, [r0]
		did_trunc = 1;
 8015a9c:	2001      	movmi	r0, #1
	int did_trunc = 0;
 8015a9e:	2000      	movpl	r0, #0
	}

	return did_trunc;
}
 8015aa0:	4770      	bx	lr
		*number = max;
 8015aa2:	edc0 0a00 	vstr	s1, [r0]
		did_trunc = 1;
 8015aa6:	2001      	movs	r0, #1
 8015aa8:	4770      	bx	lr
 8015aaa:	bf00      	nop
 8015aac:	0000      	movs	r0, r0
	...

08015ab0 <utils_truncate_number_int>:

int utils_truncate_number_int(int *number, int min, int max) {
	int did_trunc = 0;

	if (*number > max) {
 8015ab0:	6803      	ldr	r3, [r0, #0]
 8015ab2:	4293      	cmp	r3, r2
 8015ab4:	dc05      	bgt.n	8015ac2 <utils_truncate_number_int+0x12>
		*number = max;
		did_trunc = 1;
	} else if (*number < min) {
 8015ab6:	428b      	cmp	r3, r1
		*number = min;
 8015ab8:	bfba      	itte	lt
 8015aba:	6001      	strlt	r1, [r0, #0]
		did_trunc = 1;
 8015abc:	2001      	movlt	r0, #1
	int did_trunc = 0;
 8015abe:	2000      	movge	r0, #0
	}

	return did_trunc;
}
 8015ac0:	4770      	bx	lr
		*number = max;
 8015ac2:	6002      	str	r2, [r0, #0]
		did_trunc = 1;
 8015ac4:	2001      	movs	r0, #1
 8015ac6:	4770      	bx	lr
	...

08015ad0 <utils_truncate_number_abs>:

int utils_truncate_number_abs(float *number, float max) {
	int did_trunc = 0;

	if (*number > max) {
 8015ad0:	edd0 7a00 	vldr	s15, [r0]
 8015ad4:	eef4 7ac0 	vcmpe.f32	s15, s0
 8015ad8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015adc:	dc06      	bgt.n	8015aec <utils_truncate_number_abs+0x1c>
		*number = max;
		did_trunc = 1;
	} else if (*number < -max) {
 8015ade:	eeb1 0a40 	vneg.f32	s0, s0
 8015ae2:	eef4 7ac0 	vcmpe.f32	s15, s0
 8015ae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015aea:	d503      	bpl.n	8015af4 <utils_truncate_number_abs+0x24>
		*number = -max;
 8015aec:	ed80 0a00 	vstr	s0, [r0]
		did_trunc = 1;
 8015af0:	2001      	movs	r0, #1
 8015af2:	4770      	bx	lr
	int did_trunc = 0;
 8015af4:	2000      	movs	r0, #0
	}

	return did_trunc;
}
 8015af6:	4770      	bx	lr
	...

08015b00 <utils_map>:

float utils_map(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 8015b00:	ee30 0a60 	vsub.f32	s0, s0, s1
 8015b04:	ee32 2a61 	vsub.f32	s4, s4, s3
 8015b08:	ee31 1a60 	vsub.f32	s2, s2, s1
 8015b0c:	ee20 2a02 	vmul.f32	s4, s0, s4
 8015b10:	ee82 0a01 	vdiv.f32	s0, s4, s2
}
 8015b14:	ee30 0a21 	vadd.f32	s0, s0, s3
 8015b18:	4770      	bx	lr
 8015b1a:	bf00      	nop
 8015b1c:	0000      	movs	r0, r0
	...

08015b20 <utils_deadband>:
/**
 * Truncate absolute values less than tres to zero. The value
 * tres will be mapped to 0 and the value max to max.
 */
void utils_deadband(float *value, float tres, float max) {
	if (fabsf(*value) < tres) {
 8015b20:	ed90 7a00 	vldr	s14, [r0]
 8015b24:	eef0 7ac7 	vabs.f32	s15, s14
 8015b28:	eef4 7ac0 	vcmpe.f32	s15, s0
 8015b2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b30:	d417      	bmi.n	8015b62 <utils_deadband+0x42>
		*value = 0.0;
	} else {
		float k = max / (max - tres);
 8015b32:	ee30 0ac0 	vsub.f32	s0, s1, s0
 8015b36:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015b3a:	eec0 6a80 	vdiv.f32	s13, s1, s0
		if (*value > 0.0) {
 8015b3e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8015b42:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8015b46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b4a:	ee67 7aa0 	vmul.f32	s15, s15, s1
			*value = k * *value + max * (1.0 - k);
		} else {
			*value = -(k * -*value + max * (1.0 - k));
 8015b4e:	bfd6      	itet	le
 8015b50:	eee7 7a66 	vfmsle.f32	s15, s14, s13
			*value = k * *value + max * (1.0 - k);
 8015b54:	eee7 7a26 	vfmagt.f32	s15, s14, s13
			*value = -(k * -*value + max * (1.0 - k));
 8015b58:	eef1 7a67 	vnegle.f32	s15, s15
 8015b5c:	edc0 7a00 	vstr	s15, [r0]
		}

	}
}
 8015b60:	4770      	bx	lr
		*value = 0.0;
 8015b62:	2300      	movs	r3, #0
 8015b64:	6003      	str	r3, [r0, #0]
 8015b66:	4770      	bx	lr
	...

08015b70 <utils_angle_difference>:
//	}
//
//	return angle1 - angle2;

	// Faster in most cases
	float difference = angle1 - angle2;
 8015b70:	ee30 0a60 	vsub.f32	s0, s0, s1
	while (difference < -180.0) difference += 2.0 * 180.0;
 8015b74:	eddf 7a10 	vldr	s15, [pc, #64]	; 8015bb8 <utils_angle_difference+0x48>
 8015b78:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015b7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b80:	d508      	bpl.n	8015b94 <utils_angle_difference+0x24>
 8015b82:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8015bbc <utils_angle_difference+0x4c>
 8015b86:	ee30 0a07 	vadd.f32	s0, s0, s14
 8015b8a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b92:	d4f8      	bmi.n	8015b86 <utils_angle_difference+0x16>
	while (difference > 180.0) difference -= 2.0 * 180.0;
 8015b94:	eddf 7a0a 	vldr	s15, [pc, #40]	; 8015bc0 <utils_angle_difference+0x50>
 8015b98:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015b9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ba0:	dd08      	ble.n	8015bb4 <utils_angle_difference+0x44>
 8015ba2:	ed9f 7a06 	vldr	s14, [pc, #24]	; 8015bbc <utils_angle_difference+0x4c>
 8015ba6:	ee30 0a47 	vsub.f32	s0, s0, s14
 8015baa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015bae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015bb2:	dcf8      	bgt.n	8015ba6 <utils_angle_difference+0x36>
	return difference;
}
 8015bb4:	4770      	bx	lr
 8015bb6:	bf00      	nop
 8015bb8:	c3340000 	.word	0xc3340000
 8015bbc:	43b40000 	.word	0x43b40000
 8015bc0:	43340000 	.word	0x43340000
	...

08015bd0 <utils_angle_difference_rad>:
 * The second angle in radians
 * @return
 * The difference between the angles in radians
 */
float utils_angle_difference_rad(float angle1, float angle2) {
	float difference = angle1 - angle2;
 8015bd0:	ee30 0a60 	vsub.f32	s0, s0, s1
	while (difference < -M_PI) difference += 2.0 * M_PI;
 8015bd4:	eddf 7a10 	vldr	s15, [pc, #64]	; 8015c18 <utils_angle_difference_rad+0x48>
 8015bd8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015bdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015be0:	d508      	bpl.n	8015bf4 <utils_angle_difference_rad+0x24>
 8015be2:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8015c1c <utils_angle_difference_rad+0x4c>
 8015be6:	ee30 0a07 	vadd.f32	s0, s0, s14
 8015bea:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015bee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015bf2:	d4f8      	bmi.n	8015be6 <utils_angle_difference_rad+0x16>
	while (difference > M_PI) difference -= 2.0 * M_PI;
 8015bf4:	eddf 7a0a 	vldr	s15, [pc, #40]	; 8015c20 <utils_angle_difference_rad+0x50>
 8015bf8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015bfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c00:	dd08      	ble.n	8015c14 <utils_angle_difference_rad+0x44>
 8015c02:	ed9f 7a06 	vldr	s14, [pc, #24]	; 8015c1c <utils_angle_difference_rad+0x4c>
 8015c06:	ee30 0a47 	vsub.f32	s0, s0, s14
 8015c0a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015c0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c12:	dcf8      	bgt.n	8015c06 <utils_angle_difference_rad+0x36>
	return difference;
}
 8015c14:	4770      	bx	lr
 8015c16:	bf00      	nop
 8015c18:	c0490fdb 	.word	0xc0490fdb
 8015c1c:	40c90fdb 	.word	0x40c90fdb
 8015c20:	40490fdb 	.word	0x40490fdb
	...

08015c30 <utils_middle_of_3>:
 * The middle value
 */
float utils_middle_of_3(float a, float b, float c) {
	float middle;

	if ((a <= b) && (a <= c)) {
 8015c30:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8015c34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c38:	d80e      	bhi.n	8015c58 <utils_middle_of_3+0x28>
 8015c3a:	eeb4 0ac1 	vcmpe.f32	s0, s2
 8015c3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c42:	d81f      	bhi.n	8015c84 <utils_middle_of_3+0x54>
		middle = (b <= c) ? b : c;
 8015c44:	eef4 0ac1 	vcmpe.f32	s1, s2
 8015c48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c4c:	bf8c      	ite	hi
 8015c4e:	eeb0 0a41 	vmovhi.f32	s0, s2
 8015c52:	eeb0 0a60 	vmovls.f32	s0, s1
 8015c56:	4770      	bx	lr
	} else if ((b <= a) && (b <= c)) {
 8015c58:	db0c      	blt.n	8015c74 <utils_middle_of_3+0x44>
 8015c5a:	eef4 0ac1 	vcmpe.f32	s1, s2
 8015c5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c62:	d807      	bhi.n	8015c74 <utils_middle_of_3+0x44>
		middle = (a <= c) ? a : c;
 8015c64:	eeb4 0ac1 	vcmpe.f32	s0, s2
 8015c68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		middle = (b <= c) ? b : c;
 8015c6c:	bf88      	it	hi
 8015c6e:	eeb0 0a41 	vmovhi.f32	s0, s2
 8015c72:	4770      	bx	lr
	} else {
		middle = (a <= b) ? a : b;
 8015c74:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8015c78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c7c:	bf88      	it	hi
 8015c7e:	eeb0 0a60 	vmovhi.f32	s0, s1
 8015c82:	4770      	bx	lr
	} else if ((b <= a) && (b <= c)) {
 8015c84:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8015c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c8c:	db04      	blt.n	8015c98 <utils_middle_of_3+0x68>
 8015c8e:	eef4 0ac1 	vcmpe.f32	s1, s2
 8015c92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c96:	d9e5      	bls.n	8015c64 <utils_middle_of_3+0x34>
	}
	return middle;
}
 8015c98:	4770      	bx	lr
 8015c9a:	bf00      	nop
 8015c9c:	0000      	movs	r0, r0
	...

08015ca0 <utils_middle_of_3_int>:
 * The middle value
 */
int utils_middle_of_3_int(int a, int b, int c) {
	int middle;

	if ((a <= b) && (a <= c)) {
 8015ca0:	4288      	cmp	r0, r1
 8015ca2:	dd05      	ble.n	8015cb0 <utils_middle_of_3_int+0x10>
		middle = (b <= c) ? b : c;
	} else if ((b <= a) && (b <= c)) {
 8015ca4:	4291      	cmp	r1, r2
 8015ca6:	dd0b      	ble.n	8015cc0 <utils_middle_of_3_int+0x20>
		middle = (a <= c) ? a : c;
	} else {
		middle = (a <= b) ? a : b;
 8015ca8:	4288      	cmp	r0, r1
 8015caa:	bfa8      	it	ge
 8015cac:	4608      	movge	r0, r1
	}
	return middle;
}
 8015cae:	4770      	bx	lr
	if ((a <= b) && (a <= c)) {
 8015cb0:	4290      	cmp	r0, r2
 8015cb2:	dd09      	ble.n	8015cc8 <utils_middle_of_3_int+0x28>
	} else if ((b <= a) && (b <= c)) {
 8015cb4:	4288      	cmp	r0, r1
 8015cb6:	daf5      	bge.n	8015ca4 <utils_middle_of_3_int+0x4>
		middle = (a <= b) ? a : b;
 8015cb8:	4288      	cmp	r0, r1
 8015cba:	bfa8      	it	ge
 8015cbc:	4608      	movge	r0, r1
}
 8015cbe:	4770      	bx	lr
		middle = (a <= c) ? a : c;
 8015cc0:	4290      	cmp	r0, r2
 8015cc2:	bfa8      	it	ge
 8015cc4:	4610      	movge	r0, r2
 8015cc6:	4770      	bx	lr
		middle = (b <= c) ? b : c;
 8015cc8:	4291      	cmp	r1, r2
 8015cca:	bfa8      	it	ge
 8015ccc:	4611      	movge	r1, r2
 8015cce:	4608      	mov	r0, r1
 8015cd0:	4770      	bx	lr
 8015cd2:	bf00      	nop
	...

08015ce0 <utils_fast_atan2>:
 *
 * @return
 * The angle in radians
 */
float utils_fast_atan2(float y, float x) {
	float abs_y = fabsf(y) + 1e-20; // kludge to prevent 0/0 condition
 8015ce0:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8015d48 <utils_fast_atan2+0x68>
 8015ce4:	eef0 7ac0 	vabs.f32	s15, s0
 8015ce8:	ee77 7a87 	vadd.f32	s15, s15, s14
	float angle;

	if (x >= 0) {
 8015cec:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 8015cf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
float utils_fast_atan2(float y, float x) {
 8015cf4:	eef0 6a40 	vmov.f32	s13, s0
 8015cf8:	ee37 5aa0 	vadd.f32	s10, s15, s1
	if (x >= 0) {
 8015cfc:	db19      	blt.n	8015d32 <utils_fast_atan2+0x52>
		float r = (x - abs_y) / (x + abs_y);
 8015cfe:	ee70 7ae7 	vsub.f32	s15, s1, s15
		float rsq = r * r;
		angle = ((0.1963 * rsq) - 0.9817) * r + (M_PI / 4.0);
 8015d02:	eddf 4a12 	vldr	s9, [pc, #72]	; 8015d4c <utils_fast_atan2+0x6c>
 8015d06:	eddf 5a12 	vldr	s11, [pc, #72]	; 8015d50 <utils_fast_atan2+0x70>
 8015d0a:	ed9f 7a12 	vldr	s14, [pc, #72]	; 8015d54 <utils_fast_atan2+0x74>
		float r = (x - abs_y) / (x + abs_y);
 8015d0e:	ee87 6a85 	vdiv.f32	s12, s15, s10
	} else {
		float r = (x + abs_y) / (abs_y - x);
		float rsq = r * r;
 8015d12:	ee66 7a06 	vmul.f32	s15, s12, s12
		angle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);
	}

	if (y < 0) {
 8015d16:	eef5 6ac0 	vcmpe.f32	s13, #0.0
		angle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);
 8015d1a:	eee7 5aa4 	vfma.f32	s11, s15, s9
	if (y < 0) {
 8015d1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		angle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);
 8015d22:	eea5 7a86 	vfma.f32	s14, s11, s12
 8015d26:	eeb0 0a47 	vmov.f32	s0, s14
		return(-angle);
 8015d2a:	bf48      	it	mi
 8015d2c:	eeb1 0a47 	vnegmi.f32	s0, s14
	} else {
		return(angle);
	}
}
 8015d30:	4770      	bx	lr
		float r = (x + abs_y) / (abs_y - x);
 8015d32:	ee77 7ae0 	vsub.f32	s15, s15, s1
		angle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);
 8015d36:	eddf 4a05 	vldr	s9, [pc, #20]	; 8015d4c <utils_fast_atan2+0x6c>
 8015d3a:	eddf 5a05 	vldr	s11, [pc, #20]	; 8015d50 <utils_fast_atan2+0x70>
 8015d3e:	ed9f 7a06 	vldr	s14, [pc, #24]	; 8015d58 <utils_fast_atan2+0x78>
		float r = (x + abs_y) / (abs_y - x);
 8015d42:	ee85 6a27 	vdiv.f32	s12, s10, s15
 8015d46:	e7e4      	b.n	8015d12 <utils_fast_atan2+0x32>
 8015d48:	1e3ce508 	.word	0x1e3ce508
 8015d4c:	3e4902de 	.word	0x3e4902de
 8015d50:	bf7b50b1 	.word	0xbf7b50b1
 8015d54:	3f490fdb 	.word	0x3f490fdb
 8015d58:	4016cbe4 	.word	0x4016cbe4
 8015d5c:	00000000 	.word	0x00000000

08015d60 <utils_saturate_vector_2d>:
 * @return
 * True if saturation happened, false otherwise
 */
bool utils_saturate_vector_2d(float *x, float *y, float max) {
	bool retval = false;
	float mag = sqrtf(*x * *x + *y * *y);
 8015d60:	edd1 7a00 	vldr	s15, [r1]
 8015d64:	ed90 7a00 	vldr	s14, [r0]
bool utils_saturate_vector_2d(float *x, float *y, float max) {
 8015d68:	b510      	push	{r4, lr}
	float mag = sqrtf(*x * *x + *y * *y);
 8015d6a:	ee67 7aa7 	vmul.f32	s15, s15, s15
bool utils_saturate_vector_2d(float *x, float *y, float max) {
 8015d6e:	ed2d 8b02 	vpush	{d8}
	float mag = sqrtf(*x * *x + *y * *y);
 8015d72:	eee7 7a07 	vfma.f32	s15, s14, s14
bool utils_saturate_vector_2d(float *x, float *y, float max) {
 8015d76:	b082      	sub	sp, #8
 8015d78:	4604      	mov	r4, r0
 8015d7a:	eef0 8a40 	vmov.f32	s17, s0
 8015d7e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8015d82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	float mag = sqrtf(*x * *x + *y * *y);
 8015d86:	eeb1 8ae7 	vsqrt.f32	s16, s15
 8015d8a:	d427      	bmi.n	8015ddc <utils_saturate_vector_2d+0x7c>
	max = fabsf(max);

	if (mag < 1e-10) {
 8015d8c:	eddf 7a17 	vldr	s15, [pc, #92]	; 8015dec <utils_saturate_vector_2d+0x8c>
		mag = 1e-10;
 8015d90:	eeb4 8a67 	vcmp.f32	s16, s15
 8015d94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015d98:	bf48      	it	mi
 8015d9a:	eeb0 8a67 	vmovmi.f32	s16, s15
	max = fabsf(max);
 8015d9e:	eeb0 0ae8 	vabs.f32	s0, s17
	}

	if (mag > max) {
 8015da2:	eeb4 8ac0 	vcmpe.f32	s16, s0
 8015da6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015daa:	dd12      	ble.n	8015dd2 <utils_saturate_vector_2d+0x72>
		const float f = max / mag;
 8015dac:	eec0 6a08 	vdiv.f32	s13, s0, s16
		*x *= f;
		*y *= f;
		retval = true;
 8015db0:	2001      	movs	r0, #1
		*x *= f;
 8015db2:	ed94 7a00 	vldr	s14, [r4]
 8015db6:	ee27 7a26 	vmul.f32	s14, s14, s13
 8015dba:	ed84 7a00 	vstr	s14, [r4]
		*y *= f;
 8015dbe:	edd1 7a00 	vldr	s15, [r1]
 8015dc2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8015dc6:	edc1 7a00 	vstr	s15, [r1]
	}

	return retval;
}
 8015dca:	b002      	add	sp, #8
 8015dcc:	ecbd 8b02 	vpop	{d8}
 8015dd0:	bd10      	pop	{r4, pc}
	bool retval = false;
 8015dd2:	2000      	movs	r0, #0
}
 8015dd4:	b002      	add	sp, #8
 8015dd6:	ecbd 8b02 	vpop	{d8}
 8015dda:	bd10      	pop	{r4, pc}
	float mag = sqrtf(*x * *x + *y * *y);
 8015ddc:	eeb0 0a67 	vmov.f32	s0, s15
 8015de0:	9101      	str	r1, [sp, #4]
 8015de2:	f00f fc9d 	bl	8025720 <sqrtf>
 8015de6:	9901      	ldr	r1, [sp, #4]
 8015de8:	e7d0      	b.n	8015d8c <utils_saturate_vector_2d+0x2c>
 8015dea:	bf00      	nop
 8015dec:	2edbe6ff 	.word	0x2edbe6ff

08015df0 <utils_fast_sincos_better>:
 * @param cos
 * A pointer to store the cosine value.
 */
void utils_fast_sincos_better(float angle, float *sin, float *cos) {
	//always wrap input angle to -PI..PI
	while (angle < -M_PI) {
 8015df0:	eddf 7a3d 	vldr	s15, [pc, #244]	; 8015ee8 <utils_fast_sincos_better+0xf8>
 8015df4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015df8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015dfc:	d508      	bpl.n	8015e10 <utils_fast_sincos_better+0x20>
		angle += 2.0 * M_PI;
 8015dfe:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 8015eec <utils_fast_sincos_better+0xfc>
 8015e02:	ee30 0a07 	vadd.f32	s0, s0, s14
	while (angle < -M_PI) {
 8015e06:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015e0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e0e:	d4f8      	bmi.n	8015e02 <utils_fast_sincos_better+0x12>
	}

	while (angle >  M_PI) {
 8015e10:	eddf 7a37 	vldr	s15, [pc, #220]	; 8015ef0 <utils_fast_sincos_better+0x100>
 8015e14:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015e18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e1c:	dd08      	ble.n	8015e30 <utils_fast_sincos_better+0x40>
		angle -= 2.0 * M_PI;
 8015e1e:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8015eec <utils_fast_sincos_better+0xfc>
 8015e22:	ee30 0a47 	vsub.f32	s0, s0, s14
	while (angle >  M_PI) {
 8015e26:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015e2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e2e:	dcf8      	bgt.n	8015e22 <utils_fast_sincos_better+0x32>
 8015e30:	ed9f 7a30 	vldr	s14, [pc, #192]	; 8015ef4 <utils_fast_sincos_better+0x104>
 8015e34:	eddf 7a30 	vldr	s15, [pc, #192]	; 8015ef8 <utils_fast_sincos_better+0x108>
 8015e38:	ee20 7a07 	vmul.f32	s14, s0, s14
 8015e3c:	ee60 7a27 	vmul.f32	s15, s0, s15
 8015e40:	ee27 7a00 	vmul.f32	s14, s14, s0
	}

	//compute sine
	if (angle < 0.0) {
 8015e44:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8015e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		*sin = 1.27323954 * angle + 0.405284735 * angle * angle;
 8015e4c:	bf4c      	ite	mi
 8015e4e:	ee77 7a87 	vaddmi.f32	s15, s15, s14
			*sin = 0.225 * (*sin * -*sin - *sin) + *sin;
		} else {
			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
		}
	} else {
		*sin = 1.27323954 * angle - 0.405284735 * angle * angle;
 8015e52:	ee77 7ac7 	vsubpl.f32	s15, s15, s14

		if (*sin < 0.0) {
			*sin = 0.225 * (*sin * -*sin - *sin) + *sin;
		} else {
			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
 8015e56:	ed9f 7a29 	vldr	s14, [pc, #164]	; 8015efc <utils_fast_sincos_better+0x10c>
		*sin = 1.27323954 * angle - 0.405284735 * angle * angle;
 8015e5a:	edc0 7a00 	vstr	s15, [r0]
		if (*sin < 0.0) {
 8015e5e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015e62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			*sin = 0.225 * (*sin * -*sin - *sin) + *sin;
 8015e66:	eef0 6a67 	vmov.f32	s13, s15
 8015e6a:	bf4c      	ite	mi
 8015e6c:	eed7 6ae7 	vfnmami.f32	s13, s15, s15
			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
 8015e70:	eed7 6aa7 	vfnmspl.f32	s13, s15, s15
 8015e74:	eee6 7a87 	vfma.f32	s15, s13, s14
		}
	}

	// compute cosine: sin(x + PI/2) = cos(x)
	angle += 0.5 * M_PI;
 8015e78:	ed9f 7a21 	vldr	s14, [pc, #132]	; 8015f00 <utils_fast_sincos_better+0x110>
			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
 8015e7c:	edc0 7a00 	vstr	s15, [r0]
	angle += 0.5 * M_PI;
 8015e80:	ee30 0a07 	vadd.f32	s0, s0, s14
	if (angle >  M_PI) {
 8015e84:	eddf 7a1a 	vldr	s15, [pc, #104]	; 8015ef0 <utils_fast_sincos_better+0x100>
 8015e88:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 8015ef4 <utils_fast_sincos_better+0x104>
 8015e8c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		angle -= 2.0 * M_PI;
 8015e94:	bfc4      	itt	gt
 8015e96:	eddf 7a15 	vldrgt	s15, [pc, #84]	; 8015eec <utils_fast_sincos_better+0xfc>
 8015e9a:	ee30 0a67 	vsubgt.f32	s0, s0, s15
 8015e9e:	eddf 7a16 	vldr	s15, [pc, #88]	; 8015ef8 <utils_fast_sincos_better+0x108>
 8015ea2:	ee20 7a07 	vmul.f32	s14, s0, s14
 8015ea6:	ee60 7a27 	vmul.f32	s15, s0, s15
 8015eaa:	ee27 7a00 	vmul.f32	s14, s14, s0
	}

	if (angle < 0.0) {
 8015eae:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8015eb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		*cos = 1.27323954 * angle + 0.405284735 * angle * angle;
 8015eb6:	bf4c      	ite	mi
 8015eb8:	ee77 7a87 	vaddmi.f32	s15, s15, s14
			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
		} else {
			*cos = 0.225 * (*cos * *cos - *cos) + *cos;
		}
	} else {
		*cos = 1.27323954 * angle - 0.405284735 * angle * angle;
 8015ebc:	ee77 7ac7 	vsubpl.f32	s15, s15, s14

		if (*cos < 0.0) {
			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
		} else {
			*cos = 0.225 * (*cos * *cos - *cos) + *cos;
 8015ec0:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8015efc <utils_fast_sincos_better+0x10c>
		*cos = 1.27323954 * angle - 0.405284735 * angle * angle;
 8015ec4:	edc1 7a00 	vstr	s15, [r1]
		if (*cos < 0.0) {
 8015ec8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
 8015ecc:	eef0 6a67 	vmov.f32	s13, s15
		if (*cos < 0.0) {
 8015ed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
 8015ed4:	bf4c      	ite	mi
 8015ed6:	eed7 6ae7 	vfnmami.f32	s13, s15, s15
			*cos = 0.225 * (*cos * *cos - *cos) + *cos;
 8015eda:	eed7 6aa7 	vfnmspl.f32	s13, s15, s15
 8015ede:	eee6 7a87 	vfma.f32	s15, s13, s14
 8015ee2:	edc1 7a00 	vstr	s15, [r1]
		}
	}
}
 8015ee6:	4770      	bx	lr
 8015ee8:	c0490fdb 	.word	0xc0490fdb
 8015eec:	40c90fdb 	.word	0x40c90fdb
 8015ef0:	40490fdb 	.word	0x40490fdb
 8015ef4:	3ecf817b 	.word	0x3ecf817b
 8015ef8:	3fa2f983 	.word	0x3fa2f983
 8015efc:	3e666666 	.word	0x3e666666
 8015f00:	3fc90fdb 	.word	0x3fc90fdb
	...

08015f10 <utils_min_abs>:
 * @return
 * The value with the lowest magnitude.
 */
float utils_min_abs(float va, float vb) {
	float res;
	if (fabsf(va) < fabsf(vb)) {
 8015f10:	eeb0 7ac0 	vabs.f32	s14, s0
 8015f14:	eef0 7ae0 	vabs.f32	s15, s1
 8015f18:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015f1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	} else {
		res = vb;
	}

	return res;
}
 8015f20:	bf58      	it	pl
 8015f22:	eeb0 0a60 	vmovpl.f32	s0, s1
 8015f26:	4770      	bx	lr
	...

08015f30 <utils_max_abs>:
 * @return
 * The value with the highest magnitude.
 */
float utils_max_abs(float va, float vb) {
	float res;
	if (fabsf(va) > fabsf(vb)) {
 8015f30:	eeb0 7ac0 	vabs.f32	s14, s0
 8015f34:	eef0 7ae0 	vabs.f32	s15, s1
 8015f38:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015f3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	} else {
		res = vb;
	}

	return res;
}
 8015f40:	bfd8      	it	le
 8015f42:	eeb0 0a60 	vmovle.f32	s0, s1
 8015f46:	4770      	bx	lr
	...

08015f50 <utils_throttle_curve>:
	for (z = 128; z > 0; z >>= 1) {
		strcat(b, ((x & z) == z) ? "1" : "0");
	}
}

float utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode) {
 8015f50:	b500      	push	{lr}
	float ret = 0.0;
	
	if (val < -1.0) {
 8015f52:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
float utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode) {
 8015f56:	ed2d 8b04 	vpush	{d8-d9}
	if (val < -1.0) {
 8015f5a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8015f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
float utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode) {
 8015f62:	b083      	sub	sp, #12
	if (val < -1.0) {
 8015f64:	d42d      	bmi.n	8015fc2 <utils_throttle_curve+0x72>
 8015f66:	eeb0 8a40 	vmov.f32	s16, s0
		val = -1.0;
	}

	if (val > 1.0) {
 8015f6a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015f6e:	eeb4 8ac0 	vcmpe.f32	s16, s0
 8015f72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		val = 1.0;
 8015f76:	bfc8      	it	gt
 8015f78:	eeb0 8a40 	vmovgt.f32	s16, s0
	if (val > 1.0) {
 8015f7c:	f340 8084 	ble.w	8016088 <utils_throttle_curve+0x138>
		curve = curve_brake;
	}

	// See
	// http://math.stackexchange.com/questions/297768/how-would-i-create-a-exponential-ramp-function-from-0-0-to-1-1-with-a-single-val
	if (mode == 0) { // Exponential
 8015f80:	b978      	cbnz	r0, 8015fa2 <utils_throttle_curve+0x52>
		if (curve >= 0.0) {
 8015f82:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 8015f86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f8a:	db21      	blt.n	8015fd0 <utils_throttle_curve+0x80>
			ret = 1.0 - powf(1.0 - val_a, 1.0 + curve);
 8015f8c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 8015f90:	ee70 0aa8 	vadd.f32	s1, s1, s17
 8015f94:	ee38 0ac0 	vsub.f32	s0, s17, s0
 8015f98:	f00e ffc2 	bl	8024f20 <powf>
 8015f9c:	ee38 0ac0 	vsub.f32	s0, s17, s0
 8015fa0:	e003      	b.n	8015faa <utils_throttle_curve+0x5a>
		} else {
			ret = powf(val_a, 1.0 - curve);
		}
	} else if (mode == 1) { // Natural
 8015fa2:	2801      	cmp	r0, #1
 8015fa4:	d01b      	beq.n	8015fde <utils_throttle_curve+0x8e>
				ret = 1.0 - ((expf(curve * (1.0 - val_a)) - 1.0) / (expf(curve) - 1.0));
			} else {
				ret = (expf(-curve * val_a) - 1.0) / (expf(-curve) - 1.0);
			}
		}
	} else if (mode == 2) { // Polynomial
 8015fa6:	2802      	cmp	r0, #2
 8015fa8:	d042      	beq.n	8016030 <utils_throttle_curve+0xe0>
		}
	} else { // Linear
		ret = val_a;
	}

	if (val < 0.0) {
 8015faa:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8015fae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		ret = -ret;
 8015fb2:	bf48      	it	mi
 8015fb4:	eeb1 0a40 	vnegmi.f32	s0, s0
	}

	return ret;
}
 8015fb8:	b003      	add	sp, #12
 8015fba:	ecbd 8b04 	vpop	{d8-d9}
 8015fbe:	f85d fb04 	ldr.w	pc, [sp], #4
		curve = curve_brake;
 8015fc2:	eef0 0a41 	vmov.f32	s1, s2
		val = -1.0;
 8015fc6:	eeb0 8a67 	vmov.f32	s16, s15
	float val_a = fabsf(val);
 8015fca:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015fce:	e7d7      	b.n	8015f80 <utils_throttle_curve+0x30>
			ret = powf(val_a, 1.0 - curve);
 8015fd0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015fd4:	ee77 0ae0 	vsub.f32	s1, s15, s1
 8015fd8:	f00e ffa2 	bl	8024f20 <powf>
 8015fdc:	e7e5      	b.n	8015faa <utils_throttle_curve+0x5a>
		if (fabsf(curve) < 1e-10) {
 8015fde:	eddf 7a2f 	vldr	s15, [pc, #188]	; 801609c <utils_throttle_curve+0x14c>
 8015fe2:	eeb0 7ae0 	vabs.f32	s14, s1
 8015fe6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015fea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015fee:	d4dc      	bmi.n	8015faa <utils_throttle_curve+0x5a>
			if (curve >= 0.0) {
 8015ff0:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 8015ff4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ff8:	db31      	blt.n	801605e <utils_throttle_curve+0x10e>
				ret = 1.0 - ((expf(curve * (1.0 - val_a)) - 1.0) / (expf(curve) - 1.0));
 8015ffa:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 8015ffe:	ee38 0ac0 	vsub.f32	s0, s17, s0
 8016002:	edcd 0a01 	vstr	s1, [sp, #4]
 8016006:	ee20 0a20 	vmul.f32	s0, s0, s1
 801600a:	f00e fd91 	bl	8024b30 <expf>
 801600e:	eddd 0a01 	vldr	s1, [sp, #4]
 8016012:	eeb0 9a40 	vmov.f32	s18, s0
 8016016:	eeb0 0a60 	vmov.f32	s0, s1
 801601a:	f00e fd89 	bl	8024b30 <expf>
 801601e:	ee79 7a68 	vsub.f32	s15, s18, s17
 8016022:	ee30 7a68 	vsub.f32	s14, s0, s17
 8016026:	ee87 0a87 	vdiv.f32	s0, s15, s14
 801602a:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801602e:	e7bc      	b.n	8015faa <utils_throttle_curve+0x5a>
		if (curve >= 0.0) {
 8016030:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 8016034:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801603c:	ee37 7ac0 	vsub.f32	s14, s15, s0
 8016040:	db08      	blt.n	8016054 <utils_throttle_curve+0x104>
			ret = 1.0 - ((1.0 - val_a) / (1.0 + curve * val_a));
 8016042:	eef0 6a67 	vmov.f32	s13, s15
 8016046:	eee0 6a80 	vfma.f32	s13, s1, s0
 801604a:	ee87 0a26 	vdiv.f32	s0, s14, s13
 801604e:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8016052:	e7aa      	b.n	8015faa <utils_throttle_curve+0x5a>
			ret = val_a / (1.0 - curve * (1.0 - val_a));
 8016054:	eee0 7ac7 	vfms.f32	s15, s1, s14
 8016058:	ee80 0a27 	vdiv.f32	s0, s0, s15
 801605c:	e7a5      	b.n	8015faa <utils_throttle_curve+0x5a>
				ret = (expf(-curve * val_a) - 1.0) / (expf(-curve) - 1.0);
 801605e:	eef1 8a60 	vneg.f32	s17, s1
 8016062:	ee28 0a80 	vmul.f32	s0, s17, s0
 8016066:	f00e fd63 	bl	8024b30 <expf>
 801606a:	eeb0 9a40 	vmov.f32	s18, s0
 801606e:	eeb0 0a68 	vmov.f32	s0, s17
 8016072:	f00e fd5d 	bl	8024b30 <expf>
 8016076:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801607a:	ee30 7a67 	vsub.f32	s14, s0, s15
 801607e:	ee39 9a67 	vsub.f32	s18, s18, s15
 8016082:	ee89 0a07 	vdiv.f32	s0, s18, s14
 8016086:	e790      	b.n	8015faa <utils_throttle_curve+0x5a>
		curve = curve_brake;
 8016088:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 801608c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016090:	bfb8      	it	lt
 8016092:	eef0 0a41 	vmovlt.f32	s1, s2
	float val_a = fabsf(val);
 8016096:	eeb0 0ac8 	vabs.f32	s0, s16
 801609a:	e771      	b.n	8015f80 <utils_throttle_curve+0x30>
 801609c:	2edbe6ff 	.word	0x2edbe6ff

080160a0 <utils_sys_lock_cnt>:
 * exist to unlock the system. That means, if lock is called five times, unlock has to
 * be called five times as well. Note that chSysLock and chSysLockFromIsr are the same
 * for this port.
 */
void utils_sys_lock_cnt(void) {
	if (!sys_lock_cnt) {
 80160a0:	4b04      	ldr	r3, [pc, #16]	; (80160b4 <utils_sys_lock_cnt+0x14>)
 80160a2:	681a      	ldr	r2, [r3, #0]
 80160a4:	b912      	cbnz	r2, 80160ac <utils_sys_lock_cnt+0xc>
 80160a6:	2220      	movs	r2, #32
 80160a8:	f382 8811 	msr	BASEPRI, r2
		chSysLock();
	}
	sys_lock_cnt++;
 80160ac:	681a      	ldr	r2, [r3, #0]
 80160ae:	3201      	adds	r2, #1
 80160b0:	601a      	str	r2, [r3, #0]
}
 80160b2:	4770      	bx	lr
 80160b4:	200063d8 	.word	0x200063d8
	...

080160c0 <utils_sys_unlock_cnt>:
 * exist to unlock the system. That means, if lock is called five times, unlock has to
 * be called five times as well. Note that chSysUnlock and chSysUnlockFromIsr are the same
 * for this port.
 */
void utils_sys_unlock_cnt(void) {
	if (sys_lock_cnt) {
 80160c0:	4b05      	ldr	r3, [pc, #20]	; (80160d8 <utils_sys_unlock_cnt+0x18>)
 80160c2:	681a      	ldr	r2, [r3, #0]
 80160c4:	b132      	cbz	r2, 80160d4 <utils_sys_unlock_cnt+0x14>
		sys_lock_cnt--;
 80160c6:	681a      	ldr	r2, [r3, #0]
 80160c8:	3a01      	subs	r2, #1
 80160ca:	601a      	str	r2, [r3, #0]
		if (!sys_lock_cnt) {
 80160cc:	681b      	ldr	r3, [r3, #0]
 80160ce:	b90b      	cbnz	r3, 80160d4 <utils_sys_unlock_cnt+0x14>
 80160d0:	f383 8811 	msr	BASEPRI, r3
			chSysUnlock();
		}
	}
}
 80160d4:	4770      	bx	lr
 80160d6:	bf00      	nop
 80160d8:	200063d8 	.word	0x200063d8
 80160dc:	00000000 	.word	0x00000000

080160e0 <packet_init>:
 80160e0:	4b03      	ldr	r3, [pc, #12]	; (80160f0 <packet_init+0x10>)
 80160e2:	eb02 1282 	add.w	r2, r2, r2, lsl #6
 80160e6:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 80160ea:	6050      	str	r0, [r2, #4]
 80160ec:	6091      	str	r1, [r2, #8]
 80160ee:	4770      	bx	lr
 80160f0:	200063dc 	.word	0x200063dc
	...

08016100 <packet_send_packet>:
 8016100:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8016104:	d83b      	bhi.n	801617e <packet_send_packet+0x7e>
 8016106:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801610a:	0194      	lsls	r4, r2, #6
 801610c:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8016184 <packet_send_packet+0x84>
 8016110:	18a3      	adds	r3, r4, r2
 8016112:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8016116:	eb08 1343 	add.w	r3, r8, r3, lsl #5
 801611a:	d92a      	bls.n	8016172 <packet_send_packet+0x72>
 801611c:	0a0e      	lsrs	r6, r1, #8
 801611e:	2503      	movs	r5, #3
 8016120:	f883 1412 	strb.w	r1, [r3, #1042]	; 0x412
 8016124:	f883 6411 	strb.w	r6, [r3, #1041]	; 0x411
 8016128:	f883 5410 	strb.w	r5, [r3, #1040]	; 0x410
 801612c:	4422      	add	r2, r4
 801612e:	0154      	lsls	r4, r2, #5
 8016130:	f504 6982 	add.w	r9, r4, #1040	; 0x410
 8016134:	4607      	mov	r7, r0
 8016136:	44c1      	add	r9, r8
 8016138:	460a      	mov	r2, r1
 801613a:	460e      	mov	r6, r1
 801613c:	eb09 0005 	add.w	r0, r9, r5
 8016140:	4639      	mov	r1, r7
 8016142:	f7f6 fced 	bl	800cb20 <memcpy>
 8016146:	4631      	mov	r1, r6
 8016148:	4638      	mov	r0, r7
 801614a:	f7fb ff11 	bl	8011f70 <crc16>
 801614e:	4444      	add	r4, r8
 8016150:	4435      	add	r5, r6
 8016152:	1963      	adds	r3, r4, r5
 8016154:	6862      	ldr	r2, [r4, #4]
 8016156:	f883 0411 	strb.w	r0, [r3, #1041]	; 0x411
 801615a:	2403      	movs	r4, #3
 801615c:	0a00      	lsrs	r0, r0, #8
 801615e:	f883 0410 	strb.w	r0, [r3, #1040]	; 0x410
 8016162:	1929      	adds	r1, r5, r4
 8016164:	f883 4412 	strb.w	r4, [r3, #1042]	; 0x412
 8016168:	b152      	cbz	r2, 8016180 <packet_send_packet+0x80>
 801616a:	4648      	mov	r0, r9
 801616c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016170:	4710      	bx	r2
 8016172:	2502      	movs	r5, #2
 8016174:	f883 1411 	strb.w	r1, [r3, #1041]	; 0x411
 8016178:	f883 5410 	strb.w	r5, [r3, #1040]	; 0x410
 801617c:	e7d6      	b.n	801612c <packet_send_packet+0x2c>
 801617e:	4770      	bx	lr
 8016180:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016184:	200063dc 	.word	0x200063dc
	...

08016190 <packet_timerfunc>:
 8016190:	4a0f      	ldr	r2, [pc, #60]	; (80161d0 <packet_timerfunc+0x40>)
 8016192:	8853      	ldrh	r3, [r2, #2]
 8016194:	b29b      	uxth	r3, r3
 8016196:	b97b      	cbnz	r3, 80161b8 <packet_timerfunc+0x28>
 8016198:	7013      	strb	r3, [r2, #0]
 801619a:	f8b2 3822 	ldrh.w	r3, [r2, #2082]	; 0x822
 801619e:	4a0c      	ldr	r2, [pc, #48]	; (80161d0 <packet_timerfunc+0x40>)
 80161a0:	b29b      	uxth	r3, r3
 80161a2:	b133      	cbz	r3, 80161b2 <packet_timerfunc+0x22>
 80161a4:	f8b2 3822 	ldrh.w	r3, [r2, #2082]	; 0x822
 80161a8:	3b01      	subs	r3, #1
 80161aa:	b29b      	uxth	r3, r3
 80161ac:	f8a2 3822 	strh.w	r3, [r2, #2082]	; 0x822
 80161b0:	4770      	bx	lr
 80161b2:	f882 3820 	strb.w	r3, [r2, #2080]	; 0x820
 80161b6:	4770      	bx	lr
 80161b8:	8853      	ldrh	r3, [r2, #2]
 80161ba:	3b01      	subs	r3, #1
 80161bc:	b29b      	uxth	r3, r3
 80161be:	8053      	strh	r3, [r2, #2]
 80161c0:	f8b2 3822 	ldrh.w	r3, [r2, #2082]	; 0x822
 80161c4:	4a02      	ldr	r2, [pc, #8]	; (80161d0 <packet_timerfunc+0x40>)
 80161c6:	b29b      	uxth	r3, r3
 80161c8:	2b00      	cmp	r3, #0
 80161ca:	d1eb      	bne.n	80161a4 <packet_timerfunc+0x14>
 80161cc:	e7f1      	b.n	80161b2 <packet_timerfunc+0x22>
 80161ce:	bf00      	nop
 80161d0:	200063dc 	.word	0x200063dc
	...

080161e0 <packet_process_byte>:
 80161e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80161e4:	018e      	lsls	r6, r1, #6
 80161e6:	1873      	adds	r3, r6, r1
 80161e8:	015b      	lsls	r3, r3, #5
 80161ea:	4d56      	ldr	r5, [pc, #344]	; (8016344 <packet_process_byte+0x164>)
 80161ec:	5ceb      	ldrb	r3, [r5, r3]
 80161ee:	2b06      	cmp	r3, #6
 80161f0:	d870      	bhi.n	80162d4 <packet_process_byte+0xf4>
 80161f2:	e8df f003 	tbb	[pc, r3]
 80161f6:	190e      	.short	0x190e
 80161f8:	685a3b27 	.word	0x685a3b27
 80161fc:	04          	.byte	0x04
 80161fd:	00          	.byte	0x00
 80161fe:	2803      	cmp	r0, #3
 8016200:	460c      	mov	r4, r1
 8016202:	f000 8083 	beq.w	801630c <packet_process_byte+0x12c>
 8016206:	4434      	add	r4, r6
 8016208:	0164      	lsls	r4, r4, #5
 801620a:	2300      	movs	r3, #0
 801620c:	552b      	strb	r3, [r5, r4]
 801620e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016212:	4431      	add	r1, r6
 8016214:	2802      	cmp	r0, #2
 8016216:	ea4f 1141 	mov.w	r1, r1, lsl #5
 801621a:	d073      	beq.n	8016304 <packet_process_byte+0x124>
 801621c:	2803      	cmp	r0, #3
 801621e:	d063      	beq.n	80162e8 <packet_process_byte+0x108>
 8016220:	2300      	movs	r3, #0
 8016222:	546b      	strb	r3, [r5, r1]
 8016224:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016228:	4431      	add	r1, r6
 801622a:	0149      	lsls	r1, r1, #5
 801622c:	186a      	adds	r2, r5, r1
 801622e:	5c6b      	ldrb	r3, [r5, r1]
 8016230:	3301      	adds	r3, #1
 8016232:	b2db      	uxtb	r3, r3
 8016234:	546b      	strb	r3, [r5, r1]
 8016236:	0200      	lsls	r0, r0, #8
 8016238:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 801623c:	60d0      	str	r0, [r2, #12]
 801623e:	8054      	strh	r4, [r2, #2]
 8016240:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016244:	4431      	add	r1, r6
 8016246:	0149      	lsls	r1, r1, #5
 8016248:	440d      	add	r5, r1
 801624a:	4a3e      	ldr	r2, [pc, #248]	; (8016344 <packet_process_byte+0x164>)
 801624c:	68eb      	ldr	r3, [r5, #12]
 801624e:	4318      	orrs	r0, r3
 8016250:	1e43      	subs	r3, r0, #1
 8016252:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8016256:	60e8      	str	r0, [r5, #12]
 8016258:	d242      	bcs.n	80162e0 <packet_process_byte+0x100>
 801625a:	5c53      	ldrb	r3, [r2, r1]
 801625c:	3301      	adds	r3, #1
 801625e:	b2db      	uxtb	r3, r3
 8016260:	5453      	strb	r3, [r2, r1]
 8016262:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8016266:	8068      	strh	r0, [r5, #2]
 8016268:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801626c:	1874      	adds	r4, r6, r1
 801626e:	0164      	lsls	r4, r4, #5
 8016270:	192a      	adds	r2, r5, r4
 8016272:	f8df c0d0 	ldr.w	ip, [pc, #208]	; 8016344 <packet_process_byte+0x164>
 8016276:	f8d2 3818 	ldr.w	r3, [r2, #2072]	; 0x818
 801627a:	68d7      	ldr	r7, [r2, #12]
 801627c:	eb02 0e03 	add.w	lr, r2, r3
 8016280:	3301      	adds	r3, #1
 8016282:	42bb      	cmp	r3, r7
 8016284:	f88e 0010 	strb.w	r0, [lr, #16]
 8016288:	f8c2 3818 	str.w	r3, [r2, #2072]	; 0x818
 801628c:	d105      	bne.n	801629a <packet_process_byte+0xba>
 801628e:	f81c 3004 	ldrb.w	r3, [ip, r4]
 8016292:	3301      	adds	r3, #1
 8016294:	b2db      	uxtb	r3, r3
 8016296:	f80c 3004 	strb.w	r3, [ip, r4]
 801629a:	4431      	add	r1, r6
 801629c:	eb05 1541 	add.w	r5, r5, r1, lsl #5
 80162a0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80162a4:	806b      	strh	r3, [r5, #2]
 80162a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80162aa:	4431      	add	r1, r6
 80162ac:	0149      	lsls	r1, r1, #5
 80162ae:	186a      	adds	r2, r5, r1
 80162b0:	5c6b      	ldrb	r3, [r5, r1]
 80162b2:	f882 081d 	strb.w	r0, [r2, #2077]	; 0x81d
 80162b6:	3301      	adds	r3, #1
 80162b8:	b2db      	uxtb	r3, r3
 80162ba:	546b      	strb	r3, [r5, r1]
 80162bc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80162c0:	8050      	strh	r0, [r2, #2]
 80162c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80162c6:	4431      	add	r1, r6
 80162c8:	0149      	lsls	r1, r1, #5
 80162ca:	186a      	adds	r2, r5, r1
 80162cc:	5c6b      	ldrb	r3, [r5, r1]
 80162ce:	f882 081c 	strb.w	r0, [r2, #2076]	; 0x81c
 80162d2:	e7f0      	b.n	80162b6 <packet_process_byte+0xd6>
 80162d4:	4431      	add	r1, r6
 80162d6:	0149      	lsls	r1, r1, #5
 80162d8:	2300      	movs	r3, #0
 80162da:	546b      	strb	r3, [r5, r1]
 80162dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80162e0:	2300      	movs	r3, #0
 80162e2:	5453      	strb	r3, [r2, r1]
 80162e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80162e8:	5c6b      	ldrb	r3, [r5, r1]
 80162ea:	186a      	adds	r2, r5, r1
 80162ec:	3301      	adds	r3, #1
 80162ee:	b2db      	uxtb	r3, r3
 80162f0:	546b      	strb	r3, [r5, r1]
 80162f2:	2000      	movs	r0, #0
 80162f4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80162f8:	f8c2 0818 	str.w	r0, [r2, #2072]	; 0x818
 80162fc:	8054      	strh	r4, [r2, #2]
 80162fe:	60d0      	str	r0, [r2, #12]
 8016300:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016304:	5c6b      	ldrb	r3, [r5, r1]
 8016306:	186a      	adds	r2, r5, r1
 8016308:	3302      	adds	r3, #2
 801630a:	e7f0      	b.n	80162ee <packet_process_byte+0x10e>
 801630c:	1877      	adds	r7, r6, r1
 801630e:	017f      	lsls	r7, r7, #5
 8016310:	eb05 0907 	add.w	r9, r5, r7
 8016314:	f107 0810 	add.w	r8, r7, #16
 8016318:	44a8      	add	r8, r5
 801631a:	4640      	mov	r0, r8
 801631c:	f8d9 100c 	ldr.w	r1, [r9, #12]
 8016320:	f7fb fe26 	bl	8011f70 <crc16>
 8016324:	f8b9 381c 	ldrh.w	r3, [r9, #2076]	; 0x81c
 8016328:	4283      	cmp	r3, r0
 801632a:	f47f af6c 	bne.w	8016206 <packet_process_byte+0x26>
 801632e:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8016332:	2b00      	cmp	r3, #0
 8016334:	f43f af67 	beq.w	8016206 <packet_process_byte+0x26>
 8016338:	f8d9 100c 	ldr.w	r1, [r9, #12]
 801633c:	4640      	mov	r0, r8
 801633e:	4798      	blx	r3
 8016340:	e761      	b.n	8016206 <packet_process_byte+0x26>
 8016342:	bf00      	nop
 8016344:	200063dc 	.word	0x200063dc
	...

08016350 <terminal_process_string>:
static volatile fault_data fault_vec[FAULT_VEC_LEN];
static volatile int fault_vec_write = 0;
static terminal_callback_struct callbacks[CALLBACK_LEN];
static int callback_write = 0;

void terminal_process_string(char *str) {
 8016350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016354:	ed2d 8b08 	vpush	{d8-d11}
	enum { kMaxArgs = 64 };
	int argc = 0;
	char *argv[kMaxArgs];

	char *p2 = strtok(str, " ");
 8016358:	498f      	ldr	r1, [pc, #572]	; (8016598 <terminal_process_string+0x248>)
void terminal_process_string(char *str) {
 801635a:	b0d8      	sub	sp, #352	; 0x160
	char *p2 = strtok(str, " ");
 801635c:	f010 fce8 	bl	8026d30 <strtok>
	while (p2 && argc < kMaxArgs) {
 8016360:	2800      	cmp	r0, #0
 8016362:	d05b      	beq.n	801641c <terminal_process_string+0xcc>
 8016364:	4603      	mov	r3, r0
		argv[argc++] = p2;
		p2 = strtok(0, " ");
 8016366:	4e8c      	ldr	r6, [pc, #560]	; (8016598 <terminal_process_string+0x248>)
 8016368:	ad18      	add	r5, sp, #96	; 0x60
	int argc = 0;
 801636a:	2400      	movs	r4, #0
 801636c:	e001      	b.n	8016372 <terminal_process_string+0x22>
	while (p2 && argc < kMaxArgs) {
 801636e:	2c40      	cmp	r4, #64	; 0x40
 8016370:	d009      	beq.n	8016386 <terminal_process_string+0x36>
		argv[argc++] = p2;
 8016372:	f845 3b04 	str.w	r3, [r5], #4
		p2 = strtok(0, " ");
 8016376:	4631      	mov	r1, r6
 8016378:	2000      	movs	r0, #0
 801637a:	f010 fcd9 	bl	8026d30 <strtok>
		argv[argc++] = p2;
 801637e:	3401      	adds	r4, #1
	while (p2 && argc < kMaxArgs) {
 8016380:	4603      	mov	r3, r0
 8016382:	2800      	cmp	r0, #0
 8016384:	d1f3      	bne.n	801636e <terminal_process_string+0x1e>
		return;
	}

	static mc_configuration mcconf; // static to save some stack
	static mc_configuration mcconf_old; // static to save some stack
	mcconf = *mc_interface_get_configuration();
 8016386:	f005 f83b 	bl	801b400 <mc_interface_get_configuration>
 801638a:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801638e:	4601      	mov	r1, r0
 8016390:	4882      	ldr	r0, [pc, #520]	; (801659c <terminal_process_string+0x24c>)
 8016392:	f7f6 fbc5 	bl	800cb20 <memcpy>
	mcconf_old = mcconf;
 8016396:	4981      	ldr	r1, [pc, #516]	; (801659c <terminal_process_string+0x24c>)
 8016398:	4881      	ldr	r0, [pc, #516]	; (80165a0 <terminal_process_string+0x250>)
 801639a:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801639e:	f7f6 fbbf 	bl	800cb20 <memcpy>

	if (strcmp(argv[0], "ping") == 0) {
 80163a2:	9d18      	ldr	r5, [sp, #96]	; 0x60
 80163a4:	497f      	ldr	r1, [pc, #508]	; (80165a4 <terminal_process_string+0x254>)
 80163a6:	4628      	mov	r0, r5
 80163a8:	f7f6 fc5e 	bl	800cc68 <strcmp>
 80163ac:	2800      	cmp	r0, #0
 80163ae:	d03d      	beq.n	801642c <terminal_process_string+0xdc>
		commands_printf("pong\n");
	} else if (strcmp(argv[0], "stop") == 0) {
 80163b0:	497d      	ldr	r1, [pc, #500]	; (80165a8 <terminal_process_string+0x258>)
 80163b2:	4628      	mov	r0, r5
 80163b4:	f7f6 fc58 	bl	800cc68 <strcmp>
 80163b8:	2800      	cmp	r0, #0
 80163ba:	d069      	beq.n	8016490 <terminal_process_string+0x140>
		mc_interface_set_duty(0);
		commands_printf("Motor stopped\n");
	} else if (strcmp(argv[0], "last_adc_duration") == 0) {
 80163bc:	497b      	ldr	r1, [pc, #492]	; (80165ac <terminal_process_string+0x25c>)
 80163be:	4628      	mov	r0, r5
 80163c0:	f7f6 fc52 	bl	800cc68 <strcmp>
 80163c4:	2800      	cmp	r0, #0
 80163c6:	d039      	beq.n	801643c <terminal_process_string+0xec>
		commands_printf("Latest ADC duration: %.4f ms", (double)(mcpwm_get_last_adc_isr_duration() * 1000.0));
		commands_printf("Latest injected ADC duration: %.4f ms", (double)(mc_interface_get_last_inj_adc_isr_duration() * 1000.0));
		commands_printf("Latest sample ADC duration: %.4f ms\n", (double)(mc_interface_get_last_sample_adc_isr_duration() * 1000.0));
	} else if (strcmp(argv[0], "kv") == 0) {
 80163c8:	4979      	ldr	r1, [pc, #484]	; (80165b0 <terminal_process_string+0x260>)
 80163ca:	4628      	mov	r0, r5
 80163cc:	f7f6 fc4c 	bl	800cc68 <strcmp>
 80163d0:	2800      	cmp	r0, #0
 80163d2:	d069      	beq.n	80164a8 <terminal_process_string+0x158>
		commands_printf("Calculated KV: %.2f rpm/volt\n", (double)mcpwm_get_kv_filtered());
	} else if (strcmp(argv[0], "mem") == 0) {
 80163d4:	4977      	ldr	r1, [pc, #476]	; (80165b4 <terminal_process_string+0x264>)
 80163d6:	4628      	mov	r0, r5
 80163d8:	f7f6 fc46 	bl	800cc68 <strcmp>
 80163dc:	2800      	cmp	r0, #0
 80163de:	d078      	beq.n	80164d2 <terminal_process_string+0x182>
		size_t n, size;
		n = chHeapStatus(NULL, &size);
		commands_printf("core free memory : %u bytes", chCoreGetStatusX());
		commands_printf("heap fragments   : %u", n);
		commands_printf("heap free total  : %u bytes\n", size);
	} else if (strcmp(argv[0], "threads") == 0) {
 80163e0:	4975      	ldr	r1, [pc, #468]	; (80165b8 <terminal_process_string+0x268>)
 80163e2:	4628      	mov	r0, r5
 80163e4:	f7f6 fc40 	bl	800cc68 <strcmp>
 80163e8:	2800      	cmp	r0, #0
 80163ea:	f000 8085 	beq.w	80164f8 <terminal_process_string+0x1a8>
					(uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
					states[tp->p_state], tp->p_name, (uint32_t)tp->p_time);
			tp = chRegNextThread(tp);
		} while (tp != NULL);
		commands_printf("");
	} else if (strcmp(argv[0], "fault") == 0) {
 80163ee:	4973      	ldr	r1, [pc, #460]	; (80165bc <terminal_process_string+0x26c>)
 80163f0:	4628      	mov	r0, r5
 80163f2:	f7f6 fc39 	bl	800cc68 <strcmp>
 80163f6:	2800      	cmp	r0, #0
 80163f8:	d062      	beq.n	80164c0 <terminal_process_string+0x170>
		commands_printf("%s\n", mc_interface_fault_to_string(mc_interface_get_fault()));
	} else if (strcmp(argv[0], "faults") == 0) {
 80163fa:	4971      	ldr	r1, [pc, #452]	; (80165c0 <terminal_process_string+0x270>)
 80163fc:	4628      	mov	r0, r5
 80163fe:	f7f6 fc33 	bl	800cc68 <strcmp>
 8016402:	4606      	mov	r6, r0
 8016404:	2800      	cmp	r0, #0
 8016406:	f040 809d 	bne.w	8016544 <terminal_process_string+0x1f4>
		if (fault_vec_write == 0) {
 801640a:	4f6e      	ldr	r7, [pc, #440]	; (80165c4 <terminal_process_string+0x274>)
 801640c:	683b      	ldr	r3, [r7, #0]
 801640e:	2b00      	cmp	r3, #0
 8016410:	f040 810c 	bne.w	801662c <terminal_process_string+0x2dc>
			commands_printf("No faults registered since startup\n");
 8016414:	486c      	ldr	r0, [pc, #432]	; (80165c8 <terminal_process_string+0x278>)
 8016416:	f002 f913 	bl	8018640 <commands_printf>
 801641a:	e002      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("No command received\n");
 801641c:	486b      	ldr	r0, [pc, #428]	; (80165cc <terminal_process_string+0x27c>)
 801641e:	f002 f90f 	bl	8018640 <commands_printf>
		if (!found) {
			commands_printf("Invalid command: %s\n"
					"type help to list all available commands\n", argv[0]);
		}
	}
}
 8016422:	b058      	add	sp, #352	; 0x160
 8016424:	ecbd 8b08 	vpop	{d8-d11}
 8016428:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		commands_printf("pong\n");
 801642c:	4868      	ldr	r0, [pc, #416]	; (80165d0 <terminal_process_string+0x280>)
 801642e:	f002 f907 	bl	8018640 <commands_printf>
}
 8016432:	b058      	add	sp, #352	; 0x160
 8016434:	ecbd 8b08 	vpop	{d8-d11}
 8016438:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		commands_printf("Latest ADC duration: %.4f ms", (double)(mcpwm_get_last_adc_isr_duration() * 1000.0));
 801643c:	f7fd fef8 	bl	8014230 <mcpwm_get_last_adc_isr_duration>
 8016440:	ed9f 8a64 	vldr	s16, [pc, #400]	; 80165d4 <terminal_process_string+0x284>
 8016444:	ee60 7a08 	vmul.f32	s15, s0, s16
 8016448:	ee17 0a90 	vmov	r0, s15
 801644c:	f7f5 ffdc 	bl	800c408 <__aeabi_f2d>
 8016450:	4602      	mov	r2, r0
 8016452:	460b      	mov	r3, r1
 8016454:	4860      	ldr	r0, [pc, #384]	; (80165d8 <terminal_process_string+0x288>)
 8016456:	f002 f8f3 	bl	8018640 <commands_printf>
		commands_printf("Latest injected ADC duration: %.4f ms", (double)(mc_interface_get_last_inj_adc_isr_duration() * 1000.0));
 801645a:	f005 fd89 	bl	801bf70 <mc_interface_get_last_inj_adc_isr_duration>
 801645e:	ee60 7a08 	vmul.f32	s15, s0, s16
 8016462:	ee17 0a90 	vmov	r0, s15
 8016466:	f7f5 ffcf 	bl	800c408 <__aeabi_f2d>
 801646a:	4602      	mov	r2, r0
 801646c:	460b      	mov	r3, r1
 801646e:	485b      	ldr	r0, [pc, #364]	; (80165dc <terminal_process_string+0x28c>)
 8016470:	f002 f8e6 	bl	8018640 <commands_printf>
		commands_printf("Latest sample ADC duration: %.4f ms\n", (double)(mc_interface_get_last_sample_adc_isr_duration() * 1000.0));
 8016474:	f005 fe0c 	bl	801c090 <mc_interface_get_last_sample_adc_isr_duration>
 8016478:	ee60 7a08 	vmul.f32	s15, s0, s16
 801647c:	ee17 0a90 	vmov	r0, s15
 8016480:	f7f5 ffc2 	bl	800c408 <__aeabi_f2d>
 8016484:	4602      	mov	r2, r0
 8016486:	460b      	mov	r3, r1
 8016488:	4855      	ldr	r0, [pc, #340]	; (80165e0 <terminal_process_string+0x290>)
 801648a:	f002 f8d9 	bl	8018640 <commands_printf>
 801648e:	e7c8      	b.n	8016422 <terminal_process_string+0xd2>
		mc_interface_set_duty(0);
 8016490:	ed9f 0a54 	vldr	s0, [pc, #336]	; 80165e4 <terminal_process_string+0x294>
 8016494:	f005 fe7c 	bl	801c190 <mc_interface_set_duty>
		commands_printf("Motor stopped\n");
 8016498:	4853      	ldr	r0, [pc, #332]	; (80165e8 <terminal_process_string+0x298>)
 801649a:	f002 f8d1 	bl	8018640 <commands_printf>
}
 801649e:	b058      	add	sp, #352	; 0x160
 80164a0:	ecbd 8b08 	vpop	{d8-d11}
 80164a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		commands_printf("Calculated KV: %.2f rpm/volt\n", (double)mcpwm_get_kv_filtered());
 80164a8:	f7fd fb3a 	bl	8013b20 <mcpwm_get_kv_filtered>
 80164ac:	ee10 0a10 	vmov	r0, s0
 80164b0:	f7f5 ffaa 	bl	800c408 <__aeabi_f2d>
 80164b4:	4602      	mov	r2, r0
 80164b6:	460b      	mov	r3, r1
 80164b8:	484c      	ldr	r0, [pc, #304]	; (80165ec <terminal_process_string+0x29c>)
 80164ba:	f002 f8c1 	bl	8018640 <commands_printf>
 80164be:	e7b0      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("%s\n", mc_interface_fault_to_string(mc_interface_get_fault()));
 80164c0:	f004 ffce 	bl	801b460 <mc_interface_get_fault>
 80164c4:	f004 ffd4 	bl	801b470 <mc_interface_fault_to_string>
 80164c8:	4601      	mov	r1, r0
 80164ca:	4849      	ldr	r0, [pc, #292]	; (80165f0 <terminal_process_string+0x2a0>)
 80164cc:	f002 f8b8 	bl	8018640 <commands_printf>
 80164d0:	e7a7      	b.n	8016422 <terminal_process_string+0xd2>
		n = chHeapStatus(NULL, &size);
 80164d2:	a911      	add	r1, sp, #68	; 0x44
 80164d4:	f7f7 fef4 	bl	800e2c0 <chHeapStatus>
 80164d8:	4604      	mov	r4, r0
		commands_printf("core free memory : %u bytes", chCoreGetStatusX());
 80164da:	f7f7 fe81 	bl	800e1e0 <chCoreGetStatusX>
 80164de:	4601      	mov	r1, r0
 80164e0:	4844      	ldr	r0, [pc, #272]	; (80165f4 <terminal_process_string+0x2a4>)
 80164e2:	f002 f8ad 	bl	8018640 <commands_printf>
		commands_printf("heap fragments   : %u", n);
 80164e6:	4621      	mov	r1, r4
 80164e8:	4843      	ldr	r0, [pc, #268]	; (80165f8 <terminal_process_string+0x2a8>)
 80164ea:	f002 f8a9 	bl	8018640 <commands_printf>
		commands_printf("heap free total  : %u bytes\n", size);
 80164ee:	9911      	ldr	r1, [sp, #68]	; 0x44
 80164f0:	4842      	ldr	r0, [pc, #264]	; (80165fc <terminal_process_string+0x2ac>)
 80164f2:	f002 f8a5 	bl	8018640 <commands_printf>
 80164f6:	e794      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("    addr    stack prio refs     state           name time    ");
 80164f8:	4841      	ldr	r0, [pc, #260]	; (8016600 <terminal_process_string+0x2b0>)
 80164fa:	4e42      	ldr	r6, [pc, #264]	; (8016604 <terminal_process_string+0x2b4>)
			commands_printf("%.8lx %.8lx %4lu %4lu %9s %14s %lu",
 80164fc:	4d42      	ldr	r5, [pc, #264]	; (8016608 <terminal_process_string+0x2b8>)
		commands_printf("    addr    stack prio refs     state           name time    ");
 80164fe:	f002 f89f 	bl	8018640 <commands_printf>
		commands_printf("-------------------------------------------------------------");
 8016502:	4842      	ldr	r0, [pc, #264]	; (801660c <terminal_process_string+0x2bc>)
 8016504:	f002 f89c 	bl	8018640 <commands_printf>
		tp = chRegFirstThread();
 8016508:	f7f7 fb7a 	bl	800dc00 <chRegFirstThread>
 801650c:	4604      	mov	r4, r0
					states[tp->p_state], tp->p_name, (uint32_t)tp->p_time);
 801650e:	6a21      	ldr	r1, [r4, #32]
			commands_printf("%.8lx %.8lx %4lu %4lu %9s %14s %lu",
 8016510:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 8016514:	9103      	str	r1, [sp, #12]
 8016516:	69a1      	ldr	r1, [r4, #24]
 8016518:	9102      	str	r1, [sp, #8]
					states[tp->p_state], tp->p_name, (uint32_t)tp->p_time);
 801651a:	7f21      	ldrb	r1, [r4, #28]
			commands_printf("%.8lx %.8lx %4lu %4lu %9s %14s %lu",
 801651c:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
 8016520:	9101      	str	r1, [sp, #4]
					(uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 8016522:	7fa1      	ldrb	r1, [r4, #30]
 8016524:	3901      	subs	r1, #1
			commands_printf("%.8lx %.8lx %4lu %4lu %9s %14s %lu",
 8016526:	9100      	str	r1, [sp, #0]
 8016528:	4628      	mov	r0, r5
 801652a:	4621      	mov	r1, r4
 801652c:	f002 f888 	bl	8018640 <commands_printf>
			tp = chRegNextThread(tp);
 8016530:	4620      	mov	r0, r4
 8016532:	f7f7 fb75 	bl	800dc20 <chRegNextThread>
		} while (tp != NULL);
 8016536:	4604      	mov	r4, r0
 8016538:	2800      	cmp	r0, #0
 801653a:	d1e8      	bne.n	801650e <terminal_process_string+0x1be>
		commands_printf("");
 801653c:	4834      	ldr	r0, [pc, #208]	; (8016610 <terminal_process_string+0x2c0>)
 801653e:	f002 f87f 	bl	8018640 <commands_printf>
 8016542:	e76e      	b.n	8016422 <terminal_process_string+0xd2>
	} else if (strcmp(argv[0], "rpm") == 0) {
 8016544:	4933      	ldr	r1, [pc, #204]	; (8016614 <terminal_process_string+0x2c4>)
 8016546:	4628      	mov	r0, r5
 8016548:	f7f6 fb8e 	bl	800cc68 <strcmp>
 801654c:	2800      	cmp	r0, #0
 801654e:	f000 80e6 	beq.w	801671e <terminal_process_string+0x3ce>
	} else if (strcmp(argv[0], "tacho") == 0) {
 8016552:	4931      	ldr	r1, [pc, #196]	; (8016618 <terminal_process_string+0x2c8>)
 8016554:	4628      	mov	r0, r5
 8016556:	f7f6 fb87 	bl	800cc68 <strcmp>
 801655a:	2800      	cmp	r0, #0
 801655c:	f000 80eb 	beq.w	8016736 <terminal_process_string+0x3e6>
	} else if (strcmp(argv[0], "tim") == 0) {
 8016560:	492e      	ldr	r1, [pc, #184]	; (801661c <terminal_process_string+0x2cc>)
 8016562:	4628      	mov	r0, r5
 8016564:	f7f6 fb80 	bl	800cc68 <strcmp>
 8016568:	2800      	cmp	r0, #0
 801656a:	f000 80eb 	beq.w	8016744 <terminal_process_string+0x3f4>
	} else if (strcmp(argv[0], "volt") == 0) {
 801656e:	492c      	ldr	r1, [pc, #176]	; (8016620 <terminal_process_string+0x2d0>)
 8016570:	4628      	mov	r0, r5
 8016572:	f7f6 fb79 	bl	800cc68 <strcmp>
 8016576:	2800      	cmp	r0, #0
 8016578:	f000 812e 	beq.w	80167d8 <terminal_process_string+0x488>
	} else if (strcmp(argv[0], "param_detect") == 0) {
 801657c:	4929      	ldr	r1, [pc, #164]	; (8016624 <terminal_process_string+0x2d4>)
 801657e:	4628      	mov	r0, r5
 8016580:	f7f6 fb72 	bl	800cc68 <strcmp>
 8016584:	2800      	cmp	r0, #0
 8016586:	f040 8185 	bne.w	8016894 <terminal_process_string+0x544>
		if (argc == 4) {
 801658a:	2c04      	cmp	r4, #4
 801658c:	f000 813c 	beq.w	8016808 <terminal_process_string+0x4b8>
			commands_printf("This command requires three arguments.\n");
 8016590:	4825      	ldr	r0, [pc, #148]	; (8016628 <terminal_process_string+0x2d8>)
 8016592:	f002 f855 	bl	8018640 <commands_printf>
 8016596:	e744      	b.n	8016422 <terminal_process_string+0xd2>
 8016598:	0802e26c 	.word	0x0802e26c
 801659c:	20007b2c 	.word	0x20007b2c
 80165a0:	20007ca0 	.word	0x20007ca0
 80165a4:	0802e100 	.word	0x0802e100
 80165a8:	0802e110 	.word	0x0802e110
 80165ac:	0802e128 	.word	0x0802e128
 80165b0:	0802e1ac 	.word	0x0802e1ac
 80165b4:	0802e1d0 	.word	0x0802e1d0
 80165b8:	0802e228 	.word	0x0802e228
 80165bc:	0802e2d4 	.word	0x0802e2d4
 80165c0:	0802e2e0 	.word	0x0802e2e0
 80165c4:	20007b28 	.word	0x20007b28
 80165c8:	0802e2e8 	.word	0x0802e2e8
 80165cc:	0802e0e8 	.word	0x0802e0e8
 80165d0:	0802e108 	.word	0x0802e108
 80165d4:	447a0000 	.word	0x447a0000
 80165d8:	0802e13c 	.word	0x0802e13c
 80165dc:	0802e15c 	.word	0x0802e15c
 80165e0:	0802e184 	.word	0x0802e184
 80165e4:	00000000 	.word	0x00000000
 80165e8:	0802e118 	.word	0x0802e118
 80165ec:	0802e1b0 	.word	0x0802e1b0
 80165f0:	0802e2dc 	.word	0x0802e2dc
 80165f4:	0802e1d4 	.word	0x0802e1d4
 80165f8:	0802e1f0 	.word	0x0802e1f0
 80165fc:	0802e208 	.word	0x0802e208
 8016600:	0802e230 	.word	0x0802e230
 8016604:	0802e000 	.word	0x0802e000
 8016608:	0802e2b0 	.word	0x0802e2b0
 801660c:	0802e270 	.word	0x0802e270
 8016610:	0802e8e0 	.word	0x0802e8e0
 8016614:	0802e490 	.word	0x0802e490
 8016618:	0802e4b0 	.word	0x0802e4b0
 801661c:	0802e4d0 	.word	0x0802e4d0
 8016620:	0802e588 	.word	0x0802e588
 8016624:	0802e5a8 	.word	0x0802e5a8
 8016628:	0802e700 	.word	0x0802e700
			commands_printf("The following faults were registered since start:\n");
 801662c:	48bd      	ldr	r0, [pc, #756]	; (8016924 <terminal_process_string+0x5d4>)
 801662e:	f002 f807 	bl	8018640 <commands_printf>
			for (int i = 0;i < fault_vec_write;i++) {
 8016632:	683b      	ldr	r3, [r7, #0]
 8016634:	2b00      	cmp	r3, #0
 8016636:	f77f aef4 	ble.w	8016422 <terminal_process_string+0xd2>
 801663a:	4dbb      	ldr	r5, [pc, #748]	; (8016928 <terminal_process_string+0x5d8>)
				commands_printf("Fault            : %s", mc_interface_fault_to_string(fault_vec[i].fault));
 801663c:	f8df a3a0 	ldr.w	sl, [pc, #928]	; 80169e0 <terminal_process_string+0x690>
				commands_printf("Current          : %.1f", (double)fault_vec[i].current);
 8016640:	f8df 93a0 	ldr.w	r9, [pc, #928]	; 80169e4 <terminal_process_string+0x694>
				commands_printf("Current filtered : %.1f", (double)fault_vec[i].current_filtered);
 8016644:	f8df 83a0 	ldr.w	r8, [pc, #928]	; 80169e8 <terminal_process_string+0x698>
				commands_printf("Fault            : %s", mc_interface_fault_to_string(fault_vec[i].fault));
 8016648:	ebc6 03c6 	rsb	r3, r6, r6, lsl #3
 801664c:	eb05 04c3 	add.w	r4, r5, r3, lsl #3
 8016650:	f815 0033 	ldrb.w	r0, [r5, r3, lsl #3]
 8016654:	f004 ff0c 	bl	801b470 <mc_interface_fault_to_string>
 8016658:	4601      	mov	r1, r0
 801665a:	4650      	mov	r0, sl
 801665c:	f001 fff0 	bl	8018640 <commands_printf>
				commands_printf("Current          : %.1f", (double)fault_vec[i].current);
 8016660:	6860      	ldr	r0, [r4, #4]
 8016662:	f7f5 fed1 	bl	800c408 <__aeabi_f2d>
 8016666:	4602      	mov	r2, r0
 8016668:	460b      	mov	r3, r1
 801666a:	4648      	mov	r0, r9
 801666c:	f001 ffe8 	bl	8018640 <commands_printf>
				commands_printf("Current filtered : %.1f", (double)fault_vec[i].current_filtered);
 8016670:	68a0      	ldr	r0, [r4, #8]
 8016672:	f7f5 fec9 	bl	800c408 <__aeabi_f2d>
 8016676:	4602      	mov	r2, r0
 8016678:	460b      	mov	r3, r1
 801667a:	4640      	mov	r0, r8
 801667c:	f001 ffe0 	bl	8018640 <commands_printf>
				commands_printf("Voltage          : %.2f", (double)fault_vec[i].voltage);
 8016680:	68e0      	ldr	r0, [r4, #12]
 8016682:	f7f5 fec1 	bl	800c408 <__aeabi_f2d>
 8016686:	4602      	mov	r2, r0
 8016688:	460b      	mov	r3, r1
 801668a:	48a8      	ldr	r0, [pc, #672]	; (801692c <terminal_process_string+0x5dc>)
 801668c:	f001 ffd8 	bl	8018640 <commands_printf>
				commands_printf("Duty             : %.3f", (double)fault_vec[i].duty);
 8016690:	6920      	ldr	r0, [r4, #16]
 8016692:	f7f5 feb9 	bl	800c408 <__aeabi_f2d>
 8016696:	4602      	mov	r2, r0
 8016698:	460b      	mov	r3, r1
 801669a:	48a5      	ldr	r0, [pc, #660]	; (8016930 <terminal_process_string+0x5e0>)
 801669c:	f001 ffd0 	bl	8018640 <commands_printf>
				commands_printf("RPM              : %.1f", (double)fault_vec[i].rpm);
 80166a0:	6960      	ldr	r0, [r4, #20]
 80166a2:	f7f5 feb1 	bl	800c408 <__aeabi_f2d>
 80166a6:	4602      	mov	r2, r0
 80166a8:	460b      	mov	r3, r1
 80166aa:	48a2      	ldr	r0, [pc, #648]	; (8016934 <terminal_process_string+0x5e4>)
 80166ac:	f001 ffc8 	bl	8018640 <commands_printf>
				commands_printf("Tacho            : %d", fault_vec[i].tacho);
 80166b0:	69a1      	ldr	r1, [r4, #24]
 80166b2:	48a1      	ldr	r0, [pc, #644]	; (8016938 <terminal_process_string+0x5e8>)
 80166b4:	f001 ffc4 	bl	8018640 <commands_printf>
				commands_printf("Cycles running   : %d", fault_vec[i].cycles_running);
 80166b8:	69e1      	ldr	r1, [r4, #28]
 80166ba:	48a0      	ldr	r0, [pc, #640]	; (801693c <terminal_process_string+0x5ec>)
 80166bc:	f001 ffc0 	bl	8018640 <commands_printf>
				commands_printf("TIM duty         : %d", (int)((float)fault_vec[i].tim_top * fault_vec[i].duty));
 80166c0:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 80166c4:	ed94 7a04 	vldr	s14, [r4, #16]
 80166c8:	489d      	ldr	r0, [pc, #628]	; (8016940 <terminal_process_string+0x5f0>)
 80166ca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			for (int i = 0;i < fault_vec_write;i++) {
 80166ce:	3601      	adds	r6, #1
				commands_printf("TIM duty         : %d", (int)((float)fault_vec[i].tim_top * fault_vec[i].duty));
 80166d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80166d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80166d8:	ee17 1a90 	vmov	r1, s15
 80166dc:	f001 ffb0 	bl	8018640 <commands_printf>
				commands_printf("TIM val samp     : %d", fault_vec[i].tim_val_samp);
 80166e0:	6a21      	ldr	r1, [r4, #32]
 80166e2:	4898      	ldr	r0, [pc, #608]	; (8016944 <terminal_process_string+0x5f4>)
 80166e4:	f001 ffac 	bl	8018640 <commands_printf>
				commands_printf("TIM current samp : %d", fault_vec[i].tim_current_samp);
 80166e8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80166ea:	4897      	ldr	r0, [pc, #604]	; (8016948 <terminal_process_string+0x5f8>)
 80166ec:	f001 ffa8 	bl	8018640 <commands_printf>
				commands_printf("TIM top          : %d", fault_vec[i].tim_top);
 80166f0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80166f2:	4896      	ldr	r0, [pc, #600]	; (801694c <terminal_process_string+0x5fc>)
 80166f4:	f001 ffa4 	bl	8018640 <commands_printf>
				commands_printf("Comm step        : %d", fault_vec[i].comm_step);
 80166f8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80166fa:	4895      	ldr	r0, [pc, #596]	; (8016950 <terminal_process_string+0x600>)
 80166fc:	f001 ffa0 	bl	8018640 <commands_printf>
				commands_printf("Temperature      : %.2f", (double)fault_vec[i].temperature);
 8016700:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8016702:	f7f5 fe81 	bl	800c408 <__aeabi_f2d>
 8016706:	4602      	mov	r2, r0
 8016708:	460b      	mov	r3, r1
 801670a:	4892      	ldr	r0, [pc, #584]	; (8016954 <terminal_process_string+0x604>)
 801670c:	f001 ff98 	bl	8018640 <commands_printf>
				commands_printf(" ");
 8016710:	4891      	ldr	r0, [pc, #580]	; (8016958 <terminal_process_string+0x608>)
 8016712:	f001 ff95 	bl	8018640 <commands_printf>
			for (int i = 0;i < fault_vec_write;i++) {
 8016716:	683b      	ldr	r3, [r7, #0]
 8016718:	42b3      	cmp	r3, r6
 801671a:	dc95      	bgt.n	8016648 <terminal_process_string+0x2f8>
 801671c:	e681      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("Electrical RPM: %.2f rpm\n", (double)mc_interface_get_rpm());
 801671e:	f004 feff 	bl	801b520 <mc_interface_get_rpm>
 8016722:	ee10 0a10 	vmov	r0, s0
 8016726:	f7f5 fe6f 	bl	800c408 <__aeabi_f2d>
 801672a:	4602      	mov	r2, r0
 801672c:	460b      	mov	r3, r1
 801672e:	488b      	ldr	r0, [pc, #556]	; (801695c <terminal_process_string+0x60c>)
 8016730:	f001 ff86 	bl	8018640 <commands_printf>
 8016734:	e675      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("Tachometer counts: %i\n", mc_interface_get_tachometer_value(0));
 8016736:	f004 ffdb 	bl	801b6f0 <mc_interface_get_tachometer_value>
 801673a:	4601      	mov	r1, r0
 801673c:	4888      	ldr	r0, [pc, #544]	; (8016960 <terminal_process_string+0x610>)
 801673e:	f001 ff7f 	bl	8018640 <commands_printf>
 8016742:	e66e      	b.n	8016422 <terminal_process_string+0xd2>
 8016744:	2320      	movs	r3, #32
 8016746:	f383 8811 	msr	BASEPRI, r3
		volatile int t1_cnt = TIM1->CNT;
 801674a:	4b86      	ldr	r3, [pc, #536]	; (8016964 <terminal_process_string+0x614>)
		volatile int t8_cnt = TIM8->CNT;
 801674c:	4a86      	ldr	r2, [pc, #536]	; (8016968 <terminal_process_string+0x618>)
		volatile int t1_cnt = TIM1->CNT;
 801674e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8016750:	910e      	str	r1, [sp, #56]	; 0x38
		volatile int t8_cnt = TIM8->CNT;
 8016752:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8016754:	910f      	str	r1, [sp, #60]	; 0x3c
		volatile int dir1 = !!(TIM1->CR1 & (1 << 4));
 8016756:	6819      	ldr	r1, [r3, #0]
 8016758:	f3c1 1100 	ubfx	r1, r1, #4, #1
 801675c:	9110      	str	r1, [sp, #64]	; 0x40
		volatile int dir8 = !!(TIM8->CR1 & (1 << 4));
 801675e:	6811      	ldr	r1, [r2, #0]
 8016760:	f3c1 1100 	ubfx	r1, r1, #4, #1
 8016764:	9111      	str	r1, [sp, #68]	; 0x44
 8016766:	f380 8811 	msr	BASEPRI, r0
		commands_printf("Tim1 CNT: %i", t1_cnt);
 801676a:	4880      	ldr	r0, [pc, #512]	; (801696c <terminal_process_string+0x61c>)
		int duty1 = TIM1->CCR1;
 801676c:	f8d3 a034 	ldr.w	sl, [r3, #52]	; 0x34
		int duty2 = TIM1->CCR2;
 8016770:	f8d3 9038 	ldr.w	r9, [r3, #56]	; 0x38
		int duty3 = TIM1->CCR3;
 8016774:	f8d3 803c 	ldr.w	r8, [r3, #60]	; 0x3c
		int top = TIM1->ARR;
 8016778:	6adf      	ldr	r7, [r3, #44]	; 0x2c
		int voltage_samp = TIM8->CCR1;
 801677a:	6b56      	ldr	r6, [r2, #52]	; 0x34
		int current1_samp = TIM1->CCR4;
 801677c:	6c1d      	ldr	r5, [r3, #64]	; 0x40
		int current2_samp = TIM8->CCR2;
 801677e:	6b94      	ldr	r4, [r2, #56]	; 0x38
		commands_printf("Tim1 CNT: %i", t1_cnt);
 8016780:	990e      	ldr	r1, [sp, #56]	; 0x38
 8016782:	f001 ff5d 	bl	8018640 <commands_printf>
		commands_printf("Tim8 CNT: %u", t8_cnt);
 8016786:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8016788:	4879      	ldr	r0, [pc, #484]	; (8016970 <terminal_process_string+0x620>)
 801678a:	f001 ff59 	bl	8018640 <commands_printf>
		commands_printf("Duty cycle1: %u", duty1);
 801678e:	4651      	mov	r1, sl
 8016790:	4878      	ldr	r0, [pc, #480]	; (8016974 <terminal_process_string+0x624>)
 8016792:	f001 ff55 	bl	8018640 <commands_printf>
		commands_printf("Duty cycle2: %u", duty2);
 8016796:	4649      	mov	r1, r9
 8016798:	4877      	ldr	r0, [pc, #476]	; (8016978 <terminal_process_string+0x628>)
 801679a:	f001 ff51 	bl	8018640 <commands_printf>
		commands_printf("Duty cycle3: %u", duty3);
 801679e:	4641      	mov	r1, r8
 80167a0:	4876      	ldr	r0, [pc, #472]	; (801697c <terminal_process_string+0x62c>)
 80167a2:	f001 ff4d 	bl	8018640 <commands_printf>
		commands_printf("Top: %u", top);
 80167a6:	4639      	mov	r1, r7
 80167a8:	4875      	ldr	r0, [pc, #468]	; (8016980 <terminal_process_string+0x630>)
 80167aa:	f001 ff49 	bl	8018640 <commands_printf>
		commands_printf("Dir1: %u", dir1);
 80167ae:	9910      	ldr	r1, [sp, #64]	; 0x40
 80167b0:	4874      	ldr	r0, [pc, #464]	; (8016984 <terminal_process_string+0x634>)
 80167b2:	f001 ff45 	bl	8018640 <commands_printf>
		commands_printf("Dir8: %u", dir8);
 80167b6:	9911      	ldr	r1, [sp, #68]	; 0x44
 80167b8:	4873      	ldr	r0, [pc, #460]	; (8016988 <terminal_process_string+0x638>)
 80167ba:	f001 ff41 	bl	8018640 <commands_printf>
		commands_printf("Voltage sample: %u", voltage_samp);
 80167be:	4631      	mov	r1, r6
 80167c0:	4872      	ldr	r0, [pc, #456]	; (801698c <terminal_process_string+0x63c>)
 80167c2:	f001 ff3d 	bl	8018640 <commands_printf>
		commands_printf("Current 1 sample: %u", current1_samp);
 80167c6:	4629      	mov	r1, r5
 80167c8:	4871      	ldr	r0, [pc, #452]	; (8016990 <terminal_process_string+0x640>)
 80167ca:	f001 ff39 	bl	8018640 <commands_printf>
		commands_printf("Current 2 sample: %u\n", current2_samp);
 80167ce:	4621      	mov	r1, r4
 80167d0:	4870      	ldr	r0, [pc, #448]	; (8016994 <terminal_process_string+0x644>)
 80167d2:	f001 ff35 	bl	8018640 <commands_printf>
 80167d6:	e624      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("Input voltage: %.2f\n", (double)GET_INPUT_VOLTAGE());
 80167d8:	4b6f      	ldr	r3, [pc, #444]	; (8016998 <terminal_process_string+0x648>)
 80167da:	eddf 6a70 	vldr	s13, [pc, #448]	; 801699c <terminal_process_string+0x64c>
 80167de:	8a1b      	ldrh	r3, [r3, #16]
 80167e0:	ed9f 7a6f 	vldr	s14, [pc, #444]	; 80169a0 <terminal_process_string+0x650>
 80167e4:	ee07 3a90 	vmov	s15, r3
 80167e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80167ec:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80167f0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80167f4:	ee17 0a90 	vmov	r0, s15
 80167f8:	f7f5 fe06 	bl	800c408 <__aeabi_f2d>
 80167fc:	4602      	mov	r2, r0
 80167fe:	460b      	mov	r3, r1
 8016800:	4868      	ldr	r0, [pc, #416]	; (80169a4 <terminal_process_string+0x654>)
 8016802:	f001 ff1d 	bl	8018640 <commands_printf>
 8016806:	e60c      	b.n	8016422 <terminal_process_string+0xd2>
			float current = -1.0;
 8016808:	4b67      	ldr	r3, [pc, #412]	; (80169a8 <terminal_process_string+0x658>)
			sscanf(argv[1], "%f", &current);
 801680a:	4968      	ldr	r1, [pc, #416]	; (80169ac <terminal_process_string+0x65c>)
 801680c:	9819      	ldr	r0, [sp, #100]	; 0x64
			float current = -1.0;
 801680e:	930b      	str	r3, [sp, #44]	; 0x2c
			sscanf(argv[1], "%f", &current);
 8016810:	aa0b      	add	r2, sp, #44	; 0x2c
			float min_rpm = -1.0;
 8016812:	930c      	str	r3, [sp, #48]	; 0x30
			float low_duty = -1.0;
 8016814:	930d      	str	r3, [sp, #52]	; 0x34
			sscanf(argv[1], "%f", &current);
 8016816:	f010 fa53 	bl	8026cc0 <sscanf>
			sscanf(argv[2], "%f", &min_rpm);
 801681a:	aa0c      	add	r2, sp, #48	; 0x30
 801681c:	4963      	ldr	r1, [pc, #396]	; (80169ac <terminal_process_string+0x65c>)
 801681e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8016820:	f010 fa4e 	bl	8026cc0 <sscanf>
			sscanf(argv[3], "%f", &low_duty);
 8016824:	aa0d      	add	r2, sp, #52	; 0x34
 8016826:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8016828:	4960      	ldr	r1, [pc, #384]	; (80169ac <terminal_process_string+0x65c>)
 801682a:	f010 fa49 	bl	8026cc0 <sscanf>
			if (current > 0.0 && current < mcconf.l_current_max &&
 801682e:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
 8016832:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8016836:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801683a:	dd27      	ble.n	801688c <terminal_process_string+0x53c>
 801683c:	4b5c      	ldr	r3, [pc, #368]	; (80169b0 <terminal_process_string+0x660>)
 801683e:	edd3 7a01 	vldr	s15, [r3, #4]
 8016842:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801684a:	d51f      	bpl.n	801688c <terminal_process_string+0x53c>
					min_rpm > 10.0 && min_rpm < 3000.0 &&
 801684c:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
			if (current > 0.0 && current < mcconf.l_current_max &&
 8016850:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8016854:	eef4 0ae7 	vcmpe.f32	s1, s15
 8016858:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801685c:	dd16      	ble.n	801688c <terminal_process_string+0x53c>
					min_rpm > 10.0 && min_rpm < 3000.0 &&
 801685e:	eddf 7a55 	vldr	s15, [pc, #340]	; 80169b4 <terminal_process_string+0x664>
 8016862:	eef4 0ae7 	vcmpe.f32	s1, s15
 8016866:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801686a:	d50f      	bpl.n	801688c <terminal_process_string+0x53c>
					low_duty > 0.02 && low_duty < 0.8) {
 801686c:	ed9d 1a0d 	vldr	s2, [sp, #52]	; 0x34
					min_rpm > 10.0 && min_rpm < 3000.0 &&
 8016870:	eddf 7a51 	vldr	s15, [pc, #324]	; 80169b8 <terminal_process_string+0x668>
 8016874:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8016878:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801687c:	dd06      	ble.n	801688c <terminal_process_string+0x53c>
					low_duty > 0.02 && low_duty < 0.8) {
 801687e:	eddf 7a4f 	vldr	s15, [pc, #316]	; 80169bc <terminal_process_string+0x66c>
 8016882:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8016886:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801688a:	d420      	bmi.n	80168ce <terminal_process_string+0x57e>
				commands_printf("Invalid argument(s).\n");
 801688c:	484c      	ldr	r0, [pc, #304]	; (80169c0 <terminal_process_string+0x670>)
 801688e:	f001 fed7 	bl	8018640 <commands_printf>
 8016892:	e5c6      	b.n	8016422 <terminal_process_string+0xd2>
	} else if (strcmp(argv[0], "rpm_dep") == 0) {
 8016894:	494b      	ldr	r1, [pc, #300]	; (80169c4 <terminal_process_string+0x674>)
 8016896:	4628      	mov	r0, r5
 8016898:	f7f6 f9e6 	bl	800cc68 <strcmp>
 801689c:	2800      	cmp	r0, #0
 801689e:	f000 81d1 	beq.w	8016c44 <terminal_process_string+0x8f4>
	} else if (strcmp(argv[0], "can_devs") == 0) {
 80168a2:	4949      	ldr	r1, [pc, #292]	; (80169c8 <terminal_process_string+0x678>)
 80168a4:	4628      	mov	r0, r5
 80168a6:	f7f6 f9df 	bl	800cc68 <strcmp>
 80168aa:	4606      	mov	r6, r0
 80168ac:	2800      	cmp	r0, #0
 80168ae:	f000 816f 	beq.w	8016b90 <terminal_process_string+0x840>
	} else if (strcmp(argv[0], "foc_encoder_detect") == 0) {
 80168b2:	4946      	ldr	r1, [pc, #280]	; (80169cc <terminal_process_string+0x67c>)
 80168b4:	4628      	mov	r0, r5
 80168b6:	f7f6 f9d7 	bl	800cc68 <strcmp>
 80168ba:	2800      	cmp	r0, #0
 80168bc:	f040 80e6 	bne.w	8016a8c <terminal_process_string+0x73c>
		if (argc == 2) {
 80168c0:	2c02      	cmp	r4, #2
 80168c2:	f000 8093 	beq.w	80169ec <terminal_process_string+0x69c>
			commands_printf("This command requires one argument.\n");
 80168c6:	4842      	ldr	r0, [pc, #264]	; (80169d0 <terminal_process_string+0x680>)
 80168c8:	f001 feba 	bl	8018640 <commands_printf>
 80168cc:	e5a9      	b.n	8016422 <terminal_process_string+0xd2>
				if (conf_general_detect_motor_param(current, min_rpm, low_duty, &cycle_integrator, &coupling_k, hall_table, &hall_res)) {
 80168ce:	ab10      	add	r3, sp, #64	; 0x40
 80168d0:	aa11      	add	r2, sp, #68	; 0x44
 80168d2:	a90f      	add	r1, sp, #60	; 0x3c
 80168d4:	a80e      	add	r0, sp, #56	; 0x38
 80168d6:	f001 f93b 	bl	8017b50 <conf_general_detect_motor_param>
 80168da:	2800      	cmp	r0, #0
 80168dc:	f000 8286 	beq.w	8016dec <terminal_process_string+0xa9c>
					commands_printf("Cycle integrator limit: %.2f", (double)cycle_integrator);
 80168e0:	980e      	ldr	r0, [sp, #56]	; 0x38
 80168e2:	f7f5 fd91 	bl	800c408 <__aeabi_f2d>
 80168e6:	4602      	mov	r2, r0
 80168e8:	460b      	mov	r3, r1
 80168ea:	483a      	ldr	r0, [pc, #232]	; (80169d4 <terminal_process_string+0x684>)
 80168ec:	f001 fea8 	bl	8018640 <commands_printf>
					commands_printf("Coupling factor: %.2f", (double)coupling_k);
 80168f0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80168f2:	f7f5 fd89 	bl	800c408 <__aeabi_f2d>
 80168f6:	4602      	mov	r2, r0
 80168f8:	460b      	mov	r3, r1
 80168fa:	4837      	ldr	r0, [pc, #220]	; (80169d8 <terminal_process_string+0x688>)
 80168fc:	f001 fea0 	bl	8018640 <commands_printf>
					if (hall_res == 0) {
 8016900:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8016902:	2b00      	cmp	r3, #0
 8016904:	f000 8255 	beq.w	8016db2 <terminal_process_string+0xa62>
					} else if (hall_res == -1) {
 8016908:	1c59      	adds	r1, r3, #1
 801690a:	f000 8274 	beq.w	8016df6 <terminal_process_string+0xaa6>
					} else if (hall_res == -2) {
 801690e:	1c9a      	adds	r2, r3, #2
 8016910:	f000 824a 	beq.w	8016da8 <terminal_process_string+0xa58>
					} else if (hall_res == -3) {
 8016914:	3303      	adds	r3, #3
 8016916:	f47f ad84 	bne.w	8016422 <terminal_process_string+0xd2>
						commands_printf("Encoder enabled. Hall sensors cannot be used.\n");
 801691a:	4830      	ldr	r0, [pc, #192]	; (80169dc <terminal_process_string+0x68c>)
 801691c:	f001 fe90 	bl	8018640 <commands_printf>
 8016920:	e57f      	b.n	8016422 <terminal_process_string+0xd2>
 8016922:	bf00      	nop
 8016924:	0802e30c 	.word	0x0802e30c
 8016928:	200075b0 	.word	0x200075b0
 801692c:	0802e388 	.word	0x0802e388
 8016930:	0802e3a0 	.word	0x0802e3a0
 8016934:	0802e3b8 	.word	0x0802e3b8
 8016938:	0802e3d0 	.word	0x0802e3d0
 801693c:	0802e3e8 	.word	0x0802e3e8
 8016940:	0802e400 	.word	0x0802e400
 8016944:	0802e418 	.word	0x0802e418
 8016948:	0802e430 	.word	0x0802e430
 801694c:	0802e448 	.word	0x0802e448
 8016950:	0802e460 	.word	0x0802e460
 8016954:	0802e478 	.word	0x0802e478
 8016958:	0802e26c 	.word	0x0802e26c
 801695c:	0802e494 	.word	0x0802e494
 8016960:	0802e4b8 	.word	0x0802e4b8
 8016964:	40010000 	.word	0x40010000
 8016968:	40010400 	.word	0x40010400
 801696c:	0802e4d4 	.word	0x0802e4d4
 8016970:	0802e4e4 	.word	0x0802e4e4
 8016974:	0802e4f4 	.word	0x0802e4f4
 8016978:	0802e504 	.word	0x0802e504
 801697c:	0802e514 	.word	0x0802e514
 8016980:	0802e524 	.word	0x0802e524
 8016984:	0802e52c 	.word	0x0802e52c
 8016988:	0802e538 	.word	0x0802e538
 801698c:	0802e544 	.word	0x0802e544
 8016990:	0802e558 	.word	0x0802e558
 8016994:	0802e570 	.word	0x0802e570
 8016998:	2000c03c 	.word	0x2000c03c
 801699c:	3a534067 	.word	0x3a534067
 80169a0:	4195d174 	.word	0x4195d174
 80169a4:	0802e590 	.word	0x0802e590
 80169a8:	bf800000 	.word	0xbf800000
 80169ac:	0802e5b8 	.word	0x0802e5b8
 80169b0:	20007b2c 	.word	0x20007b2c
 80169b4:	453b8000 	.word	0x453b8000
 80169b8:	3ca3d70a 	.word	0x3ca3d70a
 80169bc:	3f4ccccd 	.word	0x3f4ccccd
 80169c0:	0802e6e8 	.word	0x0802e6e8
 80169c4:	0802e728 	.word	0x0802e728
 80169c8:	0802e784 	.word	0x0802e784
 80169cc:	0802e860 	.word	0x0802e860
 80169d0:	0802e8bc 	.word	0x0802e8bc
 80169d4:	0802e5bc 	.word	0x0802e5bc
 80169d8:	0802e5dc 	.word	0x0802e5dc
 80169dc:	0802e680 	.word	0x0802e680
 80169e0:	0802e340 	.word	0x0802e340
 80169e4:	0802e358 	.word	0x0802e358
 80169e8:	0802e370 	.word	0x0802e370
			float current = -1.0;
 80169ec:	4ba4      	ldr	r3, [pc, #656]	; (8016c80 <terminal_process_string+0x930>)
			sscanf(argv[1], "%f", &current);
 80169ee:	9819      	ldr	r0, [sp, #100]	; 0x64
 80169f0:	49a4      	ldr	r1, [pc, #656]	; (8016c84 <terminal_process_string+0x934>)
			float current = -1.0;
 80169f2:	930f      	str	r3, [sp, #60]	; 0x3c
			sscanf(argv[1], "%f", &current);
 80169f4:	aa0f      	add	r2, sp, #60	; 0x3c
 80169f6:	f010 f963 	bl	8026cc0 <sscanf>
			if (current > 0.0 && current <= mcconf.l_current_max) {
 80169fa:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
 80169fe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016a02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a06:	f77f af41 	ble.w	801688c <terminal_process_string+0x53c>
 8016a0a:	4c9f      	ldr	r4, [pc, #636]	; (8016c88 <terminal_process_string+0x938>)
 8016a0c:	ed94 7a01 	vldr	s14, [r4, #4]
 8016a10:	eef4 7ac7 	vcmpe.f32	s15, s14
 8016a14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a18:	f63f af38 	bhi.w	801688c <terminal_process_string+0x53c>
				if (encoder_is_configured()) {
 8016a1c:	f004 f948 	bl	801acb0 <encoder_is_configured>
 8016a20:	2800      	cmp	r0, #0
 8016a22:	d06d      	beq.n	8016b00 <terminal_process_string+0x7b0>
					mcconf.motor_type = MOTOR_TYPE_FOC;
 8016a24:	2302      	movs	r3, #2
					mc_interface_set_configuration(&mcconf);
 8016a26:	4620      	mov	r0, r4
					mc_motor_type type_old = mcconf.motor_type;
 8016a28:	78a6      	ldrb	r6, [r4, #2]
					mcconf.motor_type = MOTOR_TYPE_FOC;
 8016a2a:	70a3      	strb	r3, [r4, #2]
					float offset = 0.0;
 8016a2c:	2500      	movs	r5, #0
					mc_interface_set_configuration(&mcconf);
 8016a2e:	f005 f9f7 	bl	801be20 <mc_interface_set_configuration>
					bool inverted = false;
 8016a32:	2700      	movs	r7, #0
					mcpwm_foc_encoder_detect(current, true, &offset, &ratio, &inverted);
 8016a34:	ed9d 0a0f 	vldr	s0, [sp, #60]	; 0x3c
					float offset = 0.0;
 8016a38:	9510      	str	r5, [sp, #64]	; 0x40
					mcpwm_foc_encoder_detect(current, true, &offset, &ratio, &inverted);
 8016a3a:	aa11      	add	r2, sp, #68	; 0x44
 8016a3c:	ab0e      	add	r3, sp, #56	; 0x38
 8016a3e:	a910      	add	r1, sp, #64	; 0x40
 8016a40:	2001      	movs	r0, #1
					float ratio = 0.0;
 8016a42:	9511      	str	r5, [sp, #68]	; 0x44
					bool inverted = false;
 8016a44:	f88d 7038 	strb.w	r7, [sp, #56]	; 0x38
					mcpwm_foc_encoder_detect(current, true, &offset, &ratio, &inverted);
 8016a48:	f007 fa0a 	bl	801de60 <mcpwm_foc_encoder_detect>
					mc_interface_set_configuration(&mcconf);
 8016a4c:	4620      	mov	r0, r4
					mcconf.motor_type = type_old;
 8016a4e:	70a6      	strb	r6, [r4, #2]
					mc_interface_set_configuration(&mcconf);
 8016a50:	f005 f9e6 	bl	801be20 <mc_interface_set_configuration>
					commands_printf("Offset   : %.2f", (double)offset);
 8016a54:	9810      	ldr	r0, [sp, #64]	; 0x40
 8016a56:	f7f5 fcd7 	bl	800c408 <__aeabi_f2d>
 8016a5a:	4602      	mov	r2, r0
 8016a5c:	460b      	mov	r3, r1
 8016a5e:	488b      	ldr	r0, [pc, #556]	; (8016c8c <terminal_process_string+0x93c>)
 8016a60:	f001 fdee 	bl	8018640 <commands_printf>
					commands_printf("Ratio    : %.2f", (double)ratio);
 8016a64:	9811      	ldr	r0, [sp, #68]	; 0x44
 8016a66:	f7f5 fccf 	bl	800c408 <__aeabi_f2d>
 8016a6a:	4602      	mov	r2, r0
 8016a6c:	460b      	mov	r3, r1
 8016a6e:	4888      	ldr	r0, [pc, #544]	; (8016c90 <terminal_process_string+0x940>)
 8016a70:	f001 fde6 	bl	8018640 <commands_printf>
					commands_printf("Inverted : %s\n", inverted ? "true" : "false");
 8016a74:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8016a78:	4a86      	ldr	r2, [pc, #536]	; (8016c94 <terminal_process_string+0x944>)
 8016a7a:	4b87      	ldr	r3, [pc, #540]	; (8016c98 <terminal_process_string+0x948>)
 8016a7c:	4887      	ldr	r0, [pc, #540]	; (8016c9c <terminal_process_string+0x94c>)
 8016a7e:	42b9      	cmp	r1, r7
 8016a80:	bf0c      	ite	eq
 8016a82:	4611      	moveq	r1, r2
 8016a84:	4619      	movne	r1, r3
 8016a86:	f001 fddb 	bl	8018640 <commands_printf>
 8016a8a:	e4ca      	b.n	8016422 <terminal_process_string+0xd2>
	} else if (strcmp(argv[0], "measure_res") == 0) {
 8016a8c:	4984      	ldr	r1, [pc, #528]	; (8016ca0 <terminal_process_string+0x950>)
 8016a8e:	4628      	mov	r0, r5
 8016a90:	f7f6 f8ea 	bl	800cc68 <strcmp>
 8016a94:	2800      	cmp	r0, #0
 8016a96:	d137      	bne.n	8016b08 <terminal_process_string+0x7b8>
		if (argc == 2) {
 8016a98:	2c02      	cmp	r4, #2
 8016a9a:	f47f af14 	bne.w	80168c6 <terminal_process_string+0x576>
			float current = -1.0;
 8016a9e:	ad11      	add	r5, sp, #68	; 0x44
 8016aa0:	4b77      	ldr	r3, [pc, #476]	; (8016c80 <terminal_process_string+0x930>)
			sscanf(argv[1], "%f", &current);
 8016aa2:	9819      	ldr	r0, [sp, #100]	; 0x64
 8016aa4:	4977      	ldr	r1, [pc, #476]	; (8016c84 <terminal_process_string+0x934>)
			float current = -1.0;
 8016aa6:	9311      	str	r3, [sp, #68]	; 0x44
			sscanf(argv[1], "%f", &current);
 8016aa8:	462a      	mov	r2, r5
 8016aaa:	f010 f909 	bl	8026cc0 <sscanf>
			if (current > 0.0 && current <= mcconf.l_current_max) {
 8016aae:	edd5 7a00 	vldr	s15, [r5]
 8016ab2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016ab6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016aba:	f77f aee7 	ble.w	801688c <terminal_process_string+0x53c>
 8016abe:	4c72      	ldr	r4, [pc, #456]	; (8016c88 <terminal_process_string+0x938>)
 8016ac0:	ed94 7a01 	vldr	s14, [r4, #4]
 8016ac4:	eef4 7ac7 	vcmpe.f32	s15, s14
 8016ac8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016acc:	f63f aede 	bhi.w	801688c <terminal_process_string+0x53c>
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016ad0:	2302      	movs	r3, #2
				mc_interface_set_configuration(&mcconf);
 8016ad2:	4620      	mov	r0, r4
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016ad4:	70a3      	strb	r3, [r4, #2]
				mc_interface_set_configuration(&mcconf);
 8016ad6:	f005 f9a3 	bl	801be20 <mc_interface_set_configuration>
				commands_printf("Resistance: %.6f ohm\n", (double)mcpwm_foc_measure_resistance(current, 2000));
 8016ada:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8016ade:	ed95 0a00 	vldr	s0, [r5]
 8016ae2:	f007 fcbd 	bl	801e460 <mcpwm_foc_measure_resistance>
 8016ae6:	ee10 0a10 	vmov	r0, s0
 8016aea:	f7f5 fc8d 	bl	800c408 <__aeabi_f2d>
 8016aee:	4602      	mov	r2, r0
 8016af0:	460b      	mov	r3, r1
 8016af2:	486c      	ldr	r0, [pc, #432]	; (8016ca4 <terminal_process_string+0x954>)
 8016af4:	f001 fda4 	bl	8018640 <commands_printf>
				mc_interface_set_configuration(&mcconf_old);
 8016af8:	486b      	ldr	r0, [pc, #428]	; (8016ca8 <terminal_process_string+0x958>)
 8016afa:	f005 f991 	bl	801be20 <mc_interface_set_configuration>
 8016afe:	e490      	b.n	8016422 <terminal_process_string+0xd2>
					commands_printf("Encoder not enabled.\n");
 8016b00:	486a      	ldr	r0, [pc, #424]	; (8016cac <terminal_process_string+0x95c>)
 8016b02:	f001 fd9d 	bl	8018640 <commands_printf>
 8016b06:	e48c      	b.n	8016422 <terminal_process_string+0xd2>
	} else if (strcmp(argv[0], "measure_ind") == 0) {
 8016b08:	4969      	ldr	r1, [pc, #420]	; (8016cb0 <terminal_process_string+0x960>)
 8016b0a:	4628      	mov	r0, r5
 8016b0c:	f7f6 f8ac 	bl	800cc68 <strcmp>
 8016b10:	2800      	cmp	r0, #0
 8016b12:	f040 80ef 	bne.w	8016cf4 <terminal_process_string+0x9a4>
		if (argc == 2) {
 8016b16:	2c02      	cmp	r4, #2
 8016b18:	f47f aed5 	bne.w	80168c6 <terminal_process_string+0x576>
			float duty = -1.0;
 8016b1c:	4b58      	ldr	r3, [pc, #352]	; (8016c80 <terminal_process_string+0x930>)
			sscanf(argv[1], "%f", &duty);
 8016b1e:	9819      	ldr	r0, [sp, #100]	; 0x64
 8016b20:	4958      	ldr	r1, [pc, #352]	; (8016c84 <terminal_process_string+0x934>)
			float duty = -1.0;
 8016b22:	9310      	str	r3, [sp, #64]	; 0x40
			sscanf(argv[1], "%f", &duty);
 8016b24:	aa10      	add	r2, sp, #64	; 0x40
 8016b26:	f010 f8cb 	bl	8026cc0 <sscanf>
			if (duty > 0.0 && duty < 0.9) {
 8016b2a:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
 8016b2e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016b32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b36:	f77f aea9 	ble.w	801688c <terminal_process_string+0x53c>
 8016b3a:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 8016cb4 <terminal_process_string+0x964>
 8016b3e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8016b42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b46:	f57f aea1 	bpl.w	801688c <terminal_process_string+0x53c>
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016b4a:	4b4f      	ldr	r3, [pc, #316]	; (8016c88 <terminal_process_string+0x938>)
				mcconf.foc_f_sw = 3000.0;
 8016b4c:	4a5a      	ldr	r2, [pc, #360]	; (8016cb8 <terminal_process_string+0x968>)
 8016b4e:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
				mc_interface_set_configuration(&mcconf);
 8016b52:	4618      	mov	r0, r3
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016b54:	2102      	movs	r1, #2
 8016b56:	7099      	strb	r1, [r3, #2]
				mc_interface_set_configuration(&mcconf);
 8016b58:	f005 f962 	bl	801be20 <mc_interface_set_configuration>
				float ind = mcpwm_foc_measure_inductance(duty, 200, &curr);
 8016b5c:	a911      	add	r1, sp, #68	; 0x44
 8016b5e:	20c8      	movs	r0, #200	; 0xc8
 8016b60:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
 8016b64:	f007 fd0c 	bl	801e580 <mcpwm_foc_measure_inductance>
				commands_printf("Inductance: %.2f microhenry (%.2f A)\n", (double)ind, (double)curr);
 8016b68:	ee10 0a10 	vmov	r0, s0
 8016b6c:	f7f5 fc4c 	bl	800c408 <__aeabi_f2d>
 8016b70:	4604      	mov	r4, r0
 8016b72:	9811      	ldr	r0, [sp, #68]	; 0x44
 8016b74:	460d      	mov	r5, r1
 8016b76:	f7f5 fc47 	bl	800c408 <__aeabi_f2d>
 8016b7a:	4622      	mov	r2, r4
 8016b7c:	e9cd 0100 	strd	r0, r1, [sp]
 8016b80:	462b      	mov	r3, r5
 8016b82:	484e      	ldr	r0, [pc, #312]	; (8016cbc <terminal_process_string+0x96c>)
 8016b84:	f001 fd5c 	bl	8018640 <commands_printf>
				mc_interface_set_configuration(&mcconf_old);
 8016b88:	4847      	ldr	r0, [pc, #284]	; (8016ca8 <terminal_process_string+0x958>)
 8016b8a:	f005 f949 	bl	801be20 <mc_interface_set_configuration>
			if (duty > 0.0 && duty < 0.9) {
 8016b8e:	e448      	b.n	8016422 <terminal_process_string+0xd2>
		commands_printf("CAN devices seen on the bus the past second:\n");
 8016b90:	484b      	ldr	r0, [pc, #300]	; (8016cc0 <terminal_process_string+0x970>)
  return ch.vtlist.vt_systime;
 8016b92:	4d4c      	ldr	r5, [pc, #304]	; (8016cc4 <terminal_process_string+0x974>)
			if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < 1.0) {
 8016b94:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 8016cc8 <terminal_process_string+0x978>
				commands_printf("ID                 : %i", msg->id);
 8016b98:	4f4c      	ldr	r7, [pc, #304]	; (8016ccc <terminal_process_string+0x97c>)
		commands_printf("CAN devices seen on the bus the past second:\n");
 8016b9a:	f001 fd51 	bl	8018640 <commands_printf>
 8016b9e:	e002      	b.n	8016ba6 <terminal_process_string+0x856>
		for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8016ba0:	2e0a      	cmp	r6, #10
 8016ba2:	f43f ac3e 	beq.w	8016422 <terminal_process_string+0xd2>
			can_status_msg *msg = comm_can_get_status_msg_index(i);
 8016ba6:	4630      	mov	r0, r6
 8016ba8:	f003 ff7a 	bl	801aaa0 <comm_can_get_status_msg_index>
			if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < 1.0) {
 8016bac:	6801      	ldr	r1, [r0, #0]
 8016bae:	2900      	cmp	r1, #0
			can_status_msg *msg = comm_can_get_status_msg_index(i);
 8016bb0:	4604      	mov	r4, r0
			if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < 1.0) {
 8016bb2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8016bb6:	f106 0601 	add.w	r6, r6, #1
			if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < 1.0) {
 8016bba:	dbf1      	blt.n	8016ba0 <terminal_process_string+0x850>
 8016bbc:	6aab      	ldr	r3, [r5, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8016bbe:	6842      	ldr	r2, [r0, #4]
 8016bc0:	1a9b      	subs	r3, r3, r2
 8016bc2:	ee07 3a90 	vmov	s15, r3
 8016bc6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8016bca:	eec7 6a88 	vdiv.f32	s13, s15, s16
 8016bce:	eef4 6ac7 	vcmpe.f32	s13, s14
 8016bd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bd6:	d5e3      	bpl.n	8016ba0 <terminal_process_string+0x850>
				commands_printf("ID                 : %i", msg->id);
 8016bd8:	4638      	mov	r0, r7
 8016bda:	f001 fd31 	bl	8018640 <commands_printf>
				commands_printf("RX Time            : %i", msg->rx_time);
 8016bde:	6861      	ldr	r1, [r4, #4]
 8016be0:	483b      	ldr	r0, [pc, #236]	; (8016cd0 <terminal_process_string+0x980>)
 8016be2:	f001 fd2d 	bl	8018640 <commands_printf>
 8016be6:	6862      	ldr	r2, [r4, #4]
  return ch.vtlist.vt_systime;
 8016be8:	6aab      	ldr	r3, [r5, #40]	; 0x28
				commands_printf("Age (milliseconds) : %.2f", (double)(UTILS_AGE_S(msg->rx_time) * 1000.0));
 8016bea:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 8016cd4 <terminal_process_string+0x984>
  return chVTGetSystemTimeX() - start;
 8016bee:	1a9b      	subs	r3, r3, r2
 8016bf0:	ee07 3a90 	vmov	s15, r3
 8016bf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8016bf8:	eec7 6a88 	vdiv.f32	s13, s15, s16
 8016bfc:	ee66 7a87 	vmul.f32	s15, s13, s14
 8016c00:	ee17 0a90 	vmov	r0, s15
 8016c04:	f7f5 fc00 	bl	800c408 <__aeabi_f2d>
 8016c08:	4602      	mov	r2, r0
 8016c0a:	460b      	mov	r3, r1
 8016c0c:	4832      	ldr	r0, [pc, #200]	; (8016cd8 <terminal_process_string+0x988>)
 8016c0e:	f001 fd17 	bl	8018640 <commands_printf>
				commands_printf("RPM                : %.2f", (double)msg->rpm);
 8016c12:	68a0      	ldr	r0, [r4, #8]
 8016c14:	f7f5 fbf8 	bl	800c408 <__aeabi_f2d>
 8016c18:	4602      	mov	r2, r0
 8016c1a:	460b      	mov	r3, r1
 8016c1c:	482f      	ldr	r0, [pc, #188]	; (8016cdc <terminal_process_string+0x98c>)
 8016c1e:	f001 fd0f 	bl	8018640 <commands_printf>
				commands_printf("Current            : %.2f", (double)msg->current);
 8016c22:	68e0      	ldr	r0, [r4, #12]
 8016c24:	f7f5 fbf0 	bl	800c408 <__aeabi_f2d>
 8016c28:	4602      	mov	r2, r0
 8016c2a:	460b      	mov	r3, r1
 8016c2c:	482c      	ldr	r0, [pc, #176]	; (8016ce0 <terminal_process_string+0x990>)
 8016c2e:	f001 fd07 	bl	8018640 <commands_printf>
				commands_printf("Duty               : %.2f\n", (double)msg->duty);
 8016c32:	6920      	ldr	r0, [r4, #16]
 8016c34:	f7f5 fbe8 	bl	800c408 <__aeabi_f2d>
 8016c38:	4602      	mov	r2, r0
 8016c3a:	460b      	mov	r3, r1
 8016c3c:	4829      	ldr	r0, [pc, #164]	; (8016ce4 <terminal_process_string+0x994>)
 8016c3e:	f001 fcff 	bl	8018640 <commands_printf>
 8016c42:	e7ad      	b.n	8016ba0 <terminal_process_string+0x850>
		mc_rpm_dep_struct rpm_dep = mcpwm_get_rpm_dep();
 8016c44:	a811      	add	r0, sp, #68	; 0x44
 8016c46:	f7fd fb03 	bl	8014250 <mcpwm_get_rpm_dep>
		commands_printf("Cycle int limit: %.2f", (double)rpm_dep.cycle_int_limit);
 8016c4a:	9811      	ldr	r0, [sp, #68]	; 0x44
 8016c4c:	f7f5 fbdc 	bl	800c408 <__aeabi_f2d>
 8016c50:	4602      	mov	r2, r0
 8016c52:	460b      	mov	r3, r1
 8016c54:	4824      	ldr	r0, [pc, #144]	; (8016ce8 <terminal_process_string+0x998>)
 8016c56:	f001 fcf3 	bl	8018640 <commands_printf>
		commands_printf("Cycle int limit running: %.2f", (double)rpm_dep.cycle_int_limit_running);
 8016c5a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8016c5c:	f7f5 fbd4 	bl	800c408 <__aeabi_f2d>
 8016c60:	4602      	mov	r2, r0
 8016c62:	460b      	mov	r3, r1
 8016c64:	4821      	ldr	r0, [pc, #132]	; (8016cec <terminal_process_string+0x99c>)
 8016c66:	f001 fceb 	bl	8018640 <commands_printf>
		commands_printf("Cycle int limit max: %.2f\n", (double)rpm_dep.cycle_int_limit_max);
 8016c6a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8016c6c:	f7f5 fbcc 	bl	800c408 <__aeabi_f2d>
 8016c70:	4602      	mov	r2, r0
 8016c72:	460b      	mov	r3, r1
 8016c74:	481e      	ldr	r0, [pc, #120]	; (8016cf0 <terminal_process_string+0x9a0>)
 8016c76:	f001 fce3 	bl	8018640 <commands_printf>
 8016c7a:	f7ff bbd2 	b.w	8016422 <terminal_process_string+0xd2>
 8016c7e:	bf00      	nop
 8016c80:	bf800000 	.word	0xbf800000
 8016c84:	0802e5b8 	.word	0x0802e5b8
 8016c88:	20007b2c 	.word	0x20007b2c
 8016c8c:	0802e874 	.word	0x0802e874
 8016c90:	0802e884 	.word	0x0802e884
 8016c94:	0802e0d8 	.word	0x0802e0d8
 8016c98:	0802e0d0 	.word	0x0802e0d0
 8016c9c:	0802e894 	.word	0x0802e894
 8016ca0:	0802e8e4 	.word	0x0802e8e4
 8016ca4:	0802e8f0 	.word	0x0802e8f0
 8016ca8:	20007ca0 	.word	0x20007ca0
 8016cac:	0802e8a4 	.word	0x0802e8a4
 8016cb0:	0802e908 	.word	0x0802e908
 8016cb4:	3f666666 	.word	0x3f666666
 8016cb8:	453b8000 	.word	0x453b8000
 8016cbc:	0802e914 	.word	0x0802e914
 8016cc0:	0802e790 	.word	0x0802e790
 8016cc4:	20001a48 	.word	0x20001a48
 8016cc8:	461c4000 	.word	0x461c4000
 8016ccc:	0802e7c0 	.word	0x0802e7c0
 8016cd0:	0802e7d8 	.word	0x0802e7d8
 8016cd4:	447a0000 	.word	0x447a0000
 8016cd8:	0802e7f0 	.word	0x0802e7f0
 8016cdc:	0802e80c 	.word	0x0802e80c
 8016ce0:	0802e828 	.word	0x0802e828
 8016ce4:	0802e844 	.word	0x0802e844
 8016ce8:	0802e730 	.word	0x0802e730
 8016cec:	0802e748 	.word	0x0802e748
 8016cf0:	0802e768 	.word	0x0802e768
	} else if (strcmp(argv[0], "measure_linkage") == 0) {
 8016cf4:	49cd      	ldr	r1, [pc, #820]	; (801702c <terminal_process_string+0xcdc>)
 8016cf6:	4628      	mov	r0, r5
 8016cf8:	f7f5 ffb6 	bl	800cc68 <strcmp>
 8016cfc:	2800      	cmp	r0, #0
 8016cfe:	d17c      	bne.n	8016dfa <terminal_process_string+0xaaa>
		if (argc == 5) {
 8016d00:	2c05      	cmp	r4, #5
 8016d02:	f47f ade0 	bne.w	80168c6 <terminal_process_string+0x576>
			float current = -1.0;
 8016d06:	4bca      	ldr	r3, [pc, #808]	; (8017030 <terminal_process_string+0xce0>)
			sscanf(argv[1], "%f", &current);
 8016d08:	49ca      	ldr	r1, [pc, #808]	; (8017034 <terminal_process_string+0xce4>)
 8016d0a:	9819      	ldr	r0, [sp, #100]	; 0x64
			float current = -1.0;
 8016d0c:	930d      	str	r3, [sp, #52]	; 0x34
			sscanf(argv[1], "%f", &current);
 8016d0e:	aa0d      	add	r2, sp, #52	; 0x34
			float duty = -1.0;
 8016d10:	930e      	str	r3, [sp, #56]	; 0x38
			float min_erpm = -1.0;
 8016d12:	930f      	str	r3, [sp, #60]	; 0x3c
			float res = -1.0;
 8016d14:	9310      	str	r3, [sp, #64]	; 0x40
			sscanf(argv[1], "%f", &current);
 8016d16:	f00f ffd3 	bl	8026cc0 <sscanf>
			sscanf(argv[2], "%f", &duty);
 8016d1a:	aa0e      	add	r2, sp, #56	; 0x38
 8016d1c:	49c5      	ldr	r1, [pc, #788]	; (8017034 <terminal_process_string+0xce4>)
 8016d1e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8016d20:	f00f ffce 	bl	8026cc0 <sscanf>
			sscanf(argv[3], "%f", &min_erpm);
 8016d24:	aa0f      	add	r2, sp, #60	; 0x3c
 8016d26:	49c3      	ldr	r1, [pc, #780]	; (8017034 <terminal_process_string+0xce4>)
 8016d28:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8016d2a:	f00f ffc9 	bl	8026cc0 <sscanf>
			sscanf(argv[4], "%f", &res);
 8016d2e:	aa10      	add	r2, sp, #64	; 0x40
 8016d30:	981c      	ldr	r0, [sp, #112]	; 0x70
 8016d32:	49c0      	ldr	r1, [pc, #768]	; (8017034 <terminal_process_string+0xce4>)
 8016d34:	f00f ffc4 	bl	8026cc0 <sscanf>
			if (current > 0.0 && current <= mcconf.l_current_max && min_erpm > 0.0 && duty > 0.02 && res >= 0.0) {
 8016d38:	ed9d 0a0d 	vldr	s0, [sp, #52]	; 0x34
 8016d3c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8016d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d44:	f77f ada2 	ble.w	801688c <terminal_process_string+0x53c>
 8016d48:	4bbb      	ldr	r3, [pc, #748]	; (8017038 <terminal_process_string+0xce8>)
 8016d4a:	edd3 7a01 	vldr	s15, [r3, #4]
 8016d4e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016d52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d56:	f63f ad99 	bhi.w	801688c <terminal_process_string+0x53c>
 8016d5a:	ed9d 1a0f 	vldr	s2, [sp, #60]	; 0x3c
 8016d5e:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8016d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d66:	f77f ad91 	ble.w	801688c <terminal_process_string+0x53c>
 8016d6a:	eddd 0a0e 	vldr	s1, [sp, #56]	; 0x38
 8016d6e:	eddf 7ab3 	vldr	s15, [pc, #716]	; 801703c <terminal_process_string+0xcec>
 8016d72:	eef4 0ae7 	vcmpe.f32	s1, s15
 8016d76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d7a:	f77f ad87 	ble.w	801688c <terminal_process_string+0x53c>
 8016d7e:	eddd 1a10 	vldr	s3, [sp, #64]	; 0x40
 8016d82:	eef5 1ac0 	vcmpe.f32	s3, #0.0
 8016d86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016d8a:	f6ff ad7f 	blt.w	801688c <terminal_process_string+0x53c>
				conf_general_measure_flux_linkage(current, duty, min_erpm, res, &linkage);
 8016d8e:	a811      	add	r0, sp, #68	; 0x44
 8016d90:	f001 f886 	bl	8017ea0 <conf_general_measure_flux_linkage>
				commands_printf("Flux linkage: %.7f\n", (double)linkage);
 8016d94:	9811      	ldr	r0, [sp, #68]	; 0x44
				commands_printf("Flux linkage: %.7f\n", (double)linkage);
 8016d96:	f7f5 fb37 	bl	800c408 <__aeabi_f2d>
 8016d9a:	4602      	mov	r2, r0
 8016d9c:	460b      	mov	r3, r1
 8016d9e:	48a8      	ldr	r0, [pc, #672]	; (8017040 <terminal_process_string+0xcf0>)
 8016da0:	f001 fc4e 	bl	8018640 <commands_printf>
 8016da4:	f7ff bb3d 	b.w	8016422 <terminal_process_string+0xd2>
						commands_printf("WS2811 enabled. Hall sensors cannot be used.\n");
 8016da8:	48a6      	ldr	r0, [pc, #664]	; (8017044 <terminal_process_string+0xcf4>)
 8016daa:	f001 fc49 	bl	8018640 <commands_printf>
 8016dae:	f7ff bb38 	b.w	8016422 <terminal_process_string+0xd2>
						commands_printf("Detected hall sensor table:");
 8016db2:	48a5      	ldr	r0, [pc, #660]	; (8017048 <terminal_process_string+0xcf8>)
						commands_printf("Hall sensor detection failed:");
 8016db4:	f001 fc44 	bl	8018640 <commands_printf>
						commands_printf("%i, %i, %i, %i, %i, %i, %i, %i\n",
 8016db8:	f99d 404b 	ldrsb.w	r4, [sp, #75]	; 0x4b
 8016dbc:	f99d 004a 	ldrsb.w	r0, [sp, #74]	; 0x4a
 8016dc0:	9404      	str	r4, [sp, #16]
 8016dc2:	f99d 5049 	ldrsb.w	r5, [sp, #73]	; 0x49
 8016dc6:	f99d 4048 	ldrsb.w	r4, [sp, #72]	; 0x48
 8016dca:	9003      	str	r0, [sp, #12]
 8016dcc:	f99d 0047 	ldrsb.w	r0, [sp, #71]	; 0x47
 8016dd0:	9000      	str	r0, [sp, #0]
 8016dd2:	f99d 3046 	ldrsb.w	r3, [sp, #70]	; 0x46
 8016dd6:	f99d 2045 	ldrsb.w	r2, [sp, #69]	; 0x45
 8016dda:	f99d 1044 	ldrsb.w	r1, [sp, #68]	; 0x44
 8016dde:	489b      	ldr	r0, [pc, #620]	; (801704c <terminal_process_string+0xcfc>)
 8016de0:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8016de4:	f001 fc2c 	bl	8018640 <commands_printf>
 8016de8:	f7ff bb1b 	b.w	8016422 <terminal_process_string+0xd2>
					commands_printf("Detection failed. Try again with different parameters.\n");
 8016dec:	4898      	ldr	r0, [pc, #608]	; (8017050 <terminal_process_string+0xd00>)
 8016dee:	f001 fc27 	bl	8018640 <commands_printf>
					low_duty > 0.02 && low_duty < 0.8) {
 8016df2:	f7ff bb16 	b.w	8016422 <terminal_process_string+0xd2>
						commands_printf("Hall sensor detection failed:");
 8016df6:	4897      	ldr	r0, [pc, #604]	; (8017054 <terminal_process_string+0xd04>)
 8016df8:	e7dc      	b.n	8016db4 <terminal_process_string+0xa64>
	} else if (strcmp(argv[0], "measure_res_ind") == 0) {
 8016dfa:	4997      	ldr	r1, [pc, #604]	; (8017058 <terminal_process_string+0xd08>)
 8016dfc:	4628      	mov	r0, r5
 8016dfe:	f7f5 ff33 	bl	800cc68 <strcmp>
 8016e02:	2800      	cmp	r0, #0
 8016e04:	f000 8083 	beq.w	8016f0e <terminal_process_string+0xbbe>
	} else if (strcmp(argv[0], "measure_linkage_foc") == 0) {
 8016e08:	4994      	ldr	r1, [pc, #592]	; (801705c <terminal_process_string+0xd0c>)
 8016e0a:	4628      	mov	r0, r5
 8016e0c:	f7f5 ff2c 	bl	800cc68 <strcmp>
 8016e10:	4606      	mov	r6, r0
 8016e12:	2800      	cmp	r0, #0
 8016e14:	f040 809d 	bne.w	8016f52 <terminal_process_string+0xc02>
		if (argc == 2) {
 8016e18:	2c02      	cmp	r4, #2
 8016e1a:	f47f ad54 	bne.w	80168c6 <terminal_process_string+0x576>
			float duty = -1.0;
 8016e1e:	ad11      	add	r5, sp, #68	; 0x44
 8016e20:	4b83      	ldr	r3, [pc, #524]	; (8017030 <terminal_process_string+0xce0>)
			sscanf(argv[1], "%f", &duty);
 8016e22:	9819      	ldr	r0, [sp, #100]	; 0x64
 8016e24:	4983      	ldr	r1, [pc, #524]	; (8017034 <terminal_process_string+0xce4>)
			float duty = -1.0;
 8016e26:	602b      	str	r3, [r5, #0]
			sscanf(argv[1], "%f", &duty);
 8016e28:	462a      	mov	r2, r5
 8016e2a:	f00f ff49 	bl	8026cc0 <sscanf>
			if (duty > 0.0) {
 8016e2e:	edd5 7a00 	vldr	s15, [r5]
 8016e32:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016e3a:	f77f ad27 	ble.w	801688c <terminal_process_string+0x53c>
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016e3e:	4f7e      	ldr	r7, [pc, #504]	; (8017038 <terminal_process_string+0xce8>)
					mc_interface_set_duty(((float)i / 100.0) * duty);
 8016e40:	ed9f 8a87 	vldr	s16, [pc, #540]	; 8017060 <terminal_process_string+0xd10>
				mcconf.motor_type = MOTOR_TYPE_FOC;
 8016e44:	70bc      	strb	r4, [r7, #2]
				mc_interface_set_configuration(&mcconf);
 8016e46:	4638      	mov	r0, r7
 8016e48:	f004 ffea 	bl	801be20 <mc_interface_set_configuration>
				const float res = (3.0 / 2.0) * mcconf.foc_motor_r;
 8016e4c:	ed97 9a31 	vldr	s18, [r7, #196]	; 0xc4
 8016e50:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 8016e54:	ee29 9a27 	vmul.f32	s18, s18, s15
				systime_t tout = timeout_get_timeout_msec();
 8016e58:	f003 f99a 	bl	801a190 <timeout_get_timeout_msec>
 8016e5c:	4607      	mov	r7, r0
				float tout_c = timeout_get_brake_current();
 8016e5e:	f003 f99f 	bl	801a1a0 <timeout_get_brake_current>
 8016e62:	eef0 aa40 	vmov.f32	s21, s0
				timeout_reset();
 8016e66:	f003 f97b 	bl	801a160 <timeout_reset>
				timeout_configure(60000, 0.0);
 8016e6a:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 8017064 <terminal_process_string+0xd14>
 8016e6e:	f64e 2060 	movw	r0, #60000	; 0xea60
 8016e72:	f003 f965 	bl	801a140 <timeout_configure>
					mc_interface_set_duty(((float)i / 100.0) * duty);
 8016e76:	ee07 6a90 	vmov	s15, r6
 8016e7a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8016e7e:	edd5 7a00 	vldr	s15, [r5]
 8016e82:	ee87 0a08 	vdiv.f32	s0, s14, s16
				for (int i = 0;i < 100;i++) {
 8016e86:	3601      	adds	r6, #1
					mc_interface_set_duty(((float)i / 100.0) * duty);
 8016e88:	ee20 0a27 	vmul.f32	s0, s0, s15
 8016e8c:	f005 f980 	bl	801c190 <mc_interface_set_duty>
					chThdSleepMilliseconds(20);
 8016e90:	20c8      	movs	r0, #200	; 0xc8
 8016e92:	f7f6 fda5 	bl	800d9e0 <chThdSleep>
				for (int i = 0;i < 100;i++) {
 8016e96:	2e64      	cmp	r6, #100	; 0x64
 8016e98:	d1ed      	bne.n	8016e76 <terminal_process_string+0xb26>
				float iq_avg = 0.0;
 8016e9a:	ed9f 8a72 	vldr	s16, [pc, #456]	; 8017064 <terminal_process_string+0xd14>
 8016e9e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
				float samples = 0.0;
 8016ea2:	eef0 8a48 	vmov.f32	s17, s16
				float rpm_avg = 0.0;
 8016ea6:	eef0 9a48 	vmov.f32	s19, s16
				float vq_avg = 0.0;
 8016eaa:	eeb0 aa48 	vmov.f32	s20, s16
					samples += 1.0;
 8016eae:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
					vq_avg += mcpwm_foc_get_vq();
 8016eb2:	f006 ffcd 	bl	801de50 <mcpwm_foc_get_vq>
 8016eb6:	ee3a aa00 	vadd.f32	s20, s20, s0
					rpm_avg += mc_interface_get_rpm();
 8016eba:	f004 fb31 	bl	801b520 <mc_interface_get_rpm>
 8016ebe:	ee79 9a80 	vadd.f32	s19, s19, s0
					iq_avg += mc_interface_get_tot_current_directional();
 8016ec2:	f004 fbbd 	bl	801b640 <mc_interface_get_tot_current_directional>
					chThdSleepMilliseconds(1);
 8016ec6:	200a      	movs	r0, #10
					iq_avg += mc_interface_get_tot_current_directional();
 8016ec8:	ee38 8a00 	vadd.f32	s16, s16, s0
					chThdSleepMilliseconds(1);
 8016ecc:	f7f6 fd88 	bl	800d9e0 <chThdSleep>
				for (int i = 0;i < 1000;i++) {
 8016ed0:	3c01      	subs	r4, #1
					samples += 1.0;
 8016ed2:	ee78 8a8b 	vadd.f32	s17, s17, s22
				for (int i = 0;i < 1000;i++) {
 8016ed6:	d1ec      	bne.n	8016eb2 <terminal_process_string+0xb62>
				mc_interface_release_motor();
 8016ed8:	f005 fa4a 	bl	801c370 <mc_interface_release_motor>
				mc_interface_set_configuration(&mcconf_old);
 8016edc:	4862      	ldr	r0, [pc, #392]	; (8017068 <terminal_process_string+0xd18>)
 8016ede:	f004 ff9f 	bl	801be20 <mc_interface_set_configuration>
				timeout_configure(tout, tout_c);
 8016ee2:	4638      	mov	r0, r7
 8016ee4:	eeb0 0a6a 	vmov.f32	s0, s21
 8016ee8:	f003 f92a 	bl	801a140 <timeout_configure>
				iq_avg /= samples;
 8016eec:	eec8 6a28 	vdiv.f32	s13, s16, s17
				vq_avg /= samples;
 8016ef0:	ee8a 7a28 	vdiv.f32	s14, s20, s17
				rpm_avg /= samples;
 8016ef4:	eec9 7aa8 	vdiv.f32	s15, s19, s17
				float linkage = (vq_avg - res * iq_avg) / (rpm_avg * ((2.0 * M_PI) / 60.0));
 8016ef8:	eea9 7a66 	vfms.f32	s14, s18, s13
 8016efc:	eddf 6a5b 	vldr	s13, [pc, #364]	; 801706c <terminal_process_string+0xd1c>
 8016f00:	ee67 7aa6 	vmul.f32	s15, s15, s13
				commands_printf("Flux linkage: %.7f\n", (double)linkage);
 8016f04:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8016f08:	ee17 0a90 	vmov	r0, s15
 8016f0c:	e743      	b.n	8016d96 <terminal_process_string+0xa46>
		mcconf.motor_type = MOTOR_TYPE_FOC;
 8016f0e:	4b4a      	ldr	r3, [pc, #296]	; (8017038 <terminal_process_string+0xce8>)
 8016f10:	2202      	movs	r2, #2
		mc_interface_set_configuration(&mcconf);
 8016f12:	4618      	mov	r0, r3
		mcconf.motor_type = MOTOR_TYPE_FOC;
 8016f14:	709a      	strb	r2, [r3, #2]
		mc_interface_set_configuration(&mcconf);
 8016f16:	f004 ff83 	bl	801be20 <mc_interface_set_configuration>
		float res = 0.0;
 8016f1a:	2300      	movs	r3, #0
		mcpwm_foc_measure_res_ind(&res, &ind);
 8016f1c:	a911      	add	r1, sp, #68	; 0x44
 8016f1e:	a810      	add	r0, sp, #64	; 0x40
		float res = 0.0;
 8016f20:	9310      	str	r3, [sp, #64]	; 0x40
		float ind = 0.0;
 8016f22:	9311      	str	r3, [sp, #68]	; 0x44
		mcpwm_foc_measure_res_ind(&res, &ind);
 8016f24:	f007 fbb4 	bl	801e690 <mcpwm_foc_measure_res_ind>
		commands_printf("Resistance: %.6f ohm", (double)res);
 8016f28:	9810      	ldr	r0, [sp, #64]	; 0x40
 8016f2a:	f7f5 fa6d 	bl	800c408 <__aeabi_f2d>
 8016f2e:	4602      	mov	r2, r0
 8016f30:	460b      	mov	r3, r1
 8016f32:	484f      	ldr	r0, [pc, #316]	; (8017070 <terminal_process_string+0xd20>)
 8016f34:	f001 fb84 	bl	8018640 <commands_printf>
		commands_printf("Inductance: %.2f microhenry\n", (double)ind);
 8016f38:	9811      	ldr	r0, [sp, #68]	; 0x44
 8016f3a:	f7f5 fa65 	bl	800c408 <__aeabi_f2d>
 8016f3e:	4602      	mov	r2, r0
 8016f40:	460b      	mov	r3, r1
 8016f42:	484c      	ldr	r0, [pc, #304]	; (8017074 <terminal_process_string+0xd24>)
 8016f44:	f001 fb7c 	bl	8018640 <commands_printf>
		mc_interface_set_configuration(&mcconf_old);
 8016f48:	4847      	ldr	r0, [pc, #284]	; (8017068 <terminal_process_string+0xd18>)
 8016f4a:	f004 ff69 	bl	801be20 <mc_interface_set_configuration>
 8016f4e:	f7ff ba68 	b.w	8016422 <terminal_process_string+0xd2>
	} else if (strcmp(argv[0], "foc_state") == 0) {
 8016f52:	4949      	ldr	r1, [pc, #292]	; (8017078 <terminal_process_string+0xd28>)
 8016f54:	4628      	mov	r0, r5
 8016f56:	f7f5 fe87 	bl	800cc68 <strcmp>
 8016f5a:	2800      	cmp	r0, #0
 8016f5c:	f000 80fd 	beq.w	801715a <terminal_process_string+0xe0a>
	} else if (strcmp(argv[0], "hw_status") == 0) {
 8016f60:	4946      	ldr	r1, [pc, #280]	; (801707c <terminal_process_string+0xd2c>)
 8016f62:	4628      	mov	r0, r5
 8016f64:	f7f5 fe80 	bl	800cc68 <strcmp>
 8016f68:	2800      	cmp	r0, #0
 8016f6a:	f000 80b9 	beq.w	80170e0 <terminal_process_string+0xd90>
	} else if (strcmp(argv[0], "drv8301_read_reg") == 0) {
 8016f6e:	4944      	ldr	r1, [pc, #272]	; (8017080 <terminal_process_string+0xd30>)
 8016f70:	4628      	mov	r0, r5
 8016f72:	f7f5 fe79 	bl	800cc68 <strcmp>
 8016f76:	2800      	cmp	r0, #0
 8016f78:	f000 80f6 	beq.w	8017168 <terminal_process_string+0xe18>
	} else if (strcmp(argv[0], "drv8301_write_reg") == 0) {
 8016f7c:	4941      	ldr	r1, [pc, #260]	; (8017084 <terminal_process_string+0xd34>)
 8016f7e:	4628      	mov	r0, r5
 8016f80:	f7f5 fe72 	bl	800cc68 <strcmp>
 8016f84:	2800      	cmp	r0, #0
 8016f86:	f000 80ef 	beq.w	8017168 <terminal_process_string+0xe18>
	} else if (strcmp(argv[0], "drv8301_set_oc_adj") == 0) {
 8016f8a:	493f      	ldr	r1, [pc, #252]	; (8017088 <terminal_process_string+0xd38>)
 8016f8c:	4628      	mov	r0, r5
 8016f8e:	f7f5 fe6b 	bl	800cc68 <strcmp>
 8016f92:	2800      	cmp	r0, #0
 8016f94:	f000 80e8 	beq.w	8017168 <terminal_process_string+0xe18>
	} else if (strcmp(argv[0], "drv8301_print_faults") == 0) {
 8016f98:	493c      	ldr	r1, [pc, #240]	; (801708c <terminal_process_string+0xd3c>)
 8016f9a:	4628      	mov	r0, r5
 8016f9c:	f7f5 fe64 	bl	800cc68 <strcmp>
 8016fa0:	2800      	cmp	r0, #0
 8016fa2:	f000 80e1 	beq.w	8017168 <terminal_process_string+0xe18>
	} else if (strcmp(argv[0], "drv8301_reset_faults") == 0) {
 8016fa6:	493a      	ldr	r1, [pc, #232]	; (8017090 <terminal_process_string+0xd40>)
 8016fa8:	4628      	mov	r0, r5
 8016faa:	f7f5 fe5d 	bl	800cc68 <strcmp>
 8016fae:	2800      	cmp	r0, #0
 8016fb0:	f000 80da 	beq.w	8017168 <terminal_process_string+0xe18>
	} else if (strcmp(argv[0], "drv8305_read_reg") == 0) {
 8016fb4:	4937      	ldr	r1, [pc, #220]	; (8017094 <terminal_process_string+0xd44>)
 8016fb6:	4628      	mov	r0, r5
 8016fb8:	f7f5 fe56 	bl	800cc68 <strcmp>
 8016fbc:	2800      	cmp	r0, #0
 8016fbe:	f000 808a 	beq.w	80170d6 <terminal_process_string+0xd86>
	} else if (strcmp(argv[0], "drv8305_write_reg") == 0) {
 8016fc2:	4935      	ldr	r1, [pc, #212]	; (8017098 <terminal_process_string+0xd48>)
 8016fc4:	4628      	mov	r0, r5
 8016fc6:	f7f5 fe4f 	bl	800cc68 <strcmp>
 8016fca:	2800      	cmp	r0, #0
 8016fcc:	f000 8083 	beq.w	80170d6 <terminal_process_string+0xd86>
	} else if (strcmp(argv[0], "foc_openloop") == 0) {
 8016fd0:	4932      	ldr	r1, [pc, #200]	; (801709c <terminal_process_string+0xd4c>)
 8016fd2:	4628      	mov	r0, r5
 8016fd4:	f7f5 fe48 	bl	800cc68 <strcmp>
 8016fd8:	2800      	cmp	r0, #0
 8016fda:	d163      	bne.n	80170a4 <terminal_process_string+0xd54>
		if (argc == 3) {
 8016fdc:	2c03      	cmp	r4, #3
 8016fde:	d004      	beq.n	8016fea <terminal_process_string+0xc9a>
			commands_printf("This command requires two arguments.\n");
 8016fe0:	482f      	ldr	r0, [pc, #188]	; (80170a0 <terminal_process_string+0xd50>)
 8016fe2:	f001 fb2d 	bl	8018640 <commands_printf>
 8016fe6:	f7ff ba1c 	b.w	8016422 <terminal_process_string+0xd2>
			float current = -1.0;
 8016fea:	4b11      	ldr	r3, [pc, #68]	; (8017030 <terminal_process_string+0xce0>)
			sscanf(argv[1], "%f", &current);
 8016fec:	4911      	ldr	r1, [pc, #68]	; (8017034 <terminal_process_string+0xce4>)
 8016fee:	9819      	ldr	r0, [sp, #100]	; 0x64
			float current = -1.0;
 8016ff0:	9310      	str	r3, [sp, #64]	; 0x40
			sscanf(argv[1], "%f", &current);
 8016ff2:	aa10      	add	r2, sp, #64	; 0x40
			float erpm = -1.0;
 8016ff4:	9311      	str	r3, [sp, #68]	; 0x44
			sscanf(argv[1], "%f", &current);
 8016ff6:	f00f fe63 	bl	8026cc0 <sscanf>
			sscanf(argv[2], "%f", &erpm);
 8016ffa:	aa11      	add	r2, sp, #68	; 0x44
 8016ffc:	981a      	ldr	r0, [sp, #104]	; 0x68
 8016ffe:	490d      	ldr	r1, [pc, #52]	; (8017034 <terminal_process_string+0xce4>)
 8017000:	f00f fe5e 	bl	8026cc0 <sscanf>
			if (current >= 0.0 && erpm >= 0.0) {
 8017004:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
 8017008:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801700c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017010:	f6ff ac3c 	blt.w	801688c <terminal_process_string+0x53c>
 8017014:	eddd 0a11 	vldr	s1, [sp, #68]	; 0x44
 8017018:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 801701c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017020:	f6ff ac34 	blt.w	801688c <terminal_process_string+0x53c>
				mcpwm_foc_set_openloop(current, erpm);
 8017024:	f006 fdc4 	bl	801dbb0 <mcpwm_foc_set_openloop>
 8017028:	f7ff b9fb 	b.w	8016422 <terminal_process_string+0xd2>
 801702c:	0802e93c 	.word	0x0802e93c
 8017030:	bf800000 	.word	0xbf800000
 8017034:	0802e5b8 	.word	0x0802e5b8
 8017038:	20007b2c 	.word	0x20007b2c
 801703c:	3ca3d70a 	.word	0x3ca3d70a
 8017040:	0802e94c 	.word	0x0802e94c
 8017044:	0802e650 	.word	0x0802e650
 8017048:	0802e5f4 	.word	0x0802e5f4
 801704c:	0802e610 	.word	0x0802e610
 8017050:	0802e6b0 	.word	0x0802e6b0
 8017054:	0802e630 	.word	0x0802e630
 8017058:	0802e960 	.word	0x0802e960
 801705c:	0802e9a8 	.word	0x0802e9a8
 8017060:	42c80000 	.word	0x42c80000
 8017064:	00000000 	.word	0x00000000
 8017068:	20007ca0 	.word	0x20007ca0
 801706c:	3dd67750 	.word	0x3dd67750
 8017070:	0802e970 	.word	0x0802e970
 8017074:	0802e988 	.word	0x0802e988
 8017078:	0802e9bc 	.word	0x0802e9bc
 801707c:	0802e9c8 	.word	0x0802e9c8
 8017080:	0802ea54 	.word	0x0802ea54
 8017084:	0802ea90 	.word	0x0802ea90
 8017088:	0802eaa4 	.word	0x0802eaa4
 801708c:	0802eab8 	.word	0x0802eab8
 8017090:	0802ead0 	.word	0x0802ead0
 8017094:	0802eae8 	.word	0x0802eae8
 8017098:	0802eb24 	.word	0x0802eb24
 801709c:	0802eb38 	.word	0x0802eb38
 80170a0:	0802eb48 	.word	0x0802eb48
	else if (strcmp(argv[0], "help") == 0) {
 80170a4:	49a2      	ldr	r1, [pc, #648]	; (8017330 <terminal_process_string+0xfe0>)
 80170a6:	4628      	mov	r0, r5
 80170a8:	f7f5 fdde 	bl	800cc68 <strcmp>
 80170ac:	4606      	mov	r6, r0
 80170ae:	2800      	cmp	r0, #0
 80170b0:	d06c      	beq.n	801718c <terminal_process_string+0xe3c>
		for (int i = 0;i < callback_write;i++) {
 80170b2:	4ba0      	ldr	r3, [pc, #640]	; (8017334 <terminal_process_string+0xfe4>)
			if (strcmp(argv[0], callbacks[i].command) == 0) {
 80170b4:	4ea0      	ldr	r6, [pc, #640]	; (8017338 <terminal_process_string+0xfe8>)
		for (int i = 0;i < callback_write;i++) {
 80170b6:	f8d3 9000 	ldr.w	r9, [r3]
 80170ba:	2700      	movs	r7, #0
 80170bc:	45b9      	cmp	r9, r7
			if (strcmp(argv[0], callbacks[i].command) == 0) {
 80170be:	ea4f 1807 	mov.w	r8, r7, lsl #4
 80170c2:	4628      	mov	r0, r5
		for (int i = 0;i < callback_write;i++) {
 80170c4:	dd5c      	ble.n	8017180 <terminal_process_string+0xe30>
			if (strcmp(argv[0], callbacks[i].command) == 0) {
 80170c6:	f858 1006 	ldr.w	r1, [r8, r6]
 80170ca:	f7f5 fdcd 	bl	800cc68 <strcmp>
 80170ce:	2800      	cmp	r0, #0
 80170d0:	d04f      	beq.n	8017172 <terminal_process_string+0xe22>
		for (int i = 0;i < callback_write;i++) {
 80170d2:	3701      	adds	r7, #1
 80170d4:	e7f2      	b.n	80170bc <terminal_process_string+0xd6c>
		commands_printf("This hardware does not have a DRV8305.\n");
 80170d6:	4899      	ldr	r0, [pc, #612]	; (801733c <terminal_process_string+0xfec>)
 80170d8:	f001 fab2 	bl	8018640 <commands_printf>
 80170dc:	f7ff b9a1 	b.w	8016422 <terminal_process_string+0xd2>
		commands_printf("Firmware: %d.%d", FW_VERSION_MAJOR, FW_VERSION_MINOR);
 80170e0:	2222      	movs	r2, #34	; 0x22
 80170e2:	2103      	movs	r1, #3
 80170e4:	4896      	ldr	r0, [pc, #600]	; (8017340 <terminal_process_string+0xff0>)
 80170e6:	f001 faab 	bl	8018640 <commands_printf>
		commands_printf("Hardware: %s", HW_NAME);
 80170ea:	4996      	ldr	r1, [pc, #600]	; (8017344 <terminal_process_string+0xff4>)
 80170ec:	4896      	ldr	r0, [pc, #600]	; (8017348 <terminal_process_string+0xff8>)
 80170ee:	f001 faa7 	bl	8018640 <commands_printf>
				STM32_UUID_8[8], STM32_UUID_8[9], STM32_UUID_8[10], STM32_UUID_8[11]);
 80170f2:	4896      	ldr	r0, [pc, #600]	; (801734c <terminal_process_string+0xffc>)
				STM32_UUID_8[0], STM32_UUID_8[1], STM32_UUID_8[2], STM32_UUID_8[3],
 80170f4:	4b96      	ldr	r3, [pc, #600]	; (8017350 <terminal_process_string+0x1000>)
 80170f6:	4a97      	ldr	r2, [pc, #604]	; (8017354 <terminal_process_string+0x1004>)
 80170f8:	4997      	ldr	r1, [pc, #604]	; (8017358 <terminal_process_string+0x1008>)
		commands_printf("UUID: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
 80170fa:	7804      	ldrb	r4, [r0, #0]
 80170fc:	781b      	ldrb	r3, [r3, #0]
 80170fe:	7812      	ldrb	r2, [r2, #0]
 8017100:	7809      	ldrb	r1, [r1, #0]
 8017102:	9408      	str	r4, [sp, #32]
 8017104:	f810 4c01 	ldrb.w	r4, [r0, #-1]
 8017108:	9407      	str	r4, [sp, #28]
 801710a:	f810 4c02 	ldrb.w	r4, [r0, #-2]
 801710e:	9406      	str	r4, [sp, #24]
 8017110:	f810 4c03 	ldrb.w	r4, [r0, #-3]
 8017114:	9405      	str	r4, [sp, #20]
 8017116:	f810 4c04 	ldrb.w	r4, [r0, #-4]
 801711a:	9404      	str	r4, [sp, #16]
 801711c:	f810 4c05 	ldrb.w	r4, [r0, #-5]
 8017120:	9403      	str	r4, [sp, #12]
 8017122:	f810 4c06 	ldrb.w	r4, [r0, #-6]
 8017126:	9402      	str	r4, [sp, #8]
 8017128:	f810 4c07 	ldrb.w	r4, [r0, #-7]
 801712c:	9401      	str	r4, [sp, #4]
				STM32_UUID_8[0], STM32_UUID_8[1], STM32_UUID_8[2], STM32_UUID_8[3],
 801712e:	3808      	subs	r0, #8
		commands_printf("UUID: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
 8017130:	7800      	ldrb	r0, [r0, #0]
 8017132:	9000      	str	r0, [sp, #0]
 8017134:	4889      	ldr	r0, [pc, #548]	; (801735c <terminal_process_string+0x100c>)
 8017136:	f001 fa83 	bl	8018640 <commands_printf>
		commands_printf("Permanent NRF found: %s", conf_general_permanent_nrf_found ? "Yes" : "No");
 801713a:	4b89      	ldr	r3, [pc, #548]	; (8017360 <terminal_process_string+0x1010>)
 801713c:	4a89      	ldr	r2, [pc, #548]	; (8017364 <terminal_process_string+0x1014>)
 801713e:	7819      	ldrb	r1, [r3, #0]
 8017140:	4b89      	ldr	r3, [pc, #548]	; (8017368 <terminal_process_string+0x1018>)
 8017142:	488a      	ldr	r0, [pc, #552]	; (801736c <terminal_process_string+0x101c>)
 8017144:	2900      	cmp	r1, #0
 8017146:	bf0c      	ite	eq
 8017148:	4611      	moveq	r1, r2
 801714a:	4619      	movne	r1, r3
 801714c:	f001 fa78 	bl	8018640 <commands_printf>
		commands_printf(" ");
 8017150:	4887      	ldr	r0, [pc, #540]	; (8017370 <terminal_process_string+0x1020>)
 8017152:	f001 fa75 	bl	8018640 <commands_printf>
 8017156:	f7ff b964 	b.w	8016422 <terminal_process_string+0xd2>
		mcpwm_foc_print_state();
 801715a:	f007 fcc1 	bl	801eae0 <mcpwm_foc_print_state>
		commands_printf(" ");
 801715e:	4884      	ldr	r0, [pc, #528]	; (8017370 <terminal_process_string+0x1020>)
 8017160:	f001 fa6e 	bl	8018640 <commands_printf>
 8017164:	f7ff b95d 	b.w	8016422 <terminal_process_string+0xd2>
		commands_printf("This hardware does not have a DRV8301.\n");
 8017168:	4882      	ldr	r0, [pc, #520]	; (8017374 <terminal_process_string+0x1024>)
 801716a:	f001 fa69 	bl	8018640 <commands_printf>
 801716e:	f7ff b958 	b.w	8016422 <terminal_process_string+0xd2>
				callbacks[i].cbf(argc, (const char**)argv);
 8017172:	4446      	add	r6, r8
 8017174:	a918      	add	r1, sp, #96	; 0x60
 8017176:	68f3      	ldr	r3, [r6, #12]
 8017178:	4620      	mov	r0, r4
 801717a:	4798      	blx	r3
 801717c:	f7ff b951 	b.w	8016422 <terminal_process_string+0xd2>
			commands_printf("Invalid command: %s\n"
 8017180:	4629      	mov	r1, r5
 8017182:	487d      	ldr	r0, [pc, #500]	; (8017378 <terminal_process_string+0x1028>)
 8017184:	f001 fa5c 	bl	8018640 <commands_printf>
 8017188:	f7ff b94b 	b.w	8016422 <terminal_process_string+0xd2>
		commands_printf("Valid commands are:");
 801718c:	487b      	ldr	r0, [pc, #492]	; (801737c <terminal_process_string+0x102c>)
 801718e:	4c6a      	ldr	r4, [pc, #424]	; (8017338 <terminal_process_string+0xfe8>)
 8017190:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8017334 <terminal_process_string+0xfe4>
				commands_printf("%s %s", callbacks[i].command, callbacks[i].arg_names);
 8017194:	f8df 82c4 	ldr.w	r8, [pc, #708]	; 801745c <terminal_process_string+0x110c>
				commands_printf("  There is no help available for this command.");
 8017198:	4f79      	ldr	r7, [pc, #484]	; (8017380 <terminal_process_string+0x1030>)
				commands_printf("  %s", callbacks[i].help);
 801719a:	4d7a      	ldr	r5, [pc, #488]	; (8017384 <terminal_process_string+0x1034>)
		commands_printf("Valid commands are:");
 801719c:	f001 fa50 	bl	8018640 <commands_printf>
		commands_printf("help");
 80171a0:	4863      	ldr	r0, [pc, #396]	; (8017330 <terminal_process_string+0xfe0>)
 80171a2:	f001 fa4d 	bl	8018640 <commands_printf>
		commands_printf("  Show this help");
 80171a6:	4878      	ldr	r0, [pc, #480]	; (8017388 <terminal_process_string+0x1038>)
 80171a8:	f001 fa4a 	bl	8018640 <commands_printf>
		commands_printf("ping");
 80171ac:	4877      	ldr	r0, [pc, #476]	; (801738c <terminal_process_string+0x103c>)
 80171ae:	f001 fa47 	bl	8018640 <commands_printf>
		commands_printf("  Print pong here to see if the reply works");
 80171b2:	4877      	ldr	r0, [pc, #476]	; (8017390 <terminal_process_string+0x1040>)
 80171b4:	f001 fa44 	bl	8018640 <commands_printf>
		commands_printf("stop");
 80171b8:	4876      	ldr	r0, [pc, #472]	; (8017394 <terminal_process_string+0x1044>)
 80171ba:	f001 fa41 	bl	8018640 <commands_printf>
		commands_printf("  Stop the motor");
 80171be:	4876      	ldr	r0, [pc, #472]	; (8017398 <terminal_process_string+0x1048>)
 80171c0:	f001 fa3e 	bl	8018640 <commands_printf>
		commands_printf("last_adc_duration");
 80171c4:	4875      	ldr	r0, [pc, #468]	; (801739c <terminal_process_string+0x104c>)
 80171c6:	f001 fa3b 	bl	8018640 <commands_printf>
		commands_printf("  The time the latest ADC interrupt consumed");
 80171ca:	4875      	ldr	r0, [pc, #468]	; (80173a0 <terminal_process_string+0x1050>)
 80171cc:	f001 fa38 	bl	8018640 <commands_printf>
		commands_printf("kv");
 80171d0:	4874      	ldr	r0, [pc, #464]	; (80173a4 <terminal_process_string+0x1054>)
 80171d2:	f001 fa35 	bl	8018640 <commands_printf>
		commands_printf("  The calculated kv of the motor");
 80171d6:	4874      	ldr	r0, [pc, #464]	; (80173a8 <terminal_process_string+0x1058>)
 80171d8:	f001 fa32 	bl	8018640 <commands_printf>
		commands_printf("mem");
 80171dc:	4873      	ldr	r0, [pc, #460]	; (80173ac <terminal_process_string+0x105c>)
 80171de:	f001 fa2f 	bl	8018640 <commands_printf>
		commands_printf("  Show memory usage");
 80171e2:	4873      	ldr	r0, [pc, #460]	; (80173b0 <terminal_process_string+0x1060>)
 80171e4:	f001 fa2c 	bl	8018640 <commands_printf>
		commands_printf("threads");
 80171e8:	4872      	ldr	r0, [pc, #456]	; (80173b4 <terminal_process_string+0x1064>)
 80171ea:	f001 fa29 	bl	8018640 <commands_printf>
		commands_printf("  List all threads");
 80171ee:	4872      	ldr	r0, [pc, #456]	; (80173b8 <terminal_process_string+0x1068>)
 80171f0:	f001 fa26 	bl	8018640 <commands_printf>
		commands_printf("fault");
 80171f4:	4871      	ldr	r0, [pc, #452]	; (80173bc <terminal_process_string+0x106c>)
 80171f6:	f001 fa23 	bl	8018640 <commands_printf>
		commands_printf("  Prints the current fault code");
 80171fa:	4871      	ldr	r0, [pc, #452]	; (80173c0 <terminal_process_string+0x1070>)
 80171fc:	f001 fa20 	bl	8018640 <commands_printf>
		commands_printf("faults");
 8017200:	4870      	ldr	r0, [pc, #448]	; (80173c4 <terminal_process_string+0x1074>)
 8017202:	f001 fa1d 	bl	8018640 <commands_printf>
		commands_printf("  Prints all stored fault codes and conditions when they arrived");
 8017206:	4870      	ldr	r0, [pc, #448]	; (80173c8 <terminal_process_string+0x1078>)
 8017208:	f001 fa1a 	bl	8018640 <commands_printf>
		commands_printf("rpm");
 801720c:	486f      	ldr	r0, [pc, #444]	; (80173cc <terminal_process_string+0x107c>)
 801720e:	f001 fa17 	bl	8018640 <commands_printf>
		commands_printf("  Prints the current electrical RPM");
 8017212:	486f      	ldr	r0, [pc, #444]	; (80173d0 <terminal_process_string+0x1080>)
 8017214:	f001 fa14 	bl	8018640 <commands_printf>
		commands_printf("tacho");
 8017218:	486e      	ldr	r0, [pc, #440]	; (80173d4 <terminal_process_string+0x1084>)
 801721a:	f001 fa11 	bl	8018640 <commands_printf>
		commands_printf("  Prints tachometer value");
 801721e:	486e      	ldr	r0, [pc, #440]	; (80173d8 <terminal_process_string+0x1088>)
 8017220:	f001 fa0e 	bl	8018640 <commands_printf>
		commands_printf("tim");
 8017224:	486d      	ldr	r0, [pc, #436]	; (80173dc <terminal_process_string+0x108c>)
 8017226:	f001 fa0b 	bl	8018640 <commands_printf>
		commands_printf("  Prints tim1 and tim8 settings");
 801722a:	486d      	ldr	r0, [pc, #436]	; (80173e0 <terminal_process_string+0x1090>)
 801722c:	f001 fa08 	bl	8018640 <commands_printf>
		commands_printf("volt");
 8017230:	486c      	ldr	r0, [pc, #432]	; (80173e4 <terminal_process_string+0x1094>)
 8017232:	f001 fa05 	bl	8018640 <commands_printf>
		commands_printf("  Prints different voltages");
 8017236:	486c      	ldr	r0, [pc, #432]	; (80173e8 <terminal_process_string+0x1098>)
 8017238:	f001 fa02 	bl	8018640 <commands_printf>
		commands_printf("param_detect [current] [min_rpm] [low_duty]");
 801723c:	486b      	ldr	r0, [pc, #428]	; (80173ec <terminal_process_string+0x109c>)
 801723e:	f001 f9ff 	bl	8018640 <commands_printf>
		commands_printf("  Spin up the motor in COMM_MODE_DELAY and compute its parameters.");
 8017242:	486b      	ldr	r0, [pc, #428]	; (80173f0 <terminal_process_string+0x10a0>)
 8017244:	f001 f9fc 	bl	8018640 <commands_printf>
		commands_printf("  This test should be performed without load on the motor.");
 8017248:	486a      	ldr	r0, [pc, #424]	; (80173f4 <terminal_process_string+0x10a4>)
 801724a:	f001 f9f9 	bl	8018640 <commands_printf>
		commands_printf("  Example: param_detect 5.0 600 0.06");
 801724e:	486a      	ldr	r0, [pc, #424]	; (80173f8 <terminal_process_string+0x10a8>)
 8017250:	f001 f9f6 	bl	8018640 <commands_printf>
		commands_printf("rpm_dep");
 8017254:	4869      	ldr	r0, [pc, #420]	; (80173fc <terminal_process_string+0x10ac>)
 8017256:	f001 f9f3 	bl	8018640 <commands_printf>
		commands_printf("  Prints some rpm-dep values");
 801725a:	4869      	ldr	r0, [pc, #420]	; (8017400 <terminal_process_string+0x10b0>)
 801725c:	f001 f9f0 	bl	8018640 <commands_printf>
		commands_printf("can_devs");
 8017260:	4868      	ldr	r0, [pc, #416]	; (8017404 <terminal_process_string+0x10b4>)
 8017262:	f001 f9ed 	bl	8018640 <commands_printf>
		commands_printf("  Prints all CAN devices seen on the bus the past second");
 8017266:	4868      	ldr	r0, [pc, #416]	; (8017408 <terminal_process_string+0x10b8>)
 8017268:	f001 f9ea 	bl	8018640 <commands_printf>
		commands_printf("foc_encoder_detect [current]");
 801726c:	4867      	ldr	r0, [pc, #412]	; (801740c <terminal_process_string+0x10bc>)
 801726e:	f001 f9e7 	bl	8018640 <commands_printf>
		commands_printf("  Run the motor at 1Hz on open loop and compute encoder settings");
 8017272:	4867      	ldr	r0, [pc, #412]	; (8017410 <terminal_process_string+0x10c0>)
 8017274:	f001 f9e4 	bl	8018640 <commands_printf>
		commands_printf("measure_res [current]");
 8017278:	4866      	ldr	r0, [pc, #408]	; (8017414 <terminal_process_string+0x10c4>)
 801727a:	f001 f9e1 	bl	8018640 <commands_printf>
		commands_printf("  Lock the motor with a current and calculate its resistance");
 801727e:	4866      	ldr	r0, [pc, #408]	; (8017418 <terminal_process_string+0x10c8>)
 8017280:	f001 f9de 	bl	8018640 <commands_printf>
		commands_printf("measure_ind [duty]");
 8017284:	4865      	ldr	r0, [pc, #404]	; (801741c <terminal_process_string+0x10cc>)
 8017286:	f001 f9db 	bl	8018640 <commands_printf>
		commands_printf("  Send short voltage pulses, measure the current and calculate the motor inductance");
 801728a:	4865      	ldr	r0, [pc, #404]	; (8017420 <terminal_process_string+0x10d0>)
 801728c:	f001 f9d8 	bl	8018640 <commands_printf>
		commands_printf("measure_linkage [current] [duty] [min_rpm] [motor_res]");
 8017290:	4864      	ldr	r0, [pc, #400]	; (8017424 <terminal_process_string+0x10d4>)
 8017292:	f001 f9d5 	bl	8018640 <commands_printf>
		commands_printf("  Run the motor in BLDC delay mode and measure the flux linkage");
 8017296:	4864      	ldr	r0, [pc, #400]	; (8017428 <terminal_process_string+0x10d8>)
 8017298:	f001 f9d2 	bl	8018640 <commands_printf>
		commands_printf("  example measure_linkage 5 0.5 700 0.076");
 801729c:	4863      	ldr	r0, [pc, #396]	; (801742c <terminal_process_string+0x10dc>)
 801729e:	f001 f9cf 	bl	8018640 <commands_printf>
		commands_printf("  tip: measure the resistance with measure_res first");
 80172a2:	4863      	ldr	r0, [pc, #396]	; (8017430 <terminal_process_string+0x10e0>)
 80172a4:	f001 f9cc 	bl	8018640 <commands_printf>
		commands_printf("measure_res_ind");
 80172a8:	4862      	ldr	r0, [pc, #392]	; (8017434 <terminal_process_string+0x10e4>)
 80172aa:	f001 f9c9 	bl	8018640 <commands_printf>
		commands_printf("  Measure the motor resistance and inductance with an incremental adaptive algorithm.");
 80172ae:	4862      	ldr	r0, [pc, #392]	; (8017438 <terminal_process_string+0x10e8>)
 80172b0:	f001 f9c6 	bl	8018640 <commands_printf>
		commands_printf("measure_linkage_foc [duty]");
 80172b4:	4861      	ldr	r0, [pc, #388]	; (801743c <terminal_process_string+0x10ec>)
 80172b6:	f001 f9c3 	bl	8018640 <commands_printf>
		commands_printf("  Run the motor with FOC and measure the flux linkage.");
 80172ba:	4861      	ldr	r0, [pc, #388]	; (8017440 <terminal_process_string+0x10f0>)
 80172bc:	f001 f9c0 	bl	8018640 <commands_printf>
		commands_printf("foc_state");
 80172c0:	4860      	ldr	r0, [pc, #384]	; (8017444 <terminal_process_string+0x10f4>)
 80172c2:	f001 f9bd 	bl	8018640 <commands_printf>
		commands_printf("  Print some FOC state variables.");
 80172c6:	4860      	ldr	r0, [pc, #384]	; (8017448 <terminal_process_string+0x10f8>)
 80172c8:	f001 f9ba 	bl	8018640 <commands_printf>
		commands_printf("hw_status");
 80172cc:	485f      	ldr	r0, [pc, #380]	; (801744c <terminal_process_string+0x10fc>)
 80172ce:	f001 f9b7 	bl	8018640 <commands_printf>
		commands_printf("  Print some hardware status information.");
 80172d2:	485f      	ldr	r0, [pc, #380]	; (8017450 <terminal_process_string+0x1100>)
 80172d4:	f001 f9b4 	bl	8018640 <commands_printf>
		commands_printf("foc_openloop [current] [erpm]");
 80172d8:	485e      	ldr	r0, [pc, #376]	; (8017454 <terminal_process_string+0x1104>)
 80172da:	f001 f9b1 	bl	8018640 <commands_printf>
		commands_printf("  Create an open loop rotating current vector.");
 80172de:	485e      	ldr	r0, [pc, #376]	; (8017458 <terminal_process_string+0x1108>)
 80172e0:	f001 f9ae 	bl	8018640 <commands_printf>
		for (int i = 0;i < callback_write;i++) {
 80172e4:	f8d9 3000 	ldr.w	r3, [r9]
 80172e8:	42b3      	cmp	r3, r6
				commands_printf("%s %s", callbacks[i].command, callbacks[i].arg_names);
 80172ea:	4640      	mov	r0, r8
		for (int i = 0;i < callback_write;i++) {
 80172ec:	dd12      	ble.n	8017314 <terminal_process_string+0xfc4>
			if (callbacks[i].arg_names) {
 80172ee:	f8d4 c008 	ldr.w	ip, [r4, #8]
 80172f2:	6823      	ldr	r3, [r4, #0]
				commands_printf("%s %s", callbacks[i].command, callbacks[i].arg_names);
 80172f4:	4662      	mov	r2, ip
 80172f6:	4619      	mov	r1, r3
			if (callbacks[i].arg_names) {
 80172f8:	f1bc 0f00 	cmp.w	ip, #0
 80172fc:	d013      	beq.n	8017326 <terminal_process_string+0xfd6>
				commands_printf("%s %s", callbacks[i].command, callbacks[i].arg_names);
 80172fe:	f001 f99f 	bl	8018640 <commands_printf>
			if (callbacks[i].help) {
 8017302:	6863      	ldr	r3, [r4, #4]
				commands_printf("  %s", callbacks[i].help);
 8017304:	4628      	mov	r0, r5
 8017306:	4619      	mov	r1, r3
			if (callbacks[i].help) {
 8017308:	b14b      	cbz	r3, 801731e <terminal_process_string+0xfce>
				commands_printf("  %s", callbacks[i].help);
 801730a:	f001 f999 	bl	8018640 <commands_printf>
		for (int i = 0;i < callback_write;i++) {
 801730e:	3601      	adds	r6, #1
 8017310:	3410      	adds	r4, #16
 8017312:	e7e7      	b.n	80172e4 <terminal_process_string+0xf94>
		commands_printf(" ");
 8017314:	4816      	ldr	r0, [pc, #88]	; (8017370 <terminal_process_string+0x1020>)
 8017316:	f001 f993 	bl	8018640 <commands_printf>
 801731a:	f7ff b882 	b.w	8016422 <terminal_process_string+0xd2>
				commands_printf("  There is no help available for this command.");
 801731e:	4638      	mov	r0, r7
 8017320:	f001 f98e 	bl	8018640 <commands_printf>
 8017324:	e7f3      	b.n	801730e <terminal_process_string+0xfbe>
				commands_printf(callbacks[i].command);
 8017326:	4618      	mov	r0, r3
 8017328:	f001 f98a 	bl	8018640 <commands_printf>
 801732c:	e7e9      	b.n	8017302 <terminal_process_string+0xfb2>
 801732e:	bf00      	nop
 8017330:	0802eb90 	.word	0x0802eb90
 8017334:	2000741c 	.word	0x2000741c
 8017338:	20007420 	.word	0x20007420
 801733c:	0802eafc 	.word	0x0802eafc
 8017340:	0802e9d4 	.word	0x0802e9d4
 8017344:	0802e9e4 	.word	0x0802e9e4
 8017348:	0802e9e8 	.word	0x0802e9e8
 801734c:	1fff7a1b 	.word	0x1fff7a1b
 8017350:	1fff7a12 	.word	0x1fff7a12
 8017354:	1fff7a11 	.word	0x1fff7a11
 8017358:	1fff7a10 	.word	0x1fff7a10
 801735c:	0802e9f8 	.word	0x0802e9f8
 8017360:	20008050 	.word	0x20008050
 8017364:	0802e0e4 	.word	0x0802e0e4
 8017368:	0802e0e0 	.word	0x0802e0e0
 801736c:	0802ea3c 	.word	0x0802ea3c
 8017370:	0802e26c 	.word	0x0802e26c
 8017374:	0802ea68 	.word	0x0802ea68
 8017378:	0802f1f0 	.word	0x0802f1f0
 801737c:	0802eb70 	.word	0x0802eb70
 8017380:	0802f1c0 	.word	0x0802f1c0
 8017384:	0802f1b8 	.word	0x0802f1b8
 8017388:	0802eb84 	.word	0x0802eb84
 801738c:	0802e100 	.word	0x0802e100
 8017390:	0802eb98 	.word	0x0802eb98
 8017394:	0802e110 	.word	0x0802e110
 8017398:	0802ebc4 	.word	0x0802ebc4
 801739c:	0802e128 	.word	0x0802e128
 80173a0:	0802ebd8 	.word	0x0802ebd8
 80173a4:	0802e1ac 	.word	0x0802e1ac
 80173a8:	0802ec08 	.word	0x0802ec08
 80173ac:	0802e1d0 	.word	0x0802e1d0
 80173b0:	0802ec2c 	.word	0x0802ec2c
 80173b4:	0802e228 	.word	0x0802e228
 80173b8:	0802ec40 	.word	0x0802ec40
 80173bc:	0802e2d4 	.word	0x0802e2d4
 80173c0:	0802ec54 	.word	0x0802ec54
 80173c4:	0802e2e0 	.word	0x0802e2e0
 80173c8:	0802ec74 	.word	0x0802ec74
 80173cc:	0802e490 	.word	0x0802e490
 80173d0:	0802ecb8 	.word	0x0802ecb8
 80173d4:	0802e4b0 	.word	0x0802e4b0
 80173d8:	0802ecdc 	.word	0x0802ecdc
 80173dc:	0802e4d0 	.word	0x0802e4d0
 80173e0:	0802ecf8 	.word	0x0802ecf8
 80173e4:	0802e588 	.word	0x0802e588
 80173e8:	0802ed18 	.word	0x0802ed18
 80173ec:	0802ed34 	.word	0x0802ed34
 80173f0:	0802ed60 	.word	0x0802ed60
 80173f4:	0802eda4 	.word	0x0802eda4
 80173f8:	0802ede0 	.word	0x0802ede0
 80173fc:	0802e728 	.word	0x0802e728
 8017400:	0802ee08 	.word	0x0802ee08
 8017404:	0802e784 	.word	0x0802e784
 8017408:	0802ee28 	.word	0x0802ee28
 801740c:	0802ee64 	.word	0x0802ee64
 8017410:	0802ee84 	.word	0x0802ee84
 8017414:	0802eec8 	.word	0x0802eec8
 8017418:	0802eee0 	.word	0x0802eee0
 801741c:	0802ef20 	.word	0x0802ef20
 8017420:	0802ef34 	.word	0x0802ef34
 8017424:	0802ef88 	.word	0x0802ef88
 8017428:	0802efc0 	.word	0x0802efc0
 801742c:	0802f000 	.word	0x0802f000
 8017430:	0802f02c 	.word	0x0802f02c
 8017434:	0802e960 	.word	0x0802e960
 8017438:	0802f064 	.word	0x0802f064
 801743c:	0802f0bc 	.word	0x0802f0bc
 8017440:	0802f0d8 	.word	0x0802f0d8
 8017444:	0802e9bc 	.word	0x0802e9bc
 8017448:	0802f110 	.word	0x0802f110
 801744c:	0802e9c8 	.word	0x0802e9c8
 8017450:	0802f134 	.word	0x0802f134
 8017454:	0802f160 	.word	0x0802f160
 8017458:	0802f180 	.word	0x0802f180
 801745c:	0802f1b0 	.word	0x0802f1b0

08017460 <terminal_add_fault_data>:

void terminal_add_fault_data(fault_data *data) {
 8017460:	b4f0      	push	{r4, r5, r6, r7}
	fault_vec[fault_vec_write++] = *data;
 8017462:	4f0e      	ldr	r7, [pc, #56]	; (801749c <terminal_add_fault_data+0x3c>)
 8017464:	4c0e      	ldr	r4, [pc, #56]	; (80174a0 <terminal_add_fault_data+0x40>)
 8017466:	683e      	ldr	r6, [r7, #0]
 8017468:	4605      	mov	r5, r0
 801746a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801746c:	f106 0c01 	add.w	ip, r6, #1
 8017470:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
 8017474:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 8017478:	f8c7 c000 	str.w	ip, [r7]
 801747c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801747e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017480:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017482:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017484:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017486:	e895 0003 	ldmia.w	r5, {r0, r1}
 801748a:	e884 0003 	stmia.w	r4, {r0, r1}
	if (fault_vec_write >= FAULT_VEC_LEN) {
 801748e:	683b      	ldr	r3, [r7, #0]
 8017490:	2b18      	cmp	r3, #24
		fault_vec_write = 0;
 8017492:	bfc4      	itt	gt
 8017494:	2300      	movgt	r3, #0
 8017496:	603b      	strgt	r3, [r7, #0]
	}
}
 8017498:	bcf0      	pop	{r4, r5, r6, r7}
 801749a:	4770      	bx	lr
 801749c:	20007b28 	.word	0x20007b28
 80174a0:	200075b0 	.word	0x200075b0
	...

080174b0 <terminal_register_command_callback>:
 */
void terminal_register_command_callback(
		const char* command,
		const char *help,
		const char *arg_names,
		void(*cbf)(int argc, const char **argv)) {
 80174b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	int callback_num = callback_write;
 80174b4:	f8df 8078 	ldr.w	r8, [pc, #120]	; 8017530 <terminal_register_command_callback+0x80>

	for (int i = 0;i < callback_write;i++) {
		// First check the address in case the same callback is registered more than once.
		if (callbacks[i].command == command) {
 80174b8:	4e1c      	ldr	r6, [pc, #112]	; (801752c <terminal_register_command_callback+0x7c>)
	int callback_num = callback_write;
 80174ba:	f8d8 7000 	ldr.w	r7, [r8]
	for (int i = 0;i < callback_write;i++) {
 80174be:	2f00      	cmp	r7, #0
		void(*cbf)(int argc, const char **argv)) {
 80174c0:	4605      	mov	r5, r0
 80174c2:	468b      	mov	fp, r1
 80174c4:	4692      	mov	sl, r2
 80174c6:	4699      	mov	r9, r3
	for (int i = 0;i < callback_write;i++) {
 80174c8:	dd1a      	ble.n	8017500 <terminal_register_command_callback+0x50>
		if (callbacks[i].command == command) {
 80174ca:	6830      	ldr	r0, [r6, #0]
 80174cc:	4285      	cmp	r5, r0
 80174ce:	d02a      	beq.n	8017526 <terminal_register_command_callback+0x76>
	for (int i = 0;i < callback_write;i++) {
 80174d0:	2400      	movs	r4, #0
 80174d2:	e007      	b.n	80174e4 <terminal_register_command_callback+0x34>
 80174d4:	3401      	adds	r4, #1
 80174d6:	42a7      	cmp	r7, r4
		if (callbacks[i].command == command) {
 80174d8:	ea4f 1304 	mov.w	r3, r4, lsl #4
	for (int i = 0;i < callback_write;i++) {
 80174dc:	d010      	beq.n	8017500 <terminal_register_command_callback+0x50>
		if (callbacks[i].command == command) {
 80174de:	58f0      	ldr	r0, [r6, r3]
 80174e0:	42a8      	cmp	r0, r5
 80174e2:	d005      	beq.n	80174f0 <terminal_register_command_callback+0x40>
			callback_num = i;
			break;
		}

		// Check by string comparison.
		if (strcmp(callbacks[i].command, command) == 0) {
 80174e4:	4629      	mov	r1, r5
 80174e6:	f7f5 fbbf 	bl	800cc68 <strcmp>
 80174ea:	2800      	cmp	r0, #0
 80174ec:	d1f2      	bne.n	80174d4 <terminal_register_command_callback+0x24>
 80174ee:	0123      	lsls	r3, r4, #4
			callback_num = i;
			break;
		}
	}

	callbacks[callback_num].command = command;
 80174f0:	18f2      	adds	r2, r6, r3
 80174f2:	50f5      	str	r5, [r6, r3]
	callbacks[callback_num].help = help;
	callbacks[callback_num].arg_names = arg_names;
 80174f4:	e9c2 ba01 	strd	fp, sl, [r2, #4]
	callbacks[callback_num].cbf = cbf;
 80174f8:	f8c2 900c 	str.w	r9, [r2, #12]
		callback_write++;
		if (callback_write >= CALLBACK_LEN) {
			callback_write = 0;
		}
	}
}
 80174fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	callbacks[callback_num].command = command;
 8017500:	013a      	lsls	r2, r7, #4
 8017502:	18b3      	adds	r3, r6, r2
		callback_write++;
 8017504:	3701      	adds	r7, #1
		if (callback_write >= CALLBACK_LEN) {
 8017506:	2f18      	cmp	r7, #24
	callbacks[callback_num].command = command;
 8017508:	50b5      	str	r5, [r6, r2]
	callbacks[callback_num].arg_names = arg_names;
 801750a:	e9c3 ba01 	strd	fp, sl, [r3, #4]
	callbacks[callback_num].cbf = cbf;
 801750e:	f8c3 900c 	str.w	r9, [r3, #12]
		if (callback_write >= CALLBACK_LEN) {
 8017512:	dd04      	ble.n	801751e <terminal_register_command_callback+0x6e>
			callback_write = 0;
 8017514:	2300      	movs	r3, #0
 8017516:	f8c8 3000 	str.w	r3, [r8]
}
 801751a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		callback_write++;
 801751e:	f8c8 7000 	str.w	r7, [r8]
}
 8017522:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017526:	2300      	movs	r3, #0
 8017528:	e7e2      	b.n	80174f0 <terminal_register_command_callback+0x40>
 801752a:	bf00      	nop
 801752c:	20007420 	.word	0x20007420
 8017530:	2000741c 	.word	0x2000741c
	...

08017540 <conf_general_init>:
bool conf_general_permanent_nrf_found = false;

// Private variables
mc_configuration mcconf, mcconf_old;

void conf_general_init(void) {
 8017540:	b508      	push	{r3, lr}
	// First, make sure that all relevant virtual addresses are assigned for page swapping.
	memset(VirtAddVarTab, 0, sizeof(VirtAddVarTab));
 8017542:	f44f 720f 	mov.w	r2, #572	; 0x23c
 8017546:	2100      	movs	r1, #0
 8017548:	4810      	ldr	r0, [pc, #64]	; (801758c <conf_general_init+0x4c>)
 801754a:	f00f fb69 	bl	8026c20 <memset>
 801754e:	4a10      	ldr	r2, [pc, #64]	; (8017590 <conf_general_init+0x50>)
 8017550:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8017554:	f502 71ba 	add.w	r1, r2, #372	; 0x174

	int ind = 0;
	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
		VirtAddVarTab[ind++] = EEPROM_BASE_MCCONF + i;
 8017558:	f822 3f02 	strh.w	r3, [r2, #2]!
 801755c:	3301      	adds	r3, #1
	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
 801755e:	428a      	cmp	r2, r1
 8017560:	b29b      	uxth	r3, r3
 8017562:	d1f9      	bne.n	8017558 <conf_general_init+0x18>
 8017564:	4a0b      	ldr	r2, [pc, #44]	; (8017594 <conf_general_init+0x54>)
 8017566:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 801756a:	f102 01c8 	add.w	r1, r2, #200	; 0xc8
	}

	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
		VirtAddVarTab[ind++] = EEPROM_BASE_APPCONF + i;
 801756e:	f822 3f02 	strh.w	r3, [r2, #2]!
 8017572:	3301      	adds	r3, #1
	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
 8017574:	4291      	cmp	r1, r2
 8017576:	b29b      	uxth	r3, r3
 8017578:	d1f9      	bne.n	801756e <conf_general_init+0x2e>
	}

	FLASH_Unlock();
 801757a:	f00c fd79 	bl	8024070 <FLASH_Unlock>
	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 801757e:	20f2      	movs	r0, #242	; 0xf2
 8017580:	f00c fd86 	bl	8024090 <FLASH_ClearFlag>
			FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);
	EE_Init();
}
 8017584:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	EE_Init();
 8017588:	f000 bea2 	b.w	80182d0 <EE_Init>
 801758c:	20007e14 	.word	0x20007e14
 8017590:	20007e12 	.word	0x20007e12
 8017594:	20007f86 	.word	0x20007f86
	...

080175a0 <conf_general_get_default_app_configuration>:
 * Load the compiled default app_configuration.
 *
 * @param conf
 * A pointer to store the default configuration to.
 */
void conf_general_get_default_app_configuration(app_configuration *conf) {
 80175a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	memset(conf, 0, sizeof(app_configuration));
 80175a4:	22c8      	movs	r2, #200	; 0xc8
 80175a6:	2100      	movs	r1, #0
 80175a8:	f00f fb3a 	bl	8026c20 <memset>
 80175ac:	4603      	mov	r3, r0
	conf->can_baud_rate = APPCONF_CAN_BAUD_RATE;

	conf->app_to_use = APPCONF_APP_TO_USE;

	conf->app_ppm_conf.ctrl_type = APPCONF_PPM_CTRL_TYPE;
	conf->app_ppm_conf.pid_max_erpm = APPCONF_PPM_PID_MAX_ERPM;
 80175ae:	4a42      	ldr	r2, [pc, #264]	; (80176b8 <conf_general_get_default_app_configuration+0x118>)
 80175b0:	61c2      	str	r2, [r0, #28]
	conf->app_ppm_conf.hyst = APPCONF_PPM_HYST;
	conf->app_ppm_conf.pulse_start = APPCONF_PPM_PULSE_START;
 80175b2:	f04f 597e 	mov.w	r9, #1065353216	; 0x3f800000
	conf->timeout_msec = APPCONF_TIMEOUT_MSEC;
 80175b6:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
	conf->app_ppm_conf.pulse_end = APPCONF_PPM_PULSE_END;
	conf->app_ppm_conf.pulse_center = APPCONF_PPM_PULSE_CENTER;
 80175ba:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
	conf->app_ppm_conf.pulse_start = APPCONF_PPM_PULSE_START;
 80175be:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
	conf->app_ppm_conf.pulse_end = APPCONF_PPM_PULSE_END;
 80175c2:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
	conf->controller_id = APPCONF_CONTROLLER_ID;
 80175c6:	2200      	movs	r2, #0
	conf->can_baud_rate = APPCONF_CAN_BAUD_RATE;
 80175c8:	2002      	movs	r0, #2
	conf->app_ppm_conf.throttle_exp_mode = APPCONF_PPM_THROTTLE_EXP_MODE;
	conf->app_ppm_conf.ramp_time_pos = APPCONF_PPM_RAMP_TIME_POS;
	conf->app_ppm_conf.ramp_time_neg = APPCONF_PPM_RAMP_TIME_NEG;
	conf->app_ppm_conf.multi_esc = APPCONF_PPM_MULTI_ESC;
	conf->app_ppm_conf.tc = APPCONF_PPM_TC;
	conf->app_ppm_conf.tc_max_diff = APPCONF_PPM_TC_MAX_DIFF;
 80175ca:	4c3c      	ldr	r4, [pc, #240]	; (80176bc <conf_general_get_default_app_configuration+0x11c>)
	conf->app_ppm_conf.hyst = APPCONF_PPM_HYST;
 80175cc:	4f3c      	ldr	r7, [pc, #240]	; (80176c0 <conf_general_get_default_app_configuration+0x120>)
	conf->app_ppm_conf.ramp_time_pos = APPCONF_PPM_RAMP_TIME_POS;
 80175ce:	4d3d      	ldr	r5, [pc, #244]	; (80176c4 <conf_general_get_default_app_configuration+0x124>)

	conf->app_adc_conf.ctrl_type = APPCONF_ADC_CTRL_TYPE;
	conf->app_adc_conf.hyst = APPCONF_ADC_HYST;
	conf->app_adc_conf.voltage_start = APPCONF_ADC_VOLTAGE_START;
 80175d0:	4e3d      	ldr	r6, [pc, #244]	; (80176c8 <conf_general_get_default_app_configuration+0x128>)
	conf->app_ppm_conf.ramp_time_neg = APPCONF_PPM_RAMP_TIME_NEG;
 80175d2:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80176cc <conf_general_get_default_app_configuration+0x12c>
	conf->timeout_msec = APPCONF_TIMEOUT_MSEC;
 80175d6:	f8c3 c004 	str.w	ip, [r3, #4]
	conf->send_can_status_rate_hz = APPCONF_SEND_CAN_STATUS_RATE_HZ;
 80175da:	f44f 7efa 	mov.w	lr, #500	; 0x1f4
	conf->app_to_use = APPCONF_APP_TO_USE;
 80175de:	f04f 0c03 	mov.w	ip, #3
	conf->app_ppm_conf.pulse_center = APPCONF_PPM_PULSE_CENTER;
 80175e2:	62d9      	str	r1, [r3, #44]	; 0x2c
	conf->app_ppm_conf.pulse_end = APPCONF_PPM_PULSE_END;
 80175e4:	f8c3 9028 	str.w	r9, [r3, #40]	; 0x28
	conf->app_ppm_conf.median_filter = APPCONF_PPM_MEDIAN_FILTER;
 80175e8:	2101      	movs	r1, #1
	conf->app_adc_conf.voltage_end = APPCONF_ADC_VOLTAGE_END;
	conf->app_adc_conf.voltage_center = APPCONF_ADC_VOLTAGE_CENTER;
 80175ea:	f8c3 9060 	str.w	r9, [r3, #96]	; 0x60

	conf->app_nrf_conf.speed = APPCONF_NRF_SPEED;
	conf->app_nrf_conf.power = APPCONF_NRF_POWER;
	conf->app_nrf_conf.crc_type = APPCONF_NRF_CRC;
	conf->app_nrf_conf.retry_delay = APPCONF_NRF_RETR_DELAY;
	conf->app_nrf_conf.retries = APPCONF_NRF_RETRIES;
 80175ee:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 80176d0 <conf_general_get_default_app_configuration+0x130>
	conf->app_adc_conf.voltage_end = APPCONF_ADC_VOLTAGE_END;
 80175f2:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 80176d4 <conf_general_get_default_app_configuration+0x134>
 80175f6:	f8c3 905c 	str.w	r9, [r3, #92]	; 0x5c
	conf->app_adc_conf.voltage2_end = APPCONF_ADC_VOLTAGE2_END;
 80175fa:	f8c3 9068 	str.w	r9, [r3, #104]	; 0x68
	conf->controller_id = APPCONF_CONTROLLER_ID;
 80175fe:	701a      	strb	r2, [r3, #0]
	conf->send_can_status = APPCONF_SEND_CAN_STATUS;
 8017600:	731a      	strb	r2, [r3, #12]
	conf->app_ppm_conf.ctrl_type = APPCONF_PPM_CTRL_TYPE;
 8017602:	761a      	strb	r2, [r3, #24]
	conf->app_ppm_conf.multi_esc = APPCONF_PPM_MULTI_ESC;
 8017604:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
	conf->app_ppm_conf.tc = APPCONF_PPM_TC;
 8017608:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
	conf->app_adc_conf.ctrl_type = APPCONF_ADC_CTRL_TYPE;
 801760c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	conf->app_adc_conf.cc_button_inverted = APPCONF_ADC_CC_BUTTON_INVERTED;
 8017610:	f883 206e 	strb.w	r2, [r3, #110]	; 0x6e
	conf->app_adc_conf.rev_button_inverted = APPCONF_ADC_REV_BUTTON_INVERTED;
 8017614:	f883 206f 	strb.w	r2, [r3, #111]	; 0x6f
	conf->app_adc_conf.voltage_inverted = APPCONF_ADC_VOLTAGE_INVERTED;
 8017618:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
	conf->send_can_status_rate_hz = APPCONF_SEND_CAN_STATUS_RATE_HZ;
 801761c:	f8c3 e010 	str.w	lr, [r3, #16]
	conf->can_baud_rate = APPCONF_CAN_BAUD_RATE;
 8017620:	7518      	strb	r0, [r3, #20]
	conf->app_ppm_conf.throttle_exp_mode = APPCONF_PPM_THROTTLE_EXP_MODE;
 8017622:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
	conf->app_to_use = APPCONF_APP_TO_USE;
 8017626:	f883 c015 	strb.w	ip, [r3, #21]
	conf->app_ppm_conf.hyst = APPCONF_PPM_HYST;
 801762a:	621f      	str	r7, [r3, #32]
	conf->app_adc_conf.hyst = APPCONF_ADC_HYST;
 801762c:	655f      	str	r7, [r3, #84]	; 0x54
	conf->app_ppm_conf.median_filter = APPCONF_PPM_MEDIAN_FILTER;
 801762e:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
	conf->app_ppm_conf.safe_start = APPCONF_PPM_SAFE_START;
 8017632:	f883 1031 	strb.w	r1, [r3, #49]	; 0x31
	conf->app_adc_conf.use_filter = APPCONF_ADC_USE_FILTER;
 8017636:	f883 106c 	strb.w	r1, [r3, #108]	; 0x6c
	conf->app_adc_conf.safe_start = APPCONF_ADC_SAFE_START;
 801763a:	f883 106d 	strb.w	r1, [r3, #109]	; 0x6d
	conf->app_ppm_conf.ramp_time_pos = APPCONF_PPM_RAMP_TIME_POS;
 801763e:	641d      	str	r5, [r3, #64]	; 0x40
	conf->app_ppm_conf.ramp_time_neg = APPCONF_PPM_RAMP_TIME_NEG;
 8017640:	f8c3 8044 	str.w	r8, [r3, #68]	; 0x44
	conf->app_ppm_conf.tc_max_diff = APPCONF_PPM_TC_MAX_DIFF;
 8017644:	64dc      	str	r4, [r3, #76]	; 0x4c
	conf->app_adc_conf.voltage_start = APPCONF_ADC_VOLTAGE_START;
 8017646:	659e      	str	r6, [r3, #88]	; 0x58
	conf->app_adc_conf.voltage2_start = APPCONF_ADC_VOLTAGE2_START;
 8017648:	665e      	str	r6, [r3, #100]	; 0x64
	conf->app_uart_baudrate = APPCONF_UART_BAUDRATE;
 801764a:	f44f 39e1 	mov.w	r9, #115200	; 0x1c200
	conf->app_adc_conf.voltage2_inverted = APPCONF_ADC_VOLTAGE2_INVERTED;
 801764e:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
	conf->app_nrf_conf.channel = APPCONF_NRF_CHANNEL;
	conf->app_nrf_conf.address[0] = APPCONF_NRF_ADDR_B0;
	conf->app_nrf_conf.address[1] = APPCONF_NRF_ADDR_B1;
 8017652:	f883 20c4 	strb.w	r2, [r3, #196]	; 0xc4
	conf->app_nrf_conf.retries = APPCONF_NRF_RETRIES;
 8017656:	f8c3 a0c0 	str.w	sl, [r3, #192]	; 0xc0
	conf->app_adc_conf.throttle_exp_mode = APPCONF_ADC_THROTTLE_EXP_MODE;
 801765a:	f883 007c 	strb.w	r0, [r3, #124]	; 0x7c
	conf->app_adc_conf.ramp_time_pos = APPCONF_ADC_RAMP_TIME_POS;
 801765e:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
	conf->app_adc_conf.ramp_time_neg = APPCONF_ADC_RAMP_TIME_NEG;
 8017662:	f8c3 8084 	str.w	r8, [r3, #132]	; 0x84
	conf->app_adc_conf.multi_esc = APPCONF_ADC_MULTI_ESC;
 8017666:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
	conf->app_adc_conf.tc = APPCONF_ADC_TC;
 801766a:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89
	conf->app_adc_conf.tc_max_diff = APPCONF_ADC_TC_MAX_DIFF;
 801766e:	f8c3 408c 	str.w	r4, [r3, #140]	; 0x8c
	conf->app_adc_conf.update_rate_hz = APPCONF_ADC_UPDATE_RATE_HZ;
 8017672:	f8c3 e090 	str.w	lr, [r3, #144]	; 0x90
	conf->app_chuk_conf.ctrl_type = APPCONF_CHUK_CTRL_TYPE;
 8017676:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
	conf->app_chuk_conf.hyst = APPCONF_CHUK_HYST;
 801767a:	f8c3 709c 	str.w	r7, [r3, #156]	; 0x9c
	conf->app_chuk_conf.ramp_time_pos = APPCONF_CHUK_RAMP_TIME_POS;
 801767e:	f8c3 60a0 	str.w	r6, [r3, #160]	; 0xa0
	conf->app_chuk_conf.ramp_time_neg = APPCONF_CHUK_RAMP_TIME_NEG;
 8017682:	f8c3 50a4 	str.w	r5, [r3, #164]	; 0xa4
	conf->app_chuk_conf.stick_erpm_per_s_in_cc = APPCONF_STICK_ERPM_PER_S_IN_CC;
 8017686:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
	conf->app_chuk_conf.throttle_exp_mode = APPCONF_CHUK_THROTTLE_EXP_MODE;
 801768a:	f883 00b4 	strb.w	r0, [r3, #180]	; 0xb4
	conf->app_chuk_conf.multi_esc = APPCONF_CHUK_MULTI_ESC;
 801768e:	f883 20b5 	strb.w	r2, [r3, #181]	; 0xb5
	conf->app_chuk_conf.tc = APPCONF_CHUK_TC;
 8017692:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
	conf->app_chuk_conf.tc_max_diff = APPCONF_CHUK_TC_MAX_DIFF;
 8017696:	f8c3 40b8 	str.w	r4, [r3, #184]	; 0xb8
	conf->app_nrf_conf.speed = APPCONF_NRF_SPEED;
 801769a:	f883 00bc 	strb.w	r0, [r3, #188]	; 0xbc
	conf->app_nrf_conf.power = APPCONF_NRF_POWER;
 801769e:	f883 c0bd 	strb.w	ip, [r3, #189]	; 0xbd
	conf->app_nrf_conf.crc_type = APPCONF_NRF_CRC;
 80176a2:	f883 10be 	strb.w	r1, [r3, #190]	; 0xbe
	conf->app_nrf_conf.retry_delay = APPCONF_NRF_RETR_DELAY;
 80176a6:	f883 20bf 	strb.w	r2, [r3, #191]	; 0xbf
	conf->app_nrf_conf.address[2] = APPCONF_NRF_ADDR_B2;
	conf->app_nrf_conf.send_crc_ack = APPCONF_NRF_SEND_CRC_ACK;
 80176aa:	f883 10c5 	strb.w	r1, [r3, #197]	; 0xc5
	conf->app_uart_baudrate = APPCONF_UART_BAUDRATE;
 80176ae:	f8c3 9094 	str.w	r9, [r3, #148]	; 0x94
}
 80176b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80176b6:	bf00      	nop
 80176b8:	466a6000 	.word	0x466a6000
 80176bc:	453b8000 	.word	0x453b8000
 80176c0:	3e19999a 	.word	0x3e19999a
 80176c4:	3e99999a 	.word	0x3e99999a
 80176c8:	3f666666 	.word	0x3f666666
 80176cc:	3dcccccd 	.word	0x3dcccccd
 80176d0:	c7c64c03 	.word	0xc7c64c03
 80176d4:	40400000 	.word	0x40400000
	...

080176e0 <conf_general_get_default_mc_configuration>:
 * Load the compiled default mc_configuration.
 *
 * @param conf
 * A pointer to store the default configuration to.
 */
void conf_general_get_default_mc_configuration(mc_configuration *conf) {
 80176e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	memset(conf, 0, sizeof(mc_configuration));
 80176e2:	f44f 72ba 	mov.w	r2, #372	; 0x174
 80176e6:	2100      	movs	r1, #0
 80176e8:	f00f fa9a 	bl	8026c20 <memset>
 80176ec:	4603      	mov	r3, r0
	conf->sensor_mode = MCCONF_SENSOR_MODE;

	conf->l_current_max = MCCONF_L_CURRENT_MAX;
	conf->l_current_min = MCCONF_L_CURRENT_MIN;
	conf->l_in_current_max = MCCONF_L_IN_CURRENT_MAX;
	conf->l_in_current_min = MCCONF_L_IN_CURRENT_MIN;
 80176ee:	4d7b      	ldr	r5, [pc, #492]	; (80178dc <conf_general_get_default_mc_configuration+0x1fc>)
	conf->l_abs_current_max = MCCONF_L_MAX_ABS_CURRENT;
 80176f0:	4e7b      	ldr	r6, [pc, #492]	; (80178e0 <conf_general_get_default_mc_configuration+0x200>)
	conf->l_min_erpm = MCCONF_L_RPM_MIN;
	conf->l_max_erpm = MCCONF_L_RPM_MAX;
	conf->l_erpm_start = MCCONF_L_RPM_START;
	conf->l_max_erpm_fbrake = MCCONF_L_CURR_MAX_RPM_FBRAKE;
 80176f2:	497c      	ldr	r1, [pc, #496]	; (80178e4 <conf_general_get_default_mc_configuration+0x204>)
	conf->l_in_current_min = MCCONF_L_IN_CURRENT_MIN;
 80176f4:	611d      	str	r5, [r3, #16]
	conf->l_max_erpm_fbrake_cc = MCCONF_L_CURR_MAX_RPM_FBRAKE_CC;
	conf->l_min_vin = MCCONF_L_MIN_VOLTAGE;
	conf->l_max_vin = MCCONF_L_MAX_VOLTAGE;
 80176f6:	4d7c      	ldr	r5, [pc, #496]	; (80178e8 <conf_general_get_default_mc_configuration+0x208>)
	conf->l_current_min = MCCONF_L_CURRENT_MIN;
 80176f8:	487c      	ldr	r0, [pc, #496]	; (80178ec <conf_general_get_default_mc_configuration+0x20c>)
	conf->l_abs_current_max = MCCONF_L_MAX_ABS_CURRENT;
 80176fa:	615e      	str	r6, [r3, #20]
	conf->l_max_erpm_fbrake = MCCONF_L_CURR_MAX_RPM_FBRAKE;
 80176fc:	6259      	str	r1, [r3, #36]	; 0x24
	conf->l_current_max = MCCONF_L_CURRENT_MAX;
 80176fe:	4e7c      	ldr	r6, [pc, #496]	; (80178f0 <conf_general_get_default_mc_configuration+0x210>)
	conf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;
	conf->l_temp_fet_end = MCCONF_L_LIM_TEMP_FET_END;
	conf->l_temp_motor_start = MCCONF_L_LIM_TEMP_MOTOR_START;
	conf->l_temp_motor_end = MCCONF_L_LIM_TEMP_MOTOR_END;
	conf->l_temp_accel_dec = MCCONF_L_LIM_TEMP_ACCEL_DEC;
	conf->l_min_duty = MCCONF_L_MIN_DUTY;
 8017700:	497c      	ldr	r1, [pc, #496]	; (80178f4 <conf_general_get_default_mc_configuration+0x214>)
	conf->l_max_vin = MCCONF_L_MAX_VOLTAGE;
 8017702:	631d      	str	r5, [r3, #48]	; 0x30
	conf->l_max_duty = MCCONF_L_MAX_DUTY;
	conf->l_watt_max = MCCONF_L_WATT_MAX;
 8017704:	4d7c      	ldr	r5, [pc, #496]	; (80178f8 <conf_general_get_default_mc_configuration+0x218>)
	conf->l_max_erpm = MCCONF_L_RPM_MAX;
 8017706:	4c7d      	ldr	r4, [pc, #500]	; (80178fc <conf_general_get_default_mc_configuration+0x21c>)
	conf->l_erpm_start = MCCONF_L_RPM_START;
 8017708:	4a7d      	ldr	r2, [pc, #500]	; (8017900 <conf_general_get_default_mc_configuration+0x220>)
	conf->l_current_min = MCCONF_L_CURRENT_MIN;
 801770a:	6098      	str	r0, [r3, #8]
	conf->l_min_duty = MCCONF_L_MIN_DUTY;
 801770c:	6599      	str	r1, [r3, #88]	; 0x58
	conf->l_max_erpm_fbrake_cc = MCCONF_L_CURR_MAX_RPM_FBRAKE_CC;
 801770e:	487d      	ldr	r0, [pc, #500]	; (8017904 <conf_general_get_default_mc_configuration+0x224>)
	conf->l_watt_max = MCCONF_L_WATT_MAX;
 8017710:	661d      	str	r5, [r3, #96]	; 0x60
	conf->l_min_vin = MCCONF_L_MIN_VOLTAGE;
 8017712:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
	conf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;
 8017716:	4d7c      	ldr	r5, [pc, #496]	; (8017908 <conf_general_get_default_mc_configuration+0x228>)
	conf->l_current_max = MCCONF_L_CURRENT_MAX;
 8017718:	605e      	str	r6, [r3, #4]
	conf->l_in_current_max = MCCONF_L_IN_CURRENT_MAX;
 801771a:	60de      	str	r6, [r3, #12]
	conf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;
 801771c:	4e7b      	ldr	r6, [pc, #492]	; (801790c <conf_general_get_default_mc_configuration+0x22c>)
	conf->l_max_erpm = MCCONF_L_RPM_MAX;
 801771e:	61dc      	str	r4, [r3, #28]
	conf->l_erpm_start = MCCONF_L_RPM_START;
 8017720:	621a      	str	r2, [r3, #32]
	conf->l_temp_motor_end = MCCONF_L_LIM_TEMP_MOTOR_END;
 8017722:	4c7b      	ldr	r4, [pc, #492]	; (8017910 <conf_general_get_default_mc_configuration+0x230>)
	conf->l_temp_accel_dec = MCCONF_L_LIM_TEMP_ACCEL_DEC;
 8017724:	4a7b      	ldr	r2, [pc, #492]	; (8017914 <conf_general_get_default_mc_configuration+0x234>)
	conf->l_max_erpm_fbrake_cc = MCCONF_L_CURR_MAX_RPM_FBRAKE_CC;
 8017726:	6298      	str	r0, [r3, #40]	; 0x28
	conf->l_min_vin = MCCONF_L_MIN_VOLTAGE;
 8017728:	62d9      	str	r1, [r3, #44]	; 0x2c
	conf->l_max_duty = MCCONF_L_MAX_DUTY;
 801772a:	487b      	ldr	r0, [pc, #492]	; (8017918 <conf_general_get_default_mc_configuration+0x238>)
	conf->l_battery_cut_end = MCCONF_L_BATTERY_CUT_END;
 801772c:	6399      	str	r1, [r3, #56]	; 0x38
	conf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;
 801772e:	641d      	str	r5, [r3, #64]	; 0x40
	conf->l_watt_min = MCCONF_L_WATT_MIN;
 8017730:	496f      	ldr	r1, [pc, #444]	; (80178f0 <conf_general_get_default_mc_configuration+0x210>)
	conf->l_temp_fet_end = MCCONF_L_LIM_TEMP_FET_END;
 8017732:	649d      	str	r5, [r3, #72]	; 0x48
	conf->l_temp_fet_start = MCCONF_L_LIM_TEMP_FET_START;
 8017734:	645e      	str	r6, [r3, #68]	; 0x44

	conf->lo_current_max = conf->l_current_max;
 8017736:	4d6d      	ldr	r5, [pc, #436]	; (80178ec <conf_general_get_default_mc_configuration+0x20c>)
	conf->l_temp_motor_start = MCCONF_L_LIM_TEMP_MOTOR_START;
 8017738:	64de      	str	r6, [r3, #76]	; 0x4c
	conf->lo_current_min = conf->l_current_min;
	conf->lo_in_current_max = conf->l_in_current_max;
 801773a:	4e68      	ldr	r6, [pc, #416]	; (80178dc <conf_general_get_default_mc_configuration+0x1fc>)
	conf->l_min_erpm = MCCONF_L_RPM_MIN;
 801773c:	4f77      	ldr	r7, [pc, #476]	; (801791c <conf_general_get_default_mc_configuration+0x23c>)
	conf->l_temp_motor_end = MCCONF_L_LIM_TEMP_MOTOR_END;
 801773e:	651c      	str	r4, [r3, #80]	; 0x50
	conf->l_temp_accel_dec = MCCONF_L_LIM_TEMP_ACCEL_DEC;
 8017740:	655a      	str	r2, [r3, #84]	; 0x54
	conf->pwm_mode = MCCONF_PWM_MODE;
 8017742:	2401      	movs	r4, #1
	conf->comm_mode = MCCONF_COMM_MODE;
 8017744:	2200      	movs	r2, #0
	conf->l_max_duty = MCCONF_L_MAX_DUTY;
 8017746:	65d8      	str	r0, [r3, #92]	; 0x5c
	conf->l_battery_cut_start = MCCONF_L_BATTERY_CUT_START;
 8017748:	4875      	ldr	r0, [pc, #468]	; (8017920 <conf_general_get_default_mc_configuration+0x240>)
	conf->l_min_erpm = MCCONF_L_RPM_MIN;
 801774a:	619f      	str	r7, [r3, #24]
	conf->lo_current_max = conf->l_current_max;
 801774c:	e9c3 511a 	strd	r5, r1, [r3, #104]	; 0x68
	conf->pwm_mode = MCCONF_PWM_MODE;
 8017750:	701c      	strb	r4, [r3, #0]
	conf->l_slow_abs_current = MCCONF_L_SLOW_ABS_OVERCURRENT;
 8017752:	f883 403c 	strb.w	r4, [r3, #60]	; 0x3c
	conf->comm_mode = MCCONF_COMM_MODE;
 8017756:	705a      	strb	r2, [r3, #1]
	conf->motor_type = MCCONF_DEFAULT_MOTOR_TYPE;
 8017758:	709a      	strb	r2, [r3, #2]
	conf->sensor_mode = MCCONF_SENSOR_MODE;
 801775a:	70da      	strb	r2, [r3, #3]

	conf->foc_current_kp = MCCONF_FOC_CURRENT_KP;
	conf->foc_current_ki = MCCONF_FOC_CURRENT_KI;
	conf->foc_f_sw = MCCONF_FOC_F_SW;
	conf->foc_dt_us = MCCONF_FOC_DT_US;
	conf->foc_encoder_inverted = MCCONF_FOC_ENCODER_INVERTED;
 801775c:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	conf->l_battery_cut_start = MCCONF_L_BATTERY_CUT_START;
 8017760:	6358      	str	r0, [r3, #52]	; 0x34
	conf->l_watt_min = MCCONF_L_WATT_MIN;
 8017762:	6659      	str	r1, [r3, #100]	; 0x64
	conf->lo_in_current_min = conf->l_in_current_min;
 8017764:	e9c3 611c 	strd	r6, r1, [r3, #112]	; 0x70
	conf->foc_motor_l = MCCONF_FOC_MOTOR_L;
	conf->foc_motor_r = MCCONF_FOC_MOTOR_R;
	conf->foc_motor_flux_linkage = MCCONF_FOC_MOTOR_FLUX_LINKAGE;
	conf->foc_observer_gain = MCCONF_FOC_OBSERVER_GAIN;
	conf->foc_observer_gain_slow = MCCONF_FOC_OBSERVER_GAIN_SLOW;
	conf->foc_duty_dowmramp_kp = MCCONF_FOC_DUTY_DOWNRAMP_KP;
 8017768:	f8c3 00dc 	str.w	r0, [r3, #220]	; 0xdc
	conf->sl_min_erpm = MCCONF_SL_MIN_RPM;
 801776c:	4e6d      	ldr	r6, [pc, #436]	; (8017924 <conf_general_get_default_mc_configuration+0x244>)
 801776e:	486e      	ldr	r0, [pc, #440]	; (8017928 <conf_general_get_default_mc_configuration+0x248>)
	conf->sl_phase_advance_at_br = MCCONF_SL_PHASE_ADVANCE_AT_BR;
 8017770:	f8df e18c 	ldr.w	lr, [pc, #396]	; 8017900 <conf_general_get_default_mc_configuration+0x220>
	conf->foc_motor_r = MCCONF_FOC_MOTOR_R;
 8017774:	496d      	ldr	r1, [pc, #436]	; (801792c <conf_general_get_default_mc_configuration+0x24c>)
	conf->foc_pll_kp = MCCONF_FOC_PLL_KP;
 8017776:	4f6e      	ldr	r7, [pc, #440]	; (8017930 <conf_general_get_default_mc_configuration+0x250>)
	conf->lo_current_motor_max_now = conf->l_current_max;
 8017778:	679d      	str	r5, [r3, #120]	; 0x78
	conf->sl_min_erpm = MCCONF_SL_MIN_RPM;
 801777a:	e9c3 601f 	strd	r6, r0, [r3, #124]	; 0x7c
	conf->sl_min_erpm_cycle_int_limit = MCCONF_SL_MIN_ERPM_CYCLE_INT_LIMIT;
 801777e:	4868      	ldr	r0, [pc, #416]	; (8017920 <conf_general_get_default_mc_configuration+0x240>)
 8017780:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
	conf->sl_max_fullbreak_current_dir_change = MCCONF_SL_MAX_FB_CURR_DIR_CHANGE;
 8017784:	f100 70ac 	add.w	r0, r0, #22544384	; 0x1580000
 8017788:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	conf->sl_phase_advance_at_br = MCCONF_SL_PHASE_ADVANCE_AT_BR;
 801778c:	4869      	ldr	r0, [pc, #420]	; (8017934 <conf_general_get_default_mc_configuration+0x254>)
	conf->sl_bemf_coupling_k = MCCONF_SL_BEMF_COUPLING_K;
 801778e:	4e6a      	ldr	r6, [pc, #424]	; (8017938 <conf_general_get_default_mc_configuration+0x258>)
	conf->foc_motor_flux_linkage = MCCONF_FOC_MOTOR_FLUX_LINKAGE;
 8017790:	4d6a      	ldr	r5, [pc, #424]	; (801793c <conf_general_get_default_mc_configuration+0x25c>)
	conf->foc_motor_r = MCCONF_FOC_MOTOR_R;
 8017792:	f8c3 10c4 	str.w	r1, [r3, #196]	; 0xc4
	conf->sl_phase_advance_at_br = MCCONF_SL_PHASE_ADVANCE_AT_BR;
 8017796:	e9c3 e023 	strd	lr, r0, [r3, #140]	; 0x8c
	conf->sl_bemf_coupling_k = MCCONF_SL_BEMF_COUPLING_K;
 801779a:	4869      	ldr	r0, [pc, #420]	; (8017940 <conf_general_get_default_mc_configuration+0x260>)
	conf->hall_table[7] = MCCONF_HALL_TAB_7;
 801779c:	f8df e1fc 	ldr.w	lr, [pc, #508]	; 801799c <conf_general_get_default_mc_configuration+0x2bc>
	conf->foc_duty_dowmramp_ki = MCCONF_FOC_DUTY_DOWNRAMP_KI;
	conf->foc_openloop_rpm = MCCONF_FOC_OPENLOOP_RPM;
 80177a0:	4968      	ldr	r1, [pc, #416]	; (8017944 <conf_general_get_default_mc_configuration+0x264>)
	conf->foc_motor_l = MCCONF_FOC_MOTOR_L;
 80177a2:	f8df c1fc 	ldr.w	ip, [pc, #508]	; 80179a0 <conf_general_get_default_mc_configuration+0x2c0>
	conf->foc_pll_kp = MCCONF_FOC_PLL_KP;
 80177a6:	f8c3 70d4 	str.w	r7, [r3, #212]	; 0xd4
	conf->sl_bemf_coupling_k = MCCONF_SL_BEMF_COUPLING_K;
 80177aa:	e9c3 6025 	strd	r6, r0, [r3, #148]	; 0x94
	conf->hall_table[7] = MCCONF_HALL_TAB_7;
 80177ae:	4860      	ldr	r0, [pc, #384]	; (8017930 <conf_general_get_default_mc_configuration+0x250>)
	conf->foc_current_kp = MCCONF_FOC_CURRENT_KP;
 80177b0:	4e65      	ldr	r6, [pc, #404]	; (8017948 <conf_general_get_default_mc_configuration+0x268>)
	conf->foc_observer_gain_slow = MCCONF_FOC_OBSERVER_GAIN_SLOW;
 80177b2:	4f66      	ldr	r7, [pc, #408]	; (801794c <conf_general_get_default_mc_configuration+0x26c>)
	conf->foc_motor_flux_linkage = MCCONF_FOC_MOTOR_FLUX_LINKAGE;
 80177b4:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
	conf->hall_table[7] = MCCONF_HALL_TAB_7;
 80177b8:	e9c3 e027 	strd	lr, r0, [r3, #156]	; 0x9c
	conf->foc_current_kp = MCCONF_FOC_CURRENT_KP;
 80177bc:	4864      	ldr	r0, [pc, #400]	; (8017950 <conf_general_get_default_mc_configuration+0x270>)
	conf->foc_pll_ki = MCCONF_FOC_PLL_KI;
 80177be:	4d65      	ldr	r5, [pc, #404]	; (8017954 <conf_general_get_default_mc_configuration+0x274>)
	conf->foc_openloop_rpm = MCCONF_FOC_OPENLOOP_RPM;
 80177c0:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
	conf->foc_current_kp = MCCONF_FOC_CURRENT_KP;
 80177c4:	e9c3 6029 	strd	r6, r0, [r3, #164]	; 0xa4
	conf->foc_current_ki = MCCONF_FOC_CURRENT_KI;
 80177c8:	4863      	ldr	r0, [pc, #396]	; (8017958 <conf_general_get_default_mc_configuration+0x278>)
 80177ca:	f8c3 00ac 	str.w	r0, [r3, #172]	; 0xac
	conf->foc_f_sw = MCCONF_FOC_F_SW;
 80177ce:	f100 4077 	add.w	r0, r0, #4143972352	; 0xf7000000
 80177d2:	f500 20f2 	add.w	r0, r0, #495616	; 0x79000
 80177d6:	f200 700a 	addw	r0, r0, #1802	; 0x70a
 80177da:	f8c3 00b0 	str.w	r0, [r3, #176]	; 0xb0
	conf->foc_dt_us = MCCONF_FOC_DT_US;
 80177de:	485f      	ldr	r0, [pc, #380]	; (801795c <conf_general_get_default_mc_configuration+0x27c>)
 80177e0:	f8c3 00b4 	str.w	r0, [r3, #180]	; 0xb4
	conf->foc_encoder_ratio = MCCONF_FOC_ENCODER_RATIO;
 80177e4:	485e      	ldr	r0, [pc, #376]	; (8017960 <conf_general_get_default_mc_configuration+0x280>)
 80177e6:	f8c3 00bc 	str.w	r0, [r3, #188]	; 0xbc
	conf->foc_duty_dowmramp_ki = MCCONF_FOC_DUTY_DOWNRAMP_KI;
 80177ea:	4e5e      	ldr	r6, [pc, #376]	; (8017964 <conf_general_get_default_mc_configuration+0x284>)
	conf->foc_observer_gain = MCCONF_FOC_OBSERVER_GAIN;
 80177ec:	485e      	ldr	r0, [pc, #376]	; (8017968 <conf_general_get_default_mc_configuration+0x288>)
 80177ee:	f8c3 00cc 	str.w	r0, [r3, #204]	; 0xcc
	conf->foc_sl_openloop_hyst = MCCONF_FOC_SL_OPENLOOP_HYST;
	conf->foc_sl_openloop_time = MCCONF_FOC_SL_OPENLOOP_TIME;
	conf->foc_sl_d_current_duty = MCCONF_FOC_SL_D_CURRENT_DUTY;
	conf->foc_sl_d_current_factor = MCCONF_FOC_SL_D_CURRENT_FACTOR;
	conf->foc_hall_table[0] = MCCONF_FOC_HALL_TAB_0;
 80177f2:	21ff      	movs	r1, #255	; 0xff
	conf->foc_sl_openloop_hyst = MCCONF_FOC_SL_OPENLOOP_HYST;
 80177f4:	485d      	ldr	r0, [pc, #372]	; (801796c <conf_general_get_default_mc_configuration+0x28c>)
	conf->foc_duty_dowmramp_ki = MCCONF_FOC_DUTY_DOWNRAMP_KI;
 80177f6:	f8c3 60e0 	str.w	r6, [r3, #224]	; 0xe0
	conf->foc_temp_comp = MCCONF_FOC_TEMP_COMP;
	conf->foc_temp_comp_base_temp = MCCONF_FOC_TEMP_COMP_BASE_TEMP;

	conf->s_pid_kp = MCCONF_S_PID_KP;
	conf->s_pid_ki = MCCONF_S_PID_KI;
	conf->s_pid_kd = MCCONF_S_PID_KD;
 80177fa:	4e5d      	ldr	r6, [pc, #372]	; (8017970 <conf_general_get_default_mc_configuration+0x290>)
	conf->foc_sensor_mode = MCCONF_FOC_SENSOR_MODE;
 80177fc:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
	conf->foc_motor_l = MCCONF_FOC_MOTOR_L;
 8017800:	f8c3 c0c0 	str.w	ip, [r3, #192]	; 0xc0
	conf->foc_observer_gain_slow = MCCONF_FOC_OBSERVER_GAIN_SLOW;
 8017804:	f8c3 70d0 	str.w	r7, [r3, #208]	; 0xd0
	conf->foc_sl_openloop_hyst = MCCONF_FOC_SL_OPENLOOP_HYST;
 8017808:	f8c3 00e8 	str.w	r0, [r3, #232]	; 0xe8
	conf->foc_sl_openloop_time = MCCONF_FOC_SL_OPENLOOP_TIME;
 801780c:	f8c3 00ec 	str.w	r0, [r3, #236]	; 0xec
	conf->foc_hall_table[0] = MCCONF_FOC_HALL_TAB_0;
 8017810:	f883 10f9 	strb.w	r1, [r3, #249]	; 0xf9
	conf->foc_pll_ki = MCCONF_FOC_PLL_KI;
 8017814:	f8c3 50d8 	str.w	r5, [r3, #216]	; 0xd8
	conf->foc_hall_table[1] = MCCONF_FOC_HALL_TAB_1;
 8017818:	f883 10fa 	strb.w	r1, [r3, #250]	; 0xfa
	conf->s_pid_kd = MCCONF_S_PID_KD;
 801781c:	f8c3 6120 	str.w	r6, [r3, #288]	; 0x120
	conf->p_pid_ang_div = MCCONF_P_PID_ANG_DIV;

	conf->cc_startup_boost_duty = MCCONF_CC_STARTUP_BOOST_DUTY;
	conf->cc_min_current = MCCONF_CC_MIN_CURRENT;
	conf->cc_gain = MCCONF_CC_GAIN;
	conf->cc_ramp_step_max = MCCONF_CC_RAMP_STEP;
 8017820:	4e54      	ldr	r6, [pc, #336]	; (8017974 <conf_general_get_default_mc_configuration+0x294>)
	conf->s_pid_min_erpm = MCCONF_S_PID_MIN_RPM;
 8017822:	4f55      	ldr	r7, [pc, #340]	; (8017978 <conf_general_get_default_mc_configuration+0x298>)
	conf->foc_sample_v0_v7 = MCCONF_FOC_SAMPLE_V0_V7;
 8017824:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	conf->foc_sample_high_current = MCCONF_FOC_SAMPLE_HIGH_CURRENT;
 8017828:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	conf->foc_temp_comp = MCCONF_FOC_TEMP_COMP;
 801782c:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110

	conf->m_fault_stop_time_ms = MCCONF_M_FAULT_STOP_TIME;
	conf->m_duty_ramp_step = MCCONF_M_RAMP_STEP;
	conf->m_current_backoff_gain = MCCONF_M_CURRENT_BACKOFF_GAIN;
	conf->m_encoder_counts = MCCONF_M_ENCODER_COUNTS;
	conf->m_sensor_port_mode = MCCONF_M_SENSOR_PORT_MODE;
 8017830:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c
	conf->m_invert_direction = MCCONF_M_INVERT_DIRECTION;
 8017834:	f883 215d 	strb.w	r2, [r3, #349]	; 0x15d
	conf->m_drv8301_oc_mode = MCCONF_M_DRV8301_OC_MODE;
 8017838:	f883 215e 	strb.w	r2, [r3, #350]	; 0x15e
	conf->cc_ramp_step_max = MCCONF_CC_RAMP_STEP;
 801783c:	f8c3 6148 	str.w	r6, [r3, #328]	; 0x148
	conf->foc_temp_comp_base_temp = MCCONF_FOC_TEMP_COMP_BASE_TEMP;
 8017840:	4a4e      	ldr	r2, [pc, #312]	; (801797c <conf_general_get_default_mc_configuration+0x29c>)
	conf->foc_hall_table[2] = MCCONF_FOC_HALL_TAB_2;
 8017842:	f883 10fb 	strb.w	r1, [r3, #251]	; 0xfb
	conf->m_fault_stop_time_ms = MCCONF_M_FAULT_STOP_TIME;
 8017846:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
	conf->foc_hall_table[3] = MCCONF_FOC_HALL_TAB_3;
 801784a:	f883 10fc 	strb.w	r1, [r3, #252]	; 0xfc
	conf->foc_hall_table[4] = MCCONF_FOC_HALL_TAB_4;
 801784e:	f883 10fd 	strb.w	r1, [r3, #253]	; 0xfd
	conf->foc_hall_table[5] = MCCONF_FOC_HALL_TAB_5;
 8017852:	f883 10fe 	strb.w	r1, [r3, #254]	; 0xfe
	conf->foc_hall_table[6] = MCCONF_FOC_HALL_TAB_6;
 8017856:	f883 10ff 	strb.w	r1, [r3, #255]	; 0xff
	conf->foc_hall_table[7] = MCCONF_FOC_HALL_TAB_7;
 801785a:	f883 1100 	strb.w	r1, [r3, #256]	; 0x100
	conf->s_pid_allow_braking = MCCONF_S_PID_ALLOW_BRAKING;
 801785e:	f883 4128 	strb.w	r4, [r3, #296]	; 0x128
	conf->cc_min_current = MCCONF_CC_MIN_CURRENT;
 8017862:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
	conf->p_pid_kp = MCCONF_P_PID_KP;
 8017866:	4c38      	ldr	r4, [pc, #224]	; (8017948 <conf_general_get_default_mc_configuration+0x268>)
	conf->cc_startup_boost_duty = MCCONF_CC_STARTUP_BOOST_DUTY;
 8017868:	4845      	ldr	r0, [pc, #276]	; (8017980 <conf_general_get_default_mc_configuration+0x2a0>)
	conf->foc_temp_comp_base_temp = MCCONF_FOC_TEMP_COMP_BASE_TEMP;
 801786a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	conf->cc_gain = MCCONF_CC_GAIN;
 801786e:	4945      	ldr	r1, [pc, #276]	; (8017984 <conf_general_get_default_mc_configuration+0x2a4>)
	conf->s_pid_min_erpm = MCCONF_S_PID_MIN_RPM;
 8017870:	f8c3 7124 	str.w	r7, [r3, #292]	; 0x124
	conf->p_pid_ang_div = MCCONF_P_PID_ANG_DIV;
 8017874:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
	conf->m_duty_ramp_step = MCCONF_M_RAMP_STEP;
 8017878:	4f43      	ldr	r7, [pc, #268]	; (8017988 <conf_general_get_default_mc_configuration+0x2a8>)
	conf->m_fault_stop_time_ms = MCCONF_M_FAULT_STOP_TIME;
 801787a:	f8c3 614c 	str.w	r6, [r3, #332]	; 0x14c
	conf->m_current_backoff_gain = MCCONF_M_CURRENT_BACKOFF_GAIN;
 801787e:	f04f 567c 	mov.w	r6, #1056964608	; 0x3f000000
	conf->p_pid_kp = MCCONF_P_PID_KP;
 8017882:	f8c3 412c 	str.w	r4, [r3, #300]	; 0x12c
	conf->p_pid_ang_div = MCCONF_P_PID_ANG_DIV;
 8017886:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
	conf->cc_startup_boost_duty = MCCONF_CC_STARTUP_BOOST_DUTY;
 801788a:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c
	conf->s_pid_kp = MCCONF_S_PID_KP;
 801788e:	4a3f      	ldr	r2, [pc, #252]	; (801798c <conf_general_get_default_mc_configuration+0x2ac>)
	conf->cc_gain = MCCONF_CC_GAIN;
 8017890:	f8c3 1144 	str.w	r1, [r3, #324]	; 0x144
	conf->m_duty_ramp_step = MCCONF_M_RAMP_STEP;
 8017894:	f8c3 7150 	str.w	r7, [r3, #336]	; 0x150
	conf->m_current_backoff_gain = MCCONF_M_CURRENT_BACKOFF_GAIN;
 8017898:	f8c3 6154 	str.w	r6, [r3, #340]	; 0x154
	conf->foc_sl_erpm = MCCONF_FOC_SL_ERPM;
 801789c:	f8df e104 	ldr.w	lr, [pc, #260]	; 80179a4 <conf_general_get_default_mc_configuration+0x2c4>
	conf->p_pid_kd = MCCONF_P_PID_KD;
 80178a0:	f8df c104 	ldr.w	ip, [pc, #260]	; 80179a8 <conf_general_get_default_mc_configuration+0x2c8>
	conf->m_drv8301_oc_adj = MCCONF_M_DRV8301_OC_ADJ;
	conf->m_bldc_f_sw_min = MCCONF_M_BLDC_F_SW_MIN;
 80178a4:	4c3a      	ldr	r4, [pc, #232]	; (8017990 <conf_general_get_default_mc_configuration+0x2b0>)
	conf->m_bldc_f_sw_max = MCCONF_M_BLDC_F_SW_MAX;
	conf->m_dc_f_sw = MCCONF_M_DC_F_SW;
 80178a6:	483b      	ldr	r0, [pc, #236]	; (8017994 <conf_general_get_default_mc_configuration+0x2b4>)
	conf->m_ntc_motor_beta = MCCONF_M_NTC_MOTOR_BETA;
 80178a8:	493b      	ldr	r1, [pc, #236]	; (8017998 <conf_general_get_default_mc_configuration+0x2b8>)
	conf->foc_sl_erpm = MCCONF_FOC_SL_ERPM;
 80178aa:	f8c3 e104 	str.w	lr, [r3, #260]	; 0x104
	conf->m_encoder_counts = MCCONF_M_ENCODER_COUNTS;
 80178ae:	f44f 5700 	mov.w	r7, #8192	; 0x2000
	conf->m_drv8301_oc_adj = MCCONF_M_DRV8301_OC_ADJ;
 80178b2:	2610      	movs	r6, #16
	conf->p_pid_kd = MCCONF_P_PID_KD;
 80178b4:	f8c3 c134 	str.w	ip, [r3, #308]	; 0x134
	conf->m_encoder_counts = MCCONF_M_ENCODER_COUNTS;
 80178b8:	f8c3 7158 	str.w	r7, [r3, #344]	; 0x158
	conf->m_drv8301_oc_adj = MCCONF_M_DRV8301_OC_ADJ;
 80178bc:	f8c3 6160 	str.w	r6, [r3, #352]	; 0x160
	conf->m_bldc_f_sw_min = MCCONF_M_BLDC_F_SW_MIN;
 80178c0:	f8c3 4164 	str.w	r4, [r3, #356]	; 0x164
	conf->s_pid_kp = MCCONF_S_PID_KP;
 80178c4:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	conf->s_pid_ki = MCCONF_S_PID_KI;
 80178c8:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
	conf->m_bldc_f_sw_max = MCCONF_M_BLDC_F_SW_MAX;
 80178cc:	f8c3 5168 	str.w	r5, [r3, #360]	; 0x168
	conf->m_dc_f_sw = MCCONF_M_DC_F_SW;
 80178d0:	f8c3 016c 	str.w	r0, [r3, #364]	; 0x16c
	conf->m_ntc_motor_beta = MCCONF_M_NTC_MOTOR_BETA;
 80178d4:	f8c3 1170 	str.w	r1, [r3, #368]	; 0x170
}
 80178d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80178da:	bf00      	nop
 80178dc:	c2200000 	.word	0xc2200000
 80178e0:	43020000 	.word	0x43020000
 80178e4:	43960000 	.word	0x43960000
 80178e8:	42640000 	.word	0x42640000
 80178ec:	c2700000 	.word	0xc2700000
 80178f0:	42700000 	.word	0x42700000
 80178f4:	3f733333 	.word	0x3f733333
 80178f8:	c66a6000 	.word	0xc66a6000
 80178fc:	47c35000 	.word	0x47c35000
 8017900:	3f4ccccd 	.word	0x3f4ccccd
 8017904:	44bb8000 	.word	0x44bb8000
 8017908:	42aa0000 	.word	0x42aa0000
 801790c:	42c80000 	.word	0x42c80000
 8017910:	3e19999a 	.word	0x3e19999a
 8017914:	3ba3d70a 	.word	0x3ba3d70a
 8017918:	466a6000 	.word	0x466a6000
 801791c:	c7c35000 	.word	0xc7c35000
 8017920:	41200000 	.word	0x41200000
 8017924:	43160000 	.word	0x43160000
 8017928:	44898000 	.word	0x44898000
 801792c:	3c75c28f 	.word	0x3c75c28f
 8017930:	44fa0000 	.word	0x44fa0000
 8017934:	479c4000 	.word	0x479c4000
 8017938:	44160000 	.word	0x44160000
 801793c:	3b20902e 	.word	0x3b20902e
 8017940:	020301ff 	.word	0x020301ff
 8017944:	43c80000 	.word	0x43c80000
 8017948:	3cf5c28f 	.word	0x3cf5c28f
 801794c:	3e99999a 	.word	0x3e99999a
 8017950:	42480000 	.word	0x42480000
 8017954:	471c4000 	.word	0x471c4000
 8017958:	469c4000 	.word	0x469c4000
 801795c:	43340000 	.word	0x43340000
 8017960:	40e00000 	.word	0x40e00000
 8017964:	43480000 	.word	0x43480000
 8017968:	4caba950 	.word	0x4caba950
 801796c:	3dcccccd 	.word	0x3dcccccd
 8017970:	38d1b717 	.word	0x38d1b717
 8017974:	3d23d70a 	.word	0x3d23d70a
 8017978:	44610000 	.word	0x44610000
 801797c:	41c80000 	.word	0x41c80000
 8017980:	3c23d70a 	.word	0x3c23d70a
 8017984:	3b96bb99 	.word	0x3b96bb99
 8017988:	3ca3d70a 	.word	0x3ca3d70a
 801798c:	3b83126f 	.word	0x3b83126f
 8017990:	453b8000 	.word	0x453b8000
 8017994:	4708b800 	.word	0x4708b800
 8017998:	45534000 	.word	0x45534000
 801799c:	ff040605 	.word	0xff040605
 80179a0:	36eae18b 	.word	0x36eae18b
 80179a4:	451c4000 	.word	0x451c4000
 80179a8:	39d1b717 	.word	0x39d1b717
 80179ac:	00000000 	.word	0x00000000

080179b0 <conf_general_read_app_configuration>:
 * Read app_configuration from EEPROM. If this fails, default values will be used.
 *
 * @param conf
 * A pointer to a app_configuration struct to write the read configuration to.
 */
void conf_general_read_app_configuration(app_configuration *conf) {
 80179b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80179b2:	4607      	mov	r7, r0
 80179b4:	b083      	sub	sp, #12
 80179b6:	1c45      	adds	r5, r0, #1
 80179b8:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
	bool is_ok = true;
	uint8_t *conf_addr = (uint8_t*)conf;
	uint16_t var;

	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
 80179bc:	f640 0634 	movw	r6, #2100	; 0x834
 80179c0:	e009      	b.n	80179d6 <conf_general_read_app_configuration+0x26>
		if (EE_ReadVariable(EEPROM_BASE_APPCONF + i, &var) == 0) {
			conf_addr[2 * i] = (var >> 8) & 0xFF;
 80179c2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
 80179c6:	42b4      	cmp	r4, r6
			conf_addr[2 * i] = (var >> 8) & 0xFF;
 80179c8:	ea4f 2213 	mov.w	r2, r3, lsr #8
 80179cc:	f805 2c01 	strb.w	r2, [r5, #-1]
			conf_addr[2 * i + 1] = var & 0xFF;
 80179d0:	f805 3b02 	strb.w	r3, [r5], #2
	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
 80179d4:	d00b      	beq.n	80179ee <conf_general_read_app_configuration+0x3e>
		if (EE_ReadVariable(EEPROM_BASE_APPCONF + i, &var) == 0) {
 80179d6:	4620      	mov	r0, r4
 80179d8:	f10d 0106 	add.w	r1, sp, #6
 80179dc:	f000 fc40 	bl	8018260 <EE_ReadVariable>
 80179e0:	3401      	adds	r4, #1
 80179e2:	b2a4      	uxth	r4, r4
 80179e4:	2800      	cmp	r0, #0
 80179e6:	d0ec      	beq.n	80179c2 <conf_general_read_app_configuration+0x12>
		}
	}

	// Set the default configuration
	if (!is_ok) {
		conf_general_get_default_app_configuration(conf);
 80179e8:	4638      	mov	r0, r7
 80179ea:	f7ff fdd9 	bl	80175a0 <conf_general_get_default_app_configuration>
	}
}
 80179ee:	b003      	add	sp, #12
 80179f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80179f2:	bf00      	nop
	...

08017a00 <conf_general_store_app_configuration>:
 * Write app_configuration to EEPROM.
 *
 * @param conf
 * A pointer to the configuration that should be stored.
 */
bool conf_general_store_app_configuration(app_configuration *conf) {
 8017a00:	b570      	push	{r4, r5, r6, lr}
 8017a02:	4605      	mov	r5, r0
	mc_interface_unlock();
 8017a04:	f003 fd1c 	bl	801b440 <mc_interface_unlock>
	mc_interface_release_motor();
 8017a08:	f004 fcb2 	bl	801c370 <mc_interface_release_motor>

	utils_sys_lock_cnt();
 8017a0c:	f7fe fb48 	bl	80160a0 <utils_sys_lock_cnt>
	mc_interface_lock();
 8017a10:	f003 fd0e 	bl	801b430 <mc_interface_lock>

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, DISABLE);
 8017a14:	2100      	movs	r1, #0
 8017a16:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8017a1a:	f00c fc09 	bl	8024230 <RCC_APB1PeriphClockCmd>

	bool is_ok = true;
	uint8_t *conf_addr = (uint8_t*)conf;
	uint16_t var;

	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 8017a1e:	20f2      	movs	r0, #242	; 0xf2
 8017a20:	f00c fb36 	bl	8024090 <FLASH_ClearFlag>
 8017a24:	3501      	adds	r5, #1
 8017a26:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
			FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);

	for (unsigned int i = 0;i < (sizeof(app_configuration) / 2);i++) {
 8017a2a:	f640 0634 	movw	r6, #2100	; 0x834
 8017a2e:	e001      	b.n	8017a34 <conf_general_store_app_configuration+0x34>
 8017a30:	42b4      	cmp	r4, r6
 8017a32:	d01d      	beq.n	8017a70 <conf_general_store_app_configuration+0x70>
		var = (conf_addr[2 * i] << 8) & 0xFF00;
 8017a34:	f815 1c01 	ldrb.w	r1, [r5, #-1]
		var |= conf_addr[2 * i + 1] & 0xFF;
 8017a38:	782b      	ldrb	r3, [r5, #0]

		if (EE_WriteVariable(EEPROM_BASE_APPCONF + i, var) != FLASH_COMPLETE) {
 8017a3a:	4620      	mov	r0, r4
 8017a3c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8017a40:	f000 fce6 	bl	8018410 <EE_WriteVariable>
 8017a44:	3401      	adds	r4, #1
 8017a46:	2809      	cmp	r0, #9
 8017a48:	b2a4      	uxth	r4, r4
 8017a4a:	f105 0502 	add.w	r5, r5, #2
 8017a4e:	d0ef      	beq.n	8017a30 <conf_general_store_app_configuration+0x30>
			is_ok = false;
 8017a50:	2400      	movs	r4, #0
			break;
		}
	}

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 8017a52:	2101      	movs	r1, #1
 8017a54:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8017a58:	f00c fbea 	bl	8024230 <RCC_APB1PeriphClockCmd>

	chThdSleepMilliseconds(100);
 8017a5c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8017a60:	f7f5 ffbe 	bl	800d9e0 <chThdSleep>
	mc_interface_unlock();
 8017a64:	f003 fcec 	bl	801b440 <mc_interface_unlock>
	utils_sys_unlock_cnt();
 8017a68:	f7fe fb2a 	bl	80160c0 <utils_sys_unlock_cnt>

	return is_ok;
}
 8017a6c:	4620      	mov	r0, r4
 8017a6e:	bd70      	pop	{r4, r5, r6, pc}
	bool is_ok = true;
 8017a70:	2401      	movs	r4, #1
 8017a72:	e7ee      	b.n	8017a52 <conf_general_store_app_configuration+0x52>
	...

08017a80 <conf_general_read_mc_configuration>:
 * Read mc_configuration from EEPROM. If this fails, default values will be used.
 *
 * @param conf
 * A pointer to a mc_configuration struct to write the read configuration to.
 */
void conf_general_read_mc_configuration(mc_configuration *conf) {
 8017a80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017a82:	4607      	mov	r7, r0
 8017a84:	b083      	sub	sp, #12
 8017a86:	1c45      	adds	r5, r0, #1
 8017a88:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
	bool is_ok = true;
	uint8_t *conf_addr = (uint8_t*)conf;
	uint16_t var;

	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
 8017a8c:	f240 46a2 	movw	r6, #1186	; 0x4a2
 8017a90:	e009      	b.n	8017aa6 <conf_general_read_mc_configuration+0x26>
		if (EE_ReadVariable(EEPROM_BASE_MCCONF + i, &var) == 0) {
			conf_addr[2 * i] = (var >> 8) & 0xFF;
 8017a92:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
 8017a96:	42b4      	cmp	r4, r6
			conf_addr[2 * i] = (var >> 8) & 0xFF;
 8017a98:	ea4f 2213 	mov.w	r2, r3, lsr #8
 8017a9c:	f805 2c01 	strb.w	r2, [r5, #-1]
			conf_addr[2 * i + 1] = var & 0xFF;
 8017aa0:	f805 3b02 	strb.w	r3, [r5], #2
	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
 8017aa4:	d00b      	beq.n	8017abe <conf_general_read_mc_configuration+0x3e>
		if (EE_ReadVariable(EEPROM_BASE_MCCONF + i, &var) == 0) {
 8017aa6:	4620      	mov	r0, r4
 8017aa8:	f10d 0106 	add.w	r1, sp, #6
 8017aac:	f000 fbd8 	bl	8018260 <EE_ReadVariable>
 8017ab0:	3401      	adds	r4, #1
 8017ab2:	b2a4      	uxth	r4, r4
 8017ab4:	2800      	cmp	r0, #0
 8017ab6:	d0ec      	beq.n	8017a92 <conf_general_read_mc_configuration+0x12>
			break;
		}
	}

	if (!is_ok) {
		conf_general_get_default_mc_configuration(conf);
 8017ab8:	4638      	mov	r0, r7
 8017aba:	f7ff fe11 	bl	80176e0 <conf_general_get_default_mc_configuration>
	}
}
 8017abe:	b003      	add	sp, #12
 8017ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017ac2:	bf00      	nop
	...

08017ad0 <conf_general_store_mc_configuration>:
 * Write mc_configuration to EEPROM.
 *
 * @param conf
 * A pointer to the configuration that should be stored.
 */
bool conf_general_store_mc_configuration(mc_configuration *conf) {
 8017ad0:	b570      	push	{r4, r5, r6, lr}
 8017ad2:	4605      	mov	r5, r0
	mc_interface_unlock();
 8017ad4:	f003 fcb4 	bl	801b440 <mc_interface_unlock>
	mc_interface_release_motor();
 8017ad8:	f004 fc4a 	bl	801c370 <mc_interface_release_motor>

	utils_sys_lock_cnt();
 8017adc:	f7fe fae0 	bl	80160a0 <utils_sys_lock_cnt>
	mc_interface_lock();
 8017ae0:	f003 fca6 	bl	801b430 <mc_interface_lock>

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, DISABLE);
 8017ae4:	2100      	movs	r1, #0
 8017ae6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8017aea:	f00c fba1 	bl	8024230 <RCC_APB1PeriphClockCmd>

	bool is_ok = true;
	uint8_t *conf_addr = (uint8_t*)conf;
	uint16_t var;

	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 8017aee:	20f2      	movs	r0, #242	; 0xf2
 8017af0:	f00c face 	bl	8024090 <FLASH_ClearFlag>
 8017af4:	3501      	adds	r5, #1
 8017af6:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
			FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);

	for (unsigned int i = 0;i < (sizeof(mc_configuration) / 2);i++) {
 8017afa:	f240 46a2 	movw	r6, #1186	; 0x4a2
 8017afe:	e001      	b.n	8017b04 <conf_general_store_mc_configuration+0x34>
 8017b00:	42b4      	cmp	r4, r6
 8017b02:	d01d      	beq.n	8017b40 <conf_general_store_mc_configuration+0x70>
		var = (conf_addr[2 * i] << 8) & 0xFF00;
 8017b04:	f815 1c01 	ldrb.w	r1, [r5, #-1]
		var |= conf_addr[2 * i + 1] & 0xFF;
 8017b08:	782b      	ldrb	r3, [r5, #0]

		if (EE_WriteVariable(EEPROM_BASE_MCCONF + i, var) != FLASH_COMPLETE) {
 8017b0a:	4620      	mov	r0, r4
 8017b0c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8017b10:	f000 fc7e 	bl	8018410 <EE_WriteVariable>
 8017b14:	3401      	adds	r4, #1
 8017b16:	2809      	cmp	r0, #9
 8017b18:	b2a4      	uxth	r4, r4
 8017b1a:	f105 0502 	add.w	r5, r5, #2
 8017b1e:	d0ef      	beq.n	8017b00 <conf_general_store_mc_configuration+0x30>
			is_ok = false;
 8017b20:	2400      	movs	r4, #0
			break;
		}
	}

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 8017b22:	2101      	movs	r1, #1
 8017b24:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8017b28:	f00c fb82 	bl	8024230 <RCC_APB1PeriphClockCmd>

	chThdSleepMilliseconds(100);
 8017b2c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8017b30:	f7f5 ff56 	bl	800d9e0 <chThdSleep>
	mc_interface_unlock();
 8017b34:	f003 fc84 	bl	801b440 <mc_interface_unlock>
	utils_sys_unlock_cnt();
 8017b38:	f7fe fac2 	bl	80160c0 <utils_sys_unlock_cnt>

	return is_ok;
}
 8017b3c:	4620      	mov	r0, r4
 8017b3e:	bd70      	pop	{r4, r5, r6, pc}
	bool is_ok = true;
 8017b40:	2401      	movs	r4, #1
 8017b42:	e7ee      	b.n	8017b22 <conf_general_store_mc_configuration+0x52>
	...

08017b50 <conf_general_detect_motor_param>:

bool conf_general_detect_motor_param(float current, float min_rpm, float low_duty,
		float *int_limit, float *bemf_coupling_k, int8_t *hall_table, int *hall_res) {
 8017b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017b54:	ed2d 8b06 	vpush	{d8-d10}
 8017b58:	b083      	sub	sp, #12
 8017b5a:	eef0 9a60 	vmov.f32	s19, s1
 8017b5e:	eeb0 aa40 	vmov.f32	s20, s0
 8017b62:	eeb0 9a41 	vmov.f32	s18, s2
 8017b66:	9301      	str	r3, [sp, #4]
 8017b68:	468a      	mov	sl, r1
 8017b6a:	4693      	mov	fp, r2
 8017b6c:	4680      	mov	r8, r0

	int ok_steps = 0;
	const float spinup_to_duty = 0.5;

	mcconf = *mc_interface_get_configuration();
 8017b6e:	f003 fc47 	bl	801b400 <mc_interface_get_configuration>
 8017b72:	4ec1      	ldr	r6, [pc, #772]	; (8017e78 <conf_general_detect_motor_param+0x328>)
 8017b74:	4601      	mov	r1, r0
 8017b76:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8017b7a:	4630      	mov	r0, r6
 8017b7c:	f7f4 ffd0 	bl	800cb20 <memcpy>
	mcconf_old = mcconf;
 8017b80:	4631      	mov	r1, r6
 8017b82:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8017b86:	48bd      	ldr	r0, [pc, #756]	; (8017e7c <conf_general_detect_motor_param+0x32c>)
 8017b88:	f7f4 ffca 	bl	800cb20 <memcpy>
	mcconf.motor_type = MOTOR_TYPE_BLDC;
	mcconf.sensor_mode = SENSOR_MODE_SENSORLESS;
	mcconf.comm_mode = COMM_MODE_INTEGRATE;
	mcconf.sl_phase_advance_at_br = 1.0;
	mcconf.sl_min_erpm = min_rpm;
	mcconf.sl_bemf_coupling_k = 300;
 8017b8c:	4bbc      	ldr	r3, [pc, #752]	; (8017e80 <conf_general_detect_motor_param+0x330>)
	mcconf.sl_cycle_int_limit = 50;
 8017b8e:	49bd      	ldr	r1, [pc, #756]	; (8017e84 <conf_general_detect_motor_param+0x334>)
	mcconf.sl_min_erpm_cycle_int_limit = 1100;
 8017b90:	4abd      	ldr	r2, [pc, #756]	; (8017e88 <conf_general_detect_motor_param+0x338>)
	mcconf.sl_bemf_coupling_k = 300;
 8017b92:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	mcconf.sl_phase_advance_at_br = 1.0;
 8017b96:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
	mcconf.motor_type = MOTOR_TYPE_BLDC;
 8017b9a:	2300      	movs	r3, #0
	mcconf.sl_phase_advance_at_br = 1.0;
 8017b9c:	f8c6 008c 	str.w	r0, [r6, #140]	; 0x8c
	mcconf.m_invert_direction = false;
	mc_interface_set_configuration(&mcconf);
 8017ba0:	4630      	mov	r0, r6
	mcconf.sl_min_erpm = min_rpm;
 8017ba2:	edc6 9a1f 	vstr	s19, [r6, #124]	; 0x7c
	mcconf.sl_cycle_int_limit = 50;
 8017ba6:	f8c6 1088 	str.w	r1, [r6, #136]	; 0x88
	mcconf.sl_min_erpm_cycle_int_limit = 1100;
 8017baa:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
	mcconf.motor_type = MOTOR_TYPE_BLDC;
 8017bae:	70b3      	strb	r3, [r6, #2]
	mcconf.sensor_mode = SENSOR_MODE_SENSORLESS;
 8017bb0:	70f3      	strb	r3, [r6, #3]
	mcconf.comm_mode = COMM_MODE_INTEGRATE;
 8017bb2:	7073      	strb	r3, [r6, #1]
	mcconf.m_invert_direction = false;
 8017bb4:	f886 315d 	strb.w	r3, [r6, #349]	; 0x15d
	mc_interface_set_configuration(&mcconf);
 8017bb8:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
 8017bbc:	f004 f930 	bl	801be20 <mc_interface_set_configuration>
 8017bc0:	e004      	b.n	8017bcc <conf_general_detect_motor_param+0x7c>
	// Wait maximum 5s for fault code to disappear
	for (int i = 0;i < 500;i++) {
		if (mc_interface_get_fault() == FAULT_CODE_NONE) {
			break;
		}
		chThdSleepMilliseconds(10);
 8017bc2:	2064      	movs	r0, #100	; 0x64
 8017bc4:	f7f5 ff0c 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 500;i++) {
 8017bc8:	3c01      	subs	r4, #1
 8017bca:	d003      	beq.n	8017bd4 <conf_general_detect_motor_param+0x84>
		if (mc_interface_get_fault() == FAULT_CODE_NONE) {
 8017bcc:	f003 fc48 	bl	801b460 <mc_interface_get_fault>
 8017bd0:	2800      	cmp	r0, #0
 8017bd2:	d1f6      	bne.n	8017bc2 <conf_general_detect_motor_param+0x72>
	}

	// Wait one second for things to get ready after
	// the fault disappears. (will fry things otherwise...)
	chThdSleepMilliseconds(1000);
 8017bd4:	f242 7010 	movw	r0, #10000	; 0x2710
 8017bd8:	f7f5 ff02 	bl	800d9e0 <chThdSleep>

	// Disable timeout
	systime_t tout = timeout_get_timeout_msec();
 8017bdc:	f002 fad8 	bl	801a190 <timeout_get_timeout_msec>
 8017be0:	4681      	mov	r9, r0
	float tout_c = timeout_get_brake_current();
 8017be2:	f002 fadd 	bl	801a1a0 <timeout_get_brake_current>
 8017be6:	eef0 aa40 	vmov.f32	s21, s0
	timeout_reset();
 8017bea:	f002 fab9 	bl	801a160 <timeout_reset>
	timeout_configure(60000, 0.0);
 8017bee:	ed9f 0aa7 	vldr	s0, [pc, #668]	; 8017e8c <conf_general_detect_motor_param+0x33c>
 8017bf2:	f64e 2060 	movw	r0, #60000	; 0xea60
 8017bf6:	f002 faa3 	bl	801a140 <timeout_configure>

	mc_interface_lock();
 8017bfa:	f003 fc19 	bl	801b430 <mc_interface_lock>

	mc_interface_lock_override_once();
 8017bfe:	f003 fc27 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_current(current);
 8017c02:	eeb0 0a4a 	vmov.f32	s0, s20
 8017c06:	f004 fb6b 	bl	801c2e0 <mc_interface_set_current>

	// Try to spin up the motor. Up to three attempts with different settings are made.
	bool started = false;
	for (int i = 0;i < 3;i++) {
 8017c0a:	2700      	movs	r7, #0

		while (mc_interface_get_duty_cycle_now() < spinup_to_duty) {
			chThdSleepMilliseconds(1);
			cnt++;

			if (mc_interface_get_duty_cycle_now() >= (spinup_to_duty / 2.0) && !switch_done) {
 8017c0c:	eef5 8a00 	vmov.f32	s17, #80	; 0x3e800000  0.250
		if (i == 1) {
 8017c10:	2f01      	cmp	r7, #1
 8017c12:	f000 8108 	beq.w	8017e26 <conf_general_detect_motor_param+0x2d6>
		} else if (i == 2) {
 8017c16:	2f02      	cmp	r7, #2
 8017c18:	f000 8120 	beq.w	8017e5c <conf_general_detect_motor_param+0x30c>
	for (int i = 0;i < 3;i++) {
 8017c1c:	2500      	movs	r5, #0
 8017c1e:	462c      	mov	r4, r5
		while (mc_interface_get_duty_cycle_now() < spinup_to_duty) {
 8017c20:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 8017c24:	f003 fc44 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8017c28:	eeb4 0ac8 	vcmpe.f32	s0, s16
 8017c2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			chThdSleepMilliseconds(1);
 8017c30:	f04f 000a 	mov.w	r0, #10
			cnt++;
 8017c34:	f104 0401 	add.w	r4, r4, #1
		while (mc_interface_get_duty_cycle_now() < spinup_to_duty) {
 8017c38:	f140 80e9 	bpl.w	8017e0e <conf_general_detect_motor_param+0x2be>
			chThdSleepMilliseconds(1);
 8017c3c:	f7f5 fed0 	bl	800d9e0 <chThdSleep>
			if (mc_interface_get_duty_cycle_now() >= (spinup_to_duty / 2.0) && !switch_done) {
 8017c40:	f003 fc36 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8017c44:	eeb4 0ae8 	vcmpe.f32	s0, s17
 8017c48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017c4c:	db0c      	blt.n	8017c68 <conf_general_detect_motor_param+0x118>
 8017c4e:	2d00      	cmp	r5, #0
 8017c50:	f000 80c1 	beq.w	8017dd6 <conf_general_detect_motor_param+0x286>
				mcpwm_switch_comm_mode(COMM_MODE_DELAY);
				switch_done = true;
			}

			if (cnt > 2000 && !switch_done) {
 8017c54:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 8017c58:	dd04      	ble.n	8017c64 <conf_general_detect_motor_param+0x114>
				started = false;
				break;
			}

			if (cnt >= 5000) {
 8017c5a:	f241 3388 	movw	r3, #5000	; 0x1388
 8017c5e:	429c      	cmp	r4, r3
 8017c60:	f000 80c1 	beq.w	8017de6 <conf_general_detect_motor_param+0x296>
	for (int i = 0;i < 3;i++) {
 8017c64:	2501      	movs	r5, #1
 8017c66:	e7dd      	b.n	8017c24 <conf_general_detect_motor_param+0xd4>
			if (cnt > 2000 && !switch_done) {
 8017c68:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 8017c6c:	ddda      	ble.n	8017c24 <conf_general_detect_motor_param+0xd4>
 8017c6e:	2d00      	cmp	r5, #0
 8017c70:	d1f3      	bne.n	8017c5a <conf_general_detect_motor_param+0x10a>
	for (int i = 0;i < 3;i++) {
 8017c72:	3701      	adds	r7, #1
 8017c74:	2f03      	cmp	r7, #3
 8017c76:	d1cb      	bne.n	8017c10 <conf_general_detect_motor_param+0xc0>
		if (switch_done) {
			break;
		}
	}

	if (!started) {
 8017c78:	2d00      	cmp	r5, #0
 8017c7a:	f000 80b4 	beq.w	8017de6 <conf_general_detect_motor_param+0x296>
	}

	ok_steps++;

	// Reset hall sensor samples
	mcpwm_reset_hall_detect_table();
 8017c7e:	f7fc fb07 	bl	8014290 <mcpwm_reset_hall_detect_table>

	// Run for a while to get hall sensor samples
	mc_interface_lock_override_once();
 8017c82:	f003 fbe5 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_duty(spinup_to_duty);
 8017c86:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 8017c8a:	f004 fa81 	bl	801c190 <mc_interface_set_duty>
	chThdSleepMilliseconds(400);
 8017c8e:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8017c92:	f7f5 fea5 	bl	800d9e0 <chThdSleep>

	// Release the motor and wait a few commutations
	mc_interface_lock_override_once();
 8017c96:	f003 fbdb 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_current(0.0);
 8017c9a:	ed9f 0a7c 	vldr	s0, [pc, #496]	; 8017e8c <conf_general_detect_motor_param+0x33c>
 8017c9e:	f004 fb1f 	bl	801c2e0 <mc_interface_set_current>
	int tacho = mc_interface_get_tachometer_value(0);
 8017ca2:	2000      	movs	r0, #0
 8017ca4:	f003 fd24 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8017ca8:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
 8017cac:	4605      	mov	r5, r0
 8017cae:	e004      	b.n	8017cba <conf_general_detect_motor_param+0x16a>
	for (int i = 0;i < 2000;i++) {
		if ((mc_interface_get_tachometer_value(0) - tacho) < 3) {
			chThdSleepMilliseconds(1);
 8017cb0:	f7f5 fe96 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 2000;i++) {
 8017cb4:	3c01      	subs	r4, #1
 8017cb6:	f000 80b4 	beq.w	8017e22 <conf_general_detect_motor_param+0x2d2>
		if ((mc_interface_get_tachometer_value(0) - tacho) < 3) {
 8017cba:	2000      	movs	r0, #0
 8017cbc:	f003 fd18 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8017cc0:	1b43      	subs	r3, r0, r5
 8017cc2:	2b02      	cmp	r3, #2
			chThdSleepMilliseconds(1);
 8017cc4:	f04f 000a 	mov.w	r0, #10
		if ((mc_interface_get_tachometer_value(0) - tacho) < 3) {
 8017cc8:	ddf2      	ble.n	8017cb0 <conf_general_detect_motor_param+0x160>
		} else {
			ok_steps++;
 8017cca:	2502      	movs	r5, #2
			break;
		}
	}

	// Average the cycle integrator for 50 commutations
	mcpwm_read_reset_avg_cycle_integrator();
 8017ccc:	f7fc faa0 	bl	8014210 <mcpwm_read_reset_avg_cycle_integrator>
	tacho = mc_interface_get_tachometer_value(false);
 8017cd0:	2000      	movs	r0, #0
 8017cd2:	f003 fd0d 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8017cd6:	f640 34b8 	movw	r4, #3000	; 0xbb8
 8017cda:	4606      	mov	r6, r0
 8017cdc:	e003      	b.n	8017ce6 <conf_general_detect_motor_param+0x196>
	for (int i = 0;i < 3000;i++) {
		if ((mc_interface_get_tachometer_value(false) - tacho) < 50) {
			chThdSleepMilliseconds(1);
 8017cde:	f7f5 fe7f 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 3000;i++) {
 8017ce2:	3c01      	subs	r4, #1
 8017ce4:	d008      	beq.n	8017cf8 <conf_general_detect_motor_param+0x1a8>
		if ((mc_interface_get_tachometer_value(false) - tacho) < 50) {
 8017ce6:	2000      	movs	r0, #0
 8017ce8:	f003 fd02 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8017cec:	1b83      	subs	r3, r0, r6
 8017cee:	2b31      	cmp	r3, #49	; 0x31
			chThdSleepMilliseconds(1);
 8017cf0:	f04f 000a 	mov.w	r0, #10
		if ((mc_interface_get_tachometer_value(false) - tacho) < 50) {
 8017cf4:	ddf3      	ble.n	8017cde <conf_general_detect_motor_param+0x18e>
		} else {
			ok_steps++;
 8017cf6:	3501      	adds	r5, #1
			break;
		}
	}

	// Get hall detect result
	*hall_res = mcpwm_get_hall_detect_result(hall_table);
 8017cf8:	4658      	mov	r0, fp
 8017cfa:	f7fc fad1 	bl	80142a0 <mcpwm_get_hall_detect_result>
 8017cfe:	9b01      	ldr	r3, [sp, #4]
 8017d00:	6018      	str	r0, [r3, #0]

	*int_limit = mcpwm_read_reset_avg_cycle_integrator();
 8017d02:	f7fc fa85 	bl	8014210 <mcpwm_read_reset_avg_cycle_integrator>
 8017d06:	f241 3488 	movw	r4, #5000	; 0x1388
 8017d0a:	ed88 0a00 	vstr	s0, [r8]
 8017d0e:	e003      	b.n	8017d18 <conf_general_detect_motor_param+0x1c8>

	// Wait for the motor to slow down
	for (int i = 0;i < 5000;i++) {
		if (mc_interface_get_duty_cycle_now() > low_duty) {
			chThdSleepMilliseconds(1);
 8017d10:	f7f5 fe66 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 5000;i++) {
 8017d14:	3c01      	subs	r4, #1
 8017d16:	d009      	beq.n	8017d2c <conf_general_detect_motor_param+0x1dc>
		if (mc_interface_get_duty_cycle_now() > low_duty) {
 8017d18:	f003 fbca 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8017d1c:	eeb4 0ac9 	vcmpe.f32	s0, s18
 8017d20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			chThdSleepMilliseconds(1);
 8017d24:	f04f 000a 	mov.w	r0, #10
		if (mc_interface_get_duty_cycle_now() > low_duty) {
 8017d28:	dcf2      	bgt.n	8017d10 <conf_general_detect_motor_param+0x1c0>
		} else {
			ok_steps++;
 8017d2a:	3501      	adds	r5, #1
			break;
		}
	}

	mc_interface_lock_override_once();
 8017d2c:	f003 fb90 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_duty(low_duty);
 8017d30:	eeb0 0a49 	vmov.f32	s0, s18
 8017d34:	f004 fa2c 	bl	801c190 <mc_interface_set_duty>

	// Average the cycle integrator for 100 commutations
	mcpwm_read_reset_avg_cycle_integrator();
 8017d38:	f7fc fa6a 	bl	8014210 <mcpwm_read_reset_avg_cycle_integrator>
	tacho = mc_interface_get_tachometer_value(0);
 8017d3c:	2000      	movs	r0, #0
 8017d3e:	f003 fcd7 	bl	801b6f0 <mc_interface_get_tachometer_value>
	float rpm_sum = 0.0;
	float rpm_iterations = 0.0;
 8017d42:	ed9f 8a52 	vldr	s16, [pc, #328]	; 8017e8c <conf_general_detect_motor_param+0x33c>
	tacho = mc_interface_get_tachometer_value(0);
 8017d46:	4606      	mov	r6, r0
	float rpm_sum = 0.0;
 8017d48:	eef0 8a48 	vmov.f32	s17, s16
	tacho = mc_interface_get_tachometer_value(0);
 8017d4c:	f640 34b8 	movw	r4, #3000	; 0xbb8
	for (int i = 0;i < 3000;i++) {
		if ((mc_interface_get_tachometer_value(0) - tacho) < 100) {
			rpm_sum += mc_interface_get_rpm();
			rpm_iterations += 1;
 8017d50:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 8017d54:	e00a      	b.n	8017d6c <conf_general_detect_motor_param+0x21c>
			rpm_sum += mc_interface_get_rpm();
 8017d56:	f003 fbe3 	bl	801b520 <mc_interface_get_rpm>
			chThdSleepMilliseconds(1);
 8017d5a:	200a      	movs	r0, #10
			rpm_sum += mc_interface_get_rpm();
 8017d5c:	ee78 8a80 	vadd.f32	s17, s17, s0
			chThdSleepMilliseconds(1);
 8017d60:	f7f5 fe3e 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 3000;i++) {
 8017d64:	3c01      	subs	r4, #1
			rpm_iterations += 1;
 8017d66:	ee38 8a09 	vadd.f32	s16, s16, s18
	for (int i = 0;i < 3000;i++) {
 8017d6a:	d006      	beq.n	8017d7a <conf_general_detect_motor_param+0x22a>
		if ((mc_interface_get_tachometer_value(0) - tacho) < 100) {
 8017d6c:	2000      	movs	r0, #0
 8017d6e:	f003 fcbf 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8017d72:	1b80      	subs	r0, r0, r6
 8017d74:	2863      	cmp	r0, #99	; 0x63
 8017d76:	ddee      	ble.n	8017d56 <conf_general_detect_motor_param+0x206>
		} else {
			ok_steps++;
 8017d78:	3501      	adds	r5, #1
			break;
		}
	}

	float avg_cycle_integrator_running = mcpwm_read_reset_avg_cycle_integrator();
 8017d7a:	f7fc fa49 	bl	8014210 <mcpwm_read_reset_avg_cycle_integrator>
 8017d7e:	eeb0 9a40 	vmov.f32	s18, s0
	float rpm = rpm_sum / rpm_iterations;

	mc_interface_lock_override_once();
 8017d82:	f003 fb65 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_release_motor();
 8017d86:	f004 faf3 	bl	801c370 <mc_interface_release_motor>

	// Try to figure out the coupling factor
	avg_cycle_integrator_running -= *int_limit;
	avg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];
 8017d8a:	4b41      	ldr	r3, [pc, #260]	; (8017e90 <conf_general_detect_motor_param+0x340>)
	avg_cycle_integrator_running -= *int_limit;
 8017d8c:	ed98 0a00 	vldr	s0, [r8]
	avg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];
 8017d90:	8a1b      	ldrh	r3, [r3, #16]
	avg_cycle_integrator_running *= rpm;
	*bemf_coupling_k = avg_cycle_integrator_running;

	// Restore settings
	mc_interface_set_configuration(&mcconf_old);
 8017d92:	483a      	ldr	r0, [pc, #232]	; (8017e7c <conf_general_detect_motor_param+0x32c>)
	avg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];
 8017d94:	ee07 3a10 	vmov	s14, r3
	avg_cycle_integrator_running -= *int_limit;
 8017d98:	ee39 0a40 	vsub.f32	s0, s18, s0
	avg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];
 8017d9c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
	float rpm = rpm_sum / rpm_iterations;
 8017da0:	eec8 7a88 	vdiv.f32	s15, s17, s16
	avg_cycle_integrator_running /= (float)ADC_Value[ADC_IND_VIN_SENS];
 8017da4:	eec0 6a07 	vdiv.f32	s13, s0, s14
	avg_cycle_integrator_running *= rpm;
 8017da8:	ee67 7aa6 	vmul.f32	s15, s15, s13
	*bemf_coupling_k = avg_cycle_integrator_running;
 8017dac:	edca 7a00 	vstr	s15, [sl]
	mc_interface_set_configuration(&mcconf_old);
 8017db0:	f004 f836 	bl	801be20 <mc_interface_set_configuration>
	timeout_configure(tout, tout_c);
 8017db4:	4648      	mov	r0, r9
 8017db6:	eeb0 0a6a 	vmov.f32	s0, s21
 8017dba:	f002 f9c1 	bl	801a140 <timeout_configure>

	mc_interface_unlock();
 8017dbe:	f003 fb3f 	bl	801b440 <mc_interface_unlock>

	return ok_steps == 5 ? true : false;
 8017dc2:	f1a5 0005 	sub.w	r0, r5, #5
 8017dc6:	fab0 f080 	clz	r0, r0
 8017dca:	0940      	lsrs	r0, r0, #5
}
 8017dcc:	b003      	add	sp, #12
 8017dce:	ecbd 8b06 	vpop	{d8-d10}
 8017dd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				mcpwm_switch_comm_mode(COMM_MODE_DELAY);
 8017dd6:	2001      	movs	r0, #1
 8017dd8:	f7fc fa52 	bl	8014280 <mcpwm_switch_comm_mode>
			if (cnt >= 5000) {
 8017ddc:	f241 3388 	movw	r3, #5000	; 0x1388
 8017de0:	429c      	cmp	r4, r3
 8017de2:	f47f af3f 	bne.w	8017c64 <conf_general_detect_motor_param+0x114>
		mc_interface_set_current(0.0);
 8017de6:	ed9f 0a29 	vldr	s0, [pc, #164]	; 8017e8c <conf_general_detect_motor_param+0x33c>
 8017dea:	f004 fa79 	bl	801c2e0 <mc_interface_set_current>
		timeout_configure(tout, tout_c);
 8017dee:	eeb0 0a6a 	vmov.f32	s0, s21
 8017df2:	4648      	mov	r0, r9
 8017df4:	f002 f9a4 	bl	801a140 <timeout_configure>
		mc_interface_set_configuration(&mcconf_old);
 8017df8:	4820      	ldr	r0, [pc, #128]	; (8017e7c <conf_general_detect_motor_param+0x32c>)
 8017dfa:	f004 f811 	bl	801be20 <mc_interface_set_configuration>
		mc_interface_unlock();
 8017dfe:	f003 fb1f 	bl	801b440 <mc_interface_unlock>
		return false;
 8017e02:	2000      	movs	r0, #0
}
 8017e04:	b003      	add	sp, #12
 8017e06:	ecbd 8b06 	vpop	{d8-d10}
 8017e0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (switch_done) {
 8017e0e:	2d00      	cmp	r5, #0
 8017e10:	f47f af35 	bne.w	8017c7e <conf_general_detect_motor_param+0x12e>
	for (int i = 0;i < 3;i++) {
 8017e14:	3701      	adds	r7, #1
 8017e16:	2f03      	cmp	r7, #3
		started = true;
 8017e18:	f04f 0501 	mov.w	r5, #1
	for (int i = 0;i < 3;i++) {
 8017e1c:	f47f aef8 	bne.w	8017c10 <conf_general_detect_motor_param+0xc0>
 8017e20:	e72a      	b.n	8017c78 <conf_general_detect_motor_param+0x128>
	ok_steps++;
 8017e22:	2501      	movs	r5, #1
 8017e24:	e752      	b.n	8017ccc <conf_general_detect_motor_param+0x17c>
			mc_interface_lock_override_once();
 8017e26:	f003 fb13 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_release_motor();
 8017e2a:	f004 faa1 	bl	801c370 <mc_interface_release_motor>
			mcconf.sl_min_erpm = 2 * min_rpm;
 8017e2e:	ee79 7aa9 	vadd.f32	s15, s19, s19
			mcconf.sl_cycle_int_limit = 20;
 8017e32:	4b18      	ldr	r3, [pc, #96]	; (8017e94 <conf_general_detect_motor_param+0x344>)
			mcconf.sl_min_erpm = 2 * min_rpm;
 8017e34:	edc6 7a1f 	vstr	s15, [r6, #124]	; 0x7c
			mcconf.sl_cycle_int_limit = 20;
 8017e38:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
			mc_interface_lock_override_once();
 8017e3c:	f003 fb08 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_set_configuration(&mcconf);
 8017e40:	480d      	ldr	r0, [pc, #52]	; (8017e78 <conf_general_detect_motor_param+0x328>)
 8017e42:	f003 ffed 	bl	801be20 <mc_interface_set_configuration>
			chThdSleepMilliseconds(1000);
 8017e46:	f242 7010 	movw	r0, #10000	; 0x2710
 8017e4a:	f7f5 fdc9 	bl	800d9e0 <chThdSleep>
			mc_interface_lock_override_once();
 8017e4e:	f003 faff 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_set_current(current);
 8017e52:	eeb0 0a4a 	vmov.f32	s0, s20
 8017e56:	f004 fa43 	bl	801c2e0 <mc_interface_set_current>
 8017e5a:	e6df      	b.n	8017c1c <conf_general_detect_motor_param+0xcc>
			mc_interface_lock_override_once();
 8017e5c:	f003 faf8 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_release_motor();
 8017e60:	f004 fa86 	bl	801c370 <mc_interface_release_motor>
			mcconf.sl_min_erpm = 4 * min_rpm;
 8017e64:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 8017e68:	ee69 7aa7 	vmul.f32	s15, s19, s15
			mcconf.comm_mode = COMM_MODE_DELAY;
 8017e6c:	2301      	movs	r3, #1
			mcconf.sl_min_erpm = 4 * min_rpm;
 8017e6e:	edc6 7a1f 	vstr	s15, [r6, #124]	; 0x7c
			mcconf.comm_mode = COMM_MODE_DELAY;
 8017e72:	7073      	strb	r3, [r6, #1]
 8017e74:	e7e2      	b.n	8017e3c <conf_general_detect_motor_param+0x2ec>
 8017e76:	bf00      	nop
 8017e78:	20008054 	.word	0x20008054
 8017e7c:	200081c8 	.word	0x200081c8
 8017e80:	43960000 	.word	0x43960000
 8017e84:	42480000 	.word	0x42480000
 8017e88:	44898000 	.word	0x44898000
 8017e8c:	00000000 	.word	0x00000000
 8017e90:	2000c03c 	.word	0x2000c03c
 8017e94:	41a00000 	.word	0x41a00000
	...

08017ea0 <conf_general_measure_flux_linkage>:
 *
 * @return
 * True for success, false otherwise.
 */
bool conf_general_measure_flux_linkage(float current, float duty,
		float min_erpm, float res, float *linkage) {
 8017ea0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017ea4:	ed2d 8b0a 	vpush	{d8-d12}
 8017ea8:	4680      	mov	r8, r0
 8017eaa:	eef0 9a41 	vmov.f32	s19, s2
 8017eae:	eeb0 9a40 	vmov.f32	s18, s0
 8017eb2:	eeb0 8a60 	vmov.f32	s16, s1
 8017eb6:	eef0 ba61 	vmov.f32	s23, s3
	mcconf = *mc_interface_get_configuration();
 8017eba:	f003 faa1 	bl	801b400 <mc_interface_get_configuration>
 8017ebe:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 801816c <conf_general_measure_flux_linkage+0x2cc>
 8017ec2:	4601      	mov	r1, r0
 8017ec4:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8017ec8:	4648      	mov	r0, r9
 8017eca:	f7f4 fe29 	bl	800cb20 <memcpy>
	mcconf_old = mcconf;
 8017ece:	4649      	mov	r1, r9
 8017ed0:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8017ed4:	489a      	ldr	r0, [pc, #616]	; (8018140 <conf_general_measure_flux_linkage+0x2a0>)
 8017ed6:	f7f4 fe23 	bl	800cb20 <memcpy>
	mcconf.motor_type = MOTOR_TYPE_BLDC;
	mcconf.sensor_mode = SENSOR_MODE_SENSORLESS;
	mcconf.comm_mode = COMM_MODE_INTEGRATE;
	mcconf.sl_phase_advance_at_br = 1.0;
	mcconf.sl_min_erpm = min_erpm;
	mcconf.m_bldc_f_sw_min = 10000.0;
 8017eda:	489a      	ldr	r0, [pc, #616]	; (8018144 <conf_general_measure_flux_linkage+0x2a4>)
	mcconf.sl_bemf_coupling_k = 300;
 8017edc:	4b9a      	ldr	r3, [pc, #616]	; (8018148 <conf_general_measure_flux_linkage+0x2a8>)
	mcconf.sl_cycle_int_limit = 50;
 8017ede:	499b      	ldr	r1, [pc, #620]	; (801814c <conf_general_measure_flux_linkage+0x2ac>)
	mcconf.sl_min_erpm_cycle_int_limit = 1100;
 8017ee0:	4a9b      	ldr	r2, [pc, #620]	; (8018150 <conf_general_measure_flux_linkage+0x2b0>)
	mcconf.m_bldc_f_sw_min = 10000.0;
 8017ee2:	f8c9 0164 	str.w	r0, [r9, #356]	; 0x164
	mcconf.sl_phase_advance_at_br = 1.0;
 8017ee6:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
	mcconf.sl_bemf_coupling_k = 300;
 8017eea:	f8c9 3094 	str.w	r3, [r9, #148]	; 0x94
	mc_interface_set_configuration(&mcconf);
 8017eee:	4648      	mov	r0, r9
	mcconf.motor_type = MOTOR_TYPE_BLDC;
 8017ef0:	2300      	movs	r3, #0
	mcconf.sl_phase_advance_at_br = 1.0;
 8017ef2:	f8c9 408c 	str.w	r4, [r9, #140]	; 0x8c
	mcconf.sl_min_erpm = min_erpm;
 8017ef6:	edc9 9a1f 	vstr	s19, [r9, #124]	; 0x7c
	mcconf.sl_cycle_int_limit = 50;
 8017efa:	f8c9 1088 	str.w	r1, [r9, #136]	; 0x88
	mcconf.sl_min_erpm_cycle_int_limit = 1100;
 8017efe:	f8c9 2080 	str.w	r2, [r9, #128]	; 0x80
	mcconf.motor_type = MOTOR_TYPE_BLDC;
 8017f02:	f889 3002 	strb.w	r3, [r9, #2]
	mcconf.sensor_mode = SENSOR_MODE_SENSORLESS;
 8017f06:	f889 3003 	strb.w	r3, [r9, #3]
	mcconf.comm_mode = COMM_MODE_INTEGRATE;
 8017f0a:	f889 3001 	strb.w	r3, [r9, #1]
	mc_interface_set_configuration(&mcconf);
 8017f0e:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
 8017f12:	f003 ff85 	bl	801be20 <mc_interface_set_configuration>
 8017f16:	e004      	b.n	8017f22 <conf_general_measure_flux_linkage+0x82>
	// Wait maximum 5s for fault code to disappear
	for (int i = 0;i < 500;i++) {
		if (mc_interface_get_fault() == FAULT_CODE_NONE) {
			break;
		}
		chThdSleepMilliseconds(10);
 8017f18:	2064      	movs	r0, #100	; 0x64
 8017f1a:	f7f5 fd61 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 500;i++) {
 8017f1e:	3c01      	subs	r4, #1
 8017f20:	d003      	beq.n	8017f2a <conf_general_measure_flux_linkage+0x8a>
		if (mc_interface_get_fault() == FAULT_CODE_NONE) {
 8017f22:	f003 fa9d 	bl	801b460 <mc_interface_get_fault>
 8017f26:	2800      	cmp	r0, #0
 8017f28:	d1f6      	bne.n	8017f18 <conf_general_measure_flux_linkage+0x78>
	}

	// Wait one second for things to get ready after
	// the fault disapears. (will fry things otherwise...)
	// TODO: Add FAULT_INIT_NOT_DONE
	chThdSleepMilliseconds(1000);
 8017f2a:	f242 7010 	movw	r0, #10000	; 0x2710
 8017f2e:	f7f5 fd57 	bl	800d9e0 <chThdSleep>

	// Disable timeout
	systime_t tout = timeout_get_timeout_msec();
 8017f32:	f002 f92d 	bl	801a190 <timeout_get_timeout_msec>
 8017f36:	4607      	mov	r7, r0
	float tout_c = timeout_get_brake_current();
 8017f38:	f002 f932 	bl	801a1a0 <timeout_get_brake_current>
 8017f3c:	eeb0 ca40 	vmov.f32	s24, s0
	timeout_reset();
 8017f40:	f002 f90e 	bl	801a160 <timeout_reset>
	timeout_configure(60000, 0.0);
 8017f44:	ed9f 0a83 	vldr	s0, [pc, #524]	; 8018154 <conf_general_measure_flux_linkage+0x2b4>
	bool started = false;
	for (int i = 0;i < 4;i++) {
		if (i == 1) {
			mc_interface_lock_override_once();
			mc_interface_release_motor();
			mcconf.sl_cycle_int_limit = 250;
 8017f48:	f8df b228 	ldr.w	fp, [pc, #552]	; 8018174 <conf_general_measure_flux_linkage+0x2d4>
	timeout_configure(60000, 0.0);
 8017f4c:	f64e 2060 	movw	r0, #60000	; 0xea60
 8017f50:	f002 f8f6 	bl	801a140 <timeout_configure>
	mc_interface_lock();
 8017f54:	f003 fa6c 	bl	801b430 <mc_interface_lock>
	mc_interface_lock_override_once();
 8017f58:	f003 fa7a 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_current(current);
 8017f5c:	eeb0 0a49 	vmov.f32	s0, s18
 8017f60:	f004 f9be 	bl	801c2e0 <mc_interface_set_current>
	for (int i = 0;i < 4;i++) {
 8017f64:	2600      	movs	r6, #0
			mc_interface_set_current(current);
		} else if (i == 3) {
			mc_interface_lock_override_once();
			mc_interface_release_motor();
			mcconf.sl_min_erpm = 4 * min_erpm;
			mcconf.comm_mode = COMM_MODE_DELAY;
 8017f66:	f04f 0a01 	mov.w	sl, #1
		if (i == 1) {
 8017f6a:	2e01      	cmp	r6, #1
 8017f6c:	f000 80e0 	beq.w	8018130 <conf_general_measure_flux_linkage+0x290>
		} else if (i == 2) {
 8017f70:	2e02      	cmp	r6, #2
 8017f72:	f000 80d1 	beq.w	8018118 <conf_general_measure_flux_linkage+0x278>
		} else if (i == 3) {
 8017f76:	2e03      	cmp	r6, #3
 8017f78:	f000 80b2 	beq.w	80180e0 <conf_general_measure_flux_linkage+0x240>
	for (int i = 0;i < 4;i++) {
 8017f7c:	2500      	movs	r5, #0
 8017f7e:	462c      	mov	r4, r5

		while (mc_interface_get_duty_cycle_now() < duty) {
			chThdSleepMilliseconds(1);
			cnt++;

			if (mc_interface_get_duty_cycle_now() >= (duty / 2.0) && !switch_done) {
 8017f80:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
		while (mc_interface_get_duty_cycle_now() < duty) {
 8017f84:	f003 fa94 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8017f88:	eeb4 0ac8 	vcmpe.f32	s0, s16
 8017f8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			chThdSleepMilliseconds(1);
 8017f90:	f04f 000a 	mov.w	r0, #10
			cnt++;
 8017f94:	f104 0401 	add.w	r4, r4, #1
		while (mc_interface_get_duty_cycle_now() < duty) {
 8017f98:	f140 8099 	bpl.w	80180ce <conf_general_measure_flux_linkage+0x22e>
			chThdSleepMilliseconds(1);
 8017f9c:	f7f5 fd20 	bl	800d9e0 <chThdSleep>
			if (mc_interface_get_duty_cycle_now() >= (duty / 2.0) && !switch_done) {
 8017fa0:	f003 fa86 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8017fa4:	ee68 7a28 	vmul.f32	s15, s16, s17
 8017fa8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8017fac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017fb0:	db0a      	blt.n	8017fc8 <conf_general_measure_flux_linkage+0x128>
 8017fb2:	2d00      	cmp	r5, #0
 8017fb4:	d071      	beq.n	801809a <conf_general_measure_flux_linkage+0x1fa>
				mcpwm_switch_comm_mode(COMM_MODE_DELAY);
				switch_done = true;
			}

			if (cnt > 2000 && !switch_done) {
 8017fb6:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 8017fba:	dd03      	ble.n	8017fc4 <conf_general_measure_flux_linkage+0x124>
				started = false;
				break;
			}

			if (cnt >= 5000) {
 8017fbc:	f241 3388 	movw	r3, #5000	; 0x1388
 8017fc0:	429c      	cmp	r4, r3
 8017fc2:	d071      	beq.n	80180a8 <conf_general_measure_flux_linkage+0x208>
	for (int i = 0;i < 4;i++) {
 8017fc4:	2501      	movs	r5, #1
 8017fc6:	e7dd      	b.n	8017f84 <conf_general_measure_flux_linkage+0xe4>
			if (cnt > 2000 && !switch_done) {
 8017fc8:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 8017fcc:	ddda      	ble.n	8017f84 <conf_general_measure_flux_linkage+0xe4>
 8017fce:	2d00      	cmp	r5, #0
 8017fd0:	d1f4      	bne.n	8017fbc <conf_general_measure_flux_linkage+0x11c>
	for (int i = 0;i < 4;i++) {
 8017fd2:	3601      	adds	r6, #1
 8017fd4:	2e04      	cmp	r6, #4
 8017fd6:	d1c8      	bne.n	8017f6a <conf_general_measure_flux_linkage+0xca>
		if (switch_done) {
			break;
		}
	}

	if (!started) {
 8017fd8:	2d00      	cmp	r5, #0
 8017fda:	d065      	beq.n	80180a8 <conf_general_measure_flux_linkage+0x208>
		mc_interface_set_configuration(&mcconf_old);
		mc_interface_unlock();
		return false;
	}

	mc_interface_lock_override_once();
 8017fdc:	f003 fa38 	bl	801b450 <mc_interface_lock_override_once>
	mc_interface_set_duty(duty);
 8017fe0:	eeb0 0a48 	vmov.f32	s0, s16
 8017fe4:	f004 f8d4 	bl	801c190 <mc_interface_set_duty>

	float avg_voltage = 0.0;
	float avg_rpm = 0.0;
	float avg_current = 0.0;
	float samples = 0.0;
 8017fe8:	ed9f 8a5a 	vldr	s16, [pc, #360]	; 8018154 <conf_general_measure_flux_linkage+0x2b4>
 8017fec:	4e5a      	ldr	r6, [pc, #360]	; (8018158 <conf_general_measure_flux_linkage+0x2b8>)
	for (int i = 0;i < 2000;i++) {
		avg_voltage += GET_INPUT_VOLTAGE() * mc_interface_get_duty_cycle_now();
 8017fee:	ed9f ba5b 	vldr	s22, [pc, #364]	; 801815c <conf_general_measure_flux_linkage+0x2bc>
 8017ff2:	eddf aa5b 	vldr	s21, [pc, #364]	; 8018160 <conf_general_measure_flux_linkage+0x2c0>
	float avg_current = 0.0;
 8017ff6:	eef0 9a48 	vmov.f32	s19, s16
	float avg_rpm = 0.0;
 8017ffa:	eef0 8a48 	vmov.f32	s17, s16
	float avg_voltage = 0.0;
 8017ffe:	eeb0 9a48 	vmov.f32	s18, s16
	mc_interface_set_duty(duty);
 8018002:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
		avg_rpm += mc_interface_get_rpm();
		avg_current += mc_interface_get_tot_current();
		samples += 1.0;
 8018006:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
		avg_voltage += GET_INPUT_VOLTAGE() * mc_interface_get_duty_cycle_now();
 801800a:	8a33      	ldrh	r3, [r6, #16]
 801800c:	b29c      	uxth	r4, r3
 801800e:	f003 fa4f 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8018012:	ee07 4a90 	vmov	s15, r4
 8018016:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801801a:	ee67 7a8b 	vmul.f32	s15, s15, s22
 801801e:	ee67 7aaa 	vmul.f32	s15, s15, s21
 8018022:	eea7 9a80 	vfma.f32	s18, s15, s0
		avg_rpm += mc_interface_get_rpm();
 8018026:	f003 fa7b 	bl	801b520 <mc_interface_get_rpm>
 801802a:	ee78 8a80 	vadd.f32	s17, s17, s0
		avg_current += mc_interface_get_tot_current();
 801802e:	f003 fad7 	bl	801b5e0 <mc_interface_get_tot_current>
		chThdSleepMilliseconds(1.0);
 8018032:	200a      	movs	r0, #10
		avg_current += mc_interface_get_tot_current();
 8018034:	ee79 9a80 	vadd.f32	s19, s19, s0
		chThdSleepMilliseconds(1.0);
 8018038:	f7f5 fcd2 	bl	800d9e0 <chThdSleep>
	for (int i = 0;i < 2000;i++) {
 801803c:	3d01      	subs	r5, #1
		samples += 1.0;
 801803e:	ee38 8a0a 	vadd.f32	s16, s16, s20
	for (int i = 0;i < 2000;i++) {
 8018042:	d1e2      	bne.n	801800a <conf_general_measure_flux_linkage+0x16a>
	}

	timeout_configure(tout, tout_c);
 8018044:	eeb0 0a4c 	vmov.f32	s0, s24
 8018048:	4638      	mov	r0, r7
 801804a:	f002 f879 	bl	801a140 <timeout_configure>
	mc_interface_set_configuration(&mcconf_old);
 801804e:	483c      	ldr	r0, [pc, #240]	; (8018140 <conf_general_measure_flux_linkage+0x2a0>)
 8018050:	f003 fee6 	bl	801be20 <mc_interface_set_configuration>
	mc_interface_unlock();
 8018054:	f003 f9f4 	bl	801b440 <mc_interface_unlock>
	mc_interface_set_current(0.0);
 8018058:	ed9f 0a3e 	vldr	s0, [pc, #248]	; 8018154 <conf_general_measure_flux_linkage+0x2b4>
 801805c:	f004 f940 	bl	801c2e0 <mc_interface_set_current>

	avg_voltage /= samples;
	avg_rpm /= samples;
	avg_current /= samples;
 8018060:	eec9 6a88 	vdiv.f32	s13, s19, s16
	avg_voltage -= avg_current * res * 2.0;

	*linkage = avg_voltage * 60.0 / (sqrtf(3.0) * 2.0 * M_PI * avg_rpm);

	return true;
 8018064:	2001      	movs	r0, #1
	avg_voltage /= samples;
 8018066:	eec9 7a08 	vdiv.f32	s15, s18, s16
	avg_rpm /= samples;
 801806a:	ee88 7a88 	vdiv.f32	s14, s17, s16
	avg_voltage -= avg_current * res * 2.0;
 801806e:	ee6b bae6 	vnmul.f32	s23, s23, s13
 8018072:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8018076:	eeeb 7aa6 	vfma.f32	s15, s23, s13
}
 801807a:	ecbd 8b0a 	vpop	{d8-d12}
	*linkage = avg_voltage * 60.0 / (sqrtf(3.0) * 2.0 * M_PI * avg_rpm);
 801807e:	eddf 6a39 	vldr	s13, [pc, #228]	; 8018164 <conf_general_measure_flux_linkage+0x2c4>
 8018082:	ed9f 6a39 	vldr	s12, [pc, #228]	; 8018168 <conf_general_measure_flux_linkage+0x2c8>
 8018086:	ee27 7a26 	vmul.f32	s14, s14, s13
 801808a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801808e:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8018092:	edc8 6a00 	vstr	s13, [r8]
}
 8018096:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				mcpwm_switch_comm_mode(COMM_MODE_DELAY);
 801809a:	2001      	movs	r0, #1
 801809c:	f7fc f8f0 	bl	8014280 <mcpwm_switch_comm_mode>
			if (cnt >= 5000) {
 80180a0:	f241 3388 	movw	r3, #5000	; 0x1388
 80180a4:	429c      	cmp	r4, r3
 80180a6:	d18d      	bne.n	8017fc4 <conf_general_measure_flux_linkage+0x124>
		mc_interface_set_current(0.0);
 80180a8:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 8018154 <conf_general_measure_flux_linkage+0x2b4>
 80180ac:	f004 f918 	bl	801c2e0 <mc_interface_set_current>
		timeout_configure(tout, tout_c);
 80180b0:	eeb0 0a4c 	vmov.f32	s0, s24
 80180b4:	4638      	mov	r0, r7
 80180b6:	f002 f843 	bl	801a140 <timeout_configure>
		mc_interface_set_configuration(&mcconf_old);
 80180ba:	4821      	ldr	r0, [pc, #132]	; (8018140 <conf_general_measure_flux_linkage+0x2a0>)
 80180bc:	f003 feb0 	bl	801be20 <mc_interface_set_configuration>
		mc_interface_unlock();
 80180c0:	f003 f9be 	bl	801b440 <mc_interface_unlock>
}
 80180c4:	ecbd 8b0a 	vpop	{d8-d12}
		return false;
 80180c8:	2000      	movs	r0, #0
}
 80180ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (switch_done) {
 80180ce:	2d00      	cmp	r5, #0
 80180d0:	d184      	bne.n	8017fdc <conf_general_measure_flux_linkage+0x13c>
	for (int i = 0;i < 4;i++) {
 80180d2:	3601      	adds	r6, #1
 80180d4:	2e04      	cmp	r6, #4
		started = true;
 80180d6:	f04f 0501 	mov.w	r5, #1
	for (int i = 0;i < 4;i++) {
 80180da:	f47f af46 	bne.w	8017f6a <conf_general_measure_flux_linkage+0xca>
 80180de:	e77b      	b.n	8017fd8 <conf_general_measure_flux_linkage+0x138>
			mc_interface_lock_override_once();
 80180e0:	f003 f9b6 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_release_motor();
 80180e4:	f004 f944 	bl	801c370 <mc_interface_release_motor>
			mcconf.sl_min_erpm = 4 * min_erpm;
 80180e8:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 80180ec:	ee69 7aa7 	vmul.f32	s15, s19, s15
			mcconf.comm_mode = COMM_MODE_DELAY;
 80180f0:	f889 a001 	strb.w	sl, [r9, #1]
			mcconf.sl_min_erpm = 4 * min_erpm;
 80180f4:	edc9 7a1f 	vstr	s15, [r9, #124]	; 0x7c
			mc_interface_lock_override_once();
 80180f8:	f003 f9aa 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_set_configuration(&mcconf);
 80180fc:	481b      	ldr	r0, [pc, #108]	; (801816c <conf_general_measure_flux_linkage+0x2cc>)
 80180fe:	f003 fe8f 	bl	801be20 <mc_interface_set_configuration>
			chThdSleepMilliseconds(1000);
 8018102:	f242 7010 	movw	r0, #10000	; 0x2710
 8018106:	f7f5 fc6b 	bl	800d9e0 <chThdSleep>
			mc_interface_lock_override_once();
 801810a:	f003 f9a1 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_set_current(current);
 801810e:	eeb0 0a49 	vmov.f32	s0, s18
 8018112:	f004 f8e5 	bl	801c2e0 <mc_interface_set_current>
 8018116:	e731      	b.n	8017f7c <conf_general_measure_flux_linkage+0xdc>
			mc_interface_lock_override_once();
 8018118:	f003 f99a 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_release_motor();
 801811c:	f004 f928 	bl	801c370 <mc_interface_release_motor>
			mcconf.sl_min_erpm = 2 * min_erpm;
 8018120:	ee79 7aa9 	vadd.f32	s15, s19, s19
			mcconf.sl_cycle_int_limit = 20;
 8018124:	4b12      	ldr	r3, [pc, #72]	; (8018170 <conf_general_measure_flux_linkage+0x2d0>)
			mcconf.sl_min_erpm = 2 * min_erpm;
 8018126:	edc9 7a1f 	vstr	s15, [r9, #124]	; 0x7c
			mcconf.sl_cycle_int_limit = 20;
 801812a:	f8c9 3088 	str.w	r3, [r9, #136]	; 0x88
 801812e:	e7e3      	b.n	80180f8 <conf_general_measure_flux_linkage+0x258>
			mc_interface_lock_override_once();
 8018130:	f003 f98e 	bl	801b450 <mc_interface_lock_override_once>
			mc_interface_release_motor();
 8018134:	f004 f91c 	bl	801c370 <mc_interface_release_motor>
			mcconf.sl_cycle_int_limit = 250;
 8018138:	f8c9 b088 	str.w	fp, [r9, #136]	; 0x88
 801813c:	e7dc      	b.n	80180f8 <conf_general_measure_flux_linkage+0x258>
 801813e:	bf00      	nop
 8018140:	200081c8 	.word	0x200081c8
 8018144:	461c4000 	.word	0x461c4000
 8018148:	43960000 	.word	0x43960000
 801814c:	42480000 	.word	0x42480000
 8018150:	44898000 	.word	0x44898000
 8018154:	00000000 	.word	0x00000000
 8018158:	2000c03c 	.word	0x2000c03c
 801815c:	3a534067 	.word	0x3a534067
 8018160:	4195d174 	.word	0x4195d174
 8018164:	412e1fef 	.word	0x412e1fef
 8018168:	42700000 	.word	0x42700000
 801816c:	20008054 	.word	0x20008054
 8018170:	41a00000 	.word	0x41a00000
 8018174:	437a0000 	.word	0x437a0000
	...

08018180 <EE_VerifyPageFullWriteVariable>:
 *           - PAGE_FULL: if valid page is full
 *           - NO_VALID_PAGE: if no valid page was found
 *           - Flash error code: on write Flash error
 */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 8018180:	b538      	push	{r3, r4, r5, lr}
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018182:	4a1b      	ldr	r2, [pc, #108]	; (80181f0 <EE_VerifyPageFullWriteVariable+0x70>)
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8018184:	4b1b      	ldr	r3, [pc, #108]	; (80181f4 <EE_VerifyPageFullWriteVariable+0x74>)
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018186:	8812      	ldrh	r2, [r2, #0]
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8018188:	881b      	ldrh	r3, [r3, #0]
 801818a:	b29c      	uxth	r4, r3
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801818c:	b292      	uxth	r2, r2
		if (PageStatus1 == VALID_PAGE)
 801818e:	b9ec      	cbnz	r4, 80181cc <EE_VerifyPageFullWriteVariable+0x4c>
			if (PageStatus0 == RECEIVE_DATA)
 8018190:	f64e 63ee 	movw	r3, #61166	; 0xeeee
				return PAGE0;         /* Page0 valid */
 8018194:	1ad3      	subs	r3, r2, r3
 8018196:	bf18      	it	ne
 8018198:	2301      	movne	r3, #1
	{
		return  NO_VALID_PAGE;
	}

	/* Get the valid Page start Address */
	Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 801819a:	f503 5400 	add.w	r4, r3, #8192	; 0x2000

	/* Get the valid Page end Address */
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 801819e:	4a16      	ldr	r2, [pc, #88]	; (80181f8 <EE_VerifyPageFullWriteVariable+0x78>)
	Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80181a0:	3401      	adds	r4, #1
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 80181a2:	3301      	adds	r3, #1
	Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80181a4:	03a4      	lsls	r4, r4, #14
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 80181a6:	eb02 3283 	add.w	r2, r2, r3, lsl #14

	/* Check each active page address starting from begining */
	while (Address < PageEndAddress)
 80181aa:	4294      	cmp	r4, r2
 80181ac:	d303      	bcc.n	80181b6 <EE_VerifyPageFullWriteVariable+0x36>
 80181ae:	e015      	b.n	80181dc <EE_VerifyPageFullWriteVariable+0x5c>
			return FlashStatus;
		}
		else
		{
			/* Next address location */
			Address = Address + 4;
 80181b0:	3404      	adds	r4, #4
	while (Address < PageEndAddress)
 80181b2:	42a2      	cmp	r2, r4
 80181b4:	d912      	bls.n	80181dc <EE_VerifyPageFullWriteVariable+0x5c>
		if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 80181b6:	6823      	ldr	r3, [r4, #0]
 80181b8:	3301      	adds	r3, #1
 80181ba:	d1f9      	bne.n	80181b0 <EE_VerifyPageFullWriteVariable+0x30>
 80181bc:	4605      	mov	r5, r0
			FlashStatus = FLASH_ProgramHalfWord(Address, Data);
 80181be:	4620      	mov	r0, r4
 80181c0:	f00b ffe6 	bl	8024190 <FLASH_ProgramHalfWord>
			if (FlashStatus != FLASH_COMPLETE)
 80181c4:	2809      	cmp	r0, #9
 80181c6:	d00d      	beq.n	80181e4 <EE_VerifyPageFullWriteVariable+0x64>
			return FlashStatus;
 80181c8:	b280      	uxth	r0, r0
		}
	}

	/* Return PAGE_FULL in case the valid page is full */
	return PAGE_FULL;
}
 80181ca:	bd38      	pop	{r3, r4, r5, pc}
		else if (PageStatus0 == VALID_PAGE)
 80181cc:	b942      	cbnz	r2, 80181e0 <EE_VerifyPageFullWriteVariable+0x60>
			if (PageStatus1 == RECEIVE_DATA)
 80181ce:	f64e 63ee 	movw	r3, #61166	; 0xeeee
				return PAGE0;         /* Page0 valid */
 80181d2:	1ae3      	subs	r3, r4, r3
 80181d4:	fab3 f383 	clz	r3, r3
 80181d8:	095b      	lsrs	r3, r3, #5
 80181da:	e7de      	b.n	801819a <EE_VerifyPageFullWriteVariable+0x1a>
	return PAGE_FULL;
 80181dc:	2080      	movs	r0, #128	; 0x80
}
 80181de:	bd38      	pop	{r3, r4, r5, pc}
		return  NO_VALID_PAGE;
 80181e0:	20ab      	movs	r0, #171	; 0xab
}
 80181e2:	bd38      	pop	{r3, r4, r5, pc}
			FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
 80181e4:	4629      	mov	r1, r5
 80181e6:	1ca0      	adds	r0, r4, #2
 80181e8:	f00b ffd2 	bl	8024190 <FLASH_ProgramHalfWord>
 80181ec:	e7ec      	b.n	80181c8 <EE_VerifyPageFullWriteVariable+0x48>
 80181ee:	bf00      	nop
 80181f0:	08004000 	.word	0x08004000
 80181f4:	08008000 	.word	0x08008000
 80181f8:	08003ffe 	.word	0x08003ffe
 80181fc:	00000000 	.word	0x00000000

08018200 <EE_EraseSectorIfNotEmpty.constprop.1>:

/*
 * Erase flash page if it is not already erased. This is to save write cycles and
 * prevent the memory from getting erased in case of unstable voltage at boot.
 */
static uint16_t EE_EraseSectorIfNotEmpty(uint32_t FLASH_Sector, uint8_t VoltageRange) {
 8018200:	b510      	push	{r4, lr}
 8018202:	4604      	mov	r4, r0
	uint8_t *addr = flash_helper_get_sector_address(FLASH_Sector);
 8018204:	f002 ff04 	bl	801b010 <flash_helper_get_sector_address>
 8018208:	f500 527f 	add.w	r2, r0, #16320	; 0x3fc0
 801820c:	323f      	adds	r2, #63	; 0x3f
 801820e:	3801      	subs	r0, #1
 8018210:	e001      	b.n	8018216 <EE_EraseSectorIfNotEmpty.constprop.1+0x16>

	for (unsigned int i = 0;i < PAGE_SIZE;i++) {
 8018212:	4290      	cmp	r0, r2
 8018214:	d009      	beq.n	801822a <EE_EraseSectorIfNotEmpty.constprop.1+0x2a>
		if (addr[i] != 0xFF) {
 8018216:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801821a:	2bff      	cmp	r3, #255	; 0xff
 801821c:	d0f9      	beq.n	8018212 <EE_EraseSectorIfNotEmpty.constprop.1+0x12>
			return FLASH_EraseSector(FLASH_Sector, VoltageRange);
 801821e:	4620      	mov	r0, r4
 8018220:	2102      	movs	r1, #2
 8018222:	f00b ff75 	bl	8024110 <FLASH_EraseSector>
 8018226:	b280      	uxth	r0, r0
		}
	}

	return FLASH_COMPLETE;
}
 8018228:	bd10      	pop	{r4, pc}
	return FLASH_COMPLETE;
 801822a:	2009      	movs	r0, #9
}
 801822c:	bd10      	pop	{r4, pc}
 801822e:	bf00      	nop

08018230 <EE_Format>:
{
 8018230:	b508      	push	{r3, lr}
	FlashStatus = EE_EraseSectorIfNotEmpty(PAGE0_ID, VOLTAGE_RANGE);
 8018232:	2008      	movs	r0, #8
 8018234:	f7ff ffe4 	bl	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
 8018238:	b2c0      	uxtb	r0, r0
	if (FlashStatus != FLASH_COMPLETE)
 801823a:	2809      	cmp	r0, #9
 801823c:	d000      	beq.n	8018240 <EE_Format+0x10>
}
 801823e:	bd08      	pop	{r3, pc}
	FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8018240:	2100      	movs	r1, #0
 8018242:	4805      	ldr	r0, [pc, #20]	; (8018258 <EE_Format+0x28>)
 8018244:	f00b ffa4 	bl	8024190 <FLASH_ProgramHalfWord>
	if (FlashStatus != FLASH_COMPLETE)
 8018248:	2809      	cmp	r0, #9
 801824a:	d1f8      	bne.n	801823e <EE_Format+0xe>
	FlashStatus = EE_EraseSectorIfNotEmpty(PAGE1_ID, VOLTAGE_RANGE);
 801824c:	2010      	movs	r0, #16
 801824e:	f7ff ffd7 	bl	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
 8018252:	b2c0      	uxtb	r0, r0
}
 8018254:	bd08      	pop	{r3, pc}
 8018256:	bf00      	nop
 8018258:	08004000 	.word	0x08004000
 801825c:	00000000 	.word	0x00000000

08018260 <EE_ReadVariable>:
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018260:	4b14      	ldr	r3, [pc, #80]	; (80182b4 <EE_ReadVariable+0x54>)
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8018262:	4a15      	ldr	r2, [pc, #84]	; (80182b8 <EE_ReadVariable+0x58>)
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018264:	881b      	ldrh	r3, [r3, #0]
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8018266:	8812      	ldrh	r2, [r2, #0]
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018268:	b29b      	uxth	r3, r3
{
 801826a:	b410      	push	{r4}
		if (PageStatus0 == VALID_PAGE)
 801826c:	b12b      	cbz	r3, 801827a <EE_ReadVariable+0x1a>
 801826e:	b292      	uxth	r2, r2
		else if (PageStatus1 == VALID_PAGE)
 8018270:	b9da      	cbnz	r2, 80182aa <EE_ReadVariable+0x4a>
 8018272:	4b12      	ldr	r3, [pc, #72]	; (80182bc <EE_ReadVariable+0x5c>)
 8018274:	4c12      	ldr	r4, [pc, #72]	; (80182c0 <EE_ReadVariable+0x60>)
 8018276:	461a      	mov	r2, r3
 8018278:	e002      	b.n	8018280 <EE_ReadVariable+0x20>
		if (PageStatus0 == VALID_PAGE)
 801827a:	4b12      	ldr	r3, [pc, #72]	; (80182c4 <EE_ReadVariable+0x64>)
 801827c:	4c12      	ldr	r4, [pc, #72]	; (80182c8 <EE_ReadVariable+0x68>)
 801827e:	461a      	mov	r2, r3
		AddressValue = (*(__IO uint16_t*)Address);
 8018280:	8812      	ldrh	r2, [r2, #0]
		if (AddressValue == VirtAddress)
 8018282:	4290      	cmp	r0, r2
 8018284:	d103      	bne.n	801828e <EE_ReadVariable+0x2e>
 8018286:	e009      	b.n	801829c <EE_ReadVariable+0x3c>
		AddressValue = (*(__IO uint16_t*)Address);
 8018288:	881a      	ldrh	r2, [r3, #0]
		if (AddressValue == VirtAddress)
 801828a:	4290      	cmp	r0, r2
 801828c:	d006      	beq.n	801829c <EE_ReadVariable+0x3c>
			Address = Address - 4;
 801828e:	3b04      	subs	r3, #4
	while (Address > (PageStartAddress + 2))
 8018290:	42a3      	cmp	r3, r4
 8018292:	d8f9      	bhi.n	8018288 <EE_ReadVariable+0x28>
	uint16_t AddressValue = 0x5555, ReadStatus = 1;
 8018294:	2001      	movs	r0, #1
}
 8018296:	f85d 4b04 	ldr.w	r4, [sp], #4
 801829a:	4770      	bx	lr
			*Data = (*(__IO uint16_t*)(Address - 2));
 801829c:	f833 3c02 	ldrh.w	r3, [r3, #-2]
 80182a0:	800b      	strh	r3, [r1, #0]
			ReadStatus = 0;
 80182a2:	2000      	movs	r0, #0
}
 80182a4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80182a8:	4770      	bx	lr
		return  NO_VALID_PAGE;
 80182aa:	20ab      	movs	r0, #171	; 0xab
}
 80182ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80182b0:	4770      	bx	lr
 80182b2:	bf00      	nop
 80182b4:	08004000 	.word	0x08004000
 80182b8:	08008000 	.word	0x08008000
 80182bc:	0800bffe 	.word	0x0800bffe
 80182c0:	08008002 	.word	0x08008002
 80182c4:	08007ffe 	.word	0x08007ffe
 80182c8:	08004002 	.word	0x08004002
 80182cc:	00000000 	.word	0x00000000

080182d0 <EE_Init>:
{
 80182d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80182d4:	4d48      	ldr	r5, [pc, #288]	; (80183f8 <EE_Init+0x128>)
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80182d6:	4e49      	ldr	r6, [pc, #292]	; (80183fc <EE_Init+0x12c>)
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80182d8:	882c      	ldrh	r4, [r5, #0]
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80182da:	8833      	ldrh	r3, [r6, #0]
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80182dc:	b2a4      	uxth	r4, r4
	switch (PageStatus0)
 80182de:	f64e 62ee 	movw	r2, #61166	; 0xeeee
 80182e2:	4294      	cmp	r4, r2
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80182e4:	b29b      	uxth	r3, r3
	switch (PageStatus0)
 80182e6:	d049      	beq.n	801837c <EE_Init+0xac>
 80182e8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80182ec:	428c      	cmp	r4, r1
 80182ee:	d036      	beq.n	801835e <EE_Init+0x8e>
 80182f0:	b124      	cbz	r4, 80182fc <EE_Init+0x2c>
		FlashStatus = EE_Format();
 80182f2:	f7ff ff9d 	bl	8018230 <EE_Format>
 80182f6:	b280      	uxth	r0, r0
}
 80182f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 80182fc:	2b00      	cmp	r3, #0
 80182fe:	d0f8      	beq.n	80182f2 <EE_Init+0x22>
		else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 8018300:	428b      	cmp	r3, r1
 8018302:	d064      	beq.n	80183ce <EE_Init+0xfe>
 8018304:	4d3e      	ldr	r5, [pc, #248]	; (8018400 <EE_Init+0x130>)
				if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8018306:	4f3f      	ldr	r7, [pc, #252]	; (8018404 <EE_Init+0x134>)
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018308:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8018408 <EE_Init+0x138>
	int16_t x = -1;
 801830c:	f04f 36ff 	mov.w	r6, #4294967295
				if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8018310:	f835 3b02 	ldrh.w	r3, [r5], #2
 8018314:	883a      	ldrh	r2, [r7, #0]
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018316:	493c      	ldr	r1, [pc, #240]	; (8018408 <EE_Init+0x138>)
				if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8018318:	4293      	cmp	r3, r2
					x = VarIdx;
 801831a:	bf08      	it	eq
 801831c:	b226      	sxtheq	r6, r4
				if (VarIdx != x)
 801831e:	42b4      	cmp	r4, r6
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018320:	4618      	mov	r0, r3
 8018322:	f104 0401 	add.w	r4, r4, #1
				if (VarIdx != x)
 8018326:	d00b      	beq.n	8018340 <EE_Init+0x70>
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018328:	f7ff ff9a 	bl	8018260 <EE_ReadVariable>
					if (ReadStatus != 0x1)
 801832c:	2801      	cmp	r0, #1
 801832e:	d007      	beq.n	8018340 <EE_Init+0x70>
						EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8018330:	f8b8 1000 	ldrh.w	r1, [r8]
 8018334:	f835 0c02 	ldrh.w	r0, [r5, #-2]
 8018338:	f7ff ff22 	bl	8018180 <EE_VerifyPageFullWriteVariable>
						if (EepromStatus != FLASH_COMPLETE)
 801833c:	2809      	cmp	r0, #9
 801833e:	d1db      	bne.n	80182f8 <EE_Init+0x28>
			for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8018340:	f5b4 7f8f 	cmp.w	r4, #286	; 0x11e
 8018344:	d1e4      	bne.n	8018310 <EE_Init+0x40>
			FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 8018346:	2100      	movs	r1, #0
 8018348:	482c      	ldr	r0, [pc, #176]	; (80183fc <EE_Init+0x12c>)
 801834a:	f00b ff21 	bl	8024190 <FLASH_ProgramHalfWord>
 801834e:	b280      	uxth	r0, r0
			if (FlashStatus != FLASH_COMPLETE)
 8018350:	2809      	cmp	r0, #9
 8018352:	d1d1      	bne.n	80182f8 <EE_Init+0x28>
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE0_ID, VOLTAGE_RANGE);
 8018354:	2008      	movs	r0, #8
}
 8018356:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE0_ID, VOLTAGE_RANGE);
 801835a:	f7ff bf51 	b.w	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
		if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 801835e:	2b00      	cmp	r3, #0
 8018360:	d0f8      	beq.n	8018354 <EE_Init+0x84>
		else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 8018362:	4293      	cmp	r3, r2
 8018364:	d1c5      	bne.n	80182f2 <EE_Init+0x22>
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE0_ID, VOLTAGE_RANGE);
 8018366:	2008      	movs	r0, #8
 8018368:	f7ff ff4a 	bl	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
			if (FlashStatus != FLASH_COMPLETE)
 801836c:	2809      	cmp	r0, #9
 801836e:	d1c3      	bne.n	80182f8 <EE_Init+0x28>
			FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 8018370:	4630      	mov	r0, r6
 8018372:	2100      	movs	r1, #0
 8018374:	f00b ff0c 	bl	8024190 <FLASH_ProgramHalfWord>
 8018378:	b280      	uxth	r0, r0
 801837a:	e7bd      	b.n	80182f8 <EE_Init+0x28>
		if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 801837c:	bb63      	cbnz	r3, 80183d8 <EE_Init+0x108>
 801837e:	4d20      	ldr	r5, [pc, #128]	; (8018400 <EE_Init+0x130>)
				if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8018380:	4e22      	ldr	r6, [pc, #136]	; (801840c <EE_Init+0x13c>)
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018382:	4f21      	ldr	r7, [pc, #132]	; (8018408 <EE_Init+0x138>)
		if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 8018384:	461c      	mov	r4, r3
	int16_t x = -1;
 8018386:	f04f 38ff 	mov.w	r8, #4294967295
				if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 801838a:	f835 3b02 	ldrh.w	r3, [r5], #2
 801838e:	8832      	ldrh	r2, [r6, #0]
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018390:	491d      	ldr	r1, [pc, #116]	; (8018408 <EE_Init+0x138>)
				if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8018392:	4293      	cmp	r3, r2
					x = VarIdx;
 8018394:	bf08      	it	eq
 8018396:	fa0f f884 	sxtheq.w	r8, r4
				if (VarIdx != x)
 801839a:	4544      	cmp	r4, r8
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 801839c:	4618      	mov	r0, r3
 801839e:	f104 0401 	add.w	r4, r4, #1
				if (VarIdx != x)
 80183a2:	d00a      	beq.n	80183ba <EE_Init+0xea>
					ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 80183a4:	f7ff ff5c 	bl	8018260 <EE_ReadVariable>
					if (ReadStatus != 0x1)
 80183a8:	2801      	cmp	r0, #1
 80183aa:	d006      	beq.n	80183ba <EE_Init+0xea>
						EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 80183ac:	8839      	ldrh	r1, [r7, #0]
 80183ae:	f835 0c02 	ldrh.w	r0, [r5, #-2]
 80183b2:	f7ff fee5 	bl	8018180 <EE_VerifyPageFullWriteVariable>
						if (EepromStatus != FLASH_COMPLETE)
 80183b6:	2809      	cmp	r0, #9
 80183b8:	d19e      	bne.n	80182f8 <EE_Init+0x28>
			for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80183ba:	f5b4 7f8f 	cmp.w	r4, #286	; 0x11e
 80183be:	d1e4      	bne.n	801838a <EE_Init+0xba>
			FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 80183c0:	2100      	movs	r1, #0
 80183c2:	480d      	ldr	r0, [pc, #52]	; (80183f8 <EE_Init+0x128>)
 80183c4:	f00b fee4 	bl	8024190 <FLASH_ProgramHalfWord>
 80183c8:	b280      	uxth	r0, r0
			if (FlashStatus != FLASH_COMPLETE)
 80183ca:	2809      	cmp	r0, #9
 80183cc:	d194      	bne.n	80182f8 <EE_Init+0x28>
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE1_ID, VOLTAGE_RANGE);
 80183ce:	2010      	movs	r0, #16
}
 80183d0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE1_ID, VOLTAGE_RANGE);
 80183d4:	f7ff bf14 	b.w	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
		else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 80183d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80183dc:	4293      	cmp	r3, r2
 80183de:	d188      	bne.n	80182f2 <EE_Init+0x22>
			FlashStatus = EE_EraseSectorIfNotEmpty(PAGE1_ID, VOLTAGE_RANGE);
 80183e0:	2010      	movs	r0, #16
 80183e2:	f7ff ff0d 	bl	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
			if (FlashStatus != FLASH_COMPLETE)
 80183e6:	2809      	cmp	r0, #9
 80183e8:	d186      	bne.n	80182f8 <EE_Init+0x28>
			FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 80183ea:	4628      	mov	r0, r5
 80183ec:	2100      	movs	r1, #0
 80183ee:	f00b fecf 	bl	8024190 <FLASH_ProgramHalfWord>
 80183f2:	b280      	uxth	r0, r0
 80183f4:	e780      	b.n	80182f8 <EE_Init+0x28>
 80183f6:	bf00      	nop
 80183f8:	08004000 	.word	0x08004000
 80183fc:	08008000 	.word	0x08008000
 8018400:	20007e14 	.word	0x20007e14
 8018404:	08008006 	.word	0x08008006
 8018408:	2000833c 	.word	0x2000833c
 801840c:	08004006 	.word	0x08004006

08018410 <EE_WriteVariable>:
{
 8018410:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8018414:	4606      	mov	r6, r0
 8018416:	460d      	mov	r5, r1
	Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8018418:	f7ff feb2 	bl	8018180 <EE_VerifyPageFullWriteVariable>
	if (Status == PAGE_FULL)
 801841c:	2880      	cmp	r0, #128	; 0x80
	Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 801841e:	4604      	mov	r4, r0
	if (Status == PAGE_FULL)
 8018420:	d002      	beq.n	8018428 <EE_WriteVariable+0x18>
}
 8018422:	4620      	mov	r0, r4
 8018424:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018428:	4925      	ldr	r1, [pc, #148]	; (80184c0 <EE_WriteVariable+0xb0>)
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 801842a:	4f26      	ldr	r7, [pc, #152]	; (80184c4 <EE_WriteVariable+0xb4>)
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801842c:	880b      	ldrh	r3, [r1, #0]
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 801842e:	883a      	ldrh	r2, [r7, #0]
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8018430:	b29b      	uxth	r3, r3
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8018432:	b292      	uxth	r2, r2
		if (PageStatus0 == VALID_PAGE)
 8018434:	b173      	cbz	r3, 8018454 <EE_WriteVariable+0x44>
		else if (PageStatus1 == VALID_PAGE)
 8018436:	b982      	cbnz	r2, 801845a <EE_WriteVariable+0x4a>
		NewPageAddress = PAGE0_BASE_ADDRESS;
 8018438:	460f      	mov	r7, r1
		OldPageId = PAGE1_ID;
 801843a:	f04f 0810 	mov.w	r8, #16
	FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
 801843e:	f64e 61ee 	movw	r1, #61166	; 0xeeee
 8018442:	4638      	mov	r0, r7
 8018444:	f00b fea4 	bl	8024190 <FLASH_ProgramHalfWord>
	if (FlashStatus != FLASH_COMPLETE)
 8018448:	2809      	cmp	r0, #9
 801844a:	d008      	beq.n	801845e <EE_WriteVariable+0x4e>
		return FlashStatus;
 801844c:	b284      	uxth	r4, r0
}
 801844e:	4620      	mov	r0, r4
 8018450:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		OldPageId = PAGE0_ID;
 8018454:	f04f 0808 	mov.w	r8, #8
 8018458:	e7f1      	b.n	801843e <EE_WriteVariable+0x2e>
		return NO_VALID_PAGE;       /* No valid Page */
 801845a:	24ab      	movs	r4, #171	; 0xab
 801845c:	e7e1      	b.n	8018422 <EE_WriteVariable+0x12>
	EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 801845e:	4629      	mov	r1, r5
 8018460:	4630      	mov	r0, r6
 8018462:	f7ff fe8d 	bl	8018180 <EE_VerifyPageFullWriteVariable>
	if (EepromStatus != FLASH_COMPLETE)
 8018466:	2809      	cmp	r0, #9
	EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8018468:	4604      	mov	r4, r0
	if (EepromStatus != FLASH_COMPLETE)
 801846a:	d1da      	bne.n	8018422 <EE_WriteVariable+0x12>
 801846c:	4d16      	ldr	r5, [pc, #88]	; (80184c8 <EE_WriteVariable+0xb8>)
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 801846e:	f8df a05c 	ldr.w	sl, [pc, #92]	; 80184cc <EE_WriteVariable+0xbc>
 8018472:	f505 790f 	add.w	r9, r5, #572	; 0x23c
 8018476:	e001      	b.n	801847c <EE_WriteVariable+0x6c>
	for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8018478:	454d      	cmp	r5, r9
 801847a:	d013      	beq.n	80184a4 <EE_WriteVariable+0x94>
		if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 801847c:	f835 3b02 	ldrh.w	r3, [r5], #2
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018480:	4912      	ldr	r1, [pc, #72]	; (80184cc <EE_WriteVariable+0xbc>)
		if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8018482:	429e      	cmp	r6, r3
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018484:	4618      	mov	r0, r3
		if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8018486:	d0f7      	beq.n	8018478 <EE_WriteVariable+0x68>
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8018488:	f7ff feea 	bl	8018260 <EE_ReadVariable>
			if (ReadStatus != 0x1)
 801848c:	2801      	cmp	r0, #1
 801848e:	d0f3      	beq.n	8018478 <EE_WriteVariable+0x68>
				EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8018490:	f8ba 1000 	ldrh.w	r1, [sl]
 8018494:	f835 0c02 	ldrh.w	r0, [r5, #-2]
 8018498:	f7ff fe72 	bl	8018180 <EE_VerifyPageFullWriteVariable>
				if (EepromStatus != FLASH_COMPLETE)
 801849c:	2809      	cmp	r0, #9
 801849e:	d0eb      	beq.n	8018478 <EE_WriteVariable+0x68>
 80184a0:	4604      	mov	r4, r0
 80184a2:	e7be      	b.n	8018422 <EE_WriteVariable+0x12>
	FlashStatus = EE_EraseSectorIfNotEmpty(OldPageId, VOLTAGE_RANGE);
 80184a4:	4640      	mov	r0, r8
 80184a6:	f7ff feab 	bl	8018200 <EE_EraseSectorIfNotEmpty.constprop.1>
	if (FlashStatus != FLASH_COMPLETE)
 80184aa:	b2c0      	uxtb	r0, r0
 80184ac:	2809      	cmp	r0, #9
 80184ae:	d1cd      	bne.n	801844c <EE_WriteVariable+0x3c>
	FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
 80184b0:	4638      	mov	r0, r7
 80184b2:	2100      	movs	r1, #0
 80184b4:	f00b fe6c 	bl	8024190 <FLASH_ProgramHalfWord>
	if (FlashStatus != FLASH_COMPLETE)
 80184b8:	2809      	cmp	r0, #9
 80184ba:	d1c7      	bne.n	801844c <EE_WriteVariable+0x3c>
 80184bc:	e7b1      	b.n	8018422 <EE_WriteVariable+0x12>
 80184be:	bf00      	nop
 80184c0:	08004000 	.word	0x08004000
 80184c4:	08008000 	.word	0x08008000
 80184c8:	20007e14 	.word	0x20007e14
 80184cc:	2000833c 	.word	0x2000833c

080184d0 <detect_thread>:
	send_buffer[ind++] = appconf->app_nrf_conf.send_crc_ack;

	commands_send_packet(send_buffer, ind);
}

static THD_FUNCTION(detect_thread, arg) {
 80184d0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80184d4:	4b35      	ldr	r3, [pc, #212]	; (80185ac <detect_thread+0xdc>)
	(void)arg;

	chRegSetThreadName("Detect");

	detect_tp = chThdGetSelfX();
 80184d6:	4a36      	ldr	r2, [pc, #216]	; (80185b0 <detect_thread+0xe0>)
 80184d8:	699b      	ldr	r3, [r3, #24]
 80184da:	4d36      	ldr	r5, [pc, #216]	; (80185b4 <detect_thread+0xe4>)
 80184dc:	4936      	ldr	r1, [pc, #216]	; (80185b8 <detect_thread+0xe8>)
 80184de:	4e37      	ldr	r6, [pc, #220]	; (80185bc <detect_thread+0xec>)
 80184e0:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 80185d4 <detect_thread+0x104>
 80184e4:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 80185dc <detect_thread+0x10c>
 80184e8:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 80185e0 <detect_thread+0x110>
 80184ec:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 80185e4 <detect_thread+0x114>
 80184f0:	ed9f 8a33 	vldr	s16, [pc, #204]	; 80185c0 <detect_thread+0xf0>
		chEvtWaitAny((eventmask_t) 1);

		if (!conf_general_detect_motor_param(detect_current, detect_min_rpm,
				detect_low_duty, &detect_cycle_int_limit, &detect_coupling_k,
				detect_hall_table, &detect_hall_res)) {
			detect_cycle_int_limit = 0.0;
 80184f4:	eddf 8a33 	vldr	s17, [pc, #204]	; 80185c4 <detect_thread+0xf4>
 80184f8:	6199      	str	r1, [r3, #24]
static THD_FUNCTION(detect_thread, arg) {
 80184fa:	b085      	sub	sp, #20
	detect_tp = chThdGetSelfX();
 80184fc:	6013      	str	r3, [r2, #0]
			detect_coupling_k = 0.0;
		}

		int32_t ind = 0;
		send_buffer[ind++] = COMM_DETECT_MOTOR_PARAM;
		buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
 80184fe:	462c      	mov	r4, r5
 8018500:	e037      	b.n	8018572 <detect_thread+0xa2>
 8018502:	eddb 7a00 	vldr	s15, [fp]
 8018506:	ee67 7a88 	vmul.f32	s15, s15, s16
 801850a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801850e:	edcd 7a01 	vstr	s15, [sp, #4]
		send_buffer[ind++] = COMM_DETECT_MOTOR_PARAM;
 8018512:	2001      	movs	r0, #1
 8018514:	2318      	movs	r3, #24
		buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
 8018516:	aa03      	add	r2, sp, #12
 8018518:	9901      	ldr	r1, [sp, #4]
		send_buffer[ind++] = COMM_DETECT_MOTOR_PARAM;
 801851a:	9003      	str	r0, [sp, #12]
		buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
 801851c:	4620      	mov	r0, r4
		send_buffer[ind++] = COMM_DETECT_MOTOR_PARAM;
 801851e:	702b      	strb	r3, [r5, #0]
		buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
 8018520:	f7f9 fb2e 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, (int32_t)(detect_coupling_k * 1000.0), &ind);
 8018524:	edd6 7a00 	vldr	s15, [r6]
		memcpy(send_buffer + ind, detect_hall_table, 8);
		ind += 8;
		send_buffer[ind++] = detect_hall_res;
 8018528:	4f27      	ldr	r7, [pc, #156]	; (80185c8 <detect_thread+0xf8>)
		buffer_append_int32(send_buffer, (int32_t)(detect_coupling_k * 1000.0), &ind);
 801852a:	ee67 7a88 	vmul.f32	s15, s15, s16
 801852e:	aa03      	add	r2, sp, #12
 8018530:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8018534:	4620      	mov	r0, r4
 8018536:	ee17 1a90 	vmov	r1, s15
 801853a:	f7f9 fb21 	bl	8011b80 <buffer_append_int32>
		memcpy(send_buffer + ind, detect_hall_table, 8);
 801853e:	f8df c090 	ldr.w	ip, [pc, #144]	; 80185d0 <detect_thread+0x100>
 8018542:	9b03      	ldr	r3, [sp, #12]

		if (send_func_last) {
 8018544:	4a21      	ldr	r2, [pc, #132]	; (80185cc <detect_thread+0xfc>)
		send_buffer[ind++] = detect_hall_res;
 8018546:	f8d7 e000 	ldr.w	lr, [r7]
		if (send_func_last) {
 801854a:	6812      	ldr	r2, [r2, #0]
		send_buffer[ind++] = detect_hall_res;
 801854c:	f88d e004 	strb.w	lr, [sp, #4]
		memcpy(send_buffer + ind, detect_hall_table, 8);
 8018550:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8018554:	eb05 0c03 	add.w	ip, r5, r3
 8018558:	50e8      	str	r0, [r5, r3]
		send_buffer[ind++] = detect_hall_res;
 801855a:	fa5f f78e 	uxtb.w	r7, lr
 801855e:	3309      	adds	r3, #9
		memcpy(send_buffer + ind, detect_hall_table, 8);
 8018560:	f8cc 1004 	str.w	r1, [ip, #4]
			send_func_last(send_buffer, ind);
 8018564:	4620      	mov	r0, r4
		send_buffer[ind++] = detect_hall_res;
 8018566:	9303      	str	r3, [sp, #12]
			send_func_last(send_buffer, ind);
 8018568:	4619      	mov	r1, r3
		send_buffer[ind++] = detect_hall_res;
 801856a:	f88c 7008 	strb.w	r7, [ip, #8]
		if (send_func_last) {
 801856e:	b1ba      	cbz	r2, 80185a0 <detect_thread+0xd0>
			send_func_last(send_buffer, ind);
 8018570:	4790      	blx	r2
		chEvtWaitAny((eventmask_t) 1);
 8018572:	2001      	movs	r0, #1
 8018574:	f7f5 fc94 	bl	800dea0 <chEvtWaitAny>
		if (!conf_general_detect_motor_param(detect_current, detect_min_rpm,
 8018578:	4b13      	ldr	r3, [pc, #76]	; (80185c8 <detect_thread+0xf8>)
 801857a:	4a15      	ldr	r2, [pc, #84]	; (80185d0 <detect_thread+0x100>)
 801857c:	490f      	ldr	r1, [pc, #60]	; (80185bc <detect_thread+0xec>)
 801857e:	4815      	ldr	r0, [pc, #84]	; (80185d4 <detect_thread+0x104>)
 8018580:	ed9a 1a00 	vldr	s2, [sl]
 8018584:	edd9 0a00 	vldr	s1, [r9]
 8018588:	ed98 0a00 	vldr	s0, [r8]
 801858c:	f7ff fae0 	bl	8017b50 <conf_general_detect_motor_param>
 8018590:	2800      	cmp	r0, #0
 8018592:	d1b6      	bne.n	8018502 <detect_thread+0x32>
			detect_cycle_int_limit = 0.0;
 8018594:	edcb 8a00 	vstr	s17, [fp]
			detect_coupling_k = 0.0;
 8018598:	edc6 8a00 	vstr	s17, [r6]
 801859c:	9001      	str	r0, [sp, #4]
 801859e:	e7b8      	b.n	8018512 <detect_thread+0x42>
	if (send_func) {
 80185a0:	4b0d      	ldr	r3, [pc, #52]	; (80185d8 <detect_thread+0x108>)
 80185a2:	681b      	ldr	r3, [r3, #0]
 80185a4:	2b00      	cmp	r3, #0
 80185a6:	d0e4      	beq.n	8018572 <detect_thread+0xa2>
		send_func(data, len);
 80185a8:	4798      	blx	r3
	for(;;) {
 80185aa:	e7e2      	b.n	8018572 <detect_thread+0xa2>
 80185ac:	20001a48 	.word	0x20001a48
 80185b0:	20008d00 	.word	0x20008d00
 80185b4:	200090f0 	.word	0x200090f0
 80185b8:	0802f230 	.word	0x0802f230
 80185bc:	20008344 	.word	0x20008344
 80185c0:	447a0000 	.word	0x447a0000
 80185c4:	00000000 	.word	0x00000000
 80185c8:	20008350 	.word	0x20008350
 80185cc:	200094f4 	.word	0x200094f4
 80185d0:	20008354 	.word	0x20008354
 80185d4:	2000834c 	.word	0x2000834c
 80185d8:	200094f0 	.word	0x200094f0
 80185dc:	2000835c 	.word	0x2000835c
 80185e0:	20008360 	.word	0x20008360
 80185e4:	20008348 	.word	0x20008348
	...

080185f0 <commands_init>:
void commands_init(void) {
 80185f0:	b500      	push	{lr}
 80185f2:	b083      	sub	sp, #12
	chThdCreateStatic(detect_thread_wa, sizeof(detect_thread_wa), NORMALPRIO, detect_thread, NULL);
 80185f4:	2300      	movs	r3, #0
 80185f6:	9300      	str	r3, [sp, #0]
 80185f8:	2240      	movs	r2, #64	; 0x40
 80185fa:	4b04      	ldr	r3, [pc, #16]	; (801860c <commands_init+0x1c>)
 80185fc:	4804      	ldr	r0, [pc, #16]	; (8018610 <commands_init+0x20>)
 80185fe:	f640 1198 	movw	r1, #2456	; 0x998
 8018602:	f7f5 f9b5 	bl	800d970 <chThdCreateStatic>
}
 8018606:	b003      	add	sp, #12
 8018608:	f85d fb04 	ldr.w	pc, [sp], #4
 801860c:	080184d1 	.word	0x080184d1
 8018610:	20008368 	.word	0x20008368
	...

08018620 <commands_set_send_func>:
	send_func = func;
 8018620:	4b01      	ldr	r3, [pc, #4]	; (8018628 <commands_set_send_func+0x8>)
 8018622:	6018      	str	r0, [r3, #0]
}
 8018624:	4770      	bx	lr
 8018626:	bf00      	nop
 8018628:	200094f0 	.word	0x200094f0
 801862c:	00000000 	.word	0x00000000

08018630 <commands_send_packet>:
	if (send_func) {
 8018630:	4b02      	ldr	r3, [pc, #8]	; (801863c <commands_send_packet+0xc>)
 8018632:	681b      	ldr	r3, [r3, #0]
 8018634:	b103      	cbz	r3, 8018638 <commands_send_packet+0x8>
		send_func(data, len);
 8018636:	4718      	bx	r3
}
 8018638:	4770      	bx	lr
 801863a:	bf00      	nop
 801863c:	200094f0 	.word	0x200094f0

08018640 <commands_printf>:
void commands_printf(const char* format, ...) {
 8018640:	b40f      	push	{r0, r1, r2, r3}
 8018642:	b510      	push	{r4, lr}
	print_buffer[0] = COMM_PRINT;
 8018644:	4c0e      	ldr	r4, [pc, #56]	; (8018680 <commands_printf+0x40>)
void commands_printf(const char* format, ...) {
 8018646:	b082      	sub	sp, #8
 8018648:	ab04      	add	r3, sp, #16
	print_buffer[0] = COMM_PRINT;
 801864a:	4620      	mov	r0, r4
 801864c:	2115      	movs	r1, #21
void commands_printf(const char* format, ...) {
 801864e:	f853 2b04 	ldr.w	r2, [r3], #4
	print_buffer[0] = COMM_PRINT;
 8018652:	f800 1b01 	strb.w	r1, [r0], #1
	len = vsnprintf(print_buffer+1, 254, format, arg);
 8018656:	21fe      	movs	r1, #254	; 0xfe
	va_start (arg, format);
 8018658:	9301      	str	r3, [sp, #4]
	len = vsnprintf(print_buffer+1, 254, format, arg);
 801865a:	f00f fad1 	bl	8027c00 <vsnprintf>
	if(len > 0) {
 801865e:	2800      	cmp	r0, #0
 8018660:	dd08      	ble.n	8018674 <commands_printf+0x34>
	if (send_func) {
 8018662:	4b08      	ldr	r3, [pc, #32]	; (8018684 <commands_printf+0x44>)
		commands_send_packet((unsigned char*)print_buffer, (len<254)? len+1: 255);
 8018664:	28fe      	cmp	r0, #254	; 0xfe
	if (send_func) {
 8018666:	681b      	ldr	r3, [r3, #0]
		commands_send_packet((unsigned char*)print_buffer, (len<254)? len+1: 255);
 8018668:	bfa8      	it	ge
 801866a:	20fe      	movge	r0, #254	; 0xfe
 801866c:	1c41      	adds	r1, r0, #1
	if (send_func) {
 801866e:	b10b      	cbz	r3, 8018674 <commands_printf+0x34>
		send_func(data, len);
 8018670:	4620      	mov	r0, r4
 8018672:	4798      	blx	r3
}
 8018674:	b002      	add	sp, #8
 8018676:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801867a:	b004      	add	sp, #16
 801867c:	4770      	bx	lr
 801867e:	bf00      	nop
 8018680:	20008ff0 	.word	0x20008ff0
 8018684:	200094f0 	.word	0x200094f0
	...

08018690 <commands_send_rotor_pos>:
void commands_send_rotor_pos(float rotor_pos) {
 8018690:	b510      	push	{r4, lr}
	buffer_append_int32(buffer, (int32_t)(rotor_pos * 100000.0), &index);
 8018692:	eddf 7a0d 	vldr	s15, [pc, #52]	; 80186c8 <commands_send_rotor_pos+0x38>
 8018696:	ee20 0a27 	vmul.f32	s0, s0, s15
void commands_send_rotor_pos(float rotor_pos) {
 801869a:	b084      	sub	sp, #16
	buffer_append_int32(buffer, (int32_t)(rotor_pos * 100000.0), &index);
 801869c:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	buffer[index++] = COMM_ROTOR_POSITION;
 80186a0:	2316      	movs	r3, #22
	buffer_append_int32(buffer, (int32_t)(rotor_pos * 100000.0), &index);
 80186a2:	ee17 1a90 	vmov	r1, s15
 80186a6:	a802      	add	r0, sp, #8
	buffer[index++] = COMM_ROTOR_POSITION;
 80186a8:	2401      	movs	r4, #1
	buffer_append_int32(buffer, (int32_t)(rotor_pos * 100000.0), &index);
 80186aa:	aa01      	add	r2, sp, #4
	buffer[index++] = COMM_ROTOR_POSITION;
 80186ac:	f88d 3008 	strb.w	r3, [sp, #8]
 80186b0:	9401      	str	r4, [sp, #4]
	buffer_append_int32(buffer, (int32_t)(rotor_pos * 100000.0), &index);
 80186b2:	f7f9 fa65 	bl	8011b80 <buffer_append_int32>
	if (send_func) {
 80186b6:	4b05      	ldr	r3, [pc, #20]	; (80186cc <commands_send_rotor_pos+0x3c>)
	commands_send_packet(buffer, index);
 80186b8:	9901      	ldr	r1, [sp, #4]
	if (send_func) {
 80186ba:	681b      	ldr	r3, [r3, #0]
 80186bc:	b10b      	cbz	r3, 80186c2 <commands_send_rotor_pos+0x32>
		send_func(data, len);
 80186be:	a802      	add	r0, sp, #8
 80186c0:	4798      	blx	r3
}
 80186c2:	b004      	add	sp, #16
 80186c4:	bd10      	pop	{r4, pc}
 80186c6:	bf00      	nop
 80186c8:	47c35000 	.word	0x47c35000
 80186cc:	200094f0 	.word	0x200094f0

080186d0 <commands_get_disp_pos_mode>:
	return display_position_mode;
 80186d0:	4b01      	ldr	r3, [pc, #4]	; (80186d8 <commands_get_disp_pos_mode+0x8>)
}
 80186d2:	7818      	ldrb	r0, [r3, #0]
 80186d4:	4770      	bx	lr
 80186d6:	bf00      	nop
 80186d8:	20008d04 	.word	0x20008d04
 80186dc:	00000000 	.word	0x00000000

080186e0 <commands_send_appconf>:
void commands_send_appconf(COMM_PACKET_ID packet_id, app_configuration *appconf) {
 80186e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	send_buffer[ind++] = packet_id;
 80186e2:	4daf      	ldr	r5, [pc, #700]	; (80189a0 <commands_send_appconf+0x2c0>)
void commands_send_appconf(COMM_PACKET_ID packet_id, app_configuration *appconf) {
 80186e4:	b083      	sub	sp, #12
	send_buffer[ind++] = appconf->controller_id;
 80186e6:	ae02      	add	r6, sp, #8
	send_buffer[ind++] = packet_id;
 80186e8:	7028      	strb	r0, [r5, #0]
	send_buffer[ind++] = appconf->controller_id;
 80186ea:	2202      	movs	r2, #2
 80186ec:	f846 2d04 	str.w	r2, [r6, #-4]!
 80186f0:	780b      	ldrb	r3, [r1, #0]
 80186f2:	706b      	strb	r3, [r5, #1]
void commands_send_appconf(COMM_PACKET_ID packet_id, app_configuration *appconf) {
 80186f4:	460c      	mov	r4, r1
	buffer_append_uint32(send_buffer, appconf->timeout_msec, &ind);
 80186f6:	4632      	mov	r2, r6
 80186f8:	6849      	ldr	r1, [r1, #4]
 80186fa:	4628      	mov	r0, r5
 80186fc:	f7f9 fa58 	bl	8011bb0 <buffer_append_uint32>
	buffer_append_float32_auto(send_buffer, appconf->timeout_brake_current, &ind);
 8018700:	4631      	mov	r1, r6
 8018702:	ed94 0a02 	vldr	s0, [r4, #8]
 8018706:	4628      	mov	r0, r5
 8018708:	f7f9 fa92 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->send_can_status;
 801870c:	9b01      	ldr	r3, [sp, #4]
 801870e:	7b22      	ldrb	r2, [r4, #12]
 8018710:	54ea      	strb	r2, [r5, r3]
	buffer_append_uint16(send_buffer, appconf->send_can_status_rate_hz, &ind);
 8018712:	4628      	mov	r0, r5
	send_buffer[ind++] = appconf->send_can_status;
 8018714:	3301      	adds	r3, #1
	buffer_append_uint16(send_buffer, appconf->send_can_status_rate_hz, &ind);
 8018716:	4632      	mov	r2, r6
 8018718:	8a21      	ldrh	r1, [r4, #16]
	send_buffer[ind++] = appconf->send_can_status;
 801871a:	9301      	str	r3, [sp, #4]
	buffer_append_uint16(send_buffer, appconf->send_can_status_rate_hz, &ind);
 801871c:	f7f9 fa20 	bl	8011b60 <buffer_append_uint16>
	send_buffer[ind++] = appconf->can_baud_rate;
 8018720:	9b01      	ldr	r3, [sp, #4]
 8018722:	7d22      	ldrb	r2, [r4, #20]
 8018724:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_to_use;
 8018726:	18ea      	adds	r2, r5, r3
 8018728:	7d61      	ldrb	r1, [r4, #21]
 801872a:	7051      	strb	r1, [r2, #1]
	send_buffer[ind++] = appconf->app_ppm_conf.ctrl_type;
 801872c:	7e21      	ldrb	r1, [r4, #24]
 801872e:	7091      	strb	r1, [r2, #2]
 8018730:	3303      	adds	r3, #3
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.pid_max_erpm, &ind);
 8018732:	4631      	mov	r1, r6
 8018734:	ed94 0a07 	vldr	s0, [r4, #28]
	send_buffer[ind++] = appconf->app_ppm_conf.ctrl_type;
 8018738:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.pid_max_erpm, &ind);
 801873a:	4628      	mov	r0, r5
 801873c:	f7f9 fa78 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.hyst, &ind);
 8018740:	4631      	mov	r1, r6
 8018742:	ed94 0a08 	vldr	s0, [r4, #32]
 8018746:	4628      	mov	r0, r5
 8018748:	f7f9 fa72 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.pulse_start, &ind);
 801874c:	4631      	mov	r1, r6
 801874e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8018752:	4628      	mov	r0, r5
 8018754:	f7f9 fa6c 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.pulse_end, &ind);
 8018758:	4631      	mov	r1, r6
 801875a:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 801875e:	4628      	mov	r0, r5
 8018760:	f7f9 fa66 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.pulse_center, &ind);
 8018764:	4631      	mov	r1, r6
 8018766:	ed94 0a0b 	vldr	s0, [r4, #44]	; 0x2c
 801876a:	4628      	mov	r0, r5
 801876c:	f7f9 fa60 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_ppm_conf.median_filter;
 8018770:	9b01      	ldr	r3, [sp, #4]
 8018772:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 8018776:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_ppm_conf.safe_start;
 8018778:	18ea      	adds	r2, r5, r3
 801877a:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
 801877e:	7051      	strb	r1, [r2, #1]
 8018780:	3302      	adds	r3, #2
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.throttle_exp, &ind);
 8018782:	4631      	mov	r1, r6
 8018784:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
	send_buffer[ind++] = appconf->app_ppm_conf.safe_start;
 8018788:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.throttle_exp, &ind);
 801878a:	4628      	mov	r0, r5
 801878c:	f7f9 fa50 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.throttle_exp_brake, &ind);
 8018790:	4631      	mov	r1, r6
 8018792:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 8018796:	4628      	mov	r0, r5
 8018798:	f7f9 fa4a 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_ppm_conf.throttle_exp_mode;
 801879c:	9b01      	ldr	r3, [sp, #4]
 801879e:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 80187a2:	54ea      	strb	r2, [r5, r3]
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.ramp_time_pos, &ind);
 80187a4:	4631      	mov	r1, r6
	send_buffer[ind++] = appconf->app_ppm_conf.throttle_exp_mode;
 80187a6:	3301      	adds	r3, #1
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.ramp_time_pos, &ind);
 80187a8:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
	send_buffer[ind++] = appconf->app_ppm_conf.throttle_exp_mode;
 80187ac:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.ramp_time_pos, &ind);
 80187ae:	4628      	mov	r0, r5
 80187b0:	f7f9 fa3e 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.ramp_time_neg, &ind);
 80187b4:	4631      	mov	r1, r6
 80187b6:	ed94 0a11 	vldr	s0, [r4, #68]	; 0x44
 80187ba:	4628      	mov	r0, r5
 80187bc:	f7f9 fa38 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_ppm_conf.multi_esc;
 80187c0:	9b01      	ldr	r3, [sp, #4]
 80187c2:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 80187c6:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_ppm_conf.tc;
 80187c8:	18ea      	adds	r2, r5, r3
 80187ca:	f894 1049 	ldrb.w	r1, [r4, #73]	; 0x49
 80187ce:	7051      	strb	r1, [r2, #1]
 80187d0:	3302      	adds	r3, #2
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.tc_max_diff, &ind);
 80187d2:	4631      	mov	r1, r6
 80187d4:	ed94 0a13 	vldr	s0, [r4, #76]	; 0x4c
	send_buffer[ind++] = appconf->app_ppm_conf.tc;
 80187d8:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_ppm_conf.tc_max_diff, &ind);
 80187da:	4628      	mov	r0, r5
 80187dc:	f7f9 fa28 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_adc_conf.ctrl_type;
 80187e0:	9b01      	ldr	r3, [sp, #4]
 80187e2:	f894 2050 	ldrb.w	r2, [r4, #80]	; 0x50
 80187e6:	54ea      	strb	r2, [r5, r3]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.hyst, &ind);
 80187e8:	4631      	mov	r1, r6
	send_buffer[ind++] = appconf->app_adc_conf.ctrl_type;
 80187ea:	3301      	adds	r3, #1
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.hyst, &ind);
 80187ec:	ed94 0a15 	vldr	s0, [r4, #84]	; 0x54
	send_buffer[ind++] = appconf->app_adc_conf.ctrl_type;
 80187f0:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.hyst, &ind);
 80187f2:	4628      	mov	r0, r5
 80187f4:	f7f9 fa1c 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.voltage_start, &ind);
 80187f8:	4631      	mov	r1, r6
 80187fa:	ed94 0a16 	vldr	s0, [r4, #88]	; 0x58
 80187fe:	4628      	mov	r0, r5
 8018800:	f7f9 fa16 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.voltage_end, &ind);
 8018804:	4631      	mov	r1, r6
 8018806:	ed94 0a17 	vldr	s0, [r4, #92]	; 0x5c
 801880a:	4628      	mov	r0, r5
 801880c:	f7f9 fa10 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.voltage_center, &ind);
 8018810:	4631      	mov	r1, r6
 8018812:	ed94 0a18 	vldr	s0, [r4, #96]	; 0x60
 8018816:	4628      	mov	r0, r5
 8018818:	f7f9 fa0a 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.voltage2_start, &ind);
 801881c:	4631      	mov	r1, r6
 801881e:	ed94 0a19 	vldr	s0, [r4, #100]	; 0x64
 8018822:	4628      	mov	r0, r5
 8018824:	f7f9 fa04 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.voltage2_end, &ind);
 8018828:	4631      	mov	r1, r6
 801882a:	ed94 0a1a 	vldr	s0, [r4, #104]	; 0x68
 801882e:	4628      	mov	r0, r5
 8018830:	f7f9 f9fe 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_adc_conf.use_filter;
 8018834:	9b01      	ldr	r3, [sp, #4]
 8018836:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
 801883a:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_adc_conf.safe_start;
 801883c:	18ea      	adds	r2, r5, r3
 801883e:	f894 106d 	ldrb.w	r1, [r4, #109]	; 0x6d
 8018842:	7051      	strb	r1, [r2, #1]
	send_buffer[ind++] = appconf->app_adc_conf.cc_button_inverted;
 8018844:	f894 106e 	ldrb.w	r1, [r4, #110]	; 0x6e
 8018848:	7091      	strb	r1, [r2, #2]
	send_buffer[ind++] = appconf->app_adc_conf.rev_button_inverted;
 801884a:	f894 106f 	ldrb.w	r1, [r4, #111]	; 0x6f
 801884e:	70d1      	strb	r1, [r2, #3]
	send_buffer[ind++] = appconf->app_adc_conf.voltage_inverted;
 8018850:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
 8018854:	7111      	strb	r1, [r2, #4]
	send_buffer[ind++] = appconf->app_adc_conf.voltage2_inverted;
 8018856:	f894 1071 	ldrb.w	r1, [r4, #113]	; 0x71
 801885a:	7151      	strb	r1, [r2, #5]
 801885c:	3306      	adds	r3, #6
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.throttle_exp, &ind);
 801885e:	4631      	mov	r1, r6
 8018860:	ed94 0a1d 	vldr	s0, [r4, #116]	; 0x74
	send_buffer[ind++] = appconf->app_adc_conf.voltage2_inverted;
 8018864:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.throttle_exp, &ind);
 8018866:	4628      	mov	r0, r5
 8018868:	f7f9 f9e2 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.throttle_exp_brake, &ind);
 801886c:	4631      	mov	r1, r6
 801886e:	ed94 0a1e 	vldr	s0, [r4, #120]	; 0x78
 8018872:	4628      	mov	r0, r5
 8018874:	f7f9 f9dc 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_adc_conf.throttle_exp_mode;
 8018878:	9b01      	ldr	r3, [sp, #4]
 801887a:	f894 207c 	ldrb.w	r2, [r4, #124]	; 0x7c
 801887e:	54ea      	strb	r2, [r5, r3]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.ramp_time_pos, &ind);
 8018880:	4631      	mov	r1, r6
	send_buffer[ind++] = appconf->app_adc_conf.throttle_exp_mode;
 8018882:	3301      	adds	r3, #1
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.ramp_time_pos, &ind);
 8018884:	ed94 0a20 	vldr	s0, [r4, #128]	; 0x80
	send_buffer[ind++] = appconf->app_adc_conf.throttle_exp_mode;
 8018888:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.ramp_time_pos, &ind);
 801888a:	4628      	mov	r0, r5
 801888c:	f7f9 f9d0 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.ramp_time_neg, &ind);
 8018890:	4631      	mov	r1, r6
 8018892:	ed94 0a21 	vldr	s0, [r4, #132]	; 0x84
 8018896:	4628      	mov	r0, r5
 8018898:	f7f9 f9ca 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_adc_conf.multi_esc;
 801889c:	9b01      	ldr	r3, [sp, #4]
 801889e:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
 80188a2:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_adc_conf.tc;
 80188a4:	18ea      	adds	r2, r5, r3
 80188a6:	f894 1089 	ldrb.w	r1, [r4, #137]	; 0x89
 80188aa:	7051      	strb	r1, [r2, #1]
 80188ac:	3302      	adds	r3, #2
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.tc_max_diff, &ind);
 80188ae:	ed94 0a23 	vldr	s0, [r4, #140]	; 0x8c
	send_buffer[ind++] = appconf->app_adc_conf.tc;
 80188b2:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_adc_conf.tc_max_diff, &ind);
 80188b4:	4631      	mov	r1, r6
 80188b6:	4628      	mov	r0, r5
 80188b8:	f7f9 f9ba 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_uint16(send_buffer, appconf->app_adc_conf.update_rate_hz, &ind);
 80188bc:	4632      	mov	r2, r6
 80188be:	f8b4 1090 	ldrh.w	r1, [r4, #144]	; 0x90
 80188c2:	4628      	mov	r0, r5
 80188c4:	f7f9 f94c 	bl	8011b60 <buffer_append_uint16>
	buffer_append_uint32(send_buffer, appconf->app_uart_baudrate, &ind);
 80188c8:	4632      	mov	r2, r6
 80188ca:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 80188ce:	4628      	mov	r0, r5
 80188d0:	f7f9 f96e 	bl	8011bb0 <buffer_append_uint32>
	send_buffer[ind++] = appconf->app_chuk_conf.ctrl_type;
 80188d4:	9b01      	ldr	r3, [sp, #4]
 80188d6:	f894 2098 	ldrb.w	r2, [r4, #152]	; 0x98
 80188da:	54ea      	strb	r2, [r5, r3]
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.hyst, &ind);
 80188dc:	4631      	mov	r1, r6
	send_buffer[ind++] = appconf->app_chuk_conf.ctrl_type;
 80188de:	3301      	adds	r3, #1
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.hyst, &ind);
 80188e0:	ed94 0a27 	vldr	s0, [r4, #156]	; 0x9c
	send_buffer[ind++] = appconf->app_chuk_conf.ctrl_type;
 80188e4:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.hyst, &ind);
 80188e6:	4628      	mov	r0, r5
 80188e8:	f7f9 f9a2 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.ramp_time_pos, &ind);
 80188ec:	4631      	mov	r1, r6
 80188ee:	ed94 0a28 	vldr	s0, [r4, #160]	; 0xa0
 80188f2:	4628      	mov	r0, r5
 80188f4:	f7f9 f99c 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.ramp_time_neg, &ind);
 80188f8:	4631      	mov	r1, r6
 80188fa:	ed94 0a29 	vldr	s0, [r4, #164]	; 0xa4
 80188fe:	4628      	mov	r0, r5
 8018900:	f7f9 f996 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.stick_erpm_per_s_in_cc, &ind);
 8018904:	4631      	mov	r1, r6
 8018906:	ed94 0a2a 	vldr	s0, [r4, #168]	; 0xa8
 801890a:	4628      	mov	r0, r5
 801890c:	f7f9 f990 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.throttle_exp, &ind);
 8018910:	4631      	mov	r1, r6
 8018912:	ed94 0a2b 	vldr	s0, [r4, #172]	; 0xac
 8018916:	4628      	mov	r0, r5
 8018918:	f7f9 f98a 	bl	8011c30 <buffer_append_float32_auto>
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.throttle_exp_brake, &ind);
 801891c:	4631      	mov	r1, r6
 801891e:	ed94 0a2c 	vldr	s0, [r4, #176]	; 0xb0
 8018922:	4628      	mov	r0, r5
 8018924:	f7f9 f984 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_chuk_conf.throttle_exp_mode;
 8018928:	9b01      	ldr	r3, [sp, #4]
 801892a:	f894 20b4 	ldrb.w	r2, [r4, #180]	; 0xb4
 801892e:	54ea      	strb	r2, [r5, r3]
	send_buffer[ind++] = appconf->app_chuk_conf.multi_esc;
 8018930:	18ea      	adds	r2, r5, r3
 8018932:	f894 10b5 	ldrb.w	r1, [r4, #181]	; 0xb5
 8018936:	7051      	strb	r1, [r2, #1]
	send_buffer[ind++] = appconf->app_chuk_conf.tc;
 8018938:	f894 10b6 	ldrb.w	r1, [r4, #182]	; 0xb6
 801893c:	7091      	strb	r1, [r2, #2]
 801893e:	3303      	adds	r3, #3
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.tc_max_diff, &ind);
 8018940:	4631      	mov	r1, r6
 8018942:	4628      	mov	r0, r5
 8018944:	ed94 0a2e 	vldr	s0, [r4, #184]	; 0xb8
	send_buffer[ind++] = appconf->app_chuk_conf.tc;
 8018948:	9301      	str	r3, [sp, #4]
	buffer_append_float32_auto(send_buffer, appconf->app_chuk_conf.tc_max_diff, &ind);
 801894a:	f7f9 f971 	bl	8011c30 <buffer_append_float32_auto>
	send_buffer[ind++] = appconf->app_nrf_conf.speed;
 801894e:	9901      	ldr	r1, [sp, #4]
 8018950:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
 8018954:	546b      	strb	r3, [r5, r1]
	send_buffer[ind++] = appconf->app_nrf_conf.power;
 8018956:	186b      	adds	r3, r5, r1
 8018958:	f894 20bd 	ldrb.w	r2, [r4, #189]	; 0xbd
 801895c:	705a      	strb	r2, [r3, #1]
	send_buffer[ind++] = appconf->app_nrf_conf.crc_type;
 801895e:	f894 20be 	ldrb.w	r2, [r4, #190]	; 0xbe
 8018962:	709a      	strb	r2, [r3, #2]
	send_buffer[ind++] = appconf->app_nrf_conf.retry_delay;
 8018964:	f894 20bf 	ldrb.w	r2, [r4, #191]	; 0xbf
 8018968:	70da      	strb	r2, [r3, #3]
	send_buffer[ind++] = appconf->app_nrf_conf.retries;
 801896a:	f894 20c0 	ldrb.w	r2, [r4, #192]	; 0xc0
 801896e:	711a      	strb	r2, [r3, #4]
	send_buffer[ind++] = appconf->app_nrf_conf.channel;
 8018970:	f894 20c1 	ldrb.w	r2, [r4, #193]	; 0xc1
 8018974:	715a      	strb	r2, [r3, #5]
	memcpy(send_buffer + ind, appconf->app_nrf_conf.address, 3);
 8018976:	4620      	mov	r0, r4
	send_buffer[ind++] = appconf->app_nrf_conf.channel;
 8018978:	1d8a      	adds	r2, r1, #6
	memcpy(send_buffer + ind, appconf->app_nrf_conf.address, 3);
 801897a:	f830 7fc2 	ldrh.w	r7, [r0, #194]!
	if (send_func) {
 801897e:	4e09      	ldr	r6, [pc, #36]	; (80189a4 <commands_send_appconf+0x2c4>)
	memcpy(send_buffer + ind, appconf->app_nrf_conf.address, 3);
 8018980:	7880      	ldrb	r0, [r0, #2]
 8018982:	52af      	strh	r7, [r5, r2]
 8018984:	442a      	add	r2, r5
	if (send_func) {
 8018986:	6836      	ldr	r6, [r6, #0]
	memcpy(send_buffer + ind, appconf->app_nrf_conf.address, 3);
 8018988:	7090      	strb	r0, [r2, #2]
	send_buffer[ind++] = appconf->app_nrf_conf.send_crc_ack;
 801898a:	f894 20c5 	ldrb.w	r2, [r4, #197]	; 0xc5
 801898e:	725a      	strb	r2, [r3, #9]
 8018990:	310a      	adds	r1, #10
 8018992:	9101      	str	r1, [sp, #4]
	if (send_func) {
 8018994:	b10e      	cbz	r6, 801899a <commands_send_appconf+0x2ba>
		send_func(data, len);
 8018996:	4628      	mov	r0, r5
 8018998:	47b0      	blx	r6
}
 801899a:	b003      	add	sp, #12
 801899c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801899e:	bf00      	nop
 80189a0:	200090f0 	.word	0x200090f0
 80189a4:	200094f0 	.word	0x200094f0
	...

080189b0 <commands_process_packet>:
	if (!len) {
 80189b0:	2900      	cmp	r1, #0
 80189b2:	f000 8083 	beq.w	8018abc <commands_process_packet+0x10c>
void commands_process_packet(unsigned char *data, unsigned int len) {
 80189b6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80189ba:	ed2d 8b04 	vpush	{d8-d9}
	packet_id = data[0];
 80189be:	4604      	mov	r4, r0
void commands_process_packet(unsigned char *data, unsigned int len) {
 80189c0:	b0b6      	sub	sp, #216	; 0xd8
	packet_id = data[0];
 80189c2:	f814 8b01 	ldrb.w	r8, [r4], #1
	int32_t ind = 0;
 80189c6:	2300      	movs	r3, #0
 80189c8:	4607      	mov	r7, r0
 80189ca:	9302      	str	r3, [sp, #8]
	len--;
 80189cc:	1e4d      	subs	r5, r1, #1
	switch (packet_id) {
 80189ce:	f1b8 0f25 	cmp.w	r8, #37	; 0x25
 80189d2:	d86e      	bhi.n	8018ab2 <commands_process_packet+0x102>
 80189d4:	e8df f018 	tbh	[pc, r8, lsl #1]
 80189d8:	0aa908e8 	.word	0x0aa908e8
 80189dc:	0a760a93 	.word	0x0a760a93
 80189e0:	0abf09c0 	.word	0x0abf09c0
 80189e4:	0ad10aad 	.word	0x0ad10aad
 80189e8:	08c808da 	.word	0x08c808da
 80189ec:	007308bc 	.word	0x007308bc
 80189f0:	05e6006d 	.word	0x05e6006d
 80189f4:	03b803b8 	.word	0x03b803b8
 80189f8:	01e40200 	.word	0x01e40200
 80189fc:	01d301e4 	.word	0x01d301e4
 8018a00:	006d01cd 	.word	0x006d01cd
 8018a04:	006d006d 	.word	0x006d006d
 8018a08:	002601a8 	.word	0x002601a8
 8018a0c:	00e0014b 	.word	0x00e0014b
 8018a10:	008d008f 	.word	0x008d008f
 8018a14:	09a2008a 	.word	0x09a2008a
 8018a18:	0950096d 	.word	0x0950096d
 8018a1c:	09220948 	.word	0x09220948
 8018a20:	0907091a 	.word	0x0907091a
		mcconf = *mc_interface_get_configuration();
 8018a24:	f002 fcec 	bl	801b400 <mc_interface_get_configuration>
 8018a28:	4cb3      	ldr	r4, [pc, #716]	; (8018cf8 <commands_process_packet+0x348>)
		send_func_last = send_func;
 8018a2a:	4db4      	ldr	r5, [pc, #720]	; (8018cfc <commands_process_packet+0x34c>)
 8018a2c:	4eb4      	ldr	r6, [pc, #720]	; (8018d00 <commands_process_packet+0x350>)
		mcconf = *mc_interface_get_configuration();
 8018a2e:	4601      	mov	r1, r0
 8018a30:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018a34:	4620      	mov	r0, r4
 8018a36:	f7f4 f873 	bl	800cb20 <memcpy>
		mcconf_old = mcconf;
 8018a3a:	4621      	mov	r1, r4
 8018a3c:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018a40:	48b0      	ldr	r0, [pc, #704]	; (8018d04 <commands_process_packet+0x354>)
 8018a42:	f7f4 f86d 	bl	800cb20 <memcpy>
		mcconf.motor_type = MOTOR_TYPE_FOC;
 8018a46:	2202      	movs	r2, #2
		mc_interface_set_configuration(&mcconf);
 8018a48:	4620      	mov	r0, r4
		send_func_last = send_func;
 8018a4a:	682b      	ldr	r3, [r5, #0]
		mcconf.motor_type = MOTOR_TYPE_FOC;
 8018a4c:	70a2      	strb	r2, [r4, #2]
		send_func_last = send_func;
 8018a4e:	6033      	str	r3, [r6, #0]
		mc_interface_set_configuration(&mcconf);
 8018a50:	f003 f9e6 	bl	801be20 <mc_interface_set_configuration>
		float l = 0.0;
 8018a54:	a936      	add	r1, sp, #216	; 0xd8
		float r = 0.0;
 8018a56:	2400      	movs	r4, #0
		bool res = mcpwm_foc_measure_res_ind(&r, &l);
 8018a58:	a803      	add	r0, sp, #12
		float l = 0.0;
 8018a5a:	f841 4dc8 	str.w	r4, [r1, #-200]!
		float r = 0.0;
 8018a5e:	9403      	str	r4, [sp, #12]
		bool res = mcpwm_foc_measure_res_ind(&r, &l);
 8018a60:	f005 fe16 	bl	801e690 <mcpwm_foc_measure_res_ind>
 8018a64:	4607      	mov	r7, r0
		mc_interface_set_configuration(&mcconf_old);
 8018a66:	48a7      	ldr	r0, [pc, #668]	; (8018d04 <commands_process_packet+0x354>)
 8018a68:	f003 f9da 	bl	801be20 <mc_interface_set_configuration>
		if (!res) {
 8018a6c:	b90f      	cbnz	r7, 8018a72 <commands_process_packet+0xc2>
			r = 0.0;
 8018a6e:	9403      	str	r4, [sp, #12]
			l = 0.0;
 8018a70:	9404      	str	r4, [sp, #16]
		send_buffer[ind++] = COMM_DETECT_MOTOR_R_L;
 8018a72:	af36      	add	r7, sp, #216	; 0xd8
 8018a74:	2301      	movs	r3, #1
 8018a76:	f847 3dd0 	str.w	r3, [r7, #-208]!
 8018a7a:	4ca3      	ldr	r4, [pc, #652]	; (8018d08 <commands_process_packet+0x358>)
		buffer_append_float32(send_buffer, r, 1e6, &ind);
 8018a7c:	eddf 0aa3 	vldr	s1, [pc, #652]	; 8018d0c <commands_process_packet+0x35c>
 8018a80:	ed9d 0a03 	vldr	s0, [sp, #12]
		send_buffer[ind++] = COMM_DETECT_MOTOR_R_L;
 8018a84:	2319      	movs	r3, #25
		buffer_append_float32(send_buffer, r, 1e6, &ind);
 8018a86:	4639      	mov	r1, r7
 8018a88:	4620      	mov	r0, r4
		send_buffer[ind++] = COMM_DETECT_MOTOR_R_L;
 8018a8a:	7023      	strb	r3, [r4, #0]
		buffer_append_float32(send_buffer, r, 1e6, &ind);
 8018a8c:	f7f9 f8c0 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, l, 1e3, &ind);
 8018a90:	4639      	mov	r1, r7
 8018a92:	4620      	mov	r0, r4
 8018a94:	eddf 0aa3 	vldr	s1, [pc, #652]	; 8018d24 <commands_process_packet+0x374>
 8018a98:	ed9d 0a04 	vldr	s0, [sp, #16]
 8018a9c:	f7f9 f8b8 	bl	8011c10 <buffer_append_float32>
		if (send_func_last) {
 8018aa0:	6833      	ldr	r3, [r6, #0]
 8018aa2:	2b00      	cmp	r3, #0
 8018aa4:	f040 8124 	bne.w	8018cf0 <commands_process_packet+0x340>
	if (send_func) {
 8018aa8:	682b      	ldr	r3, [r5, #0]
			commands_send_packet(send_buffer, ind);
 8018aaa:	9902      	ldr	r1, [sp, #8]
	if (send_func) {
 8018aac:	b10b      	cbz	r3, 8018ab2 <commands_process_packet+0x102>
			appdata_func(data, len);
 8018aae:	4620      	mov	r0, r4
 8018ab0:	4798      	blx	r3
}
 8018ab2:	b036      	add	sp, #216	; 0xd8
 8018ab4:	ecbd 8b04 	vpop	{d8-d9}
 8018ab8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8018abc:	4770      	bx	lr
		mcconf = *mc_interface_get_configuration();
 8018abe:	f002 fc9f 	bl	801b400 <mc_interface_get_configuration>
 8018ac2:	4b8d      	ldr	r3, [pc, #564]	; (8018cf8 <commands_process_packet+0x348>)
 8018ac4:	4601      	mov	r1, r0
 8018ac6:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018aca:	4618      	mov	r0, r3
 8018acc:	f7f4 f828 	bl	800cb20 <memcpy>
		display_position_mode = data[ind++];
 8018ad0:	498f      	ldr	r1, [pc, #572]	; (8018d10 <commands_process_packet+0x360>)
 8018ad2:	787b      	ldrb	r3, [r7, #1]
		if (mcconf.motor_type == MOTOR_TYPE_BLDC) {
 8018ad4:	7882      	ldrb	r2, [r0, #2]
		display_position_mode = data[ind++];
 8018ad6:	700b      	strb	r3, [r1, #0]
 8018ad8:	2101      	movs	r1, #1
 8018ada:	9102      	str	r1, [sp, #8]
		if (mcconf.motor_type == MOTOR_TYPE_BLDC) {
 8018adc:	b932      	cbnz	r2, 8018aec <commands_process_packet+0x13c>
			if (display_position_mode == DISP_POS_MODE_NONE) {
 8018ade:	2b00      	cmp	r3, #0
 8018ae0:	f001 825d 	beq.w	8019f9e <commands_process_packet+0x15ee>
			} else if (display_position_mode == DISP_POS_MODE_INDUCTANCE) {
 8018ae4:	2b01      	cmp	r3, #1
 8018ae6:	d101      	bne.n	8018aec <commands_process_packet+0x13c>
				mcpwm_set_detect();
 8018ae8:	f7fb fada 	bl	80140a0 <mcpwm_set_detect>
		timeout_reset();
 8018aec:	f001 fb38 	bl	801a160 <timeout_reset>
		break;
 8018af0:	e7df      	b.n	8018ab2 <commands_process_packet+0x102>
  __ASM volatile ("cpsid i" : : : "memory");
 8018af2:	b672      	cpsid	i
 8018af4:	e7fe      	b.n	8018af4 <commands_process_packet+0x144>
		mcconf = *mc_interface_get_configuration();
 8018af6:	f002 fc83 	bl	801b400 <mc_interface_get_configuration>
 8018afa:	4d7f      	ldr	r5, [pc, #508]	; (8018cf8 <commands_process_packet+0x348>)
 8018afc:	4601      	mov	r1, r0
 8018afe:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018b02:	4628      	mov	r0, r5
 8018b04:	f7f4 f80c 	bl	800cb20 <memcpy>
		if (mcconf.m_sensor_port_mode == SENSOR_PORT_MODE_HALL) {
 8018b08:	f895 815c 	ldrb.w	r8, [r5, #348]	; 0x15c
 8018b0c:	f1b8 0f00 	cmp.w	r8, #0
 8018b10:	f041 8266 	bne.w	8019fe0 <commands_process_packet+0x1630>
			mcconf_old = mcconf;
 8018b14:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018b18:	4629      	mov	r1, r5
 8018b1a:	487a      	ldr	r0, [pc, #488]	; (8018d04 <commands_process_packet+0x354>)
			send_func_last = send_func;
 8018b1c:	4e77      	ldr	r6, [pc, #476]	; (8018cfc <commands_process_packet+0x34c>)
 8018b1e:	4f78      	ldr	r7, [pc, #480]	; (8018d00 <commands_process_packet+0x350>)
			mcconf_old = mcconf;
 8018b20:	f7f3 fffe 	bl	800cb20 <memcpy>
			ind = 0;
 8018b24:	a936      	add	r1, sp, #216	; 0xd8
			float current = buffer_get_float32(data, 1e3, &ind);
 8018b26:	4620      	mov	r0, r4
			ind = 0;
 8018b28:	f841 8dd0 	str.w	r8, [r1, #-208]!
			float current = buffer_get_float32(data, 1e3, &ind);
 8018b2c:	ed9f 0a7d 	vldr	s0, [pc, #500]	; 8018d24 <commands_process_packet+0x374>
			mcconf.foc_f_sw = 10000.0;
 8018b30:	4c78      	ldr	r4, [pc, #480]	; (8018d14 <commands_process_packet+0x364>)
			float current = buffer_get_float32(data, 1e3, &ind);
 8018b32:	f7f9 f90d 	bl	8011d50 <buffer_get_float32>
			send_func_last = send_func;
 8018b36:	6833      	ldr	r3, [r6, #0]
			mcconf.foc_current_kp = 0.01;
 8018b38:	4977      	ldr	r1, [pc, #476]	; (8018d18 <commands_process_packet+0x368>)
			send_func_last = send_func;
 8018b3a:	603b      	str	r3, [r7, #0]
			mcconf.motor_type = MOTOR_TYPE_FOC;
 8018b3c:	2202      	movs	r2, #2
			mcconf.foc_current_ki = 10.0;
 8018b3e:	4b77      	ldr	r3, [pc, #476]	; (8018d1c <commands_process_packet+0x36c>)
			mcconf.foc_current_kp = 0.01;
 8018b40:	f8c5 10a4 	str.w	r1, [r5, #164]	; 0xa4
			mc_interface_set_configuration(&mcconf);
 8018b44:	4628      	mov	r0, r5
			float current = buffer_get_float32(data, 1e3, &ind);
 8018b46:	eeb0 8a40 	vmov.f32	s16, s0
			mcconf.motor_type = MOTOR_TYPE_FOC;
 8018b4a:	70aa      	strb	r2, [r5, #2]
			mcconf.foc_current_ki = 10.0;
 8018b4c:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
			mcconf.foc_f_sw = 10000.0;
 8018b50:	f8c5 40ac 	str.w	r4, [r5, #172]	; 0xac
			mc_interface_set_configuration(&mcconf);
 8018b54:	f003 f964 	bl	801be20 <mc_interface_set_configuration>
			bool res = mcpwm_foc_hall_detect(current, hall_tab);
 8018b58:	eeb0 0a48 	vmov.f32	s0, s16
 8018b5c:	a804      	add	r0, sp, #16
 8018b5e:	f005 fe97 	bl	801e890 <mcpwm_foc_hall_detect>
 8018b62:	4604      	mov	r4, r0
			mc_interface_set_configuration(&mcconf_old);
 8018b64:	4867      	ldr	r0, [pc, #412]	; (8018d04 <commands_process_packet+0x354>)
 8018b66:	f003 f95b 	bl	801be20 <mc_interface_set_configuration>
			send_buffer[ind++] = COMM_DETECT_HALL_FOC;
 8018b6a:	4a67      	ldr	r2, [pc, #412]	; (8018d08 <commands_process_packet+0x358>)
			if (send_func_last) {
 8018b6c:	683f      	ldr	r7, [r7, #0]
			send_buffer[ind++] = COMM_DETECT_HALL_FOC;
 8018b6e:	4615      	mov	r5, r2
			memcpy(send_buffer + ind, hall_tab, 8);
 8018b70:	ab04      	add	r3, sp, #16
 8018b72:	cb03      	ldmia	r3!, {r0, r1}
			send_buffer[ind++] = COMM_DETECT_HALL_FOC;
 8018b74:	231c      	movs	r3, #28
 8018b76:	f805 3b01 	strb.w	r3, [r5], #1
			send_buffer[ind++] = res ? 0 : 1;
 8018b7a:	f084 0401 	eor.w	r4, r4, #1
 8018b7e:	230a      	movs	r3, #10
			memcpy(send_buffer + ind, hall_tab, 8);
 8018b80:	f8c2 0001 	str.w	r0, [r2, #1]
			send_buffer[ind++] = res ? 0 : 1;
 8018b84:	9302      	str	r3, [sp, #8]
			memcpy(send_buffer + ind, hall_tab, 8);
 8018b86:	6069      	str	r1, [r5, #4]
			send_buffer[ind++] = res ? 0 : 1;
 8018b88:	7254      	strb	r4, [r2, #9]
			if (send_func_last) {
 8018b8a:	2f00      	cmp	r7, #0
 8018b8c:	f001 821f 	beq.w	8019fce <commands_process_packet+0x161e>
				send_func_last(send_buffer, ind);
 8018b90:	4619      	mov	r1, r3
 8018b92:	4610      	mov	r0, r2
 8018b94:	47b8      	blx	r7
 8018b96:	e78c      	b.n	8018ab2 <commands_process_packet+0x102>
		if (encoder_is_configured()) {
 8018b98:	f002 f88a 	bl	801acb0 <encoder_is_configured>
 8018b9c:	4606      	mov	r6, r0
 8018b9e:	2800      	cmp	r0, #0
 8018ba0:	f001 822e 	beq.w	801a000 <commands_process_packet+0x1650>
			mcconf = *mc_interface_get_configuration();
 8018ba4:	f002 fc2c 	bl	801b400 <mc_interface_get_configuration>
 8018ba8:	4d53      	ldr	r5, [pc, #332]	; (8018cf8 <commands_process_packet+0x348>)
			send_func_last = send_func;
 8018baa:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8018cfc <commands_process_packet+0x34c>
 8018bae:	f8df 9150 	ldr.w	r9, [pc, #336]	; 8018d00 <commands_process_packet+0x350>
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 8018bb2:	4e55      	ldr	r6, [pc, #340]	; (8018d08 <commands_process_packet+0x358>)
			ind = 0;
 8018bb4:	af36      	add	r7, sp, #216	; 0xd8
			mcconf = *mc_interface_get_configuration();
 8018bb6:	4601      	mov	r1, r0
 8018bb8:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018bbc:	4628      	mov	r0, r5
 8018bbe:	f7f3 ffaf 	bl	800cb20 <memcpy>
			ind = 0;
 8018bc2:	f04f 0a00 	mov.w	sl, #0
			mcconf_old = mcconf;
 8018bc6:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8018bca:	4629      	mov	r1, r5
 8018bcc:	484d      	ldr	r0, [pc, #308]	; (8018d04 <commands_process_packet+0x354>)
 8018bce:	f7f3 ffa7 	bl	800cb20 <memcpy>
			ind = 0;
 8018bd2:	f847 add0 	str.w	sl, [r7, #-208]!
			float current = buffer_get_float32(data, 1e3, &ind);
 8018bd6:	4620      	mov	r0, r4
			send_func_last = send_func;
 8018bd8:	f8d8 3000 	ldr.w	r3, [r8]
			float current = buffer_get_float32(data, 1e3, &ind);
 8018bdc:	ed9f 0a51 	vldr	s0, [pc, #324]	; 8018d24 <commands_process_packet+0x374>
			send_func_last = send_func;
 8018be0:	f8c9 3000 	str.w	r3, [r9]
			float current = buffer_get_float32(data, 1e3, &ind);
 8018be4:	4639      	mov	r1, r7
 8018be6:	f7f9 f8b3 	bl	8011d50 <buffer_get_float32>
			mcconf.foc_f_sw = 10000.0;
 8018bea:	4b4a      	ldr	r3, [pc, #296]	; (8018d14 <commands_process_packet+0x364>)
			mcconf.foc_current_kp = 0.01;
 8018bec:	4a4a      	ldr	r2, [pc, #296]	; (8018d18 <commands_process_packet+0x368>)
			mcconf.foc_f_sw = 10000.0;
 8018bee:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac
			mcconf.motor_type = MOTOR_TYPE_FOC;
 8018bf2:	2102      	movs	r1, #2
			mcconf.foc_current_ki = 10.0;
 8018bf4:	4b49      	ldr	r3, [pc, #292]	; (8018d1c <commands_process_packet+0x36c>)
			mcconf.motor_type = MOTOR_TYPE_FOC;
 8018bf6:	70a9      	strb	r1, [r5, #2]
			mc_interface_set_configuration(&mcconf);
 8018bf8:	4628      	mov	r0, r5
			float current = buffer_get_float32(data, 1e3, &ind);
 8018bfa:	eeb0 8a40 	vmov.f32	s16, s0
			mcconf.foc_current_kp = 0.01;
 8018bfe:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
			mcconf.foc_current_ki = 10.0;
 8018c02:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
			mc_interface_set_configuration(&mcconf);
 8018c06:	f003 f90b 	bl	801be20 <mc_interface_set_configuration>
			bool inverted = false;
 8018c0a:	ab36      	add	r3, sp, #216	; 0xd8
			mcpwm_foc_encoder_detect(current, false, &offset, &ratio, &inverted);
 8018c0c:	eeb0 0a48 	vmov.f32	s0, s16
			bool inverted = false;
 8018c10:	f803 add1 	strb.w	sl, [r3, #-209]!
			mcpwm_foc_encoder_detect(current, false, &offset, &ratio, &inverted);
 8018c14:	aa04      	add	r2, sp, #16
 8018c16:	a903      	add	r1, sp, #12
			float offset = 0.0;
 8018c18:	2400      	movs	r4, #0
			mcpwm_foc_encoder_detect(current, false, &offset, &ratio, &inverted);
 8018c1a:	4650      	mov	r0, sl
			float offset = 0.0;
 8018c1c:	9403      	str	r4, [sp, #12]
			float ratio = 0.0;
 8018c1e:	9404      	str	r4, [sp, #16]
			mcpwm_foc_encoder_detect(current, false, &offset, &ratio, &inverted);
 8018c20:	f005 f91e 	bl	801de60 <mcpwm_foc_encoder_detect>
			mc_interface_set_configuration(&mcconf_old);
 8018c24:	4837      	ldr	r0, [pc, #220]	; (8018d04 <commands_process_packet+0x354>)
 8018c26:	f003 f8fb 	bl	801be20 <mc_interface_set_configuration>
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 8018c2a:	221b      	movs	r2, #27
 8018c2c:	2301      	movs	r3, #1
			buffer_append_float32(send_buffer, offset, 1e6, &ind);
 8018c2e:	4639      	mov	r1, r7
 8018c30:	4630      	mov	r0, r6
 8018c32:	eddf 0a36 	vldr	s1, [pc, #216]	; 8018d0c <commands_process_packet+0x35c>
 8018c36:	ed9d 0a03 	vldr	s0, [sp, #12]
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 8018c3a:	7032      	strb	r2, [r6, #0]
 8018c3c:	9302      	str	r3, [sp, #8]
			buffer_append_float32(send_buffer, offset, 1e6, &ind);
 8018c3e:	f7f8 ffe7 	bl	8011c10 <buffer_append_float32>
			buffer_append_float32(send_buffer, ratio, 1e6, &ind);
 8018c42:	4639      	mov	r1, r7
 8018c44:	4630      	mov	r0, r6
 8018c46:	eddf 0a31 	vldr	s1, [pc, #196]	; 8018d0c <commands_process_packet+0x35c>
 8018c4a:	ed9d 0a04 	vldr	s0, [sp, #16]
 8018c4e:	f7f8 ffdf 	bl	8011c10 <buffer_append_float32>
			send_buffer[ind++] = inverted;
 8018c52:	9902      	ldr	r1, [sp, #8]
 8018c54:	f89d 2007 	ldrb.w	r2, [sp, #7]
			if (send_func_last) {
 8018c58:	f8d9 3000 	ldr.w	r3, [r9]
			send_buffer[ind++] = inverted;
 8018c5c:	5472      	strb	r2, [r6, r1]
 8018c5e:	3101      	adds	r1, #1
 8018c60:	9102      	str	r1, [sp, #8]
			if (send_func_last) {
 8018c62:	2b00      	cmp	r3, #0
 8018c64:	f001 81c5 	beq.w	8019ff2 <commands_process_packet+0x1642>
		send_func(data, len);
 8018c68:	4630      	mov	r0, r6
 8018c6a:	4798      	blx	r3
 8018c6c:	e721      	b.n	8018ab2 <commands_process_packet+0x102>
		float current = buffer_get_float32(data, 1e3, &ind);
 8018c6e:	a902      	add	r1, sp, #8
 8018c70:	4620      	mov	r0, r4
 8018c72:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 8018d24 <commands_process_packet+0x374>
		send_func_last = send_func;
 8018c76:	4d21      	ldr	r5, [pc, #132]	; (8018cfc <commands_process_packet+0x34c>)
 8018c78:	4e21      	ldr	r6, [pc, #132]	; (8018d00 <commands_process_packet+0x350>)
		float current = buffer_get_float32(data, 1e3, &ind);
 8018c7a:	f7f9 f869 	bl	8011d50 <buffer_get_float32>
		float min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018c7e:	a902      	add	r1, sp, #8
		float current = buffer_get_float32(data, 1e3, &ind);
 8018c80:	eeb0 8a40 	vmov.f32	s16, s0
		float min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018c84:	4620      	mov	r0, r4
 8018c86:	ed9f 0a27 	vldr	s0, [pc, #156]	; 8018d24 <commands_process_packet+0x374>
 8018c8a:	f7f9 f861 	bl	8011d50 <buffer_get_float32>
		float duty = buffer_get_float32(data, 1e3, &ind);
 8018c8e:	a902      	add	r1, sp, #8
		float min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018c90:	eeb0 9a40 	vmov.f32	s18, s0
		float duty = buffer_get_float32(data, 1e3, &ind);
 8018c94:	4620      	mov	r0, r4
 8018c96:	ed9f 0a23 	vldr	s0, [pc, #140]	; 8018d24 <commands_process_packet+0x374>
 8018c9a:	f7f9 f859 	bl	8011d50 <buffer_get_float32>
		float resistance = buffer_get_float32(data, 1e6, &ind);
 8018c9e:	4620      	mov	r0, r4
		float duty = buffer_get_float32(data, 1e3, &ind);
 8018ca0:	eef0 8a40 	vmov.f32	s17, s0
		float resistance = buffer_get_float32(data, 1e6, &ind);
 8018ca4:	a902      	add	r1, sp, #8
 8018ca6:	ed9f 0a19 	vldr	s0, [pc, #100]	; 8018d0c <commands_process_packet+0x35c>
 8018caa:	f7f9 f851 	bl	8011d50 <buffer_get_float32>
		send_func_last = send_func;
 8018cae:	682b      	ldr	r3, [r5, #0]
 8018cb0:	6033      	str	r3, [r6, #0]
		bool res = conf_general_measure_flux_linkage(current, duty, min_rpm, resistance, &linkage);
 8018cb2:	eef0 1a40 	vmov.f32	s3, s0
 8018cb6:	eeb0 1a49 	vmov.f32	s2, s18
 8018cba:	eef0 0a68 	vmov.f32	s1, s17
 8018cbe:	eeb0 0a48 	vmov.f32	s0, s16
 8018cc2:	a804      	add	r0, sp, #16
 8018cc4:	f7ff f8ec 	bl	8017ea0 <conf_general_measure_flux_linkage>
		if (!res) {
 8018cc8:	b908      	cbnz	r0, 8018cce <commands_process_packet+0x31e>
			linkage = 0.0;
 8018cca:	2300      	movs	r3, #0
 8018ccc:	9304      	str	r3, [sp, #16]
		send_buffer[ind++] = COMM_DETECT_MOTOR_FLUX_LINKAGE;
 8018cce:	4c0e      	ldr	r4, [pc, #56]	; (8018d08 <commands_process_packet+0x358>)
		buffer_append_float32(send_buffer, linkage, 1e7, &ind);
 8018cd0:	eddf 0a13 	vldr	s1, [pc, #76]	; 8018d20 <commands_process_packet+0x370>
 8018cd4:	ed9d 0a04 	vldr	s0, [sp, #16]
		send_buffer[ind++] = COMM_DETECT_MOTOR_FLUX_LINKAGE;
 8018cd8:	2301      	movs	r3, #1
 8018cda:	221a      	movs	r2, #26
		buffer_append_float32(send_buffer, linkage, 1e7, &ind);
 8018cdc:	a902      	add	r1, sp, #8
 8018cde:	4620      	mov	r0, r4
		send_buffer[ind++] = COMM_DETECT_MOTOR_FLUX_LINKAGE;
 8018ce0:	9302      	str	r3, [sp, #8]
 8018ce2:	7022      	strb	r2, [r4, #0]
		buffer_append_float32(send_buffer, linkage, 1e7, &ind);
 8018ce4:	f7f8 ff94 	bl	8011c10 <buffer_append_float32>
		if (send_func_last) {
 8018ce8:	6833      	ldr	r3, [r6, #0]
 8018cea:	2b00      	cmp	r3, #0
 8018cec:	f43f aedc 	beq.w	8018aa8 <commands_process_packet+0xf8>
			send_func_last(send_buffer, ind);
 8018cf0:	4620      	mov	r0, r4
 8018cf2:	9902      	ldr	r1, [sp, #8]
 8018cf4:	4798      	blx	r3
 8018cf6:	e6dc      	b.n	8018ab2 <commands_process_packet+0x102>
 8018cf8:	20008d08 	.word	0x20008d08
 8018cfc:	200094f0 	.word	0x200094f0
 8018d00:	200094f4 	.word	0x200094f4
 8018d04:	20008e7c 	.word	0x20008e7c
 8018d08:	200090f0 	.word	0x200090f0
 8018d0c:	49742400 	.word	0x49742400
 8018d10:	20008d04 	.word	0x20008d04
 8018d14:	461c4000 	.word	0x461c4000
 8018d18:	3c23d70a 	.word	0x3c23d70a
 8018d1c:	41200000 	.word	0x41200000
 8018d20:	4b189680 	.word	0x4b189680
 8018d24:	447a0000 	.word	0x447a0000
		detect_current = buffer_get_float32(data, 1e3, &ind);
 8018d28:	a902      	add	r1, sp, #8
 8018d2a:	4620      	mov	r0, r4
 8018d2c:	ed1f 0a03 	vldr	s0, [pc, #-12]	; 8018d24 <commands_process_packet+0x374>
 8018d30:	f7f9 f80e 	bl	8011d50 <buffer_get_float32>
 8018d34:	4b21      	ldr	r3, [pc, #132]	; (8018dbc <commands_process_packet+0x40c>)
		detect_min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018d36:	a902      	add	r1, sp, #8
		detect_current = buffer_get_float32(data, 1e3, &ind);
 8018d38:	ed83 0a00 	vstr	s0, [r3]
		detect_min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018d3c:	4620      	mov	r0, r4
 8018d3e:	ed9f 0a20 	vldr	s0, [pc, #128]	; 8018dc0 <commands_process_packet+0x410>
 8018d42:	f7f9 f805 	bl	8011d50 <buffer_get_float32>
 8018d46:	4b1f      	ldr	r3, [pc, #124]	; (8018dc4 <commands_process_packet+0x414>)
		detect_low_duty = buffer_get_float32(data, 1e3, &ind);
 8018d48:	a902      	add	r1, sp, #8
 8018d4a:	4620      	mov	r0, r4
		detect_min_rpm = buffer_get_float32(data, 1e3, &ind);
 8018d4c:	ed83 0a00 	vstr	s0, [r3]
		detect_low_duty = buffer_get_float32(data, 1e3, &ind);
 8018d50:	ed9f 0a1b 	vldr	s0, [pc, #108]	; 8018dc0 <commands_process_packet+0x410>
 8018d54:	f7f8 fffc 	bl	8011d50 <buffer_get_float32>
 8018d58:	491b      	ldr	r1, [pc, #108]	; (8018dc8 <commands_process_packet+0x418>)
		send_func_last = send_func;
 8018d5a:	4a1c      	ldr	r2, [pc, #112]	; (8018dcc <commands_process_packet+0x41c>)
		chEvtSignal(detect_tp, (eventmask_t) 1);
 8018d5c:	481c      	ldr	r0, [pc, #112]	; (8018dd0 <commands_process_packet+0x420>)
		send_func_last = send_func;
 8018d5e:	4b1d      	ldr	r3, [pc, #116]	; (8018dd4 <commands_process_packet+0x424>)
 8018d60:	6812      	ldr	r2, [r2, #0]
		detect_low_duty = buffer_get_float32(data, 1e3, &ind);
 8018d62:	ed81 0a00 	vstr	s0, [r1]
		chEvtSignal(detect_tp, (eventmask_t) 1);
 8018d66:	6800      	ldr	r0, [r0, #0]
		send_func_last = send_func;
 8018d68:	601a      	str	r2, [r3, #0]
		chEvtSignal(detect_tp, (eventmask_t) 1);
 8018d6a:	2101      	movs	r1, #1
 8018d6c:	f7f5 f888 	bl	800de80 <chEvtSignal>
		break;
 8018d70:	e69f      	b.n	8018ab2 <commands_process_packet+0x102>
		data[len] = '\0';
 8018d72:	2300      	movs	r3, #0
		terminal_process_string((char*)data);
 8018d74:	4620      	mov	r0, r4
		data[len] = '\0';
 8018d76:	547b      	strb	r3, [r7, r1]
		terminal_process_string((char*)data);
 8018d78:	f7fd faea 	bl	8016350 <terminal_process_string>
		break;
 8018d7c:	e699      	b.n	8018ab2 <commands_process_packet+0x102>
		mode = data[ind++];
 8018d7e:	a936      	add	r1, sp, #216	; 0xd8
 8018d80:	2301      	movs	r3, #1
 8018d82:	f841 3dd0 	str.w	r3, [r1, #-208]!
		sample_len = buffer_get_uint16(data, &ind);
 8018d86:	4620      	mov	r0, r4
		mode = data[ind++];
 8018d88:	787d      	ldrb	r5, [r7, #1]
		sample_len = buffer_get_uint16(data, &ind);
 8018d8a:	f7f8 ffa1 	bl	8011cd0 <buffer_get_uint16>
		decimation = data[ind++];
 8018d8e:	9b02      	ldr	r3, [sp, #8]
		mc_interface_sample_print_data(mode, sample_len, decimation);
 8018d90:	4601      	mov	r1, r0
 8018d92:	5ce2      	ldrb	r2, [r4, r3]
 8018d94:	4628      	mov	r0, r5
		decimation = data[ind++];
 8018d96:	3301      	adds	r3, #1
 8018d98:	9302      	str	r3, [sp, #8]
		mc_interface_sample_print_data(mode, sample_len, decimation);
 8018d9a:	f003 f981 	bl	801c0a0 <mc_interface_sample_print_data>
	} break;
 8018d9e:	e688      	b.n	8018ab2 <commands_process_packet+0x102>
		if (packet_id == COMM_GET_APPCONF) {
 8018da0:	f1b8 0f11 	cmp.w	r8, #17
 8018da4:	f001 80ff 	beq.w	8019fa6 <commands_process_packet+0x15f6>
			conf_general_get_default_app_configuration(&appconf);
 8018da8:	ac04      	add	r4, sp, #16
 8018daa:	4620      	mov	r0, r4
 8018dac:	f7fe fbf8 	bl	80175a0 <conf_general_get_default_app_configuration>
		commands_send_appconf(packet_id, &appconf);
 8018db0:	4621      	mov	r1, r4
 8018db2:	4640      	mov	r0, r8
 8018db4:	f7ff fc94 	bl	80186e0 <commands_send_appconf>
		break;
 8018db8:	e67b      	b.n	8018ab2 <commands_process_packet+0x102>
 8018dba:	bf00      	nop
 8018dbc:	20008348 	.word	0x20008348
 8018dc0:	447a0000 	.word	0x447a0000
 8018dc4:	20008360 	.word	0x20008360
 8018dc8:	2000835c 	.word	0x2000835c
 8018dcc:	200094f0 	.word	0x200094f0
 8018dd0:	20008d00 	.word	0x20008d00
 8018dd4:	200094f4 	.word	0x200094f4
		appconf = *app_get_configuration();
 8018dd8:	f007 fbe2 	bl	80205a0 <app_get_configuration>
 8018ddc:	22c8      	movs	r2, #200	; 0xc8
 8018dde:	4601      	mov	r1, r0
 8018de0:	a804      	add	r0, sp, #16
		appconf.controller_id = data[ind++];
 8018de2:	2501      	movs	r5, #1
		appconf = *app_get_configuration();
 8018de4:	f7f3 fe9c 	bl	800cb20 <memcpy>
		appconf.controller_id = data[ind++];
 8018de8:	787b      	ldrb	r3, [r7, #1]
 8018dea:	f88d 3010 	strb.w	r3, [sp, #16]
		appconf.timeout_msec = buffer_get_uint32(data, &ind);
 8018dee:	a902      	add	r1, sp, #8
 8018df0:	4620      	mov	r0, r4
		appconf.controller_id = data[ind++];
 8018df2:	9502      	str	r5, [sp, #8]
		appconf.timeout_msec = buffer_get_uint32(data, &ind);
 8018df4:	f7f8 ff94 	bl	8011d20 <buffer_get_uint32>
		appconf.timeout_brake_current = buffer_get_float32_auto(data, &ind);
 8018df8:	a902      	add	r1, sp, #8
		appconf.timeout_msec = buffer_get_uint32(data, &ind);
 8018dfa:	9005      	str	r0, [sp, #20]
		appconf.timeout_brake_current = buffer_get_float32_auto(data, &ind);
 8018dfc:	4620      	mov	r0, r4
 8018dfe:	f7f8 ffb7 	bl	8011d70 <buffer_get_float32_auto>
		appconf.send_can_status = data[ind++];
 8018e02:	9b02      	ldr	r3, [sp, #8]
 8018e04:	5ce2      	ldrb	r2, [r4, r3]
		appconf.timeout_brake_current = buffer_get_float32_auto(data, &ind);
 8018e06:	ed8d 0a06 	vstr	s0, [sp, #24]
		appconf.send_can_status = data[ind++];
 8018e0a:	3200      	adds	r2, #0
 8018e0c:	bf18      	it	ne
 8018e0e:	2201      	movne	r2, #1
 8018e10:	442b      	add	r3, r5
		appconf.send_can_status_rate_hz = buffer_get_uint16(data, &ind);
 8018e12:	a902      	add	r1, sp, #8
 8018e14:	4620      	mov	r0, r4
		appconf.send_can_status = data[ind++];
 8018e16:	f88d 201c 	strb.w	r2, [sp, #28]
 8018e1a:	9302      	str	r3, [sp, #8]
		appconf.send_can_status_rate_hz = buffer_get_uint16(data, &ind);
 8018e1c:	f7f8 ff58 	bl	8011cd0 <buffer_get_uint16>
		appconf.can_baud_rate = data[ind++];
 8018e20:	9b02      	ldr	r3, [sp, #8]
		appconf.send_can_status_rate_hz = buffer_get_uint16(data, &ind);
 8018e22:	9008      	str	r0, [sp, #32]
		appconf.can_baud_rate = data[ind++];
 8018e24:	195a      	adds	r2, r3, r5
		appconf.app_to_use = data[ind++];
 8018e26:	1c99      	adds	r1, r3, #2
 8018e28:	5ca2      	ldrb	r2, [r4, r2]
		appconf.app_ppm_conf.ctrl_type = data[ind++];
 8018e2a:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_to_use = data[ind++];
 8018e2c:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		appconf.can_baud_rate = data[ind++];
 8018e30:	5ce2      	ldrb	r2, [r4, r3]
		appconf.app_ppm_conf.ctrl_type = data[ind++];
 8018e32:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8018e36:	3303      	adds	r3, #3
		appconf.app_ppm_conf.pid_max_erpm = buffer_get_float32_auto(data, &ind);
 8018e38:	4620      	mov	r0, r4
 8018e3a:	a902      	add	r1, sp, #8
		appconf.can_baud_rate = data[ind++];
 8018e3c:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
		appconf.app_ppm_conf.ctrl_type = data[ind++];
 8018e40:	9302      	str	r3, [sp, #8]
		appconf.app_ppm_conf.pid_max_erpm = buffer_get_float32_auto(data, &ind);
 8018e42:	f7f8 ff95 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018e46:	4620      	mov	r0, r4
 8018e48:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.pid_max_erpm = buffer_get_float32_auto(data, &ind);
 8018e4a:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
		appconf.app_ppm_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018e4e:	f7f8 ff8f 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.pulse_start = buffer_get_float32_auto(data, &ind);
 8018e52:	4620      	mov	r0, r4
 8018e54:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018e56:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
		appconf.app_ppm_conf.pulse_start = buffer_get_float32_auto(data, &ind);
 8018e5a:	f7f8 ff89 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.pulse_end = buffer_get_float32_auto(data, &ind);
 8018e5e:	4620      	mov	r0, r4
 8018e60:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.pulse_start = buffer_get_float32_auto(data, &ind);
 8018e62:	ed8d 0a0d 	vstr	s0, [sp, #52]	; 0x34
		appconf.app_ppm_conf.pulse_end = buffer_get_float32_auto(data, &ind);
 8018e66:	f7f8 ff83 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.pulse_center = buffer_get_float32_auto(data, &ind);
 8018e6a:	4620      	mov	r0, r4
 8018e6c:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.pulse_end = buffer_get_float32_auto(data, &ind);
 8018e6e:	ed8d 0a0e 	vstr	s0, [sp, #56]	; 0x38
		appconf.app_ppm_conf.pulse_center = buffer_get_float32_auto(data, &ind);
 8018e72:	f7f8 ff7d 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.median_filter = data[ind++];
 8018e76:	9b02      	ldr	r3, [sp, #8]
 8018e78:	1959      	adds	r1, r3, r5
 8018e7a:	5ce2      	ldrb	r2, [r4, r3]
		appconf.app_ppm_conf.safe_start = data[ind++];
 8018e7c:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_ppm_conf.pulse_center = buffer_get_float32_auto(data, &ind);
 8018e7e:	ed8d 0a0f 	vstr	s0, [sp, #60]	; 0x3c
		appconf.app_ppm_conf.median_filter = data[ind++];
 8018e82:	3200      	adds	r2, #0
 8018e84:	bf18      	it	ne
 8018e86:	2201      	movne	r2, #1
		appconf.app_ppm_conf.safe_start = data[ind++];
 8018e88:	3100      	adds	r1, #0
 8018e8a:	bf18      	it	ne
 8018e8c:	2101      	movne	r1, #1
 8018e8e:	3302      	adds	r3, #2
		appconf.app_ppm_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018e90:	4620      	mov	r0, r4
		appconf.app_ppm_conf.safe_start = data[ind++];
 8018e92:	f88d 1041 	strb.w	r1, [sp, #65]	; 0x41
		appconf.app_ppm_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018e96:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.median_filter = data[ind++];
 8018e98:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		appconf.app_ppm_conf.safe_start = data[ind++];
 8018e9c:	9302      	str	r3, [sp, #8]
		appconf.app_ppm_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018e9e:	f7f8 ff67 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018ea2:	4620      	mov	r0, r4
 8018ea4:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018ea6:	ed8d 0a11 	vstr	s0, [sp, #68]	; 0x44
		appconf.app_ppm_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018eaa:	f7f8 ff61 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.throttle_exp_mode = data[ind++];
 8018eae:	9b02      	ldr	r3, [sp, #8]
		appconf.app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018eb0:	4620      	mov	r0, r4
		appconf.app_ppm_conf.throttle_exp_mode = data[ind++];
 8018eb2:	195a      	adds	r2, r3, r5
		appconf.app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018eb4:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.throttle_exp_mode = data[ind++];
 8018eb6:	5ce3      	ldrb	r3, [r4, r3]
 8018eb8:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
 8018ebc:	9202      	str	r2, [sp, #8]
		appconf.app_ppm_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018ebe:	ed8d 0a12 	vstr	s0, [sp, #72]	; 0x48
		appconf.app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018ec2:	f7f8 ff55 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018ec6:	4620      	mov	r0, r4
 8018ec8:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018eca:	ed8d 0a14 	vstr	s0, [sp, #80]	; 0x50
		appconf.app_ppm_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018ece:	f7f8 ff4f 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_ppm_conf.multi_esc = data[ind++];
 8018ed2:	9b02      	ldr	r3, [sp, #8]
 8018ed4:	1959      	adds	r1, r3, r5
 8018ed6:	5ce2      	ldrb	r2, [r4, r3]
		appconf.app_ppm_conf.tc = data[ind++];
 8018ed8:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_ppm_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018eda:	ed8d 0a15 	vstr	s0, [sp, #84]	; 0x54
		appconf.app_ppm_conf.multi_esc = data[ind++];
 8018ede:	3200      	adds	r2, #0
 8018ee0:	bf18      	it	ne
 8018ee2:	2201      	movne	r2, #1
		appconf.app_ppm_conf.tc = data[ind++];
 8018ee4:	3100      	adds	r1, #0
 8018ee6:	bf18      	it	ne
 8018ee8:	2101      	movne	r1, #1
 8018eea:	3302      	adds	r3, #2
		appconf.app_ppm_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8018eec:	4620      	mov	r0, r4
		appconf.app_ppm_conf.tc = data[ind++];
 8018eee:	f88d 1059 	strb.w	r1, [sp, #89]	; 0x59
		appconf.app_ppm_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8018ef2:	a902      	add	r1, sp, #8
		appconf.app_ppm_conf.multi_esc = data[ind++];
 8018ef4:	f88d 2058 	strb.w	r2, [sp, #88]	; 0x58
		appconf.app_ppm_conf.tc = data[ind++];
 8018ef8:	9302      	str	r3, [sp, #8]
		appconf.app_ppm_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8018efa:	f7f8 ff39 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.ctrl_type = data[ind++];
 8018efe:	9b02      	ldr	r3, [sp, #8]
		appconf.app_adc_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018f00:	4620      	mov	r0, r4
		appconf.app_adc_conf.ctrl_type = data[ind++];
 8018f02:	195a      	adds	r2, r3, r5
		appconf.app_adc_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018f04:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.ctrl_type = data[ind++];
 8018f06:	5ce3      	ldrb	r3, [r4, r3]
 8018f08:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 8018f0c:	9202      	str	r2, [sp, #8]
		appconf.app_ppm_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8018f0e:	ed8d 0a17 	vstr	s0, [sp, #92]	; 0x5c
		appconf.app_adc_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018f12:	f7f8 ff2d 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.voltage_start = buffer_get_float32_auto(data, &ind);
 8018f16:	4620      	mov	r0, r4
 8018f18:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.hyst = buffer_get_float32_auto(data, &ind);
 8018f1a:	ed8d 0a19 	vstr	s0, [sp, #100]	; 0x64
		appconf.app_adc_conf.voltage_start = buffer_get_float32_auto(data, &ind);
 8018f1e:	f7f8 ff27 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.voltage_end = buffer_get_float32_auto(data, &ind);
 8018f22:	4620      	mov	r0, r4
 8018f24:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.voltage_start = buffer_get_float32_auto(data, &ind);
 8018f26:	ed8d 0a1a 	vstr	s0, [sp, #104]	; 0x68
		appconf.app_adc_conf.voltage_end = buffer_get_float32_auto(data, &ind);
 8018f2a:	f7f8 ff21 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.voltage_center = buffer_get_float32_auto(data, &ind);
 8018f2e:	4620      	mov	r0, r4
 8018f30:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.voltage_end = buffer_get_float32_auto(data, &ind);
 8018f32:	ed8d 0a1b 	vstr	s0, [sp, #108]	; 0x6c
		appconf.app_adc_conf.voltage_center = buffer_get_float32_auto(data, &ind);
 8018f36:	f7f8 ff1b 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.voltage2_start = buffer_get_float32_auto(data, &ind);
 8018f3a:	4620      	mov	r0, r4
 8018f3c:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.voltage_center = buffer_get_float32_auto(data, &ind);
 8018f3e:	ed8d 0a1c 	vstr	s0, [sp, #112]	; 0x70
		appconf.app_adc_conf.voltage2_start = buffer_get_float32_auto(data, &ind);
 8018f42:	f7f8 ff15 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.voltage2_end = buffer_get_float32_auto(data, &ind);
 8018f46:	4620      	mov	r0, r4
 8018f48:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.voltage2_start = buffer_get_float32_auto(data, &ind);
 8018f4a:	ed8d 0a1d 	vstr	s0, [sp, #116]	; 0x74
		appconf.app_adc_conf.voltage2_end = buffer_get_float32_auto(data, &ind);
 8018f4e:	f7f8 ff0f 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.use_filter = data[ind++];
 8018f52:	9b02      	ldr	r3, [sp, #8]
 8018f54:	1959      	adds	r1, r3, r5
		appconf.app_adc_conf.safe_start = data[ind++];
 8018f56:	1c98      	adds	r0, r3, #2
 8018f58:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_adc_conf.cc_button_inverted = data[ind++];
 8018f5a:	5c27      	ldrb	r7, [r4, r0]
		appconf.app_adc_conf.safe_start = data[ind++];
 8018f5c:	3100      	adds	r1, #0
		appconf.app_adc_conf.cc_button_inverted = data[ind++];
 8018f5e:	f103 0203 	add.w	r2, r3, #3
		appconf.app_adc_conf.rev_button_inverted = data[ind++];
 8018f62:	f103 0004 	add.w	r0, r3, #4
		appconf.app_adc_conf.safe_start = data[ind++];
 8018f66:	bf18      	it	ne
 8018f68:	2101      	movne	r1, #1
		appconf.app_adc_conf.rev_button_inverted = data[ind++];
 8018f6a:	5ca6      	ldrb	r6, [r4, r2]
		appconf.app_adc_conf.voltage_inverted = data[ind++];
 8018f6c:	5c20      	ldrb	r0, [r4, r0]
		appconf.app_adc_conf.use_filter = data[ind++];
 8018f6e:	5ce2      	ldrb	r2, [r4, r3]
		appconf.app_adc_conf.safe_start = data[ind++];
 8018f70:	f88d 107d 	strb.w	r1, [sp, #125]	; 0x7d
		appconf.app_adc_conf.voltage_inverted = data[ind++];
 8018f74:	1d59      	adds	r1, r3, #5
		appconf.app_adc_conf.cc_button_inverted = data[ind++];
 8018f76:	3700      	adds	r7, #0
		appconf.app_adc_conf.voltage2_inverted = data[ind++];
 8018f78:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_adc_conf.voltage2_end = buffer_get_float32_auto(data, &ind);
 8018f7a:	ed8d 0a1e 	vstr	s0, [sp, #120]	; 0x78
		appconf.app_adc_conf.cc_button_inverted = data[ind++];
 8018f7e:	bf18      	it	ne
 8018f80:	2701      	movne	r7, #1
		appconf.app_adc_conf.rev_button_inverted = data[ind++];
 8018f82:	3600      	adds	r6, #0
 8018f84:	bf18      	it	ne
 8018f86:	2601      	movne	r6, #1
		appconf.app_adc_conf.voltage_inverted = data[ind++];
 8018f88:	3000      	adds	r0, #0
 8018f8a:	bf18      	it	ne
 8018f8c:	2001      	movne	r0, #1
		appconf.app_adc_conf.voltage2_inverted = data[ind++];
 8018f8e:	3100      	adds	r1, #0
 8018f90:	bf18      	it	ne
 8018f92:	2101      	movne	r1, #1
		appconf.app_adc_conf.use_filter = data[ind++];
 8018f94:	3200      	adds	r2, #0
 8018f96:	bf18      	it	ne
 8018f98:	2201      	movne	r2, #1
		appconf.app_adc_conf.voltage2_inverted = data[ind++];
 8018f9a:	3306      	adds	r3, #6
		appconf.app_adc_conf.voltage_inverted = data[ind++];
 8018f9c:	f88d 0080 	strb.w	r0, [sp, #128]	; 0x80
		appconf.app_adc_conf.voltage2_inverted = data[ind++];
 8018fa0:	f88d 1081 	strb.w	r1, [sp, #129]	; 0x81
		appconf.app_adc_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018fa4:	4620      	mov	r0, r4
 8018fa6:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.use_filter = data[ind++];
 8018fa8:	f88d 207c 	strb.w	r2, [sp, #124]	; 0x7c
		appconf.app_adc_conf.voltage2_inverted = data[ind++];
 8018fac:	9302      	str	r3, [sp, #8]
		appconf.app_adc_conf.rev_button_inverted = data[ind++];
 8018fae:	f88d 607f 	strb.w	r6, [sp, #127]	; 0x7f
		appconf.app_adc_conf.cc_button_inverted = data[ind++];
 8018fb2:	f88d 707e 	strb.w	r7, [sp, #126]	; 0x7e
		appconf.app_adc_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018fb6:	f7f8 fedb 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018fba:	4620      	mov	r0, r4
 8018fbc:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8018fbe:	ed8d 0a21 	vstr	s0, [sp, #132]	; 0x84
		appconf.app_adc_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018fc2:	f7f8 fed5 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.throttle_exp_mode = data[ind++];
 8018fc6:	9b02      	ldr	r3, [sp, #8]
		appconf.app_adc_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018fc8:	4620      	mov	r0, r4
		appconf.app_adc_conf.throttle_exp_mode = data[ind++];
 8018fca:	195a      	adds	r2, r3, r5
		appconf.app_adc_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018fcc:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.throttle_exp_mode = data[ind++];
 8018fce:	5ce3      	ldrb	r3, [r4, r3]
 8018fd0:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 8018fd4:	9202      	str	r2, [sp, #8]
		appconf.app_adc_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8018fd6:	ed8d 0a22 	vstr	s0, [sp, #136]	; 0x88
		appconf.app_adc_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018fda:	f7f8 fec9 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018fde:	4620      	mov	r0, r4
 8018fe0:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8018fe2:	ed8d 0a24 	vstr	s0, [sp, #144]	; 0x90
		appconf.app_adc_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018fe6:	f7f8 fec3 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.multi_esc = data[ind++];
 8018fea:	9b02      	ldr	r3, [sp, #8]
 8018fec:	1959      	adds	r1, r3, r5
 8018fee:	5ce2      	ldrb	r2, [r4, r3]
		appconf.app_adc_conf.tc = data[ind++];
 8018ff0:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_adc_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8018ff2:	ed8d 0a25 	vstr	s0, [sp, #148]	; 0x94
		appconf.app_adc_conf.multi_esc = data[ind++];
 8018ff6:	3200      	adds	r2, #0
 8018ff8:	bf18      	it	ne
 8018ffa:	2201      	movne	r2, #1
		appconf.app_adc_conf.tc = data[ind++];
 8018ffc:	3100      	adds	r1, #0
 8018ffe:	bf18      	it	ne
 8019000:	2101      	movne	r1, #1
 8019002:	3302      	adds	r3, #2
		appconf.app_adc_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8019004:	4620      	mov	r0, r4
		appconf.app_adc_conf.tc = data[ind++];
 8019006:	f88d 1099 	strb.w	r1, [sp, #153]	; 0x99
		appconf.app_adc_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 801900a:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.multi_esc = data[ind++];
 801900c:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
		appconf.app_adc_conf.tc = data[ind++];
 8019010:	9302      	str	r3, [sp, #8]
		appconf.app_adc_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 8019012:	f7f8 fead 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_adc_conf.update_rate_hz = buffer_get_uint16(data, &ind);
 8019016:	a902      	add	r1, sp, #8
 8019018:	4620      	mov	r0, r4
		appconf.app_adc_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 801901a:	ed8d 0a27 	vstr	s0, [sp, #156]	; 0x9c
		appconf.app_adc_conf.update_rate_hz = buffer_get_uint16(data, &ind);
 801901e:	f7f8 fe57 	bl	8011cd0 <buffer_get_uint16>
		appconf.app_uart_baudrate = buffer_get_uint32(data, &ind);
 8019022:	a902      	add	r1, sp, #8
		appconf.app_adc_conf.update_rate_hz = buffer_get_uint16(data, &ind);
 8019024:	9028      	str	r0, [sp, #160]	; 0xa0
		appconf.app_uart_baudrate = buffer_get_uint32(data, &ind);
 8019026:	4620      	mov	r0, r4
 8019028:	f7f8 fe7a 	bl	8011d20 <buffer_get_uint32>
		appconf.app_chuk_conf.ctrl_type = data[ind++];
 801902c:	9b02      	ldr	r3, [sp, #8]
		appconf.app_uart_baudrate = buffer_get_uint32(data, &ind);
 801902e:	9029      	str	r0, [sp, #164]	; 0xa4
		appconf.app_chuk_conf.ctrl_type = data[ind++];
 8019030:	195a      	adds	r2, r3, r5
		appconf.app_chuk_conf.hyst = buffer_get_float32_auto(data, &ind);
 8019032:	4620      	mov	r0, r4
		appconf.app_chuk_conf.ctrl_type = data[ind++];
 8019034:	5ce3      	ldrb	r3, [r4, r3]
 8019036:	f88d 30a8 	strb.w	r3, [sp, #168]	; 0xa8
		appconf.app_chuk_conf.hyst = buffer_get_float32_auto(data, &ind);
 801903a:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.ctrl_type = data[ind++];
 801903c:	9202      	str	r2, [sp, #8]
		appconf.app_chuk_conf.hyst = buffer_get_float32_auto(data, &ind);
 801903e:	f7f8 fe97 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8019042:	4620      	mov	r0, r4
 8019044:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.hyst = buffer_get_float32_auto(data, &ind);
 8019046:	ed8d 0a2b 	vstr	s0, [sp, #172]	; 0xac
		appconf.app_chuk_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 801904a:	f7f8 fe91 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 801904e:	4620      	mov	r0, r4
 8019050:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.ramp_time_pos = buffer_get_float32_auto(data, &ind);
 8019052:	ed8d 0a2c 	vstr	s0, [sp, #176]	; 0xb0
		appconf.app_chuk_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 8019056:	f7f8 fe8b 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.stick_erpm_per_s_in_cc = buffer_get_float32_auto(data, &ind);
 801905a:	4620      	mov	r0, r4
 801905c:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.ramp_time_neg = buffer_get_float32_auto(data, &ind);
 801905e:	ed8d 0a2d 	vstr	s0, [sp, #180]	; 0xb4
		appconf.app_chuk_conf.stick_erpm_per_s_in_cc = buffer_get_float32_auto(data, &ind);
 8019062:	f7f8 fe85 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8019066:	4620      	mov	r0, r4
 8019068:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.stick_erpm_per_s_in_cc = buffer_get_float32_auto(data, &ind);
 801906a:	ed8d 0a2e 	vstr	s0, [sp, #184]	; 0xb8
		appconf.app_chuk_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 801906e:	f7f8 fe7f 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 8019072:	4620      	mov	r0, r4
 8019074:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.throttle_exp = buffer_get_float32_auto(data, &ind);
 8019076:	ed8d 0a2f 	vstr	s0, [sp, #188]	; 0xbc
		appconf.app_chuk_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 801907a:	f7f8 fe79 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_chuk_conf.throttle_exp_mode = data[ind++];
 801907e:	9b02      	ldr	r3, [sp, #8]
 8019080:	1959      	adds	r1, r3, r5
		appconf.app_chuk_conf.multi_esc = data[ind++];
 8019082:	1c9a      	adds	r2, r3, #2
 8019084:	5c60      	ldrb	r0, [r4, r1]
		appconf.app_chuk_conf.tc = data[ind++];
 8019086:	5ca2      	ldrb	r2, [r4, r2]
		appconf.app_chuk_conf.throttle_exp_mode = data[ind++];
 8019088:	5ce1      	ldrb	r1, [r4, r3]
 801908a:	f88d 10c4 	strb.w	r1, [sp, #196]	; 0xc4
		appconf.app_chuk_conf.multi_esc = data[ind++];
 801908e:	3000      	adds	r0, #0
 8019090:	bf18      	it	ne
 8019092:	2001      	movne	r0, #1
		appconf.app_chuk_conf.tc = data[ind++];
 8019094:	3200      	adds	r2, #0
 8019096:	bf18      	it	ne
 8019098:	2201      	movne	r2, #1
 801909a:	3303      	adds	r3, #3
		appconf.app_chuk_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 801909c:	a902      	add	r1, sp, #8
		appconf.app_chuk_conf.multi_esc = data[ind++];
 801909e:	f88d 00c5 	strb.w	r0, [sp, #197]	; 0xc5
		appconf.app_chuk_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 80190a2:	4620      	mov	r0, r4
		appconf.app_chuk_conf.tc = data[ind++];
 80190a4:	f88d 20c6 	strb.w	r2, [sp, #198]	; 0xc6
 80190a8:	9302      	str	r3, [sp, #8]
		appconf.app_chuk_conf.throttle_exp_brake = buffer_get_float32_auto(data, &ind);
 80190aa:	ed8d 0a30 	vstr	s0, [sp, #192]	; 0xc0
		appconf.app_chuk_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 80190ae:	f7f8 fe5f 	bl	8011d70 <buffer_get_float32_auto>
		appconf.app_nrf_conf.speed = data[ind++];
 80190b2:	9b02      	ldr	r3, [sp, #8]
		appconf.app_chuk_conf.tc_max_diff = buffer_get_float32_auto(data, &ind);
 80190b4:	ed8d 0a32 	vstr	s0, [sp, #200]	; 0xc8
		appconf.app_nrf_conf.speed = data[ind++];
 80190b8:	1959      	adds	r1, r3, r5
		appconf.app_nrf_conf.power = data[ind++];
 80190ba:	1c9a      	adds	r2, r3, #2
		appconf.app_nrf_conf.crc_type = data[ind++];
 80190bc:	1cde      	adds	r6, r3, #3
		appconf.app_nrf_conf.retry_delay = data[ind++];
 80190be:	1d18      	adds	r0, r3, #4
		appconf.app_nrf_conf.power = data[ind++];
 80190c0:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_nrf_conf.crc_type = data[ind++];
 80190c2:	5ca2      	ldrb	r2, [r4, r2]
		appconf.app_nrf_conf.retries = data[ind++];
 80190c4:	5c20      	ldrb	r0, [r4, r0]
		appconf.app_nrf_conf.retry_delay = data[ind++];
 80190c6:	5da6      	ldrb	r6, [r4, r6]
		appconf.app_nrf_conf.power = data[ind++];
 80190c8:	f88d 10cd 	strb.w	r1, [sp, #205]	; 0xcd
		appconf.app_nrf_conf.retries = data[ind++];
 80190cc:	1d59      	adds	r1, r3, #5
		appconf.app_nrf_conf.crc_type = data[ind++];
 80190ce:	f88d 20ce 	strb.w	r2, [sp, #206]	; 0xce
		appconf.app_nrf_conf.send_crc_ack = data[ind++];
 80190d2:	18e2      	adds	r2, r4, r3
		appconf.app_nrf_conf.channel = data[ind++];
 80190d4:	5c61      	ldrb	r1, [r4, r1]
		appconf.app_nrf_conf.send_crc_ack = data[ind++];
 80190d6:	7a52      	ldrb	r2, [r2, #9]
		appconf.app_nrf_conf.retries = data[ind++];
 80190d8:	f88d 00d0 	strb.w	r0, [sp, #208]	; 0xd0
		appconf.app_nrf_conf.channel = data[ind++];
 80190dc:	f88d 10d1 	strb.w	r1, [sp, #209]	; 0xd1
		appconf.app_nrf_conf.retry_delay = data[ind++];
 80190e0:	f88d 60cf 	strb.w	r6, [sp, #207]	; 0xcf
		appconf.app_nrf_conf.channel = data[ind++];
 80190e4:	1d98      	adds	r0, r3, #6
		memcpy(appconf.app_nrf_conf.address, data + ind, 3);
 80190e6:	1821      	adds	r1, r4, r0
		appconf.app_nrf_conf.speed = data[ind++];
 80190e8:	5ce4      	ldrb	r4, [r4, r3]
 80190ea:	f88d 40cc 	strb.w	r4, [sp, #204]	; 0xcc
		appconf.app_nrf_conf.channel = data[ind++];
 80190ee:	9002      	str	r0, [sp, #8]
		appconf.app_nrf_conf.send_crc_ack = data[ind++];
 80190f0:	3200      	adds	r2, #0
		memcpy(appconf.app_nrf_conf.address, data + ind, 3);
 80190f2:	7888      	ldrb	r0, [r1, #2]
 80190f4:	8809      	ldrh	r1, [r1, #0]
 80190f6:	f88d 00d4 	strb.w	r0, [sp, #212]	; 0xd4
		appconf.app_nrf_conf.send_crc_ack = data[ind++];
 80190fa:	bf18      	it	ne
 80190fc:	2201      	movne	r2, #1
 80190fe:	330a      	adds	r3, #10
		conf_general_store_app_configuration(&appconf);
 8019100:	a804      	add	r0, sp, #16
		appconf.app_nrf_conf.send_crc_ack = data[ind++];
 8019102:	f88d 20d5 	strb.w	r2, [sp, #213]	; 0xd5
 8019106:	9302      	str	r3, [sp, #8]
		memcpy(appconf.app_nrf_conf.address, data + ind, 3);
 8019108:	f8ad 10d2 	strh.w	r1, [sp, #210]	; 0xd2
		conf_general_store_app_configuration(&appconf);
 801910c:	f7fe fc78 	bl	8017a00 <conf_general_store_app_configuration>
		app_set_configuration(&appconf);
 8019110:	a804      	add	r0, sp, #16
 8019112:	f007 fa4d 	bl	80205b0 <app_set_configuration>
		timeout_configure(appconf.timeout_msec, appconf.timeout_brake_current);
 8019116:	ed9d 0a06 	vldr	s0, [sp, #24]
 801911a:	9805      	ldr	r0, [sp, #20]
 801911c:	f001 f810 	bl	801a140 <timeout_configure>
		chThdSleepMilliseconds(200);
 8019120:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8019124:	f7f4 fc5c 	bl	800d9e0 <chThdSleep>
	if (send_func) {
 8019128:	4b05      	ldr	r3, [pc, #20]	; (8019140 <commands_process_packet+0x790>)
		send_buffer[ind++] = packet_id;
 801912a:	4806      	ldr	r0, [pc, #24]	; (8019144 <commands_process_packet+0x794>)
	if (send_func) {
 801912c:	681b      	ldr	r3, [r3, #0]
		send_buffer[ind++] = packet_id;
 801912e:	9502      	str	r5, [sp, #8]
 8019130:	2210      	movs	r2, #16
 8019132:	7002      	strb	r2, [r0, #0]
	if (send_func) {
 8019134:	2b00      	cmp	r3, #0
 8019136:	f43f acbc 	beq.w	8018ab2 <commands_process_packet+0x102>
		send_func(data, len);
 801913a:	4629      	mov	r1, r5
 801913c:	4798      	blx	r3
 801913e:	e4b8      	b.n	8018ab2 <commands_process_packet+0x102>
 8019140:	200094f0 	.word	0x200094f0
 8019144:	200090f0 	.word	0x200090f0
		if (packet_id == COMM_GET_MCCONF) {
 8019148:	f1b8 0f0e 	cmp.w	r8, #14
 801914c:	f000 8735 	beq.w	8019fba <commands_process_packet+0x160a>
			conf_general_get_default_mc_configuration(&mcconf);
 8019150:	48f1      	ldr	r0, [pc, #964]	; (8019518 <commands_process_packet+0xb68>)
 8019152:	f7fe fac5 	bl	80176e0 <conf_general_get_default_mc_configuration>
		send_buffer[ind++] = mcconf.sensor_mode;
 8019156:	ae36      	add	r6, sp, #216	; 0xd8
		send_buffer[ind++] = mcconf.pwm_mode;
 8019158:	4def      	ldr	r5, [pc, #956]	; (8019518 <commands_process_packet+0xb68>)
		send_buffer[ind++] = packet_id;
 801915a:	4cf0      	ldr	r4, [pc, #960]	; (801951c <commands_process_packet+0xb6c>)
		send_buffer[ind++] = mcconf.comm_mode;
 801915c:	7868      	ldrb	r0, [r5, #1]
		send_buffer[ind++] = mcconf.motor_type;
 801915e:	78aa      	ldrb	r2, [r5, #2]
		buffer_append_float32_auto(send_buffer, mcconf.l_current_max, &ind);
 8019160:	ed95 0a01 	vldr	s0, [r5, #4]
		send_buffer[ind++] = mcconf.comm_mode;
 8019164:	70a0      	strb	r0, [r4, #2]
		send_buffer[ind++] = mcconf.sensor_mode;
 8019166:	2305      	movs	r3, #5
 8019168:	f846 3dd0 	str.w	r3, [r6, #-208]!
		send_buffer[ind++] = mcconf.pwm_mode;
 801916c:	782b      	ldrb	r3, [r5, #0]
 801916e:	7063      	strb	r3, [r4, #1]
		buffer_append_float32_auto(send_buffer, mcconf.l_current_max, &ind);
 8019170:	4631      	mov	r1, r6
		send_buffer[ind++] = mcconf.sensor_mode;
 8019172:	78eb      	ldrb	r3, [r5, #3]
		send_buffer[ind++] = mcconf.motor_type;
 8019174:	70e2      	strb	r2, [r4, #3]
		buffer_append_float32_auto(send_buffer, mcconf.l_current_max, &ind);
 8019176:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.sensor_mode;
 8019178:	7123      	strb	r3, [r4, #4]
		send_buffer[ind++] = packet_id;
 801917a:	f884 8000 	strb.w	r8, [r4]
		buffer_append_float32_auto(send_buffer, mcconf.l_current_max, &ind);
 801917e:	f7f8 fd57 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_current_min, &ind);
 8019182:	4631      	mov	r1, r6
 8019184:	ed95 0a02 	vldr	s0, [r5, #8]
 8019188:	4620      	mov	r0, r4
 801918a:	f7f8 fd51 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_in_current_max, &ind);
 801918e:	4631      	mov	r1, r6
 8019190:	ed95 0a03 	vldr	s0, [r5, #12]
 8019194:	4620      	mov	r0, r4
 8019196:	f7f8 fd4b 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_in_current_min, &ind);
 801919a:	4631      	mov	r1, r6
 801919c:	ed95 0a04 	vldr	s0, [r5, #16]
 80191a0:	4620      	mov	r0, r4
 80191a2:	f7f8 fd45 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_abs_current_max, &ind);
 80191a6:	4631      	mov	r1, r6
 80191a8:	ed95 0a05 	vldr	s0, [r5, #20]
 80191ac:	4620      	mov	r0, r4
 80191ae:	f7f8 fd3f 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_min_erpm, &ind);
 80191b2:	4631      	mov	r1, r6
 80191b4:	ed95 0a06 	vldr	s0, [r5, #24]
 80191b8:	4620      	mov	r0, r4
 80191ba:	f7f8 fd39 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_max_erpm, &ind);
 80191be:	4631      	mov	r1, r6
 80191c0:	ed95 0a07 	vldr	s0, [r5, #28]
 80191c4:	4620      	mov	r0, r4
 80191c6:	f7f8 fd33 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_erpm_start, &ind);
 80191ca:	4631      	mov	r1, r6
 80191cc:	ed95 0a08 	vldr	s0, [r5, #32]
 80191d0:	4620      	mov	r0, r4
 80191d2:	f7f8 fd2d 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_max_erpm_fbrake, &ind);
 80191d6:	4631      	mov	r1, r6
 80191d8:	ed95 0a09 	vldr	s0, [r5, #36]	; 0x24
 80191dc:	4620      	mov	r0, r4
 80191de:	f7f8 fd27 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_max_erpm_fbrake_cc, &ind);
 80191e2:	4631      	mov	r1, r6
 80191e4:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
 80191e8:	4620      	mov	r0, r4
 80191ea:	f7f8 fd21 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_min_vin, &ind);
 80191ee:	4631      	mov	r1, r6
 80191f0:	ed95 0a0b 	vldr	s0, [r5, #44]	; 0x2c
 80191f4:	4620      	mov	r0, r4
 80191f6:	f7f8 fd1b 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_max_vin, &ind);
 80191fa:	4631      	mov	r1, r6
 80191fc:	ed95 0a0c 	vldr	s0, [r5, #48]	; 0x30
 8019200:	4620      	mov	r0, r4
 8019202:	f7f8 fd15 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_battery_cut_start, &ind);
 8019206:	4631      	mov	r1, r6
 8019208:	ed95 0a0d 	vldr	s0, [r5, #52]	; 0x34
 801920c:	4620      	mov	r0, r4
 801920e:	f7f8 fd0f 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_battery_cut_end, &ind);
 8019212:	4631      	mov	r1, r6
 8019214:	ed95 0a0e 	vldr	s0, [r5, #56]	; 0x38
 8019218:	4620      	mov	r0, r4
 801921a:	f7f8 fd09 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.l_slow_abs_current;
 801921e:	9b02      	ldr	r3, [sp, #8]
 8019220:	f895 203c 	ldrb.w	r2, [r5, #60]	; 0x3c
 8019224:	54e2      	strb	r2, [r4, r3]
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_fet_start, &ind);
 8019226:	ed95 0a10 	vldr	s0, [r5, #64]	; 0x40
		send_buffer[ind++] = mcconf.l_slow_abs_current;
 801922a:	3301      	adds	r3, #1
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_fet_start, &ind);
 801922c:	4631      	mov	r1, r6
 801922e:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.l_slow_abs_current;
 8019230:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_fet_start, &ind);
 8019232:	f7f8 fcfd 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_fet_end, &ind);
 8019236:	4631      	mov	r1, r6
 8019238:	ed95 0a11 	vldr	s0, [r5, #68]	; 0x44
 801923c:	4620      	mov	r0, r4
 801923e:	f7f8 fcf7 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_motor_start, &ind);
 8019242:	4631      	mov	r1, r6
 8019244:	ed95 0a12 	vldr	s0, [r5, #72]	; 0x48
 8019248:	4620      	mov	r0, r4
 801924a:	f7f8 fcf1 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_motor_end, &ind);
 801924e:	4631      	mov	r1, r6
 8019250:	ed95 0a13 	vldr	s0, [r5, #76]	; 0x4c
 8019254:	4620      	mov	r0, r4
 8019256:	f7f8 fceb 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_temp_accel_dec, &ind);
 801925a:	4631      	mov	r1, r6
 801925c:	ed95 0a14 	vldr	s0, [r5, #80]	; 0x50
 8019260:	4620      	mov	r0, r4
 8019262:	f7f8 fce5 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_min_duty, &ind);
 8019266:	4631      	mov	r1, r6
 8019268:	ed95 0a15 	vldr	s0, [r5, #84]	; 0x54
 801926c:	4620      	mov	r0, r4
 801926e:	f7f8 fcdf 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_max_duty, &ind);
 8019272:	4631      	mov	r1, r6
 8019274:	ed95 0a16 	vldr	s0, [r5, #88]	; 0x58
 8019278:	4620      	mov	r0, r4
 801927a:	f7f8 fcd9 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_watt_max, &ind);
 801927e:	4631      	mov	r1, r6
 8019280:	ed95 0a17 	vldr	s0, [r5, #92]	; 0x5c
 8019284:	4620      	mov	r0, r4
 8019286:	f7f8 fcd3 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.l_watt_min, &ind);
 801928a:	4631      	mov	r1, r6
 801928c:	ed95 0a18 	vldr	s0, [r5, #96]	; 0x60
 8019290:	4620      	mov	r0, r4
 8019292:	f7f8 fccd 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_min_erpm, &ind);
 8019296:	4631      	mov	r1, r6
 8019298:	ed95 0a1f 	vldr	s0, [r5, #124]	; 0x7c
 801929c:	4620      	mov	r0, r4
 801929e:	f7f8 fcc7 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_min_erpm_cycle_int_limit, &ind);
 80192a2:	4631      	mov	r1, r6
 80192a4:	ed95 0a20 	vldr	s0, [r5, #128]	; 0x80
 80192a8:	4620      	mov	r0, r4
 80192aa:	f7f8 fcc1 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_max_fullbreak_current_dir_change, &ind);
 80192ae:	4631      	mov	r1, r6
 80192b0:	ed95 0a21 	vldr	s0, [r5, #132]	; 0x84
 80192b4:	4620      	mov	r0, r4
 80192b6:	f7f8 fcbb 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_cycle_int_limit, &ind);
 80192ba:	4631      	mov	r1, r6
 80192bc:	ed95 0a22 	vldr	s0, [r5, #136]	; 0x88
 80192c0:	4620      	mov	r0, r4
 80192c2:	f7f8 fcb5 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_phase_advance_at_br, &ind);
 80192c6:	4631      	mov	r1, r6
 80192c8:	ed95 0a23 	vldr	s0, [r5, #140]	; 0x8c
 80192cc:	4620      	mov	r0, r4
 80192ce:	f7f8 fcaf 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_cycle_int_rpm_br, &ind);
 80192d2:	4631      	mov	r1, r6
 80192d4:	ed95 0a24 	vldr	s0, [r5, #144]	; 0x90
 80192d8:	4620      	mov	r0, r4
 80192da:	f7f8 fca9 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.sl_bemf_coupling_k, &ind);
 80192de:	4631      	mov	r1, r6
 80192e0:	ed95 0a25 	vldr	s0, [r5, #148]	; 0x94
 80192e4:	4620      	mov	r0, r4
 80192e6:	f7f8 fca3 	bl	8011c30 <buffer_append_float32_auto>
		memcpy(send_buffer + ind, mcconf.hall_table, 8);
 80192ea:	9b02      	ldr	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.hall_sl_erpm, &ind);
 80192ec:	ed95 0a28 	vldr	s0, [r5, #160]	; 0xa0
		memcpy(send_buffer + ind, mcconf.hall_table, 8);
 80192f0:	f105 0298 	add.w	r2, r5, #152	; 0x98
 80192f4:	ca03      	ldmia	r2!, {r0, r1}
 80192f6:	18e2      	adds	r2, r4, r3
 80192f8:	50e0      	str	r0, [r4, r3]
		ind += 8;
 80192fa:	3308      	adds	r3, #8
		memcpy(send_buffer + ind, mcconf.hall_table, 8);
 80192fc:	6051      	str	r1, [r2, #4]
		buffer_append_float32_auto(send_buffer, mcconf.hall_sl_erpm, &ind);
 80192fe:	4620      	mov	r0, r4
 8019300:	4631      	mov	r1, r6
		ind += 8;
 8019302:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.hall_sl_erpm, &ind);
 8019304:	f7f8 fc94 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_current_kp, &ind);
 8019308:	4631      	mov	r1, r6
 801930a:	ed95 0a29 	vldr	s0, [r5, #164]	; 0xa4
 801930e:	4620      	mov	r0, r4
 8019310:	f7f8 fc8e 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_current_ki, &ind);
 8019314:	4631      	mov	r1, r6
 8019316:	ed95 0a2a 	vldr	s0, [r5, #168]	; 0xa8
 801931a:	4620      	mov	r0, r4
 801931c:	f7f8 fc88 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_f_sw, &ind);
 8019320:	4631      	mov	r1, r6
 8019322:	ed95 0a2b 	vldr	s0, [r5, #172]	; 0xac
 8019326:	4620      	mov	r0, r4
 8019328:	f7f8 fc82 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_dt_us, &ind);
 801932c:	4631      	mov	r1, r6
 801932e:	ed95 0a2c 	vldr	s0, [r5, #176]	; 0xb0
 8019332:	4620      	mov	r0, r4
 8019334:	f7f8 fc7c 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.foc_encoder_inverted;
 8019338:	9b02      	ldr	r3, [sp, #8]
 801933a:	f895 20b8 	ldrb.w	r2, [r5, #184]	; 0xb8
 801933e:	54e2      	strb	r2, [r4, r3]
		buffer_append_float32_auto(send_buffer, mcconf.foc_encoder_offset, &ind);
 8019340:	ed95 0a2d 	vldr	s0, [r5, #180]	; 0xb4
		send_buffer[ind++] = mcconf.foc_encoder_inverted;
 8019344:	3301      	adds	r3, #1
		buffer_append_float32_auto(send_buffer, mcconf.foc_encoder_offset, &ind);
 8019346:	4631      	mov	r1, r6
 8019348:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.foc_encoder_inverted;
 801934a:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.foc_encoder_offset, &ind);
 801934c:	f7f8 fc70 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_encoder_ratio, &ind);
 8019350:	4631      	mov	r1, r6
 8019352:	ed95 0a2f 	vldr	s0, [r5, #188]	; 0xbc
 8019356:	4620      	mov	r0, r4
 8019358:	f7f8 fc6a 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.foc_sensor_mode;
 801935c:	9b02      	ldr	r3, [sp, #8]
 801935e:	f895 20f8 	ldrb.w	r2, [r5, #248]	; 0xf8
 8019362:	54e2      	strb	r2, [r4, r3]
		buffer_append_float32_auto(send_buffer, mcconf.foc_pll_kp, &ind);
 8019364:	ed95 0a35 	vldr	s0, [r5, #212]	; 0xd4
		send_buffer[ind++] = mcconf.foc_sensor_mode;
 8019368:	3301      	adds	r3, #1
		buffer_append_float32_auto(send_buffer, mcconf.foc_pll_kp, &ind);
 801936a:	4631      	mov	r1, r6
 801936c:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.foc_sensor_mode;
 801936e:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.foc_pll_kp, &ind);
 8019370:	f7f8 fc5e 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_pll_ki, &ind);
 8019374:	4631      	mov	r1, r6
 8019376:	ed95 0a36 	vldr	s0, [r5, #216]	; 0xd8
 801937a:	4620      	mov	r0, r4
 801937c:	f7f8 fc58 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_motor_l, &ind);
 8019380:	4631      	mov	r1, r6
 8019382:	ed95 0a30 	vldr	s0, [r5, #192]	; 0xc0
 8019386:	4620      	mov	r0, r4
 8019388:	f7f8 fc52 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_motor_r, &ind);
 801938c:	4631      	mov	r1, r6
 801938e:	ed95 0a31 	vldr	s0, [r5, #196]	; 0xc4
 8019392:	4620      	mov	r0, r4
 8019394:	f7f8 fc4c 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_motor_flux_linkage, &ind);
 8019398:	4631      	mov	r1, r6
 801939a:	ed95 0a32 	vldr	s0, [r5, #200]	; 0xc8
 801939e:	4620      	mov	r0, r4
 80193a0:	f7f8 fc46 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_observer_gain, &ind);
 80193a4:	4631      	mov	r1, r6
 80193a6:	ed95 0a33 	vldr	s0, [r5, #204]	; 0xcc
 80193aa:	4620      	mov	r0, r4
 80193ac:	f7f8 fc40 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_observer_gain_slow, &ind);
 80193b0:	4631      	mov	r1, r6
 80193b2:	ed95 0a34 	vldr	s0, [r5, #208]	; 0xd0
 80193b6:	4620      	mov	r0, r4
 80193b8:	f7f8 fc3a 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_duty_dowmramp_kp, &ind);
 80193bc:	4631      	mov	r1, r6
 80193be:	ed95 0a37 	vldr	s0, [r5, #220]	; 0xdc
 80193c2:	4620      	mov	r0, r4
 80193c4:	f7f8 fc34 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_duty_dowmramp_ki, &ind);
 80193c8:	4631      	mov	r1, r6
 80193ca:	ed95 0a38 	vldr	s0, [r5, #224]	; 0xe0
 80193ce:	4620      	mov	r0, r4
 80193d0:	f7f8 fc2e 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_openloop_rpm, &ind);
 80193d4:	4631      	mov	r1, r6
 80193d6:	ed95 0a39 	vldr	s0, [r5, #228]	; 0xe4
 80193da:	4620      	mov	r0, r4
 80193dc:	f7f8 fc28 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_openloop_hyst, &ind);
 80193e0:	4631      	mov	r1, r6
 80193e2:	ed95 0a3a 	vldr	s0, [r5, #232]	; 0xe8
 80193e6:	4620      	mov	r0, r4
 80193e8:	f7f8 fc22 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_openloop_time, &ind);
 80193ec:	4631      	mov	r1, r6
 80193ee:	ed95 0a3b 	vldr	s0, [r5, #236]	; 0xec
 80193f2:	4620      	mov	r0, r4
 80193f4:	f7f8 fc1c 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_d_current_duty, &ind);
 80193f8:	4631      	mov	r1, r6
 80193fa:	ed95 0a3c 	vldr	s0, [r5, #240]	; 0xf0
 80193fe:	4620      	mov	r0, r4
 8019400:	f7f8 fc16 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_d_current_factor, &ind);
 8019404:	4631      	mov	r1, r6
 8019406:	ed95 0a3d 	vldr	s0, [r5, #244]	; 0xf4
 801940a:	4620      	mov	r0, r4
 801940c:	f7f8 fc10 	bl	8011c30 <buffer_append_float32_auto>
		memcpy(send_buffer + ind, mcconf.foc_hall_table, 8);
 8019410:	462a      	mov	r2, r5
 8019412:	9b02      	ldr	r3, [sp, #8]
 8019414:	f852 1ff9 	ldr.w	r1, [r2, #249]!
 8019418:	50e1      	str	r1, [r4, r3]
 801941a:	6850      	ldr	r0, [r2, #4]
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_erpm, &ind);
 801941c:	ed95 0a41 	vldr	s0, [r5, #260]	; 0x104
		memcpy(send_buffer + ind, mcconf.foc_hall_table, 8);
 8019420:	18e2      	adds	r2, r4, r3
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_erpm, &ind);
 8019422:	4631      	mov	r1, r6
		ind += 8;
 8019424:	3308      	adds	r3, #8
		memcpy(send_buffer + ind, mcconf.foc_hall_table, 8);
 8019426:	6050      	str	r0, [r2, #4]
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_erpm, &ind);
 8019428:	4620      	mov	r0, r4
		ind += 8;
 801942a:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.foc_sl_erpm, &ind);
 801942c:	f7f8 fc00 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.foc_sample_v0_v7;
 8019430:	9b02      	ldr	r3, [sp, #8]
 8019432:	f895 2108 	ldrb.w	r2, [r5, #264]	; 0x108
 8019436:	54e2      	strb	r2, [r4, r3]
		send_buffer[ind++] = mcconf.foc_sample_high_current;
 8019438:	18e2      	adds	r2, r4, r3
 801943a:	f895 7109 	ldrb.w	r7, [r5, #265]	; 0x109
		buffer_append_float32_auto(send_buffer, mcconf.foc_sat_comp, &ind);
 801943e:	ed95 0a43 	vldr	s0, [r5, #268]	; 0x10c
		send_buffer[ind++] = mcconf.foc_sample_high_current;
 8019442:	7057      	strb	r7, [r2, #1]
 8019444:	3302      	adds	r3, #2
		buffer_append_float32_auto(send_buffer, mcconf.foc_sat_comp, &ind);
 8019446:	4631      	mov	r1, r6
 8019448:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.foc_sample_high_current;
 801944a:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.foc_sat_comp, &ind);
 801944c:	f7f8 fbf0 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.foc_temp_comp;
 8019450:	9b02      	ldr	r3, [sp, #8]
 8019452:	f895 2110 	ldrb.w	r2, [r5, #272]	; 0x110
 8019456:	54e2      	strb	r2, [r4, r3]
		buffer_append_float32_auto(send_buffer, mcconf.foc_temp_comp_base_temp, &ind);
 8019458:	ed95 0a45 	vldr	s0, [r5, #276]	; 0x114
		send_buffer[ind++] = mcconf.foc_temp_comp;
 801945c:	3301      	adds	r3, #1
		buffer_append_float32_auto(send_buffer, mcconf.foc_temp_comp_base_temp, &ind);
 801945e:	4631      	mov	r1, r6
 8019460:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.foc_temp_comp;
 8019462:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.foc_temp_comp_base_temp, &ind);
 8019464:	f7f8 fbe4 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.s_pid_kp, &ind);
 8019468:	4631      	mov	r1, r6
 801946a:	ed95 0a46 	vldr	s0, [r5, #280]	; 0x118
 801946e:	4620      	mov	r0, r4
 8019470:	f7f8 fbde 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.s_pid_ki, &ind);
 8019474:	4631      	mov	r1, r6
 8019476:	ed95 0a47 	vldr	s0, [r5, #284]	; 0x11c
 801947a:	4620      	mov	r0, r4
 801947c:	f7f8 fbd8 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.s_pid_kd, &ind);
 8019480:	4631      	mov	r1, r6
 8019482:	ed95 0a48 	vldr	s0, [r5, #288]	; 0x120
 8019486:	4620      	mov	r0, r4
 8019488:	f7f8 fbd2 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.s_pid_min_erpm, &ind);
 801948c:	4631      	mov	r1, r6
 801948e:	ed95 0a49 	vldr	s0, [r5, #292]	; 0x124
 8019492:	4620      	mov	r0, r4
 8019494:	f7f8 fbcc 	bl	8011c30 <buffer_append_float32_auto>
		send_buffer[ind++] = mcconf.s_pid_allow_braking;
 8019498:	9b02      	ldr	r3, [sp, #8]
 801949a:	f895 2128 	ldrb.w	r2, [r5, #296]	; 0x128
 801949e:	54e2      	strb	r2, [r4, r3]
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_kp, &ind);
 80194a0:	ed95 0a4b 	vldr	s0, [r5, #300]	; 0x12c
		send_buffer[ind++] = mcconf.s_pid_allow_braking;
 80194a4:	3301      	adds	r3, #1
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_kp, &ind);
 80194a6:	4631      	mov	r1, r6
 80194a8:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.s_pid_allow_braking;
 80194aa:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_kp, &ind);
 80194ac:	f7f8 fbc0 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_ki, &ind);
 80194b0:	4631      	mov	r1, r6
 80194b2:	ed95 0a4c 	vldr	s0, [r5, #304]	; 0x130
 80194b6:	4620      	mov	r0, r4
 80194b8:	f7f8 fbba 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_kd, &ind);
 80194bc:	4631      	mov	r1, r6
 80194be:	ed95 0a4d 	vldr	s0, [r5, #308]	; 0x134
 80194c2:	4620      	mov	r0, r4
 80194c4:	f7f8 fbb4 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.p_pid_ang_div, &ind);
 80194c8:	4631      	mov	r1, r6
 80194ca:	ed95 0a4e 	vldr	s0, [r5, #312]	; 0x138
 80194ce:	4620      	mov	r0, r4
 80194d0:	f7f8 fbae 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.cc_startup_boost_duty, &ind);
 80194d4:	4631      	mov	r1, r6
 80194d6:	ed95 0a4f 	vldr	s0, [r5, #316]	; 0x13c
 80194da:	4620      	mov	r0, r4
 80194dc:	f7f8 fba8 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.cc_min_current, &ind);
 80194e0:	4631      	mov	r1, r6
 80194e2:	ed95 0a50 	vldr	s0, [r5, #320]	; 0x140
 80194e6:	4620      	mov	r0, r4
 80194e8:	f7f8 fba2 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.cc_gain, &ind);
 80194ec:	4631      	mov	r1, r6
 80194ee:	ed95 0a51 	vldr	s0, [r5, #324]	; 0x144
 80194f2:	4620      	mov	r0, r4
 80194f4:	f7f8 fb9c 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.cc_ramp_step_max, &ind);
 80194f8:	ed95 0a52 	vldr	s0, [r5, #328]	; 0x148
 80194fc:	4631      	mov	r1, r6
 80194fe:	4620      	mov	r0, r4
 8019500:	f7f8 fb96 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_int32(send_buffer, mcconf.m_fault_stop_time_ms, &ind);
 8019504:	4632      	mov	r2, r6
 8019506:	f8d5 114c 	ldr.w	r1, [r5, #332]	; 0x14c
 801950a:	4620      	mov	r0, r4
 801950c:	f7f8 fb38 	bl	8011b80 <buffer_append_int32>
		buffer_append_float32_auto(send_buffer, mcconf.m_duty_ramp_step, &ind);
 8019510:	4631      	mov	r1, r6
 8019512:	ed95 0a54 	vldr	s0, [r5, #336]	; 0x150
 8019516:	e003      	b.n	8019520 <commands_process_packet+0xb70>
 8019518:	20008d08 	.word	0x20008d08
 801951c:	200090f0 	.word	0x200090f0
 8019520:	4620      	mov	r0, r4
 8019522:	f7f8 fb85 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.m_current_backoff_gain, &ind);
 8019526:	ed95 0a55 	vldr	s0, [r5, #340]	; 0x154
 801952a:	4631      	mov	r1, r6
 801952c:	4620      	mov	r0, r4
 801952e:	f7f8 fb7f 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_uint32(send_buffer, mcconf.m_encoder_counts, &ind);
 8019532:	4632      	mov	r2, r6
 8019534:	f8d5 1158 	ldr.w	r1, [r5, #344]	; 0x158
 8019538:	4620      	mov	r0, r4
 801953a:	f7f8 fb39 	bl	8011bb0 <buffer_append_uint32>
		send_buffer[ind++] = mcconf.m_sensor_port_mode;
 801953e:	9b02      	ldr	r3, [sp, #8]
 8019540:	f895 215c 	ldrb.w	r2, [r5, #348]	; 0x15c
 8019544:	54e2      	strb	r2, [r4, r3]
		send_buffer[ind++] = mcconf.m_invert_direction;
 8019546:	18e2      	adds	r2, r4, r3
		send_buffer[ind++] = mcconf.m_drv8301_oc_mode;
 8019548:	f895 015e 	ldrb.w	r0, [r5, #350]	; 0x15e
 801954c:	7090      	strb	r0, [r2, #2]
		send_buffer[ind++] = mcconf.m_drv8301_oc_adj;
 801954e:	3304      	adds	r3, #4
		buffer_append_float32_auto(send_buffer, mcconf.m_bldc_f_sw_min, &ind);
 8019550:	ed95 0a59 	vldr	s0, [r5, #356]	; 0x164
		send_buffer[ind++] = mcconf.m_invert_direction;
 8019554:	f895 715d 	ldrb.w	r7, [r5, #349]	; 0x15d
		send_buffer[ind++] = mcconf.m_drv8301_oc_adj;
 8019558:	9302      	str	r3, [sp, #8]
		buffer_append_float32_auto(send_buffer, mcconf.m_bldc_f_sw_min, &ind);
 801955a:	4631      	mov	r1, r6
		send_buffer[ind++] = mcconf.m_drv8301_oc_adj;
 801955c:	f8d5 3160 	ldr.w	r3, [r5, #352]	; 0x160
 8019560:	70d3      	strb	r3, [r2, #3]
		buffer_append_float32_auto(send_buffer, mcconf.m_bldc_f_sw_min, &ind);
 8019562:	4620      	mov	r0, r4
		send_buffer[ind++] = mcconf.m_invert_direction;
 8019564:	7057      	strb	r7, [r2, #1]
		buffer_append_float32_auto(send_buffer, mcconf.m_bldc_f_sw_min, &ind);
 8019566:	f7f8 fb63 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.m_bldc_f_sw_max, &ind);
 801956a:	4631      	mov	r1, r6
 801956c:	ed95 0a5a 	vldr	s0, [r5, #360]	; 0x168
 8019570:	4620      	mov	r0, r4
 8019572:	f7f8 fb5d 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.m_dc_f_sw, &ind);
 8019576:	4631      	mov	r1, r6
 8019578:	ed95 0a5b 	vldr	s0, [r5, #364]	; 0x16c
 801957c:	4620      	mov	r0, r4
 801957e:	f7f8 fb57 	bl	8011c30 <buffer_append_float32_auto>
		buffer_append_float32_auto(send_buffer, mcconf.m_ntc_motor_beta, &ind);
 8019582:	4631      	mov	r1, r6
 8019584:	ed95 0a5c 	vldr	s0, [r5, #368]	; 0x170
 8019588:	4620      	mov	r0, r4
 801958a:	f7f8 fb51 	bl	8011c30 <buffer_append_float32_auto>
	if (send_func) {
 801958e:	4b04      	ldr	r3, [pc, #16]	; (80195a0 <commands_process_packet+0xbf0>)
		commands_send_packet(send_buffer, ind);
 8019590:	9902      	ldr	r1, [sp, #8]
	if (send_func) {
 8019592:	681b      	ldr	r3, [r3, #0]
 8019594:	2b00      	cmp	r3, #0
 8019596:	f47f aa8a 	bne.w	8018aae <commands_process_packet+0xfe>
 801959a:	f7ff ba8a 	b.w	8018ab2 <commands_process_packet+0x102>
 801959e:	bf00      	nop
 80195a0:	200094f0 	.word	0x200094f0
		mcconf = *mc_interface_get_configuration();
 80195a4:	f001 ff2c 	bl	801b400 <mc_interface_get_configuration>
 80195a8:	4de4      	ldr	r5, [pc, #912]	; (801993c <commands_process_packet+0xf8c>)
		mcconf.sensor_mode = data[ind++];
 80195aa:	ae36      	add	r6, sp, #216	; 0xd8
		mcconf = *mc_interface_get_configuration();
 80195ac:	4601      	mov	r1, r0
 80195ae:	f44f 72ba 	mov.w	r2, #372	; 0x174
 80195b2:	4628      	mov	r0, r5
 80195b4:	f7f3 fab4 	bl	800cb20 <memcpy>
		mcconf.sensor_mode = data[ind++];
 80195b8:	2304      	movs	r3, #4
 80195ba:	f846 3dd0 	str.w	r3, [r6, #-208]!
		mcconf.pwm_mode = data[ind++];
 80195be:	7879      	ldrb	r1, [r7, #1]
		mcconf.comm_mode = data[ind++];
 80195c0:	78b8      	ldrb	r0, [r7, #2]
		mcconf.motor_type = data[ind++];
 80195c2:	78fa      	ldrb	r2, [r7, #3]
		mcconf.sensor_mode = data[ind++];
 80195c4:	793b      	ldrb	r3, [r7, #4]
		mcconf.pwm_mode = data[ind++];
 80195c6:	7029      	strb	r1, [r5, #0]
		mcconf.comm_mode = data[ind++];
 80195c8:	7068      	strb	r0, [r5, #1]
		mcconf.l_current_max = buffer_get_float32_auto(data, &ind);
 80195ca:	4631      	mov	r1, r6
 80195cc:	4620      	mov	r0, r4
		mcconf.motor_type = data[ind++];
 80195ce:	70aa      	strb	r2, [r5, #2]
		mcconf.sensor_mode = data[ind++];
 80195d0:	70eb      	strb	r3, [r5, #3]
		mcconf.l_current_max = buffer_get_float32_auto(data, &ind);
 80195d2:	f7f8 fbcd 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_current_min = buffer_get_float32_auto(data, &ind);
 80195d6:	4631      	mov	r1, r6
 80195d8:	4620      	mov	r0, r4
		mcconf.l_current_max = buffer_get_float32_auto(data, &ind);
 80195da:	ed85 0a01 	vstr	s0, [r5, #4]
		mcconf.l_current_min = buffer_get_float32_auto(data, &ind);
 80195de:	f7f8 fbc7 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_in_current_max = buffer_get_float32_auto(data, &ind);
 80195e2:	4631      	mov	r1, r6
 80195e4:	4620      	mov	r0, r4
		mcconf.l_current_min = buffer_get_float32_auto(data, &ind);
 80195e6:	ed85 0a02 	vstr	s0, [r5, #8]
		mcconf.l_in_current_max = buffer_get_float32_auto(data, &ind);
 80195ea:	f7f8 fbc1 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_in_current_min = buffer_get_float32_auto(data, &ind);
 80195ee:	4631      	mov	r1, r6
 80195f0:	4620      	mov	r0, r4
		mcconf.l_in_current_max = buffer_get_float32_auto(data, &ind);
 80195f2:	ed85 0a03 	vstr	s0, [r5, #12]
		mcconf.l_in_current_min = buffer_get_float32_auto(data, &ind);
 80195f6:	f7f8 fbbb 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_abs_current_max = buffer_get_float32_auto(data, &ind);
 80195fa:	4631      	mov	r1, r6
 80195fc:	4620      	mov	r0, r4
		mcconf.l_in_current_min = buffer_get_float32_auto(data, &ind);
 80195fe:	ed85 0a04 	vstr	s0, [r5, #16]
		mcconf.l_abs_current_max = buffer_get_float32_auto(data, &ind);
 8019602:	f7f8 fbb5 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_min_erpm = buffer_get_float32_auto(data, &ind);
 8019606:	4631      	mov	r1, r6
 8019608:	4620      	mov	r0, r4
		mcconf.l_abs_current_max = buffer_get_float32_auto(data, &ind);
 801960a:	ed85 0a05 	vstr	s0, [r5, #20]
		mcconf.l_min_erpm = buffer_get_float32_auto(data, &ind);
 801960e:	f7f8 fbaf 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_max_erpm = buffer_get_float32_auto(data, &ind);
 8019612:	4631      	mov	r1, r6
 8019614:	4620      	mov	r0, r4
		mcconf.l_min_erpm = buffer_get_float32_auto(data, &ind);
 8019616:	ed85 0a06 	vstr	s0, [r5, #24]
		mcconf.l_max_erpm = buffer_get_float32_auto(data, &ind);
 801961a:	f7f8 fba9 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_erpm_start = buffer_get_float32_auto(data, &ind);
 801961e:	4631      	mov	r1, r6
 8019620:	4620      	mov	r0, r4
		mcconf.l_max_erpm = buffer_get_float32_auto(data, &ind);
 8019622:	ed85 0a07 	vstr	s0, [r5, #28]
		mcconf.l_erpm_start = buffer_get_float32_auto(data, &ind);
 8019626:	f7f8 fba3 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_max_erpm_fbrake = buffer_get_float32_auto(data, &ind);
 801962a:	4631      	mov	r1, r6
 801962c:	4620      	mov	r0, r4
		mcconf.l_erpm_start = buffer_get_float32_auto(data, &ind);
 801962e:	ed85 0a08 	vstr	s0, [r5, #32]
		mcconf.l_max_erpm_fbrake = buffer_get_float32_auto(data, &ind);
 8019632:	f7f8 fb9d 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_max_erpm_fbrake_cc = buffer_get_float32_auto(data, &ind);
 8019636:	4631      	mov	r1, r6
 8019638:	4620      	mov	r0, r4
		mcconf.l_max_erpm_fbrake = buffer_get_float32_auto(data, &ind);
 801963a:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
		mcconf.l_max_erpm_fbrake_cc = buffer_get_float32_auto(data, &ind);
 801963e:	f7f8 fb97 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_min_vin = buffer_get_float32_auto(data, &ind);
 8019642:	4631      	mov	r1, r6
 8019644:	4620      	mov	r0, r4
		mcconf.l_max_erpm_fbrake_cc = buffer_get_float32_auto(data, &ind);
 8019646:	ed85 0a0a 	vstr	s0, [r5, #40]	; 0x28
		mcconf.l_min_vin = buffer_get_float32_auto(data, &ind);
 801964a:	f7f8 fb91 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_max_vin = buffer_get_float32_auto(data, &ind);
 801964e:	4631      	mov	r1, r6
 8019650:	4620      	mov	r0, r4
		mcconf.l_min_vin = buffer_get_float32_auto(data, &ind);
 8019652:	ed85 0a0b 	vstr	s0, [r5, #44]	; 0x2c
		mcconf.l_max_vin = buffer_get_float32_auto(data, &ind);
 8019656:	f7f8 fb8b 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_battery_cut_start = buffer_get_float32_auto(data, &ind);
 801965a:	4631      	mov	r1, r6
 801965c:	4620      	mov	r0, r4
		mcconf.l_max_vin = buffer_get_float32_auto(data, &ind);
 801965e:	ed85 0a0c 	vstr	s0, [r5, #48]	; 0x30
		mcconf.l_battery_cut_start = buffer_get_float32_auto(data, &ind);
 8019662:	f7f8 fb85 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_battery_cut_end = buffer_get_float32_auto(data, &ind);
 8019666:	4631      	mov	r1, r6
 8019668:	4620      	mov	r0, r4
		mcconf.l_battery_cut_start = buffer_get_float32_auto(data, &ind);
 801966a:	ed85 0a0d 	vstr	s0, [r5, #52]	; 0x34
		mcconf.l_battery_cut_end = buffer_get_float32_auto(data, &ind);
 801966e:	f7f8 fb7f 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_slow_abs_current = data[ind++];
 8019672:	9b02      	ldr	r3, [sp, #8]
		mcconf.l_battery_cut_end = buffer_get_float32_auto(data, &ind);
 8019674:	ed85 0a0e 	vstr	s0, [r5, #56]	; 0x38
		mcconf.l_slow_abs_current = data[ind++];
 8019678:	5ce2      	ldrb	r2, [r4, r3]
 801967a:	3200      	adds	r2, #0
 801967c:	bf18      	it	ne
 801967e:	2201      	movne	r2, #1
 8019680:	3301      	adds	r3, #1
		mcconf.l_temp_fet_start = buffer_get_float32_auto(data, &ind);
 8019682:	4631      	mov	r1, r6
 8019684:	4620      	mov	r0, r4
		mcconf.l_slow_abs_current = data[ind++];
 8019686:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
 801968a:	9302      	str	r3, [sp, #8]
		mcconf.l_temp_fet_start = buffer_get_float32_auto(data, &ind);
 801968c:	f7f8 fb70 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_temp_fet_end = buffer_get_float32_auto(data, &ind);
 8019690:	4631      	mov	r1, r6
 8019692:	4620      	mov	r0, r4
		mcconf.l_temp_fet_start = buffer_get_float32_auto(data, &ind);
 8019694:	ed85 0a10 	vstr	s0, [r5, #64]	; 0x40
		mcconf.l_temp_fet_end = buffer_get_float32_auto(data, &ind);
 8019698:	f7f8 fb6a 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_temp_motor_start = buffer_get_float32_auto(data, &ind);
 801969c:	4631      	mov	r1, r6
 801969e:	4620      	mov	r0, r4
		mcconf.l_temp_fet_end = buffer_get_float32_auto(data, &ind);
 80196a0:	ed85 0a11 	vstr	s0, [r5, #68]	; 0x44
		mcconf.l_temp_motor_start = buffer_get_float32_auto(data, &ind);
 80196a4:	f7f8 fb64 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_temp_motor_end = buffer_get_float32_auto(data, &ind);
 80196a8:	4631      	mov	r1, r6
 80196aa:	4620      	mov	r0, r4
		mcconf.l_temp_motor_start = buffer_get_float32_auto(data, &ind);
 80196ac:	ed85 0a12 	vstr	s0, [r5, #72]	; 0x48
		mcconf.l_temp_motor_end = buffer_get_float32_auto(data, &ind);
 80196b0:	f7f8 fb5e 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_temp_accel_dec = buffer_get_float32_auto(data, &ind);
 80196b4:	4631      	mov	r1, r6
 80196b6:	4620      	mov	r0, r4
		mcconf.l_temp_motor_end = buffer_get_float32_auto(data, &ind);
 80196b8:	ed85 0a13 	vstr	s0, [r5, #76]	; 0x4c
		mcconf.l_temp_accel_dec = buffer_get_float32_auto(data, &ind);
 80196bc:	f7f8 fb58 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_min_duty = buffer_get_float32_auto(data, &ind);
 80196c0:	4631      	mov	r1, r6
 80196c2:	4620      	mov	r0, r4
		mcconf.l_temp_accel_dec = buffer_get_float32_auto(data, &ind);
 80196c4:	ed85 0a14 	vstr	s0, [r5, #80]	; 0x50
		mcconf.l_min_duty = buffer_get_float32_auto(data, &ind);
 80196c8:	f7f8 fb52 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_max_duty = buffer_get_float32_auto(data, &ind);
 80196cc:	4631      	mov	r1, r6
 80196ce:	4620      	mov	r0, r4
		mcconf.l_min_duty = buffer_get_float32_auto(data, &ind);
 80196d0:	ed85 0a15 	vstr	s0, [r5, #84]	; 0x54
		mcconf.l_max_duty = buffer_get_float32_auto(data, &ind);
 80196d4:	f7f8 fb4c 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_watt_max = buffer_get_float32_auto(data, &ind);
 80196d8:	4631      	mov	r1, r6
 80196da:	4620      	mov	r0, r4
		mcconf.l_max_duty = buffer_get_float32_auto(data, &ind);
 80196dc:	ed85 0a16 	vstr	s0, [r5, #88]	; 0x58
		mcconf.l_watt_max = buffer_get_float32_auto(data, &ind);
 80196e0:	f7f8 fb46 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.l_watt_min = buffer_get_float32_auto(data, &ind);
 80196e4:	4631      	mov	r1, r6
 80196e6:	4620      	mov	r0, r4
		mcconf.l_watt_max = buffer_get_float32_auto(data, &ind);
 80196e8:	ed85 0a17 	vstr	s0, [r5, #92]	; 0x5c
		mcconf.l_watt_min = buffer_get_float32_auto(data, &ind);
 80196ec:	f7f8 fb40 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.lo_in_current_max = mcconf.l_in_current_max;
 80196f0:	68e9      	ldr	r1, [r5, #12]
		mcconf.lo_in_current_min = mcconf.l_in_current_min;
 80196f2:	6928      	ldr	r0, [r5, #16]
		mcconf.lo_current_max = mcconf.l_current_max;
 80196f4:	686a      	ldr	r2, [r5, #4]
		mcconf.lo_current_min = mcconf.l_current_min;
 80196f6:	68ab      	ldr	r3, [r5, #8]
		mcconf.lo_in_current_max = mcconf.l_in_current_max;
 80196f8:	66e9      	str	r1, [r5, #108]	; 0x6c
		mcconf.lo_in_current_min = mcconf.l_in_current_min;
 80196fa:	6728      	str	r0, [r5, #112]	; 0x70
		mcconf.sl_min_erpm = buffer_get_float32_auto(data, &ind);
 80196fc:	4631      	mov	r1, r6
 80196fe:	4620      	mov	r0, r4
		mcconf.lo_current_max = mcconf.l_current_max;
 8019700:	666a      	str	r2, [r5, #100]	; 0x64
		mcconf.lo_current_motor_max_now = mcconf.l_current_max;
 8019702:	676a      	str	r2, [r5, #116]	; 0x74
		mcconf.lo_current_min = mcconf.l_current_min;
 8019704:	66ab      	str	r3, [r5, #104]	; 0x68
		mcconf.lo_current_motor_min_now = mcconf.l_current_min;
 8019706:	67ab      	str	r3, [r5, #120]	; 0x78
		mcconf.l_watt_min = buffer_get_float32_auto(data, &ind);
 8019708:	ed85 0a18 	vstr	s0, [r5, #96]	; 0x60
		mcconf.sl_min_erpm = buffer_get_float32_auto(data, &ind);
 801970c:	f7f8 fb30 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_min_erpm_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019710:	4631      	mov	r1, r6
 8019712:	4620      	mov	r0, r4
		mcconf.sl_min_erpm = buffer_get_float32_auto(data, &ind);
 8019714:	ed85 0a1f 	vstr	s0, [r5, #124]	; 0x7c
		mcconf.sl_min_erpm_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019718:	f7f8 fb2a 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_max_fullbreak_current_dir_change = buffer_get_float32_auto(data, &ind);
 801971c:	4631      	mov	r1, r6
 801971e:	4620      	mov	r0, r4
		mcconf.sl_min_erpm_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019720:	ed85 0a20 	vstr	s0, [r5, #128]	; 0x80
		mcconf.sl_max_fullbreak_current_dir_change = buffer_get_float32_auto(data, &ind);
 8019724:	f7f8 fb24 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019728:	4631      	mov	r1, r6
 801972a:	4620      	mov	r0, r4
		mcconf.sl_max_fullbreak_current_dir_change = buffer_get_float32_auto(data, &ind);
 801972c:	ed85 0a21 	vstr	s0, [r5, #132]	; 0x84
		mcconf.sl_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019730:	f7f8 fb1e 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_phase_advance_at_br = buffer_get_float32_auto(data, &ind);
 8019734:	4631      	mov	r1, r6
 8019736:	4620      	mov	r0, r4
		mcconf.sl_cycle_int_limit = buffer_get_float32_auto(data, &ind);
 8019738:	ed85 0a22 	vstr	s0, [r5, #136]	; 0x88
		mcconf.sl_phase_advance_at_br = buffer_get_float32_auto(data, &ind);
 801973c:	f7f8 fb18 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_cycle_int_rpm_br = buffer_get_float32_auto(data, &ind);
 8019740:	4631      	mov	r1, r6
 8019742:	4620      	mov	r0, r4
		mcconf.sl_phase_advance_at_br = buffer_get_float32_auto(data, &ind);
 8019744:	ed85 0a23 	vstr	s0, [r5, #140]	; 0x8c
		mcconf.sl_cycle_int_rpm_br = buffer_get_float32_auto(data, &ind);
 8019748:	f7f8 fb12 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.sl_bemf_coupling_k = buffer_get_float32_auto(data, &ind);
 801974c:	4631      	mov	r1, r6
 801974e:	4620      	mov	r0, r4
		mcconf.sl_cycle_int_rpm_br = buffer_get_float32_auto(data, &ind);
 8019750:	ed85 0a24 	vstr	s0, [r5, #144]	; 0x90
		mcconf.sl_bemf_coupling_k = buffer_get_float32_auto(data, &ind);
 8019754:	f7f8 fb0c 	bl	8011d70 <buffer_get_float32_auto>
		memcpy(mcconf.hall_table, data + ind, 8);
 8019758:	9b02      	ldr	r3, [sp, #8]
		mcconf.sl_bemf_coupling_k = buffer_get_float32_auto(data, &ind);
 801975a:	ed85 0a25 	vstr	s0, [r5, #148]	; 0x94
		memcpy(mcconf.hall_table, data + ind, 8);
 801975e:	18e1      	adds	r1, r4, r3
 8019760:	f105 0298 	add.w	r2, r5, #152	; 0x98
 8019764:	6808      	ldr	r0, [r1, #0]
 8019766:	6849      	ldr	r1, [r1, #4]
		ind += 8;
 8019768:	3308      	adds	r3, #8
		memcpy(mcconf.hall_table, data + ind, 8);
 801976a:	c203      	stmia	r2!, {r0, r1}
		mcconf.hall_sl_erpm = buffer_get_float32_auto(data, &ind);
 801976c:	4631      	mov	r1, r6
 801976e:	4620      	mov	r0, r4
		ind += 8;
 8019770:	9302      	str	r3, [sp, #8]
		mcconf.hall_sl_erpm = buffer_get_float32_auto(data, &ind);
 8019772:	f7f8 fafd 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_current_kp = buffer_get_float32_auto(data, &ind);
 8019776:	4631      	mov	r1, r6
 8019778:	4620      	mov	r0, r4
		mcconf.hall_sl_erpm = buffer_get_float32_auto(data, &ind);
 801977a:	ed85 0a28 	vstr	s0, [r5, #160]	; 0xa0
		mcconf.foc_current_kp = buffer_get_float32_auto(data, &ind);
 801977e:	f7f8 faf7 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_current_ki = buffer_get_float32_auto(data, &ind);
 8019782:	4631      	mov	r1, r6
 8019784:	4620      	mov	r0, r4
		mcconf.foc_current_kp = buffer_get_float32_auto(data, &ind);
 8019786:	ed85 0a29 	vstr	s0, [r5, #164]	; 0xa4
		mcconf.foc_current_ki = buffer_get_float32_auto(data, &ind);
 801978a:	f7f8 faf1 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_f_sw = buffer_get_float32_auto(data, &ind);
 801978e:	4631      	mov	r1, r6
 8019790:	4620      	mov	r0, r4
		mcconf.foc_current_ki = buffer_get_float32_auto(data, &ind);
 8019792:	ed85 0a2a 	vstr	s0, [r5, #168]	; 0xa8
		mcconf.foc_f_sw = buffer_get_float32_auto(data, &ind);
 8019796:	f7f8 faeb 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_dt_us = buffer_get_float32_auto(data, &ind);
 801979a:	4631      	mov	r1, r6
 801979c:	4620      	mov	r0, r4
		mcconf.foc_f_sw = buffer_get_float32_auto(data, &ind);
 801979e:	ed85 0a2b 	vstr	s0, [r5, #172]	; 0xac
		mcconf.foc_dt_us = buffer_get_float32_auto(data, &ind);
 80197a2:	f7f8 fae5 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_encoder_inverted = data[ind++];
 80197a6:	9b02      	ldr	r3, [sp, #8]
		mcconf.foc_dt_us = buffer_get_float32_auto(data, &ind);
 80197a8:	ed85 0a2c 	vstr	s0, [r5, #176]	; 0xb0
		mcconf.foc_encoder_inverted = data[ind++];
 80197ac:	5ce2      	ldrb	r2, [r4, r3]
 80197ae:	3200      	adds	r2, #0
 80197b0:	bf18      	it	ne
 80197b2:	2201      	movne	r2, #1
 80197b4:	3301      	adds	r3, #1
		mcconf.foc_encoder_offset = buffer_get_float32_auto(data, &ind);
 80197b6:	4631      	mov	r1, r6
 80197b8:	4620      	mov	r0, r4
		mcconf.foc_encoder_inverted = data[ind++];
 80197ba:	f885 20b8 	strb.w	r2, [r5, #184]	; 0xb8
 80197be:	9302      	str	r3, [sp, #8]
		mcconf.foc_encoder_offset = buffer_get_float32_auto(data, &ind);
 80197c0:	f7f8 fad6 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_encoder_ratio = buffer_get_float32_auto(data, &ind);
 80197c4:	4631      	mov	r1, r6
 80197c6:	4620      	mov	r0, r4
		mcconf.foc_encoder_offset = buffer_get_float32_auto(data, &ind);
 80197c8:	ed85 0a2d 	vstr	s0, [r5, #180]	; 0xb4
		mcconf.foc_encoder_ratio = buffer_get_float32_auto(data, &ind);
 80197cc:	f7f8 fad0 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sensor_mode = data[ind++];
 80197d0:	9b02      	ldr	r3, [sp, #8]
		mcconf.foc_encoder_ratio = buffer_get_float32_auto(data, &ind);
 80197d2:	ed85 0a2f 	vstr	s0, [r5, #188]	; 0xbc
		mcconf.foc_sensor_mode = data[ind++];
 80197d6:	5ce2      	ldrb	r2, [r4, r3]
 80197d8:	f885 20f8 	strb.w	r2, [r5, #248]	; 0xf8
 80197dc:	3301      	adds	r3, #1
		mcconf.foc_pll_kp = buffer_get_float32_auto(data, &ind);
 80197de:	4631      	mov	r1, r6
 80197e0:	4620      	mov	r0, r4
		mcconf.foc_sensor_mode = data[ind++];
 80197e2:	9302      	str	r3, [sp, #8]
		mcconf.foc_pll_kp = buffer_get_float32_auto(data, &ind);
 80197e4:	f7f8 fac4 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_pll_ki = buffer_get_float32_auto(data, &ind);
 80197e8:	4631      	mov	r1, r6
 80197ea:	4620      	mov	r0, r4
		mcconf.foc_pll_kp = buffer_get_float32_auto(data, &ind);
 80197ec:	ed85 0a35 	vstr	s0, [r5, #212]	; 0xd4
		mcconf.foc_pll_ki = buffer_get_float32_auto(data, &ind);
 80197f0:	f7f8 fabe 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_motor_l = buffer_get_float32_auto(data, &ind);
 80197f4:	4631      	mov	r1, r6
 80197f6:	4620      	mov	r0, r4
		mcconf.foc_pll_ki = buffer_get_float32_auto(data, &ind);
 80197f8:	ed85 0a36 	vstr	s0, [r5, #216]	; 0xd8
		mcconf.foc_motor_l = buffer_get_float32_auto(data, &ind);
 80197fc:	f7f8 fab8 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_motor_r = buffer_get_float32_auto(data, &ind);
 8019800:	4631      	mov	r1, r6
 8019802:	4620      	mov	r0, r4
		mcconf.foc_motor_l = buffer_get_float32_auto(data, &ind);
 8019804:	ed85 0a30 	vstr	s0, [r5, #192]	; 0xc0
		mcconf.foc_motor_r = buffer_get_float32_auto(data, &ind);
 8019808:	f7f8 fab2 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_motor_flux_linkage = buffer_get_float32_auto(data, &ind);
 801980c:	4631      	mov	r1, r6
 801980e:	4620      	mov	r0, r4
		mcconf.foc_motor_r = buffer_get_float32_auto(data, &ind);
 8019810:	ed85 0a31 	vstr	s0, [r5, #196]	; 0xc4
		mcconf.foc_motor_flux_linkage = buffer_get_float32_auto(data, &ind);
 8019814:	f7f8 faac 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_observer_gain = buffer_get_float32_auto(data, &ind);
 8019818:	4631      	mov	r1, r6
 801981a:	4620      	mov	r0, r4
		mcconf.foc_motor_flux_linkage = buffer_get_float32_auto(data, &ind);
 801981c:	ed85 0a32 	vstr	s0, [r5, #200]	; 0xc8
		mcconf.foc_observer_gain = buffer_get_float32_auto(data, &ind);
 8019820:	f7f8 faa6 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_observer_gain_slow = buffer_get_float32_auto(data, &ind);
 8019824:	4631      	mov	r1, r6
 8019826:	4620      	mov	r0, r4
		mcconf.foc_observer_gain = buffer_get_float32_auto(data, &ind);
 8019828:	ed85 0a33 	vstr	s0, [r5, #204]	; 0xcc
		mcconf.foc_observer_gain_slow = buffer_get_float32_auto(data, &ind);
 801982c:	f7f8 faa0 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_duty_dowmramp_kp = buffer_get_float32_auto(data, &ind);
 8019830:	4631      	mov	r1, r6
 8019832:	4620      	mov	r0, r4
		mcconf.foc_observer_gain_slow = buffer_get_float32_auto(data, &ind);
 8019834:	ed85 0a34 	vstr	s0, [r5, #208]	; 0xd0
		mcconf.foc_duty_dowmramp_kp = buffer_get_float32_auto(data, &ind);
 8019838:	f7f8 fa9a 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_duty_dowmramp_ki = buffer_get_float32_auto(data, &ind);
 801983c:	4631      	mov	r1, r6
 801983e:	4620      	mov	r0, r4
		mcconf.foc_duty_dowmramp_kp = buffer_get_float32_auto(data, &ind);
 8019840:	ed85 0a37 	vstr	s0, [r5, #220]	; 0xdc
		mcconf.foc_duty_dowmramp_ki = buffer_get_float32_auto(data, &ind);
 8019844:	f7f8 fa94 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_openloop_rpm = buffer_get_float32_auto(data, &ind);
 8019848:	4631      	mov	r1, r6
 801984a:	4620      	mov	r0, r4
		mcconf.foc_duty_dowmramp_ki = buffer_get_float32_auto(data, &ind);
 801984c:	ed85 0a38 	vstr	s0, [r5, #224]	; 0xe0
		mcconf.foc_openloop_rpm = buffer_get_float32_auto(data, &ind);
 8019850:	f7f8 fa8e 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sl_openloop_hyst = buffer_get_float32_auto(data, &ind);
 8019854:	4631      	mov	r1, r6
 8019856:	4620      	mov	r0, r4
		mcconf.foc_openloop_rpm = buffer_get_float32_auto(data, &ind);
 8019858:	ed85 0a39 	vstr	s0, [r5, #228]	; 0xe4
		mcconf.foc_sl_openloop_hyst = buffer_get_float32_auto(data, &ind);
 801985c:	f7f8 fa88 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sl_openloop_time = buffer_get_float32_auto(data, &ind);
 8019860:	4631      	mov	r1, r6
 8019862:	4620      	mov	r0, r4
		mcconf.foc_sl_openloop_hyst = buffer_get_float32_auto(data, &ind);
 8019864:	ed85 0a3a 	vstr	s0, [r5, #232]	; 0xe8
		mcconf.foc_sl_openloop_time = buffer_get_float32_auto(data, &ind);
 8019868:	f7f8 fa82 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sl_d_current_duty = buffer_get_float32_auto(data, &ind);
 801986c:	4631      	mov	r1, r6
 801986e:	4620      	mov	r0, r4
		mcconf.foc_sl_openloop_time = buffer_get_float32_auto(data, &ind);
 8019870:	ed85 0a3b 	vstr	s0, [r5, #236]	; 0xec
		mcconf.foc_sl_d_current_duty = buffer_get_float32_auto(data, &ind);
 8019874:	f7f8 fa7c 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sl_d_current_factor = buffer_get_float32_auto(data, &ind);
 8019878:	4631      	mov	r1, r6
 801987a:	4620      	mov	r0, r4
		mcconf.foc_sl_d_current_duty = buffer_get_float32_auto(data, &ind);
 801987c:	ed85 0a3c 	vstr	s0, [r5, #240]	; 0xf0
		mcconf.foc_sl_d_current_factor = buffer_get_float32_auto(data, &ind);
 8019880:	f7f8 fa76 	bl	8011d70 <buffer_get_float32_auto>
		memcpy(mcconf.foc_hall_table, data + ind, 8);
 8019884:	9b02      	ldr	r3, [sp, #8]
		mcconf.foc_sl_d_current_factor = buffer_get_float32_auto(data, &ind);
 8019886:	ed85 0a3d 	vstr	s0, [r5, #244]	; 0xf4
		memcpy(mcconf.foc_hall_table, data + ind, 8);
 801988a:	18e2      	adds	r2, r4, r3
		mcconf.foc_sl_erpm = buffer_get_float32_auto(data, &ind);
 801988c:	4631      	mov	r1, r6
		memcpy(mcconf.foc_hall_table, data + ind, 8);
 801988e:	6817      	ldr	r7, [r2, #0]
 8019890:	6852      	ldr	r2, [r2, #4]
 8019892:	f8c5 20fd 	str.w	r2, [r5, #253]	; 0xfd
		ind += 8;
 8019896:	3308      	adds	r3, #8
		mcconf.foc_sl_erpm = buffer_get_float32_auto(data, &ind);
 8019898:	4620      	mov	r0, r4
		memcpy(mcconf.foc_hall_table, data + ind, 8);
 801989a:	f8c5 70f9 	str.w	r7, [r5, #249]	; 0xf9
		ind += 8;
 801989e:	9302      	str	r3, [sp, #8]
		mcconf.foc_sl_erpm = buffer_get_float32_auto(data, &ind);
 80198a0:	f7f8 fa66 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_sample_v0_v7 = data[ind++];
 80198a4:	9b02      	ldr	r3, [sp, #8]
		mcconf.foc_sl_erpm = buffer_get_float32_auto(data, &ind);
 80198a6:	ed85 0a41 	vstr	s0, [r5, #260]	; 0x104
		mcconf.foc_sample_v0_v7 = data[ind++];
 80198aa:	5ce2      	ldrb	r2, [r4, r3]
 80198ac:	3200      	adds	r2, #0
 80198ae:	f103 0101 	add.w	r1, r3, #1
 80198b2:	bf18      	it	ne
 80198b4:	2201      	movne	r2, #1
 80198b6:	f885 2108 	strb.w	r2, [r5, #264]	; 0x108
		mcconf.foc_sample_high_current = data[ind++];
 80198ba:	5c62      	ldrb	r2, [r4, r1]
 80198bc:	3200      	adds	r2, #0
 80198be:	bf18      	it	ne
 80198c0:	2201      	movne	r2, #1
 80198c2:	3302      	adds	r3, #2
		mcconf.foc_sat_comp = buffer_get_float32_auto(data, &ind);
 80198c4:	4631      	mov	r1, r6
 80198c6:	4620      	mov	r0, r4
		mcconf.foc_sample_high_current = data[ind++];
 80198c8:	f885 2109 	strb.w	r2, [r5, #265]	; 0x109
 80198cc:	9302      	str	r3, [sp, #8]
		mcconf.foc_sat_comp = buffer_get_float32_auto(data, &ind);
 80198ce:	f7f8 fa4f 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.foc_temp_comp = data[ind++];
 80198d2:	9b02      	ldr	r3, [sp, #8]
		mcconf.foc_sat_comp = buffer_get_float32_auto(data, &ind);
 80198d4:	ed85 0a43 	vstr	s0, [r5, #268]	; 0x10c
		mcconf.foc_temp_comp = data[ind++];
 80198d8:	5ce2      	ldrb	r2, [r4, r3]
 80198da:	3200      	adds	r2, #0
 80198dc:	bf18      	it	ne
 80198de:	2201      	movne	r2, #1
 80198e0:	3301      	adds	r3, #1
		mcconf.foc_temp_comp_base_temp = buffer_get_float32_auto(data, &ind);
 80198e2:	4631      	mov	r1, r6
 80198e4:	4620      	mov	r0, r4
		mcconf.foc_temp_comp = data[ind++];
 80198e6:	f885 2110 	strb.w	r2, [r5, #272]	; 0x110
 80198ea:	9302      	str	r3, [sp, #8]
		mcconf.foc_temp_comp_base_temp = buffer_get_float32_auto(data, &ind);
 80198ec:	f7f8 fa40 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.s_pid_kp = buffer_get_float32_auto(data, &ind);
 80198f0:	4631      	mov	r1, r6
 80198f2:	4620      	mov	r0, r4
		mcconf.foc_temp_comp_base_temp = buffer_get_float32_auto(data, &ind);
 80198f4:	ed85 0a45 	vstr	s0, [r5, #276]	; 0x114
		mcconf.s_pid_kp = buffer_get_float32_auto(data, &ind);
 80198f8:	f7f8 fa3a 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.s_pid_ki = buffer_get_float32_auto(data, &ind);
 80198fc:	4631      	mov	r1, r6
 80198fe:	4620      	mov	r0, r4
		mcconf.s_pid_kp = buffer_get_float32_auto(data, &ind);
 8019900:	ed85 0a46 	vstr	s0, [r5, #280]	; 0x118
		mcconf.s_pid_ki = buffer_get_float32_auto(data, &ind);
 8019904:	f7f8 fa34 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.s_pid_kd = buffer_get_float32_auto(data, &ind);
 8019908:	4631      	mov	r1, r6
 801990a:	4620      	mov	r0, r4
		mcconf.s_pid_ki = buffer_get_float32_auto(data, &ind);
 801990c:	ed85 0a47 	vstr	s0, [r5, #284]	; 0x11c
		mcconf.s_pid_kd = buffer_get_float32_auto(data, &ind);
 8019910:	f7f8 fa2e 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.s_pid_min_erpm = buffer_get_float32_auto(data, &ind);
 8019914:	4631      	mov	r1, r6
 8019916:	4620      	mov	r0, r4
		mcconf.s_pid_kd = buffer_get_float32_auto(data, &ind);
 8019918:	ed85 0a48 	vstr	s0, [r5, #288]	; 0x120
		mcconf.s_pid_min_erpm = buffer_get_float32_auto(data, &ind);
 801991c:	f7f8 fa28 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.s_pid_allow_braking = data[ind++];
 8019920:	9b02      	ldr	r3, [sp, #8]
		mcconf.s_pid_min_erpm = buffer_get_float32_auto(data, &ind);
 8019922:	ed85 0a49 	vstr	s0, [r5, #292]	; 0x124
		mcconf.s_pid_allow_braking = data[ind++];
 8019926:	5ce2      	ldrb	r2, [r4, r3]
 8019928:	3200      	adds	r2, #0
 801992a:	bf18      	it	ne
 801992c:	2201      	movne	r2, #1
 801992e:	3301      	adds	r3, #1
		mcconf.p_pid_kp = buffer_get_float32_auto(data, &ind);
 8019930:	4631      	mov	r1, r6
 8019932:	4620      	mov	r0, r4
		mcconf.s_pid_allow_braking = data[ind++];
 8019934:	f885 2128 	strb.w	r2, [r5, #296]	; 0x128
 8019938:	e018      	b.n	801996c <commands_process_packet+0xfbc>
 801993a:	bf00      	nop
 801993c:	20008d08 	.word	0x20008d08
 8019940:	42c80000 	.word	0x42c80000
 8019944:	c2c80000 	.word	0xc2c80000
 8019948:	43160000 	.word	0x43160000
 801994c:	42640000 	.word	0x42640000
 8019950:	48435000 	.word	0x48435000
 8019954:	c8435000 	.word	0xc8435000
 8019958:	3dcccccd 	.word	0x3dcccccd
 801995c:	3f733333 	.word	0x3f733333
 8019960:	00000000 	.word	0x00000000
 8019964:	42dc0000 	.word	0x42dc0000
 8019968:	c2200000 	.word	0xc2200000
 801996c:	9302      	str	r3, [sp, #8]
		mcconf.p_pid_kp = buffer_get_float32_auto(data, &ind);
 801996e:	f7f8 f9ff 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.p_pid_ki = buffer_get_float32_auto(data, &ind);
 8019972:	4631      	mov	r1, r6
 8019974:	4620      	mov	r0, r4
		mcconf.p_pid_kp = buffer_get_float32_auto(data, &ind);
 8019976:	ed85 0a4b 	vstr	s0, [r5, #300]	; 0x12c
		mcconf.p_pid_ki = buffer_get_float32_auto(data, &ind);
 801997a:	f7f8 f9f9 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.p_pid_kd = buffer_get_float32_auto(data, &ind);
 801997e:	4631      	mov	r1, r6
 8019980:	4620      	mov	r0, r4
		mcconf.p_pid_ki = buffer_get_float32_auto(data, &ind);
 8019982:	ed85 0a4c 	vstr	s0, [r5, #304]	; 0x130
		mcconf.p_pid_kd = buffer_get_float32_auto(data, &ind);
 8019986:	f7f8 f9f3 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.p_pid_ang_div = buffer_get_float32_auto(data, &ind);
 801998a:	4631      	mov	r1, r6
 801998c:	4620      	mov	r0, r4
		mcconf.p_pid_kd = buffer_get_float32_auto(data, &ind);
 801998e:	ed85 0a4d 	vstr	s0, [r5, #308]	; 0x134
		mcconf.p_pid_ang_div = buffer_get_float32_auto(data, &ind);
 8019992:	f7f8 f9ed 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.cc_startup_boost_duty = buffer_get_float32_auto(data, &ind);
 8019996:	4631      	mov	r1, r6
 8019998:	4620      	mov	r0, r4
		mcconf.p_pid_ang_div = buffer_get_float32_auto(data, &ind);
 801999a:	ed85 0a4e 	vstr	s0, [r5, #312]	; 0x138
		mcconf.cc_startup_boost_duty = buffer_get_float32_auto(data, &ind);
 801999e:	f7f8 f9e7 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.cc_min_current = buffer_get_float32_auto(data, &ind);
 80199a2:	4631      	mov	r1, r6
 80199a4:	4620      	mov	r0, r4
		mcconf.cc_startup_boost_duty = buffer_get_float32_auto(data, &ind);
 80199a6:	ed85 0a4f 	vstr	s0, [r5, #316]	; 0x13c
		mcconf.cc_min_current = buffer_get_float32_auto(data, &ind);
 80199aa:	f7f8 f9e1 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.cc_gain = buffer_get_float32_auto(data, &ind);
 80199ae:	4631      	mov	r1, r6
 80199b0:	4620      	mov	r0, r4
		mcconf.cc_min_current = buffer_get_float32_auto(data, &ind);
 80199b2:	ed85 0a50 	vstr	s0, [r5, #320]	; 0x140
		mcconf.cc_gain = buffer_get_float32_auto(data, &ind);
 80199b6:	f7f8 f9db 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.cc_ramp_step_max = buffer_get_float32_auto(data, &ind);
 80199ba:	4631      	mov	r1, r6
 80199bc:	4620      	mov	r0, r4
		mcconf.cc_gain = buffer_get_float32_auto(data, &ind);
 80199be:	ed85 0a51 	vstr	s0, [r5, #324]	; 0x144
		mcconf.cc_ramp_step_max = buffer_get_float32_auto(data, &ind);
 80199c2:	f7f8 f9d5 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_fault_stop_time_ms = buffer_get_int32(data, &ind);
 80199c6:	4631      	mov	r1, r6
 80199c8:	4620      	mov	r0, r4
		mcconf.cc_ramp_step_max = buffer_get_float32_auto(data, &ind);
 80199ca:	ed85 0a52 	vstr	s0, [r5, #328]	; 0x148
		mcconf.m_fault_stop_time_ms = buffer_get_int32(data, &ind);
 80199ce:	f7f8 f98f 	bl	8011cf0 <buffer_get_int32>
		mcconf.m_duty_ramp_step = buffer_get_float32_auto(data, &ind);
 80199d2:	4631      	mov	r1, r6
		mcconf.m_fault_stop_time_ms = buffer_get_int32(data, &ind);
 80199d4:	f8c5 014c 	str.w	r0, [r5, #332]	; 0x14c
		mcconf.m_duty_ramp_step = buffer_get_float32_auto(data, &ind);
 80199d8:	4620      	mov	r0, r4
 80199da:	f7f8 f9c9 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_current_backoff_gain = buffer_get_float32_auto(data, &ind);
 80199de:	4631      	mov	r1, r6
 80199e0:	4620      	mov	r0, r4
		mcconf.m_duty_ramp_step = buffer_get_float32_auto(data, &ind);
 80199e2:	ed85 0a54 	vstr	s0, [r5, #336]	; 0x150
		mcconf.m_current_backoff_gain = buffer_get_float32_auto(data, &ind);
 80199e6:	f7f8 f9c3 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_encoder_counts = buffer_get_uint32(data, &ind);
 80199ea:	4631      	mov	r1, r6
 80199ec:	4620      	mov	r0, r4
		mcconf.m_current_backoff_gain = buffer_get_float32_auto(data, &ind);
 80199ee:	ed85 0a55 	vstr	s0, [r5, #340]	; 0x154
		mcconf.m_encoder_counts = buffer_get_uint32(data, &ind);
 80199f2:	f7f8 f995 	bl	8011d20 <buffer_get_uint32>
		mcconf.m_sensor_port_mode = data[ind++];
 80199f6:	9b02      	ldr	r3, [sp, #8]
		mcconf.m_encoder_counts = buffer_get_uint32(data, &ind);
 80199f8:	f8c5 0158 	str.w	r0, [r5, #344]	; 0x158
		mcconf.m_sensor_port_mode = data[ind++];
 80199fc:	5ce2      	ldrb	r2, [r4, r3]
 80199fe:	f885 215c 	strb.w	r2, [r5, #348]	; 0x15c
 8019a02:	1c5a      	adds	r2, r3, #1
		mcconf.m_invert_direction = data[ind++];
 8019a04:	1c99      	adds	r1, r3, #2
 8019a06:	5ca2      	ldrb	r2, [r4, r2]
 8019a08:	3200      	adds	r2, #0
 8019a0a:	bf18      	it	ne
 8019a0c:	2201      	movne	r2, #1
 8019a0e:	f885 215d 	strb.w	r2, [r5, #349]	; 0x15d
		mcconf.m_drv8301_oc_mode = data[ind++];
 8019a12:	5c62      	ldrb	r2, [r4, r1]
 8019a14:	f885 215e 	strb.w	r2, [r5, #350]	; 0x15e
 8019a18:	1cda      	adds	r2, r3, #3
		mcconf.m_bldc_f_sw_min = buffer_get_float32_auto(data, &ind);
 8019a1a:	4631      	mov	r1, r6
		mcconf.m_drv8301_oc_adj = data[ind++];
 8019a1c:	5ca2      	ldrb	r2, [r4, r2]
 8019a1e:	f8c5 2160 	str.w	r2, [r5, #352]	; 0x160
 8019a22:	3304      	adds	r3, #4
		mcconf.m_bldc_f_sw_min = buffer_get_float32_auto(data, &ind);
 8019a24:	4620      	mov	r0, r4
		mcconf.m_drv8301_oc_adj = data[ind++];
 8019a26:	9302      	str	r3, [sp, #8]
		mcconf.m_bldc_f_sw_min = buffer_get_float32_auto(data, &ind);
 8019a28:	f7f8 f9a2 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_bldc_f_sw_max = buffer_get_float32_auto(data, &ind);
 8019a2c:	4631      	mov	r1, r6
 8019a2e:	4620      	mov	r0, r4
		mcconf.m_bldc_f_sw_min = buffer_get_float32_auto(data, &ind);
 8019a30:	ed85 0a59 	vstr	s0, [r5, #356]	; 0x164
		mcconf.m_bldc_f_sw_max = buffer_get_float32_auto(data, &ind);
 8019a34:	f7f8 f99c 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_dc_f_sw = buffer_get_float32_auto(data, &ind);
 8019a38:	4631      	mov	r1, r6
 8019a3a:	4620      	mov	r0, r4
		mcconf.m_bldc_f_sw_max = buffer_get_float32_auto(data, &ind);
 8019a3c:	ed85 0a5a 	vstr	s0, [r5, #360]	; 0x168
		mcconf.m_dc_f_sw = buffer_get_float32_auto(data, &ind);
 8019a40:	f7f8 f996 	bl	8011d70 <buffer_get_float32_auto>
		mcconf.m_ntc_motor_beta = buffer_get_float32_auto(data, &ind);
 8019a44:	4631      	mov	r1, r6
 8019a46:	4620      	mov	r0, r4
		mcconf.m_dc_f_sw = buffer_get_float32_auto(data, &ind);
 8019a48:	ed85 0a5b 	vstr	s0, [r5, #364]	; 0x16c
		mcconf.m_ntc_motor_beta = buffer_get_float32_auto(data, &ind);
 8019a4c:	f7f8 f990 	bl	8011d70 <buffer_get_float32_auto>
		utils_truncate_number(&mcconf.l_current_max, HW_LIM_CURRENT);
 8019a50:	ed5f 0a45 	vldr	s1, [pc, #-276]	; 8019940 <commands_process_packet+0xf90>
		mcconf.m_ntc_motor_beta = buffer_get_float32_auto(data, &ind);
 8019a54:	ed85 0a5c 	vstr	s0, [r5, #368]	; 0x170
		utils_truncate_number(&mcconf.l_current_max, HW_LIM_CURRENT);
 8019a58:	1d28      	adds	r0, r5, #4
 8019a5a:	ed1f 0a46 	vldr	s0, [pc, #-280]	; 8019944 <commands_process_packet+0xf94>
 8019a5e:	f7fc f80f 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_current_min, HW_LIM_CURRENT);
 8019a62:	ed5f 0a49 	vldr	s1, [pc, #-292]	; 8019940 <commands_process_packet+0xf90>
 8019a66:	ed1f 0a49 	vldr	s0, [pc, #-292]	; 8019944 <commands_process_packet+0xf94>
 8019a6a:	f105 0008 	add.w	r0, r5, #8
 8019a6e:	f7fc f807 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_in_current_max, HW_LIM_CURRENT_IN);
 8019a72:	ed5f 0a4d 	vldr	s1, [pc, #-308]	; 8019940 <commands_process_packet+0xf90>
 8019a76:	ed1f 0a4d 	vldr	s0, [pc, #-308]	; 8019944 <commands_process_packet+0xf94>
 8019a7a:	f105 000c 	add.w	r0, r5, #12
 8019a7e:	f7fb ffff 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_in_current_min, HW_LIM_CURRENT);
 8019a82:	ed5f 0a51 	vldr	s1, [pc, #-324]	; 8019940 <commands_process_packet+0xf90>
 8019a86:	ed1f 0a51 	vldr	s0, [pc, #-324]	; 8019944 <commands_process_packet+0xf94>
 8019a8a:	f105 0010 	add.w	r0, r5, #16
 8019a8e:	f7fb fff7 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_abs_current_max, HW_LIM_CURRENT_ABS);
 8019a92:	ed5f 0a53 	vldr	s1, [pc, #-332]	; 8019948 <commands_process_packet+0xf98>
 8019a96:	ed1f 0a4e 	vldr	s0, [pc, #-312]	; 8019960 <commands_process_packet+0xfb0>
 8019a9a:	f105 0014 	add.w	r0, r5, #20
 8019a9e:	f7fb ffef 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_max_vin, HW_LIM_VIN);
 8019aa2:	ed5f 0a56 	vldr	s1, [pc, #-344]	; 801994c <commands_process_packet+0xf9c>
 8019aa6:	eeb1 0a08 	vmov.f32	s0, #24	; 0x40c00000  6.0
 8019aaa:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8019aae:	f7fb ffe7 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_min_vin, HW_LIM_VIN);
 8019ab2:	ed5f 0a5a 	vldr	s1, [pc, #-360]	; 801994c <commands_process_packet+0xf9c>
 8019ab6:	eeb1 0a08 	vmov.f32	s0, #24	; 0x40c00000  6.0
 8019aba:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 8019abe:	f7fb ffdf 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_max_erpm, HW_LIM_ERPM);
 8019ac2:	ed5f 0a5d 	vldr	s1, [pc, #-372]	; 8019950 <commands_process_packet+0xfa0>
 8019ac6:	ed1f 0a5d 	vldr	s0, [pc, #-372]	; 8019954 <commands_process_packet+0xfa4>
 8019aca:	f105 001c 	add.w	r0, r5, #28
 8019ace:	f7fb ffd7 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_min_erpm, HW_LIM_ERPM);
 8019ad2:	ed5f 0a61 	vldr	s1, [pc, #-388]	; 8019950 <commands_process_packet+0xfa0>
 8019ad6:	ed1f 0a61 	vldr	s0, [pc, #-388]	; 8019954 <commands_process_packet+0xfa4>
 8019ada:	f105 0018 	add.w	r0, r5, #24
 8019ade:	f7fb ffcf 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_min_duty, HW_LIM_DUTY_MIN);
 8019ae2:	ed5f 0a63 	vldr	s1, [pc, #-396]	; 8019958 <commands_process_packet+0xfa8>
 8019ae6:	ed1f 0a62 	vldr	s0, [pc, #-392]	; 8019960 <commands_process_packet+0xfb0>
 8019aea:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8019aee:	f7fb ffc7 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_max_duty, HW_LIM_DUTY_MAX);
 8019af2:	ed5f 0a66 	vldr	s1, [pc, #-408]	; 801995c <commands_process_packet+0xfac>
 8019af6:	ed1f 0a66 	vldr	s0, [pc, #-408]	; 8019960 <commands_process_packet+0xfb0>
 8019afa:	f105 0058 	add.w	r0, r5, #88	; 0x58
 8019afe:	f7fb ffbf 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_temp_fet_start, HW_LIM_TEMP_FET);
 8019b02:	ed5f 0a68 	vldr	s1, [pc, #-416]	; 8019964 <commands_process_packet+0xfb4>
 8019b06:	ed1f 0a68 	vldr	s0, [pc, #-416]	; 8019968 <commands_process_packet+0xfb8>
 8019b0a:	f105 0040 	add.w	r0, r5, #64	; 0x40
 8019b0e:	f7fb ffb7 	bl	8015a80 <utils_truncate_number>
		utils_truncate_number(&mcconf.l_temp_fet_end, HW_LIM_TEMP_FET);
 8019b12:	ed5f 0a6c 	vldr	s1, [pc, #-432]	; 8019964 <commands_process_packet+0xfb4>
 8019b16:	ed1f 0a6c 	vldr	s0, [pc, #-432]	; 8019968 <commands_process_packet+0xfb8>
 8019b1a:	f105 0044 	add.w	r0, r5, #68	; 0x44
 8019b1e:	f7fb ffaf 	bl	8015a80 <utils_truncate_number>
		conf_general_store_mc_configuration(&mcconf);
 8019b22:	4628      	mov	r0, r5
 8019b24:	f7fd ffd4 	bl	8017ad0 <conf_general_store_mc_configuration>
		mc_interface_set_configuration(&mcconf);
 8019b28:	4628      	mov	r0, r5
 8019b2a:	f002 f979 	bl	801be20 <mc_interface_set_configuration>
		chThdSleepMilliseconds(200);
 8019b2e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8019b32:	f7f3 ff55 	bl	800d9e0 <chThdSleep>
	if (send_func) {
 8019b36:	4bd7      	ldr	r3, [pc, #860]	; (8019e94 <commands_process_packet+0x14e4>)
		send_buffer[ind++] = packet_id;
 8019b38:	48d7      	ldr	r0, [pc, #860]	; (8019e98 <commands_process_packet+0x14e8>)
	if (send_func) {
 8019b3a:	681b      	ldr	r3, [r3, #0]
		send_buffer[ind++] = packet_id;
 8019b3c:	220d      	movs	r2, #13
 8019b3e:	2101      	movs	r1, #1
 8019b40:	7002      	strb	r2, [r0, #0]
 8019b42:	9102      	str	r1, [sp, #8]
	if (send_func) {
 8019b44:	2b00      	cmp	r3, #0
 8019b46:	f43e afb4 	beq.w	8018ab2 <commands_process_packet+0x102>
		send_func(data, len);
 8019b4a:	4798      	blx	r3
 8019b4c:	f7fe bfb1 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_handbrake(buffer_get_float32(data, 1e3, &ind));
 8019b50:	4620      	mov	r0, r4
 8019b52:	a902      	add	r1, sp, #8
 8019b54:	ed9f 0ad1 	vldr	s0, [pc, #836]	; 8019e9c <commands_process_packet+0x14ec>
 8019b58:	f7f8 f8fa 	bl	8011d50 <buffer_get_float32>
 8019b5c:	f002 fc50 	bl	801c400 <mc_interface_set_handbrake>
		timeout_reset();
 8019b60:	f000 fafe 	bl	801a160 <timeout_reset>
		break;
 8019b64:	f7fe bfa5 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_pid_pos((float)buffer_get_int32(data, &ind) / 1000000.0);
 8019b68:	a902      	add	r1, sp, #8
 8019b6a:	4620      	mov	r0, r4
 8019b6c:	f7f8 f8c0 	bl	8011cf0 <buffer_get_int32>
 8019b70:	ee07 0a10 	vmov	s14, r0
 8019b74:	eddf 7aca 	vldr	s15, [pc, #808]	; 8019ea0 <commands_process_packet+0x14f0>
 8019b78:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 8019b7c:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8019b80:	f002 fb66 	bl	801c250 <mc_interface_set_pid_pos>
		timeout_reset();
 8019b84:	f000 faec 	bl	801a160 <timeout_reset>
		break;
 8019b88:	f7fe bf93 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_pid_speed((float)buffer_get_int32(data, &ind));
 8019b8c:	a902      	add	r1, sp, #8
 8019b8e:	4620      	mov	r0, r4
 8019b90:	f7f8 f8ae 	bl	8011cf0 <buffer_get_int32>
 8019b94:	ee07 0a90 	vmov	s15, r0
 8019b98:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8019b9c:	f002 fb28 	bl	801c1f0 <mc_interface_set_pid_speed>
		timeout_reset();
 8019ba0:	f000 fade 	bl	801a160 <timeout_reset>
		break;
 8019ba4:	f7fe bf85 	b.w	8018ab2 <commands_process_packet+0x102>
		strcpy((char*)(send_buffer + ind), HW_NAME);
 8019ba8:	4abe      	ldr	r2, [pc, #760]	; (8019ea4 <commands_process_packet+0x14f4>)
		send_buffer[ind++] = COMM_FW_VERSION;
 8019baa:	4bbb      	ldr	r3, [pc, #748]	; (8019e98 <commands_process_packet+0x14e8>)
		strcpy((char*)(send_buffer + ind), HW_NAME);
 8019bac:	8811      	ldrh	r1, [r2, #0]
 8019bae:	7890      	ldrb	r0, [r2, #2]
 8019bb0:	f8a3 1003 	strh.w	r1, [r3, #3]
		send_buffer[ind++] = FW_VERSION_MAJOR;
 8019bb4:	2222      	movs	r2, #34	; 0x22
		send_buffer[ind++] = COMM_FW_VERSION;
 8019bb6:	f44f 7140 	mov.w	r1, #768	; 0x300
		memcpy(send_buffer + ind, STM32_UUID_8, 12);
 8019bba:	4cbb      	ldr	r4, [pc, #748]	; (8019ea8 <commands_process_packet+0x14f8>)
		strcpy((char*)(send_buffer + ind), HW_NAME);
 8019bbc:	7158      	strb	r0, [r3, #5]
		send_buffer[ind++] = COMM_FW_VERSION;
 8019bbe:	8019      	strh	r1, [r3, #0]
		send_buffer[ind++] = FW_VERSION_MAJOR;
 8019bc0:	709a      	strb	r2, [r3, #2]
		memcpy(send_buffer + ind, STM32_UUID_8, 12);
 8019bc2:	cc07      	ldmia	r4!, {r0, r1, r2}
	if (send_func) {
 8019bc4:	4cb3      	ldr	r4, [pc, #716]	; (8019e94 <commands_process_packet+0x14e4>)
		memcpy(send_buffer + ind, STM32_UUID_8, 12);
 8019bc6:	f8c3 100a 	str.w	r1, [r3, #10]
	if (send_func) {
 8019bca:	6824      	ldr	r4, [r4, #0]
		memcpy(send_buffer + ind, STM32_UUID_8, 12);
 8019bcc:	f8c3 0006 	str.w	r0, [r3, #6]
		ind += 12;
 8019bd0:	2112      	movs	r1, #18
		memcpy(send_buffer + ind, STM32_UUID_8, 12);
 8019bd2:	f8c3 200e 	str.w	r2, [r3, #14]
		ind += 12;
 8019bd6:	9102      	str	r1, [sp, #8]
	if (send_func) {
 8019bd8:	2c00      	cmp	r4, #0
 8019bda:	f43e af6a 	beq.w	8018ab2 <commands_process_packet+0x102>
		send_func(data, len);
 8019bde:	4618      	mov	r0, r3
 8019be0:	47a0      	blx	r4
 8019be2:	f7fe bf66 	b.w	8018ab2 <commands_process_packet+0x102>
		nrf_driver_start_pairing(buffer_get_int32(data, &ind));
 8019be6:	a902      	add	r1, sp, #8
 8019be8:	4620      	mov	r0, r4
 8019bea:	f7f8 f881 	bl	8011cf0 <buffer_get_int32>
 8019bee:	f009 ff67 	bl	8023ac0 <nrf_driver_start_pairing>
	if (send_func) {
 8019bf2:	4ba8      	ldr	r3, [pc, #672]	; (8019e94 <commands_process_packet+0x14e4>)
		send_buffer[ind++] = packet_id;
 8019bf4:	48a8      	ldr	r0, [pc, #672]	; (8019e98 <commands_process_packet+0x14e8>)
	if (send_func) {
 8019bf6:	681b      	ldr	r3, [r3, #0]
		send_buffer[ind++] = packet_id;
 8019bf8:	2425      	movs	r4, #37	; 0x25
		send_buffer[ind++] = NRF_PAIR_STARTED;
 8019bfa:	2200      	movs	r2, #0
 8019bfc:	2102      	movs	r1, #2
		send_buffer[ind++] = packet_id;
 8019bfe:	7004      	strb	r4, [r0, #0]
		send_buffer[ind++] = NRF_PAIR_STARTED;
 8019c00:	7042      	strb	r2, [r0, #1]
 8019c02:	9102      	str	r1, [sp, #8]
	if (send_func) {
 8019c04:	2b00      	cmp	r3, #0
 8019c06:	d1a0      	bne.n	8019b4a <commands_process_packet+0x119a>
 8019c08:	f7fe bf53 	b.w	8018ab2 <commands_process_packet+0x102>
		if (appdata_func) {
 8019c0c:	4ba7      	ldr	r3, [pc, #668]	; (8019eac <commands_process_packet+0x14fc>)
 8019c0e:	681b      	ldr	r3, [r3, #0]
 8019c10:	2b00      	cmp	r3, #0
 8019c12:	f43e af4e 	beq.w	8018ab2 <commands_process_packet+0x102>
			appdata_func(data, len);
 8019c16:	4629      	mov	r1, r5
 8019c18:	f7fe bf49 	b.w	8018aae <commands_process_packet+0xfe>
		chuck_d_tmp.bt_c = data[ind++];
 8019c1c:	78c2      	ldrb	r2, [r0, #3]
		chuck_d_tmp.bt_z = data[ind++];
 8019c1e:	7903      	ldrb	r3, [r0, #4]
		chuck_d_tmp.js_x = data[ind++];
 8019c20:	7841      	ldrb	r1, [r0, #1]
		chuck_d_tmp.js_y = data[ind++];
 8019c22:	7885      	ldrb	r5, [r0, #2]
		chuck_d_tmp.js_x = data[ind++];
 8019c24:	9104      	str	r1, [sp, #16]
		chuck_d_tmp.bt_c = data[ind++];
 8019c26:	3200      	adds	r2, #0
 8019c28:	bf18      	it	ne
 8019c2a:	2201      	movne	r2, #1
		chuck_d_tmp.bt_z = data[ind++];
 8019c2c:	3300      	adds	r3, #0
 8019c2e:	bf18      	it	ne
 8019c30:	2301      	movne	r3, #1
		chuck_d_tmp.acc_x = buffer_get_int16(data, &ind);
 8019c32:	a902      	add	r1, sp, #8
		chuck_d_tmp.bt_c = data[ind++];
 8019c34:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
		chuck_d_tmp.acc_x = buffer_get_int16(data, &ind);
 8019c38:	4620      	mov	r0, r4
		chuck_d_tmp.bt_z = data[ind++];
 8019c3a:	2204      	movs	r2, #4
 8019c3c:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8019c40:	9202      	str	r2, [sp, #8]
		chuck_d_tmp.js_y = data[ind++];
 8019c42:	9505      	str	r5, [sp, #20]
		chuck_d_tmp.acc_x = buffer_get_int16(data, &ind);
 8019c44:	f7f8 f834 	bl	8011cb0 <buffer_get_int16>
		chuck_d_tmp.acc_y = buffer_get_int16(data, &ind);
 8019c48:	a902      	add	r1, sp, #8
		chuck_d_tmp.acc_x = buffer_get_int16(data, &ind);
 8019c4a:	9006      	str	r0, [sp, #24]
		chuck_d_tmp.acc_y = buffer_get_int16(data, &ind);
 8019c4c:	4620      	mov	r0, r4
 8019c4e:	f7f8 f82f 	bl	8011cb0 <buffer_get_int16>
		chuck_d_tmp.acc_z = buffer_get_int16(data, &ind);
 8019c52:	a902      	add	r1, sp, #8
		chuck_d_tmp.acc_y = buffer_get_int16(data, &ind);
 8019c54:	9007      	str	r0, [sp, #28]
		chuck_d_tmp.acc_z = buffer_get_int16(data, &ind);
 8019c56:	4620      	mov	r0, r4
 8019c58:	f7f8 f82a 	bl	8011cb0 <buffer_get_int16>
 8019c5c:	9008      	str	r0, [sp, #32]
		app_nunchuk_update_output(&chuck_d_tmp);
 8019c5e:	a804      	add	r0, sp, #16
 8019c60:	f008 fc3e 	bl	80224e0 <app_nunchuk_update_output>
		break;
 8019c64:	f7fe bf25 	b.w	8018ab2 <commands_process_packet+0x102>
		comm_can_send_buffer(data[0], data + 1, len - 1, false);
 8019c68:	1e8a      	subs	r2, r1, #2
 8019c6a:	2300      	movs	r3, #0
 8019c6c:	1c81      	adds	r1, r0, #2
 8019c6e:	7840      	ldrb	r0, [r0, #1]
 8019c70:	f000 fdf6 	bl	801a860 <comm_can_send_buffer>
		break;
 8019c74:	f7fe bf1d 	b.w	8018ab2 <commands_process_packet+0x102>
		send_buffer[ind++] = COMM_GET_DECODED_CHUK;
 8019c78:	ad36      	add	r5, sp, #216	; 0xd8
 8019c7a:	4c87      	ldr	r4, [pc, #540]	; (8019e98 <commands_process_packet+0x14e8>)
 8019c7c:	2201      	movs	r2, #1
 8019c7e:	2321      	movs	r3, #33	; 0x21
 8019c80:	f845 2dd0 	str.w	r2, [r5, #-208]!
 8019c84:	7023      	strb	r3, [r4, #0]
		buffer_append_int32(send_buffer, (int32_t)(app_nunchuk_get_decoded_chuk() * 1000000.0), &ind);
 8019c86:	f008 fc13 	bl	80224b0 <app_nunchuk_get_decoded_chuk>
 8019c8a:	eddf 7a85 	vldr	s15, [pc, #532]	; 8019ea0 <commands_process_packet+0x14f0>
 8019c8e:	ee60 7a27 	vmul.f32	s15, s0, s15
 8019c92:	462a      	mov	r2, r5
 8019c94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019c98:	ee17 1a90 	vmov	r1, s15
 8019c9c:	4620      	mov	r0, r4
 8019c9e:	f7f7 ff6f 	bl	8011b80 <buffer_append_int32>
	if (send_func) {
 8019ca2:	4b7c      	ldr	r3, [pc, #496]	; (8019e94 <commands_process_packet+0x14e4>)
		commands_send_packet(send_buffer, ind);
 8019ca4:	9902      	ldr	r1, [sp, #8]
	if (send_func) {
 8019ca6:	681b      	ldr	r3, [r3, #0]
 8019ca8:	2b00      	cmp	r3, #0
 8019caa:	f47e af00 	bne.w	8018aae <commands_process_packet+0xfe>
 8019cae:	f7fe bf00 	b.w	8018ab2 <commands_process_packet+0x102>
		send_buffer[ind++] = COMM_GET_DECODED_ADC;
 8019cb2:	ad36      	add	r5, sp, #216	; 0xd8
 8019cb4:	4c78      	ldr	r4, [pc, #480]	; (8019e98 <commands_process_packet+0x14e8>)
		buffer_append_int32(send_buffer, (int32_t)(app_adc_get_decoded_level() * 1000000.0), &ind);
 8019cb6:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 8019ea0 <commands_process_packet+0x14f0>
		send_buffer[ind++] = COMM_GET_DECODED_ADC;
 8019cba:	2320      	movs	r3, #32
 8019cbc:	2201      	movs	r2, #1
 8019cbe:	7023      	strb	r3, [r4, #0]
 8019cc0:	f845 2dd0 	str.w	r2, [r5, #-208]!
		buffer_append_int32(send_buffer, (int32_t)(app_adc_get_decoded_level() * 1000000.0), &ind);
 8019cc4:	f007 fed4 	bl	8021a70 <app_adc_get_decoded_level>
 8019cc8:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019ccc:	462a      	mov	r2, r5
 8019cce:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019cd2:	4620      	mov	r0, r4
 8019cd4:	ee17 1a90 	vmov	r1, s15
 8019cd8:	f7f7 ff52 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, (int32_t)(app_adc_get_voltage() * 1000000.0), &ind);
 8019cdc:	f007 fed0 	bl	8021a80 <app_adc_get_voltage>
 8019ce0:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019ce4:	462a      	mov	r2, r5
 8019ce6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019cea:	4620      	mov	r0, r4
 8019cec:	ee17 1a90 	vmov	r1, s15
 8019cf0:	f7f7 ff46 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, (int32_t)(app_adc_get_decoded_level2() * 1000000.0), &ind);
 8019cf4:	f007 fecc 	bl	8021a90 <app_adc_get_decoded_level2>
 8019cf8:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019cfc:	462a      	mov	r2, r5
 8019cfe:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019d02:	4620      	mov	r0, r4
 8019d04:	ee17 1a90 	vmov	r1, s15
 8019d08:	f7f7 ff3a 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, (int32_t)(app_adc_get_voltage2() * 1000000.0), &ind);
 8019d0c:	f007 fec8 	bl	8021aa0 <app_adc_get_voltage2>
 8019d10:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019d14:	462a      	mov	r2, r5
 8019d16:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019d1a:	e7bd      	b.n	8019c98 <commands_process_packet+0x12e8>
		send_buffer[ind++] = COMM_GET_DECODED_PPM;
 8019d1c:	ad36      	add	r5, sp, #216	; 0xd8
 8019d1e:	4c5e      	ldr	r4, [pc, #376]	; (8019e98 <commands_process_packet+0x14e8>)
		buffer_append_int32(send_buffer, (int32_t)(app_ppm_get_decoded_level() * 1000000.0), &ind);
 8019d20:	ed9f 8a5f 	vldr	s16, [pc, #380]	; 8019ea0 <commands_process_packet+0x14f0>
		send_buffer[ind++] = COMM_GET_DECODED_PPM;
 8019d24:	231f      	movs	r3, #31
 8019d26:	2201      	movs	r2, #1
 8019d28:	f845 2dd0 	str.w	r2, [r5, #-208]!
 8019d2c:	7023      	strb	r3, [r4, #0]
		buffer_append_int32(send_buffer, (int32_t)(app_ppm_get_decoded_level() * 1000000.0), &ind);
 8019d2e:	f007 f88f 	bl	8020e50 <app_ppm_get_decoded_level>
 8019d32:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019d36:	462a      	mov	r2, r5
 8019d38:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019d3c:	4620      	mov	r0, r4
 8019d3e:	ee17 1a90 	vmov	r1, s15
 8019d42:	f7f7 ff1d 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, (int32_t)(servodec_get_last_pulse_len(0) * 1000000.0), &ind);
 8019d46:	2000      	movs	r0, #0
 8019d48:	f7fb fe1a 	bl	8015980 <servodec_get_last_pulse_len>
 8019d4c:	ee20 0a08 	vmul.f32	s0, s0, s16
 8019d50:	462a      	mov	r2, r5
 8019d52:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8019d56:	e79f      	b.n	8019c98 <commands_process_packet+0x12e8>
		send_buffer[ind++] = COMM_GET_VALUES;
 8019d58:	ad36      	add	r5, sp, #216	; 0xd8
 8019d5a:	2301      	movs	r3, #1
 8019d5c:	f845 3dd0 	str.w	r3, [r5, #-208]!
 8019d60:	4c4d      	ldr	r4, [pc, #308]	; (8019e98 <commands_process_packet+0x14e8>)
 8019d62:	2304      	movs	r3, #4
 8019d64:	7023      	strb	r3, [r4, #0]
		buffer_append_float16(send_buffer, mc_interface_temp_fet_filtered(), 1e1, &ind);
 8019d66:	f002 f9c3 	bl	801c0f0 <mc_interface_temp_fet_filtered>
 8019d6a:	4629      	mov	r1, r5
 8019d6c:	4620      	mov	r0, r4
 8019d6e:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8019d72:	f7f7 ff35 	bl	8011be0 <buffer_append_float16>
		buffer_append_float16(send_buffer, mc_interface_temp_motor_filtered(), 1e1, &ind);
 8019d76:	f002 f9c3 	bl	801c100 <mc_interface_temp_motor_filtered>
 8019d7a:	4629      	mov	r1, r5
 8019d7c:	4620      	mov	r0, r4
 8019d7e:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8019d82:	f7f7 ff2d 	bl	8011be0 <buffer_append_float16>
		buffer_append_float32(send_buffer, mc_interface_read_reset_avg_motor_current(), 1e2, &ind);
 8019d86:	f002 f90b 	bl	801bfa0 <mc_interface_read_reset_avg_motor_current>
 8019d8a:	4629      	mov	r1, r5
 8019d8c:	4620      	mov	r0, r4
 8019d8e:	eddf 0a48 	vldr	s1, [pc, #288]	; 8019eb0 <commands_process_packet+0x1500>
 8019d92:	f7f7 ff3d 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_read_reset_avg_input_current(), 1e2, &ind);
 8019d96:	f002 f913 	bl	801bfc0 <mc_interface_read_reset_avg_input_current>
 8019d9a:	4629      	mov	r1, r5
 8019d9c:	4620      	mov	r0, r4
 8019d9e:	eddf 0a44 	vldr	s1, [pc, #272]	; 8019eb0 <commands_process_packet+0x1500>
 8019da2:	f7f7 ff35 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_read_reset_avg_id(), 1e2, &ind);
 8019da6:	f002 f91b 	bl	801bfe0 <mc_interface_read_reset_avg_id>
 8019daa:	4629      	mov	r1, r5
 8019dac:	4620      	mov	r0, r4
 8019dae:	eddf 0a40 	vldr	s1, [pc, #256]	; 8019eb0 <commands_process_packet+0x1500>
 8019db2:	f7f7 ff2d 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_read_reset_avg_iq(), 1e2, &ind);
 8019db6:	f002 f92b 	bl	801c010 <mc_interface_read_reset_avg_iq>
 8019dba:	4629      	mov	r1, r5
 8019dbc:	4620      	mov	r0, r4
 8019dbe:	eddf 0a3c 	vldr	s1, [pc, #240]	; 8019eb0 <commands_process_packet+0x1500>
 8019dc2:	f7f7 ff25 	bl	8011c10 <buffer_append_float32>
		buffer_append_float16(send_buffer, mc_interface_get_duty_cycle_now(), 1e3, &ind);
 8019dc6:	f001 fb73 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 8019dca:	4629      	mov	r1, r5
 8019dcc:	4620      	mov	r0, r4
 8019dce:	eddf 0a33 	vldr	s1, [pc, #204]	; 8019e9c <commands_process_packet+0x14ec>
 8019dd2:	f7f7 ff05 	bl	8011be0 <buffer_append_float16>
		buffer_append_float32(send_buffer, mc_interface_get_rpm(), 1e0, &ind);
 8019dd6:	f001 fba3 	bl	801b520 <mc_interface_get_rpm>
 8019dda:	4629      	mov	r1, r5
 8019ddc:	4620      	mov	r0, r4
 8019dde:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8019de2:	f7f7 ff15 	bl	8011c10 <buffer_append_float32>
		buffer_append_float16(send_buffer, GET_INPUT_VOLTAGE(), 1e1, &ind);
 8019de6:	4b33      	ldr	r3, [pc, #204]	; (8019eb4 <commands_process_packet+0x1504>)
 8019de8:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8019eb8 <commands_process_packet+0x1508>
 8019dec:	8a1b      	ldrh	r3, [r3, #16]
 8019dee:	ed9f 0a33 	vldr	s0, [pc, #204]	; 8019ebc <commands_process_packet+0x150c>
 8019df2:	ee07 3a90 	vmov	s15, r3
 8019df6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8019dfa:	4629      	mov	r1, r5
 8019dfc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019e00:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8019e04:	ee27 0a80 	vmul.f32	s0, s15, s0
 8019e08:	4620      	mov	r0, r4
 8019e0a:	f7f7 fee9 	bl	8011be0 <buffer_append_float16>
		buffer_append_float32(send_buffer, mc_interface_get_amp_hours(false), 1e4, &ind);
 8019e0e:	2000      	movs	r0, #0
 8019e10:	f001 fba6 	bl	801b560 <mc_interface_get_amp_hours>
 8019e14:	4629      	mov	r1, r5
 8019e16:	eddf 0a2a 	vldr	s1, [pc, #168]	; 8019ec0 <commands_process_packet+0x1510>
 8019e1a:	4620      	mov	r0, r4
 8019e1c:	f7f7 fef8 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_get_amp_hours_charged(false), 1e4, &ind);
 8019e20:	2000      	movs	r0, #0
 8019e22:	f001 fbad 	bl	801b580 <mc_interface_get_amp_hours_charged>
 8019e26:	4629      	mov	r1, r5
 8019e28:	eddf 0a25 	vldr	s1, [pc, #148]	; 8019ec0 <commands_process_packet+0x1510>
 8019e2c:	4620      	mov	r0, r4
 8019e2e:	f7f7 feef 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_get_watt_hours(false), 1e4, &ind);
 8019e32:	2000      	movs	r0, #0
 8019e34:	f001 fbb4 	bl	801b5a0 <mc_interface_get_watt_hours>
 8019e38:	4629      	mov	r1, r5
 8019e3a:	eddf 0a21 	vldr	s1, [pc, #132]	; 8019ec0 <commands_process_packet+0x1510>
 8019e3e:	4620      	mov	r0, r4
 8019e40:	f7f7 fee6 	bl	8011c10 <buffer_append_float32>
		buffer_append_float32(send_buffer, mc_interface_get_watt_hours_charged(false), 1e4, &ind);
 8019e44:	2000      	movs	r0, #0
 8019e46:	f001 fbbb 	bl	801b5c0 <mc_interface_get_watt_hours_charged>
 8019e4a:	eddf 0a1d 	vldr	s1, [pc, #116]	; 8019ec0 <commands_process_packet+0x1510>
 8019e4e:	4629      	mov	r1, r5
 8019e50:	4620      	mov	r0, r4
 8019e52:	f7f7 fedd 	bl	8011c10 <buffer_append_float32>
		buffer_append_int32(send_buffer, mc_interface_get_tachometer_value(false), &ind);
 8019e56:	2000      	movs	r0, #0
 8019e58:	f001 fc4a 	bl	801b6f0 <mc_interface_get_tachometer_value>
 8019e5c:	462a      	mov	r2, r5
 8019e5e:	4601      	mov	r1, r0
 8019e60:	4620      	mov	r0, r4
 8019e62:	f7f7 fe8d 	bl	8011b80 <buffer_append_int32>
		buffer_append_int32(send_buffer, mc_interface_get_tachometer_abs_value(false), &ind);
 8019e66:	2000      	movs	r0, #0
 8019e68:	f002 f872 	bl	801bf50 <mc_interface_get_tachometer_abs_value>
 8019e6c:	462a      	mov	r2, r5
 8019e6e:	4601      	mov	r1, r0
 8019e70:	4620      	mov	r0, r4
 8019e72:	f7f7 fe85 	bl	8011b80 <buffer_append_int32>
		send_buffer[ind++] = mc_interface_get_fault();
 8019e76:	9d02      	ldr	r5, [sp, #8]
 8019e78:	1c6b      	adds	r3, r5, #1
 8019e7a:	9302      	str	r3, [sp, #8]
 8019e7c:	f001 faf0 	bl	801b460 <mc_interface_get_fault>
	if (send_func) {
 8019e80:	4b04      	ldr	r3, [pc, #16]	; (8019e94 <commands_process_packet+0x14e4>)
		send_buffer[ind++] = mc_interface_get_fault();
 8019e82:	5560      	strb	r0, [r4, r5]
	if (send_func) {
 8019e84:	681b      	ldr	r3, [r3, #0]
		commands_send_packet(send_buffer, ind);
 8019e86:	9902      	ldr	r1, [sp, #8]
	if (send_func) {
 8019e88:	2b00      	cmp	r3, #0
 8019e8a:	f47e ae10 	bne.w	8018aae <commands_process_packet+0xfe>
 8019e8e:	f7fe be10 	b.w	8018ab2 <commands_process_packet+0x102>
 8019e92:	bf00      	nop
 8019e94:	200094f0 	.word	0x200094f0
 8019e98:	200090f0 	.word	0x200090f0
 8019e9c:	447a0000 	.word	0x447a0000
 8019ea0:	49742400 	.word	0x49742400
 8019ea4:	0802e9e4 	.word	0x0802e9e4
 8019ea8:	1fff7a10 	.word	0x1fff7a10
 8019eac:	20008340 	.word	0x20008340
 8019eb0:	42c80000 	.word	0x42c80000
 8019eb4:	2000c03c 	.word	0x2000c03c
 8019eb8:	3a534067 	.word	0x3a534067
 8019ebc:	4195d174 	.word	0x4195d174
 8019ec0:	461c4000 	.word	0x461c4000
		new_app_offset = buffer_get_uint32(data, &ind);
 8019ec4:	a902      	add	r1, sp, #8
 8019ec6:	4620      	mov	r0, r4
 8019ec8:	f7f7 ff2a 	bl	8011d20 <buffer_get_uint32>
		flash_res = flash_helper_write_new_app_data(new_app_offset, data + ind, len - ind);
 8019ecc:	9902      	ldr	r1, [sp, #8]
 8019ece:	1a6a      	subs	r2, r5, r1
 8019ed0:	4421      	add	r1, r4
 8019ed2:	f001 f825 	bl	801af20 <flash_helper_write_new_app_data>
	if (send_func) {
 8019ed6:	4a5b      	ldr	r2, [pc, #364]	; (801a044 <commands_process_packet+0x1694>)
		send_buffer[ind++] = COMM_WRITE_NEW_APP_DATA;
 8019ed8:	4b5b      	ldr	r3, [pc, #364]	; (801a048 <commands_process_packet+0x1698>)
	if (send_func) {
 8019eda:	6812      	ldr	r2, [r2, #0]
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019edc:	f1a0 0009 	sub.w	r0, r0, #9
 8019ee0:	fab0 f080 	clz	r0, r0
 8019ee4:	0940      	lsrs	r0, r0, #5
		send_buffer[ind++] = COMM_WRITE_NEW_APP_DATA;
 8019ee6:	2403      	movs	r4, #3
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019ee8:	2102      	movs	r1, #2
 8019eea:	7058      	strb	r0, [r3, #1]
		send_buffer[ind++] = COMM_WRITE_NEW_APP_DATA;
 8019eec:	701c      	strb	r4, [r3, #0]
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019eee:	9102      	str	r1, [sp, #8]
	if (send_func) {
 8019ef0:	2a00      	cmp	r2, #0
 8019ef2:	f43e adde 	beq.w	8018ab2 <commands_process_packet+0x102>
		send_func(data, len);
 8019ef6:	4618      	mov	r0, r3
 8019ef8:	4790      	blx	r2
 8019efa:	f7fe bdda 	b.w	8018ab2 <commands_process_packet+0x102>
		flash_res = flash_helper_erase_new_app(buffer_get_uint32(data, &ind));
 8019efe:	a902      	add	r1, sp, #8
 8019f00:	4620      	mov	r0, r4
 8019f02:	f7f7 ff0d 	bl	8011d20 <buffer_get_uint32>
 8019f06:	f000 ffc3 	bl	801ae90 <flash_helper_erase_new_app>
	if (send_func) {
 8019f0a:	4a4e      	ldr	r2, [pc, #312]	; (801a044 <commands_process_packet+0x1694>)
		send_buffer[ind++] = COMM_ERASE_NEW_APP;
 8019f0c:	4b4e      	ldr	r3, [pc, #312]	; (801a048 <commands_process_packet+0x1698>)
	if (send_func) {
 8019f0e:	6812      	ldr	r2, [r2, #0]
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019f10:	f1a0 0009 	sub.w	r0, r0, #9
 8019f14:	fab0 f080 	clz	r0, r0
		send_buffer[ind++] = COMM_ERASE_NEW_APP;
 8019f18:	2102      	movs	r1, #2
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019f1a:	0940      	lsrs	r0, r0, #5
 8019f1c:	7058      	strb	r0, [r3, #1]
		send_buffer[ind++] = COMM_ERASE_NEW_APP;
 8019f1e:	7019      	strb	r1, [r3, #0]
		send_buffer[ind++] = flash_res == FLASH_COMPLETE ? 1 : 0;
 8019f20:	9102      	str	r1, [sp, #8]
	if (send_func) {
 8019f22:	2a00      	cmp	r2, #0
 8019f24:	d1e7      	bne.n	8019ef6 <commands_process_packet+0x1546>
 8019f26:	f7fe bdc4 	b.w	8018ab2 <commands_process_packet+0x102>
		flash_helper_jump_to_bootloader();
 8019f2a:	f001 f829 	bl	801af80 <flash_helper_jump_to_bootloader>
		break;
 8019f2e:	f7fe bdc0 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_current((float)buffer_get_int32(data, &ind) / 1000.0);
 8019f32:	a902      	add	r1, sp, #8
 8019f34:	4620      	mov	r0, r4
 8019f36:	f7f7 fedb 	bl	8011cf0 <buffer_get_int32>
 8019f3a:	ee07 0a10 	vmov	s14, r0
 8019f3e:	eddf 7a43 	vldr	s15, [pc, #268]	; 801a04c <commands_process_packet+0x169c>
 8019f42:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 8019f46:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8019f4a:	f002 f9c9 	bl	801c2e0 <mc_interface_set_current>
		timeout_reset();
 8019f4e:	f000 f907 	bl	801a160 <timeout_reset>
		break;
 8019f52:	f7fe bdae 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_duty((float)buffer_get_int32(data, &ind) / 100000.0);
 8019f56:	a902      	add	r1, sp, #8
 8019f58:	4620      	mov	r0, r4
 8019f5a:	f7f7 fec9 	bl	8011cf0 <buffer_get_int32>
 8019f5e:	ee07 0a10 	vmov	s14, r0
 8019f62:	eddf 7a3b 	vldr	s15, [pc, #236]	; 801a050 <commands_process_packet+0x16a0>
 8019f66:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 8019f6a:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8019f6e:	f002 f90f 	bl	801c190 <mc_interface_set_duty>
		timeout_reset();
 8019f72:	f000 f8f5 	bl	801a160 <timeout_reset>
		break;
 8019f76:	f7fe bd9c 	b.w	8018ab2 <commands_process_packet+0x102>
		mc_interface_set_brake_current((float)buffer_get_int32(data, &ind) / 1000.0);
 8019f7a:	a902      	add	r1, sp, #8
 8019f7c:	4620      	mov	r0, r4
 8019f7e:	f7f7 feb7 	bl	8011cf0 <buffer_get_int32>
 8019f82:	ee07 0a10 	vmov	s14, r0
 8019f86:	eddf 7a31 	vldr	s15, [pc, #196]	; 801a04c <commands_process_packet+0x169c>
 8019f8a:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 8019f8e:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8019f92:	f002 f9f5 	bl	801c380 <mc_interface_set_brake_current>
		timeout_reset();
 8019f96:	f000 f8e3 	bl	801a160 <timeout_reset>
		break;
 8019f9a:	f7fe bd8a 	b.w	8018ab2 <commands_process_packet+0x102>
				mc_interface_release_motor();
 8019f9e:	f002 f9e7 	bl	801c370 <mc_interface_release_motor>
 8019fa2:	f7fe bda3 	b.w	8018aec <commands_process_packet+0x13c>
			appconf = *app_get_configuration();
 8019fa6:	f006 fafb 	bl	80205a0 <app_get_configuration>
 8019faa:	ac04      	add	r4, sp, #16
 8019fac:	4601      	mov	r1, r0
 8019fae:	22c8      	movs	r2, #200	; 0xc8
 8019fb0:	4620      	mov	r0, r4
 8019fb2:	f7f2 fdb5 	bl	800cb20 <memcpy>
 8019fb6:	f7fe befb 	b.w	8018db0 <commands_process_packet+0x400>
			mcconf = *mc_interface_get_configuration();
 8019fba:	f001 fa21 	bl	801b400 <mc_interface_get_configuration>
 8019fbe:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8019fc2:	4601      	mov	r1, r0
 8019fc4:	4823      	ldr	r0, [pc, #140]	; (801a054 <commands_process_packet+0x16a4>)
 8019fc6:	f7f2 fdab 	bl	800cb20 <memcpy>
 8019fca:	f7ff b8c4 	b.w	8019156 <commands_process_packet+0x7a6>
	if (send_func) {
 8019fce:	6834      	ldr	r4, [r6, #0]
 8019fd0:	2c00      	cmp	r4, #0
 8019fd2:	f43e ad6e 	beq.w	8018ab2 <commands_process_packet+0x102>
		send_func(data, len);
 8019fd6:	4619      	mov	r1, r3
 8019fd8:	4610      	mov	r0, r2
 8019fda:	47a0      	blx	r4
 8019fdc:	f7fe bd69 	b.w	8018ab2 <commands_process_packet+0x102>
			memset(send_buffer, 255, 8);
 8019fe0:	4b19      	ldr	r3, [pc, #100]	; (801a048 <commands_process_packet+0x1698>)
			send_buffer[ind++] = 0;
 8019fe2:	2100      	movs	r1, #0
			memset(send_buffer, 255, 8);
 8019fe4:	f04f 32ff 	mov.w	r2, #4294967295
			send_buffer[ind++] = 0;
 8019fe8:	7259      	strb	r1, [r3, #9]
			memset(send_buffer, 255, 8);
 8019fea:	e9c3 2200 	strd	r2, r2, [r3]
 8019fee:	f7fe bd60 	b.w	8018ab2 <commands_process_packet+0x102>
	if (send_func) {
 8019ff2:	f8d8 3000 	ldr.w	r3, [r8]
 8019ff6:	2b00      	cmp	r3, #0
 8019ff8:	f47e ae36 	bne.w	8018c68 <commands_process_packet+0x2b8>
 8019ffc:	f7fe bd59 	b.w	8018ab2 <commands_process_packet+0x102>
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 801a000:	ad36      	add	r5, sp, #216	; 0xd8
 801a002:	2301      	movs	r3, #1
 801a004:	f845 3dd0 	str.w	r3, [r5, #-208]!
 801a008:	4c0f      	ldr	r4, [pc, #60]	; (801a048 <commands_process_packet+0x1698>)
			buffer_append_float32(send_buffer, 1001.0, 1e6, &ind);
 801a00a:	eddf 0a13 	vldr	s1, [pc, #76]	; 801a058 <commands_process_packet+0x16a8>
 801a00e:	ed9f 0a13 	vldr	s0, [pc, #76]	; 801a05c <commands_process_packet+0x16ac>
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 801a012:	231b      	movs	r3, #27
			buffer_append_float32(send_buffer, 1001.0, 1e6, &ind);
 801a014:	4629      	mov	r1, r5
 801a016:	4620      	mov	r0, r4
			send_buffer[ind++] = COMM_DETECT_ENCODER;
 801a018:	7023      	strb	r3, [r4, #0]
			buffer_append_float32(send_buffer, 1001.0, 1e6, &ind);
 801a01a:	f7f7 fdf9 	bl	8011c10 <buffer_append_float32>
			buffer_append_float32(send_buffer, 0.0, 1e6, &ind);
 801a01e:	4629      	mov	r1, r5
 801a020:	4620      	mov	r0, r4
 801a022:	eddf 0a0d 	vldr	s1, [pc, #52]	; 801a058 <commands_process_packet+0x16a8>
 801a026:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 801a060 <commands_process_packet+0x16b0>
 801a02a:	f7f7 fdf1 	bl	8011c10 <buffer_append_float32>
	if (send_func) {
 801a02e:	4b05      	ldr	r3, [pc, #20]	; (801a044 <commands_process_packet+0x1694>)
			send_buffer[ind++] = false;
 801a030:	9902      	ldr	r1, [sp, #8]
	if (send_func) {
 801a032:	681b      	ldr	r3, [r3, #0]
			send_buffer[ind++] = false;
 801a034:	5466      	strb	r6, [r4, r1]
 801a036:	3101      	adds	r1, #1
 801a038:	9102      	str	r1, [sp, #8]
	if (send_func) {
 801a03a:	2b00      	cmp	r3, #0
 801a03c:	f47e ad37 	bne.w	8018aae <commands_process_packet+0xfe>
 801a040:	f7fe bd37 	b.w	8018ab2 <commands_process_packet+0x102>
 801a044:	200094f0 	.word	0x200094f0
 801a048:	200090f0 	.word	0x200090f0
 801a04c:	447a0000 	.word	0x447a0000
 801a050:	47c35000 	.word	0x47c35000
 801a054:	20008d08 	.word	0x20008d08
 801a058:	49742400 	.word	0x49742400
 801a05c:	447a4000 	.word	0x447a4000
	...

0801a070 <timeout_thread>:

float timeout_get_brake_current(void) {
	return timeout_brake_current;
}

static THD_FUNCTION(timeout_thread, arg) {
 801a070:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
 801a074:	4f16      	ldr	r7, [pc, #88]	; (801a0d0 <timeout_thread+0x60>)
 801a076:	4a17      	ldr	r2, [pc, #92]	; (801a0d4 <timeout_thread+0x64>)
 801a078:	69bb      	ldr	r3, [r7, #24]
 801a07a:	4c17      	ldr	r4, [pc, #92]	; (801a0d8 <timeout_thread+0x68>)
 801a07c:	f8df a060 	ldr.w	sl, [pc, #96]	; 801a0e0 <timeout_thread+0x70>
 801a080:	f8df b060 	ldr.w	fp, [pc, #96]	; 801a0e4 <timeout_thread+0x74>
 801a084:	4d15      	ldr	r5, [pc, #84]	; (801a0dc <timeout_thread+0x6c>)
	(void)arg;

	chRegSetThreadName("Timeout");

	for(;;) {
		if (timeout_msec != 0 && chVTTimeElapsedSinceX(last_update_time) > MS2ST(timeout_msec)) {
 801a086:	f8df 9060 	ldr.w	r9, [pc, #96]	; 801a0e8 <timeout_thread+0x78>
 801a08a:	619a      	str	r2, [r3, #24]
			mc_interface_unlock();
			mc_interface_set_brake_current(timeout_brake_current);
			has_timeout = true;
		} else {
			has_timeout = false;
 801a08c:	2600      	movs	r6, #0
		if (timeout_msec != 0 && chVTTimeElapsedSinceX(last_update_time) > MS2ST(timeout_msec)) {
 801a08e:	f242 7810 	movw	r8, #10000	; 0x2710
 801a092:	6823      	ldr	r3, [r4, #0]
 801a094:	b16b      	cbz	r3, 801a0b2 <timeout_thread+0x42>
 801a096:	f8da 1000 	ldr.w	r1, [sl]
  return ch.vtlist.vt_systime;
 801a09a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a09c:	6823      	ldr	r3, [r4, #0]
 801a09e:	fb08 f303 	mul.w	r3, r8, r3
 801a0a2:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
  return chVTGetSystemTimeX() - start;
 801a0a6:	1a52      	subs	r2, r2, r1
 801a0a8:	fba9 1303 	umull	r1, r3, r9, r3
 801a0ac:	ebb2 1f93 	cmp.w	r2, r3, lsr #6
 801a0b0:	d804      	bhi.n	801a0bc <timeout_thread+0x4c>
			has_timeout = false;
 801a0b2:	702e      	strb	r6, [r5, #0]
		}

		chThdSleepMilliseconds(10);
 801a0b4:	2064      	movs	r0, #100	; 0x64
 801a0b6:	f7f3 fc93 	bl	800d9e0 <chThdSleep>
		if (timeout_msec != 0 && chVTTimeElapsedSinceX(last_update_time) > MS2ST(timeout_msec)) {
 801a0ba:	e7ea      	b.n	801a092 <timeout_thread+0x22>
			mc_interface_unlock();
 801a0bc:	f001 f9c0 	bl	801b440 <mc_interface_unlock>
			mc_interface_set_brake_current(timeout_brake_current);
 801a0c0:	ed9b 0a00 	vldr	s0, [fp]
 801a0c4:	f002 f95c 	bl	801c380 <mc_interface_set_brake_current>
			has_timeout = true;
 801a0c8:	2301      	movs	r3, #1
 801a0ca:	702b      	strb	r3, [r5, #0]
 801a0cc:	e7f2      	b.n	801a0b4 <timeout_thread+0x44>
 801a0ce:	bf00      	nop
 801a0d0:	20001a48 	.word	0x20001a48
 801a0d4:	0802f240 	.word	0x0802f240
 801a0d8:	20009504 	.word	0x20009504
 801a0dc:	200094f8 	.word	0x200094f8
 801a0e0:	200094fc 	.word	0x200094fc
 801a0e4:	20009500 	.word	0x20009500
 801a0e8:	10624dd3 	.word	0x10624dd3
 801a0ec:	00000000 	.word	0x00000000

0801a0f0 <timeout_init>:
void timeout_init(void) {
 801a0f0:	b570      	push	{r4, r5, r6, lr}
	timeout_msec = 1000;
 801a0f2:	4c0b      	ldr	r4, [pc, #44]	; (801a120 <timeout_init+0x30>)
	last_update_time = 0;
 801a0f4:	4a0b      	ldr	r2, [pc, #44]	; (801a124 <timeout_init+0x34>)
	timeout_brake_current = 0.0;
 801a0f6:	490c      	ldr	r1, [pc, #48]	; (801a128 <timeout_init+0x38>)
	has_timeout = false;
 801a0f8:	4d0c      	ldr	r5, [pc, #48]	; (801a12c <timeout_init+0x3c>)
	chThdCreateStatic(timeout_thread_wa, sizeof(timeout_thread_wa), NORMALPRIO, timeout_thread, NULL);
 801a0fa:	4b0d      	ldr	r3, [pc, #52]	; (801a130 <timeout_init+0x40>)
void timeout_init(void) {
 801a0fc:	b082      	sub	sp, #8
	timeout_msec = 1000;
 801a0fe:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 801a102:	6026      	str	r6, [r4, #0]
	timeout_brake_current = 0.0;
 801a104:	2000      	movs	r0, #0
	last_update_time = 0;
 801a106:	2400      	movs	r4, #0
	chThdCreateStatic(timeout_thread_wa, sizeof(timeout_thread_wa), NORMALPRIO, timeout_thread, NULL);
 801a108:	9400      	str	r4, [sp, #0]
	last_update_time = 0;
 801a10a:	6014      	str	r4, [r2, #0]
	timeout_brake_current = 0.0;
 801a10c:	6008      	str	r0, [r1, #0]
	chThdCreateStatic(timeout_thread_wa, sizeof(timeout_thread_wa), NORMALPRIO, timeout_thread, NULL);
 801a10e:	2240      	movs	r2, #64	; 0x40
 801a110:	f44f 7166 	mov.w	r1, #920	; 0x398
 801a114:	4807      	ldr	r0, [pc, #28]	; (801a134 <timeout_init+0x44>)
	has_timeout = false;
 801a116:	702c      	strb	r4, [r5, #0]
	chThdCreateStatic(timeout_thread_wa, sizeof(timeout_thread_wa), NORMALPRIO, timeout_thread, NULL);
 801a118:	f7f3 fc2a 	bl	800d970 <chThdCreateStatic>
}
 801a11c:	b002      	add	sp, #8
 801a11e:	bd70      	pop	{r4, r5, r6, pc}
 801a120:	20009504 	.word	0x20009504
 801a124:	200094fc 	.word	0x200094fc
 801a128:	20009500 	.word	0x20009500
 801a12c:	200094f8 	.word	0x200094f8
 801a130:	0801a071 	.word	0x0801a071
 801a134:	20009508 	.word	0x20009508
	...

0801a140 <timeout_configure>:
	timeout_msec = timeout;
 801a140:	4a02      	ldr	r2, [pc, #8]	; (801a14c <timeout_configure+0xc>)
	timeout_brake_current = brake_current;
 801a142:	4b03      	ldr	r3, [pc, #12]	; (801a150 <timeout_configure+0x10>)
	timeout_msec = timeout;
 801a144:	6010      	str	r0, [r2, #0]
	timeout_brake_current = brake_current;
 801a146:	ed83 0a00 	vstr	s0, [r3]
}
 801a14a:	4770      	bx	lr
 801a14c:	20009504 	.word	0x20009504
 801a150:	20009500 	.word	0x20009500
	...

0801a160 <timeout_reset>:
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 801a160:	2320      	movs	r3, #32
 801a162:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.vt_systime;
 801a166:	4a04      	ldr	r2, [pc, #16]	; (801a178 <timeout_reset+0x18>)
 801a168:	2300      	movs	r3, #0
 801a16a:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801a16c:	f383 8811 	msr	BASEPRI, r3
	last_update_time = chVTGetSystemTime();
 801a170:	4b02      	ldr	r3, [pc, #8]	; (801a17c <timeout_reset+0x1c>)
 801a172:	601a      	str	r2, [r3, #0]
}
 801a174:	4770      	bx	lr
 801a176:	bf00      	nop
 801a178:	20001a48 	.word	0x20001a48
 801a17c:	200094fc 	.word	0x200094fc

0801a180 <timeout_has_timeout>:
	return has_timeout;
 801a180:	4b01      	ldr	r3, [pc, #4]	; (801a188 <timeout_has_timeout+0x8>)
 801a182:	7818      	ldrb	r0, [r3, #0]
}
 801a184:	4770      	bx	lr
 801a186:	bf00      	nop
 801a188:	200094f8 	.word	0x200094f8
 801a18c:	00000000 	.word	0x00000000

0801a190 <timeout_get_timeout_msec>:
	return timeout_msec;
 801a190:	4b01      	ldr	r3, [pc, #4]	; (801a198 <timeout_get_timeout_msec+0x8>)
 801a192:	6818      	ldr	r0, [r3, #0]
}
 801a194:	4770      	bx	lr
 801a196:	bf00      	nop
 801a198:	20009504 	.word	0x20009504
 801a19c:	00000000 	.word	0x00000000

0801a1a0 <timeout_get_brake_current>:
	return timeout_brake_current;
 801a1a0:	4b01      	ldr	r3, [pc, #4]	; (801a1a8 <timeout_get_brake_current+0x8>)
 801a1a2:	ed93 0a00 	vldr	s0, [r3]
}
 801a1a6:	4770      	bx	lr
 801a1a8:	20009500 	.word	0x20009500
 801a1ac:	00000000 	.word	0x00000000

0801a1b0 <cancom_process_thread>:
	}

	chEvtUnregister(&CANDx.rxfull_event, &el);
}

static THD_FUNCTION(cancom_process_thread, arg) {
 801a1b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a1b4:	f8df a364 	ldr.w	sl, [pc, #868]	; 801a51c <cancom_process_thread+0x36c>
 801a1b8:	4acc      	ldr	r2, [pc, #816]	; (801a4ec <cancom_process_thread+0x33c>)
 801a1ba:	f8da 3018 	ldr.w	r3, [sl, #24]
	(void)arg;

	chRegSetThreadName("Cancom process");
	process_tp = chThdGetSelfX();
 801a1be:	49cc      	ldr	r1, [pc, #816]	; (801a4f0 <cancom_process_thread+0x340>)
 801a1c0:	4ccc      	ldr	r4, [pc, #816]	; (801a4f4 <cancom_process_thread+0x344>)
 801a1c2:	4dcd      	ldr	r5, [pc, #820]	; (801a4f8 <cancom_process_thread+0x348>)
 801a1c4:	4ecd      	ldr	r6, [pc, #820]	; (801a4fc <cancom_process_thread+0x34c>)
 801a1c6:	f8df 9348 	ldr.w	r9, [pc, #840]	; 801a510 <cancom_process_thread+0x360>
 801a1ca:	4fcd      	ldr	r7, [pc, #820]	; (801a500 <cancom_process_thread+0x350>)
static THD_FUNCTION(cancom_process_thread, arg) {
 801a1cc:	ed2d 8b04 	vpush	{d8-d9}
 801a1d0:	b089      	sub	sp, #36	; 0x24
 801a1d2:	619a      	str	r2, [r3, #24]
							ind = 0;
							stat_tmp->id = id;
							stat_tmp->rx_time = chVTGetSystemTime();
							stat_tmp->rpm = (float)buffer_get_int32(rxmsg.data8, &ind);
							stat_tmp->current = (float)buffer_get_int16(rxmsg.data8, &ind) / 10.0;
							stat_tmp->duty = (float)buffer_get_int16(rxmsg.data8, &ind) / 1000.0;
 801a1d4:	ed9f 8acb 	vldr	s16, [pc, #812]	; 801a504 <cancom_process_thread+0x354>
						mc_interface_set_brake_current_rel(buffer_get_float32(rxmsg.data8, 1e5, &ind));
 801a1d8:	eddf 8acb 	vldr	s17, [pc, #812]	; 801a508 <cancom_process_thread+0x358>
						mc_interface_set_pid_pos((float)buffer_get_int32(rxmsg.data8, &ind) / 1000000.0);
 801a1dc:	ed9f 9acb 	vldr	s18, [pc, #812]	; 801a50c <cancom_process_thread+0x35c>
	process_tp = chThdGetSelfX();
 801a1e0:	600b      	str	r3, [r1, #0]
	int32_t ind = 0;
 801a1e2:	2200      	movs	r2, #0
 801a1e4:	9202      	str	r2, [sp, #8]
		chEvtWaitAny((eventmask_t) 1);
 801a1e6:	2001      	movs	r0, #1
 801a1e8:	f7f3 fe5a 	bl	800dea0 <chEvtWaitAny>
		while (rx_frame_read != rx_frame_write) {
 801a1ec:	f8d4 e000 	ldr.w	lr, [r4]
 801a1f0:	682b      	ldr	r3, [r5, #0]
 801a1f2:	459e      	cmp	lr, r3
 801a1f4:	d0f7      	beq.n	801a1e6 <cancom_process_thread+0x36>
			CANRxFrame rxmsg = rx_frames[rx_frame_read++];
 801a1f6:	eb0e 0c8e 	add.w	ip, lr, lr, lsl #2
 801a1fa:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
 801a1fe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801a202:	f10d 080c 	add.w	r8, sp, #12
 801a206:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
			if (rxmsg.IDE == CAN_IDE_EXT) {
 801a20a:	f89d 2010 	ldrb.w	r2, [sp, #16]
			CANRxFrame rxmsg = rx_frames[rx_frame_read++];
 801a20e:	f8dc 3000 	ldr.w	r3, [ip]
 801a212:	f8c8 3000 	str.w	r3, [r8]
			if (rxmsg.IDE == CAN_IDE_EXT) {
 801a216:	0691      	lsls	r1, r2, #26
			CANRxFrame rxmsg = rx_frames[rx_frame_read++];
 801a218:	f10e 0301 	add.w	r3, lr, #1
 801a21c:	6023      	str	r3, [r4, #0]
			if (rxmsg.IDE == CAN_IDE_EXT) {
 801a21e:	d52b      	bpl.n	801a278 <cancom_process_thread+0xc8>
				uint8_t id = rxmsg.EID & 0xFF;
 801a220:	9b05      	ldr	r3, [sp, #20]
 801a222:	f3c3 031c 	ubfx	r3, r3, #0, #29
 801a226:	fa5f fb83 	uxtb.w	fp, r3
				if (id == 255 || id == app_get_configuration()->controller_id) {
 801a22a:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 801a22e:	f3c3 2807 	ubfx	r8, r3, #8, #8
 801a232:	d030      	beq.n	801a296 <cancom_process_thread+0xe6>
 801a234:	f006 f9b4 	bl	80205a0 <app_get_configuration>
 801a238:	7803      	ldrb	r3, [r0, #0]
 801a23a:	455b      	cmp	r3, fp
 801a23c:	d02b      	beq.n	801a296 <cancom_process_thread+0xe6>
				switch (cmd) {
 801a23e:	f1b8 0f09 	cmp.w	r8, #9
 801a242:	d10d      	bne.n	801a260 <cancom_process_thread+0xb0>
 801a244:	4ab2      	ldr	r2, [pc, #712]	; (801a510 <cancom_process_thread+0x360>)
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 801a246:	2300      	movs	r3, #0
						if (stat_tmp->id == id || stat_tmp->id == -1) {
 801a248:	6811      	ldr	r1, [r2, #0]
 801a24a:	4559      	cmp	r1, fp
 801a24c:	f102 0214 	add.w	r2, r2, #20
 801a250:	f000 8111 	beq.w	801a476 <cancom_process_thread+0x2c6>
 801a254:	3101      	adds	r1, #1
 801a256:	f000 810e 	beq.w	801a476 <cancom_process_thread+0x2c6>
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 801a25a:	3301      	adds	r3, #1
 801a25c:	2b0a      	cmp	r3, #10
 801a25e:	d1f3      	bne.n	801a248 <cancom_process_thread+0x98>
 801a260:	f8d4 e000 	ldr.w	lr, [r4]
				if (sid_callback) {
					sid_callback(rxmsg.SID, rxmsg.data8, rxmsg.DLC);
				}
			}

			if (rx_frame_read == RX_FRAMES_SIZE) {
 801a264:	f1be 0f64 	cmp.w	lr, #100	; 0x64
 801a268:	d102      	bne.n	801a270 <cancom_process_thread+0xc0>
				rx_frame_read = 0;
 801a26a:	2300      	movs	r3, #0
 801a26c:	6023      	str	r3, [r4, #0]
 801a26e:	469e      	mov	lr, r3
		while (rx_frame_read != rx_frame_write) {
 801a270:	682b      	ldr	r3, [r5, #0]
 801a272:	4573      	cmp	r3, lr
 801a274:	d1bf      	bne.n	801a1f6 <cancom_process_thread+0x46>
 801a276:	e7b6      	b.n	801a1e6 <cancom_process_thread+0x36>
				if (sid_callback) {
 801a278:	f8d7 8000 	ldr.w	r8, [r7]
 801a27c:	f1b8 0f00 	cmp.w	r8, #0
 801a280:	f000 8131 	beq.w	801a4e6 <cancom_process_thread+0x336>
					sid_callback(rxmsg.SID, rxmsg.data8, rxmsg.DLC);
 801a284:	f8bd 0014 	ldrh.w	r0, [sp, #20]
 801a288:	f002 020f 	and.w	r2, r2, #15
 801a28c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 801a290:	a906      	add	r1, sp, #24
 801a292:	47c0      	blx	r8
 801a294:	e7e4      	b.n	801a260 <cancom_process_thread+0xb0>
					switch (cmd) {
 801a296:	f1b8 0f0b 	cmp.w	r8, #11
 801a29a:	d8d0      	bhi.n	801a23e <cancom_process_thread+0x8e>
 801a29c:	a301      	add	r3, pc, #4	; (adr r3, 801a2a4 <cancom_process_thread+0xf4>)
 801a29e:	f853 f028 	ldr.w	pc, [r3, r8, lsl #2]
 801a2a2:	bf00      	nop
 801a2a4:	0801a3f3 	.word	0x0801a3f3
 801a2a8:	0801a3d1 	.word	0x0801a3d1
 801a2ac:	0801a433 	.word	0x0801a433
 801a2b0:	0801a415 	.word	0x0801a415
 801a2b4:	0801a455 	.word	0x0801a455
 801a2b8:	0801a3b5 	.word	0x0801a3b5
 801a2bc:	0801a38d 	.word	0x0801a38d
 801a2c0:	0801a333 	.word	0x0801a333
 801a2c4:	0801a309 	.word	0x0801a309
 801a2c8:	0801a23f 	.word	0x0801a23f
 801a2cc:	0801a2ef 	.word	0x0801a2ef
 801a2d0:	0801a2d5 	.word	0x0801a2d5
						ind = 0;
 801a2d4:	2300      	movs	r3, #0
						mc_interface_set_brake_current_rel(buffer_get_float32(rxmsg.data8, 1e5, &ind));
 801a2d6:	a902      	add	r1, sp, #8
 801a2d8:	a806      	add	r0, sp, #24
 801a2da:	eeb0 0a68 	vmov.f32	s0, s17
						ind = 0;
 801a2de:	9302      	str	r3, [sp, #8]
						mc_interface_set_brake_current_rel(buffer_get_float32(rxmsg.data8, 1e5, &ind));
 801a2e0:	f7f7 fd36 	bl	8011d50 <buffer_get_float32>
 801a2e4:	f002 f87c 	bl	801c3e0 <mc_interface_set_brake_current_rel>
						timeout_reset();
 801a2e8:	f7ff ff3a 	bl	801a160 <timeout_reset>
						break;
 801a2ec:	e7b8      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a2ee:	2300      	movs	r3, #0
						mc_interface_set_current_rel(buffer_get_float32(rxmsg.data8, 1e5, &ind));
 801a2f0:	a902      	add	r1, sp, #8
 801a2f2:	a806      	add	r0, sp, #24
 801a2f4:	eeb0 0a68 	vmov.f32	s0, s17
						ind = 0;
 801a2f8:	9302      	str	r3, [sp, #8]
						mc_interface_set_current_rel(buffer_get_float32(rxmsg.data8, 1e5, &ind));
 801a2fa:	f7f7 fd29 	bl	8011d50 <buffer_get_float32>
 801a2fe:	f002 f81f 	bl	801c340 <mc_interface_set_current_rel>
						timeout_reset();
 801a302:	f7ff ff2d 	bl	801a160 <timeout_reset>
						break;
 801a306:	e7ab      	b.n	801a260 <cancom_process_thread+0xb0>
						rx_buffer_last_id = rxmsg.data8[ind++];
 801a308:	4982      	ldr	r1, [pc, #520]	; (801a514 <cancom_process_thread+0x364>)
 801a30a:	f89d 2018 	ldrb.w	r2, [sp, #24]
						if (commands_send) {
 801a30e:	f89d 3019 	ldrb.w	r3, [sp, #25]
						rx_buffer_last_id = rxmsg.data8[ind++];
 801a312:	600a      	str	r2, [r1, #0]
						commands_send = rxmsg.data8[ind++];
 801a314:	2202      	movs	r2, #2
 801a316:	9202      	str	r2, [sp, #8]
						if (commands_send) {
 801a318:	2b00      	cmp	r3, #0
 801a31a:	f000 8101 	beq.w	801a520 <cancom_process_thread+0x370>
							commands_send_packet(rxmsg.data8 + ind, rxmsg.DLC - ind);
 801a31e:	f89d 1010 	ldrb.w	r1, [sp, #16]
 801a322:	f001 010f 	and.w	r1, r1, #15
 801a326:	3902      	subs	r1, #2
 801a328:	f10d 001a 	add.w	r0, sp, #26
 801a32c:	f7fe f980 	bl	8018630 <commands_send_packet>
 801a330:	e796      	b.n	801a260 <cancom_process_thread+0xb0>
						rxbuf_len = (unsigned int)rxmsg.data8[ind++] << 8;
 801a332:	f89d 301a 	ldrb.w	r3, [sp, #26]
						rxbuf_len |= (unsigned int)rxmsg.data8[ind++];
 801a336:	f89d 801b 	ldrb.w	r8, [sp, #27]
						rx_buffer_last_id = rxmsg.data8[ind++];
 801a33a:	4976      	ldr	r1, [pc, #472]	; (801a514 <cancom_process_thread+0x364>)
 801a33c:	f89d 2018 	ldrb.w	r2, [sp, #24]
 801a340:	600a      	str	r2, [r1, #0]
						rxbuf_len |= (unsigned int)rxmsg.data8[ind++];
 801a342:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
						if (rxbuf_len > RX_BUFFER_SIZE) {
 801a346:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
						rxbuf_len |= (unsigned int)rxmsg.data8[ind++];
 801a34a:	f04f 0304 	mov.w	r3, #4
 801a34e:	9302      	str	r3, [sp, #8]
						commands_send = rxmsg.data8[ind++];
 801a350:	f89d 3019 	ldrb.w	r3, [sp, #25]
						if (rxbuf_len > RX_BUFFER_SIZE) {
 801a354:	d884      	bhi.n	801a260 <cancom_process_thread+0xb0>
						crc_low = rxmsg.data8[ind++];
 801a356:	2206      	movs	r2, #6
 801a358:	9202      	str	r2, [sp, #8]
						if (crc16(rx_buffer, rxbuf_len)
 801a35a:	4641      	mov	r1, r8
						crc_high = rxmsg.data8[ind++];
 801a35c:	f89d 201c 	ldrb.w	r2, [sp, #28]
						if (crc16(rx_buffer, rxbuf_len)
 801a360:	486d      	ldr	r0, [pc, #436]	; (801a518 <cancom_process_thread+0x368>)
 801a362:	9301      	str	r3, [sp, #4]
						crc_high = rxmsg.data8[ind++];
 801a364:	9200      	str	r2, [sp, #0]
						crc_low = rxmsg.data8[ind++];
 801a366:	f89d b01d 	ldrb.w	fp, [sp, #29]
						if (crc16(rx_buffer, rxbuf_len)
 801a36a:	f7f7 fe01 	bl	8011f70 <crc16>
										| (unsigned short) crc_low)) {
 801a36e:	9a00      	ldr	r2, [sp, #0]
						if (crc16(rx_buffer, rxbuf_len)
 801a370:	9b01      	ldr	r3, [sp, #4]
										| (unsigned short) crc_low)) {
 801a372:	ea4b 2b02 	orr.w	fp, fp, r2, lsl #8
						if (crc16(rx_buffer, rxbuf_len)
 801a376:	4558      	cmp	r0, fp
 801a378:	f47f af72 	bne.w	801a260 <cancom_process_thread+0xb0>
							if (commands_send) {
 801a37c:	2b00      	cmp	r3, #0
 801a37e:	f000 80dd 	beq.w	801a53c <cancom_process_thread+0x38c>
								commands_send_packet(rx_buffer, rxbuf_len);
 801a382:	4641      	mov	r1, r8
 801a384:	4864      	ldr	r0, [pc, #400]	; (801a518 <cancom_process_thread+0x368>)
 801a386:	f7fe f953 	bl	8018630 <commands_send_packet>
 801a38a:	e769      	b.n	801a260 <cancom_process_thread+0xb0>
 801a38c:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 801a390:	ba40      	rev16	r0, r0
 801a392:	b280      	uxth	r0, r0
						if (rxbuf_ind < RX_BUFFER_SIZE) {
 801a394:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 801a398:	f4bf af62 	bcs.w	801a260 <cancom_process_thread+0xb0>
							memcpy(rx_buffer + rxbuf_ind, rxmsg.data8 + 2, rxmsg.DLC - 2);
 801a39c:	f89d 2010 	ldrb.w	r2, [sp, #16]
 801a3a0:	4b5d      	ldr	r3, [pc, #372]	; (801a518 <cancom_process_thread+0x368>)
 801a3a2:	f002 020f 	and.w	r2, r2, #15
 801a3a6:	4418      	add	r0, r3
 801a3a8:	3a02      	subs	r2, #2
 801a3aa:	f10d 011a 	add.w	r1, sp, #26
 801a3ae:	f7f2 fbb7 	bl	800cb20 <memcpy>
 801a3b2:	e755      	b.n	801a260 <cancom_process_thread+0xb0>
						memcpy(rx_buffer + rxmsg.data8[0], rxmsg.data8 + 1, rxmsg.DLC - 1);
 801a3b4:	f89d 2010 	ldrb.w	r2, [sp, #16]
 801a3b8:	f89d 0018 	ldrb.w	r0, [sp, #24]
 801a3bc:	4b56      	ldr	r3, [pc, #344]	; (801a518 <cancom_process_thread+0x368>)
 801a3be:	f002 020f 	and.w	r2, r2, #15
 801a3c2:	3a01      	subs	r2, #1
 801a3c4:	4418      	add	r0, r3
 801a3c6:	f10d 0119 	add.w	r1, sp, #25
 801a3ca:	f7f2 fba9 	bl	800cb20 <memcpy>
						break;
 801a3ce:	e747      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a3d0:	2300      	movs	r3, #0
						mc_interface_set_current((float)buffer_get_int32(rxmsg.data8, &ind) / 1000.0);
 801a3d2:	a902      	add	r1, sp, #8
 801a3d4:	a806      	add	r0, sp, #24
						ind = 0;
 801a3d6:	9302      	str	r3, [sp, #8]
						mc_interface_set_current((float)buffer_get_int32(rxmsg.data8, &ind) / 1000.0);
 801a3d8:	f7f7 fc8a 	bl	8011cf0 <buffer_get_int32>
 801a3dc:	ee07 0a90 	vmov	s15, r0
 801a3e0:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801a3e4:	ee80 0a08 	vdiv.f32	s0, s0, s16
 801a3e8:	f001 ff7a 	bl	801c2e0 <mc_interface_set_current>
						timeout_reset();
 801a3ec:	f7ff feb8 	bl	801a160 <timeout_reset>
						break;
 801a3f0:	e736      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a3f2:	2300      	movs	r3, #0
						mc_interface_set_duty((float)buffer_get_int32(rxmsg.data8, &ind) / 100000.0);
 801a3f4:	a902      	add	r1, sp, #8
 801a3f6:	a806      	add	r0, sp, #24
						ind = 0;
 801a3f8:	9302      	str	r3, [sp, #8]
						mc_interface_set_duty((float)buffer_get_int32(rxmsg.data8, &ind) / 100000.0);
 801a3fa:	f7f7 fc79 	bl	8011cf0 <buffer_get_int32>
 801a3fe:	ee07 0a90 	vmov	s15, r0
 801a402:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801a406:	ee80 0a28 	vdiv.f32	s0, s0, s17
 801a40a:	f001 fec1 	bl	801c190 <mc_interface_set_duty>
						timeout_reset();
 801a40e:	f7ff fea7 	bl	801a160 <timeout_reset>
						break;
 801a412:	e725      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a414:	2300      	movs	r3, #0
						mc_interface_set_pid_speed((float)buffer_get_int32(rxmsg.data8, &ind));
 801a416:	a902      	add	r1, sp, #8
 801a418:	a806      	add	r0, sp, #24
						ind = 0;
 801a41a:	9302      	str	r3, [sp, #8]
						mc_interface_set_pid_speed((float)buffer_get_int32(rxmsg.data8, &ind));
 801a41c:	f7f7 fc68 	bl	8011cf0 <buffer_get_int32>
 801a420:	ee07 0a90 	vmov	s15, r0
 801a424:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801a428:	f001 fee2 	bl	801c1f0 <mc_interface_set_pid_speed>
						timeout_reset();
 801a42c:	f7ff fe98 	bl	801a160 <timeout_reset>
						break;
 801a430:	e716      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a432:	2300      	movs	r3, #0
						mc_interface_set_brake_current((float)buffer_get_int32(rxmsg.data8, &ind) / 1000.0);
 801a434:	a902      	add	r1, sp, #8
 801a436:	a806      	add	r0, sp, #24
						ind = 0;
 801a438:	9302      	str	r3, [sp, #8]
						mc_interface_set_brake_current((float)buffer_get_int32(rxmsg.data8, &ind) / 1000.0);
 801a43a:	f7f7 fc59 	bl	8011cf0 <buffer_get_int32>
 801a43e:	ee07 0a90 	vmov	s15, r0
 801a442:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801a446:	ee80 0a08 	vdiv.f32	s0, s0, s16
 801a44a:	f001 ff99 	bl	801c380 <mc_interface_set_brake_current>
						timeout_reset();
 801a44e:	f7ff fe87 	bl	801a160 <timeout_reset>
						break;
 801a452:	e705      	b.n	801a260 <cancom_process_thread+0xb0>
						ind = 0;
 801a454:	2300      	movs	r3, #0
						mc_interface_set_pid_pos((float)buffer_get_int32(rxmsg.data8, &ind) / 1000000.0);
 801a456:	a902      	add	r1, sp, #8
 801a458:	a806      	add	r0, sp, #24
						ind = 0;
 801a45a:	9302      	str	r3, [sp, #8]
						mc_interface_set_pid_pos((float)buffer_get_int32(rxmsg.data8, &ind) / 1000000.0);
 801a45c:	f7f7 fc48 	bl	8011cf0 <buffer_get_int32>
 801a460:	ee07 0a90 	vmov	s15, r0
 801a464:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801a468:	ee80 0a09 	vdiv.f32	s0, s0, s18
 801a46c:	f001 fef0 	bl	801c250 <mc_interface_set_pid_pos>
						timeout_reset();
 801a470:	f7ff fe76 	bl	801a160 <timeout_reset>
						break;
 801a474:	e6f4      	b.n	801a260 <cancom_process_thread+0xb0>
							stat_tmp->id = id;
 801a476:	eb03 0383 	add.w	r3, r3, r3, lsl #2
							ind = 0;
 801a47a:	2200      	movs	r2, #0
							stat_tmp->id = id;
 801a47c:	f849 b023 	str.w	fp, [r9, r3, lsl #2]
 801a480:	eb09 0883 	add.w	r8, r9, r3, lsl #2
							ind = 0;
 801a484:	9202      	str	r2, [sp, #8]
 801a486:	2320      	movs	r3, #32
 801a488:	f383 8811 	msr	BASEPRI, r3
 801a48c:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 801a490:	f382 8811 	msr	BASEPRI, r2
							stat_tmp->rx_time = chVTGetSystemTime();
 801a494:	f8c8 3004 	str.w	r3, [r8, #4]
							stat_tmp->rpm = (float)buffer_get_int32(rxmsg.data8, &ind);
 801a498:	a902      	add	r1, sp, #8
 801a49a:	a806      	add	r0, sp, #24
 801a49c:	f7f7 fc28 	bl	8011cf0 <buffer_get_int32>
 801a4a0:	ee07 0a90 	vmov	s15, r0
 801a4a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
							stat_tmp->current = (float)buffer_get_int16(rxmsg.data8, &ind) / 10.0;
 801a4a8:	a902      	add	r1, sp, #8
							stat_tmp->rpm = (float)buffer_get_int32(rxmsg.data8, &ind);
 801a4aa:	edc8 7a02 	vstr	s15, [r8, #8]
							stat_tmp->current = (float)buffer_get_int16(rxmsg.data8, &ind) / 10.0;
 801a4ae:	a806      	add	r0, sp, #24
 801a4b0:	f7f7 fbfe 	bl	8011cb0 <buffer_get_int16>
 801a4b4:	ee07 0a90 	vmov	s15, r0
 801a4b8:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801a4bc:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 801a4c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
							stat_tmp->duty = (float)buffer_get_int16(rxmsg.data8, &ind) / 1000.0;
 801a4c4:	a902      	add	r1, sp, #8
 801a4c6:	a806      	add	r0, sp, #24
							stat_tmp->current = (float)buffer_get_int16(rxmsg.data8, &ind) / 10.0;
 801a4c8:	edc8 7a03 	vstr	s15, [r8, #12]
							stat_tmp->duty = (float)buffer_get_int16(rxmsg.data8, &ind) / 1000.0;
 801a4cc:	f7f7 fbf0 	bl	8011cb0 <buffer_get_int16>
 801a4d0:	ee07 0a90 	vmov	s15, r0
 801a4d4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801a4d8:	f8d4 e000 	ldr.w	lr, [r4]
 801a4dc:	eec7 7a08 	vdiv.f32	s15, s14, s16
 801a4e0:	edc8 7a04 	vstr	s15, [r8, #16]
							break;
 801a4e4:	e6be      	b.n	801a264 <cancom_process_thread+0xb4>
 801a4e6:	469e      	mov	lr, r3
 801a4e8:	e6bc      	b.n	801a264 <cancom_process_thread+0xb4>
 801a4ea:	bf00      	nop
 801a4ec:	0802f250 	.word	0x0802f250
 801a4f0:	2000b378 	.word	0x2000b378
 801a4f4:	2000b780 	.word	0x2000b780
 801a4f8:	2000b784 	.word	0x2000b784
 801a4fc:	2000b788 	.word	0x2000b788
 801a500:	2000bf58 	.word	0x2000bf58
 801a504:	447a0000 	.word	0x447a0000
 801a508:	47c35000 	.word	0x47c35000
 801a50c:	49742400 	.word	0x49742400
 801a510:	2000bf5c 	.word	0x2000bf5c
 801a514:	2000b77c 	.word	0x2000b77c
 801a518:	2000b37c 	.word	0x2000b37c
 801a51c:	20001a48 	.word	0x20001a48
							commands_set_send_func(send_packet_wrapper);
 801a520:	480a      	ldr	r0, [pc, #40]	; (801a54c <cancom_process_thread+0x39c>)
 801a522:	f7fe f87d 	bl	8018620 <commands_set_send_func>
							commands_process_packet(rxmsg.data8 + ind, rxmsg.DLC - ind);
 801a526:	f89d 1010 	ldrb.w	r1, [sp, #16]
 801a52a:	9802      	ldr	r0, [sp, #8]
 801a52c:	ab06      	add	r3, sp, #24
 801a52e:	f001 010f 	and.w	r1, r1, #15
 801a532:	1a09      	subs	r1, r1, r0
 801a534:	4418      	add	r0, r3
 801a536:	f7fe fa3b 	bl	80189b0 <commands_process_packet>
 801a53a:	e691      	b.n	801a260 <cancom_process_thread+0xb0>
								commands_set_send_func(send_packet_wrapper);
 801a53c:	4803      	ldr	r0, [pc, #12]	; (801a54c <cancom_process_thread+0x39c>)
 801a53e:	f7fe f86f 	bl	8018620 <commands_set_send_func>
								commands_process_packet(rx_buffer, rxbuf_len);
 801a542:	4641      	mov	r1, r8
 801a544:	4802      	ldr	r0, [pc, #8]	; (801a550 <cancom_process_thread+0x3a0>)
 801a546:	f7fe fa33 	bl	80189b0 <commands_process_packet>
 801a54a:	e689      	b.n	801a260 <cancom_process_thread+0xb0>
 801a54c:	0801a9c1 	.word	0x0801a9c1
 801a550:	2000b37c 	.word	0x2000b37c
	...

0801a560 <cancom_read_thread>:
static THD_FUNCTION(cancom_read_thread, arg) {
 801a560:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a564:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 801a624 <cancom_read_thread+0xc4>
 801a568:	4a29      	ldr	r2, [pc, #164]	; (801a610 <cancom_read_thread+0xb0>)
 801a56a:	f8da 3018 	ldr.w	r3, [sl, #24]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 801a56e:	4829      	ldr	r0, [pc, #164]	; (801a614 <cancom_read_thread+0xb4>)
 801a570:	619a      	str	r2, [r3, #24]
 801a572:	b08a      	sub	sp, #40	; 0x28
 801a574:	4669      	mov	r1, sp
 801a576:	f04f 33ff 	mov.w	r3, #4294967295
 801a57a:	2201      	movs	r2, #1
 801a57c:	f7f3 fc20 	bl	800ddc0 <chEvtRegisterMaskWithFlags>
		msg_t result = canReceive(&CANDx, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
 801a580:	4e25      	ldr	r6, [pc, #148]	; (801a618 <cancom_read_thread+0xb8>)
 801a582:	4d26      	ldr	r5, [pc, #152]	; (801a61c <cancom_read_thread+0xbc>)
 801a584:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 801a628 <cancom_read_thread+0xc8>
  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 801a588:	f8da 3018 	ldr.w	r3, [sl, #24]
	while(!chThdShouldTerminateX()) {
 801a58c:	7f5b      	ldrb	r3, [r3, #29]
 801a58e:	f013 0404 	ands.w	r4, r3, #4
 801a592:	d136      	bne.n	801a602 <cancom_read_thread+0xa2>
		if (chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(10)) == 0) {
 801a594:	2164      	movs	r1, #100	; 0x64
 801a596:	f04f 30ff 	mov.w	r0, #4294967295
 801a59a:	f7f3 fca1 	bl	800dee0 <chEvtWaitAnyTimeout>
 801a59e:	2800      	cmp	r0, #0
 801a5a0:	d0f2      	beq.n	801a588 <cancom_read_thread+0x28>
		msg_t result = canReceive(&CANDx, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
 801a5a2:	aa05      	add	r2, sp, #20
 801a5a4:	4623      	mov	r3, r4
 801a5a6:	4621      	mov	r1, r4
 801a5a8:	4630      	mov	r0, r6
 801a5aa:	f7f3 ffa9 	bl	800e500 <canReceive>
		while (result == MSG_OK) {
 801a5ae:	2800      	cmp	r0, #0
 801a5b0:	d1ea      	bne.n	801a588 <cancom_read_thread+0x28>
 801a5b2:	4f1b      	ldr	r7, [pc, #108]	; (801a620 <cancom_read_thread+0xc0>)
				rx_frame_write = 0;
 801a5b4:	4681      	mov	r9, r0
			rx_frames[rx_frame_write++] = rxmsg;
 801a5b6:	ac05      	add	r4, sp, #20
 801a5b8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a5ba:	f8d5 c000 	ldr.w	ip, [r5]
 801a5be:	f8d4 e000 	ldr.w	lr, [r4]
 801a5c2:	eb0c 048c 	add.w	r4, ip, ip, lsl #2
 801a5c6:	eb08 0484 	add.w	r4, r8, r4, lsl #2
 801a5ca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
			chEvtSignal(process_tp, (eventmask_t) 1);
 801a5cc:	2101      	movs	r1, #1
			rx_frames[rx_frame_write++] = rxmsg;
 801a5ce:	eb0c 0301 	add.w	r3, ip, r1
			if (rx_frame_write == RX_FRAMES_SIZE) {
 801a5d2:	2b64      	cmp	r3, #100	; 0x64
			chEvtSignal(process_tp, (eventmask_t) 1);
 801a5d4:	6838      	ldr	r0, [r7, #0]
			rx_frames[rx_frame_write++] = rxmsg;
 801a5d6:	602b      	str	r3, [r5, #0]
 801a5d8:	f8c4 e000 	str.w	lr, [r4]
				rx_frame_write = 0;
 801a5dc:	bf08      	it	eq
 801a5de:	f8c5 9000 	streq.w	r9, [r5]
			chEvtSignal(process_tp, (eventmask_t) 1);
 801a5e2:	f7f3 fc4d 	bl	800de80 <chEvtSignal>
			result = canReceive(&CANDx, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
 801a5e6:	2300      	movs	r3, #0
 801a5e8:	4619      	mov	r1, r3
 801a5ea:	aa05      	add	r2, sp, #20
 801a5ec:	4630      	mov	r0, r6
 801a5ee:	f7f3 ff87 	bl	800e500 <canReceive>
		while (result == MSG_OK) {
 801a5f2:	2800      	cmp	r0, #0
 801a5f4:	d0df      	beq.n	801a5b6 <cancom_read_thread+0x56>
 801a5f6:	f8da 3018 	ldr.w	r3, [sl, #24]
	while(!chThdShouldTerminateX()) {
 801a5fa:	7f5b      	ldrb	r3, [r3, #29]
 801a5fc:	f013 0404 	ands.w	r4, r3, #4
 801a600:	d0c8      	beq.n	801a594 <cancom_read_thread+0x34>
	chEvtUnregister(&CANDx.rxfull_event, &el);
 801a602:	4669      	mov	r1, sp
 801a604:	4803      	ldr	r0, [pc, #12]	; (801a614 <cancom_read_thread+0xb4>)
 801a606:	f7f3 fbf3 	bl	800ddf0 <chEvtUnregister>
}
 801a60a:	b00a      	add	sp, #40	; 0x28
 801a60c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801a610:	0802f260 	.word	0x0802f260
 801a614:	20001d64 	.word	0x20001d64
 801a618:	20001d4c 	.word	0x20001d4c
 801a61c:	2000b784 	.word	0x2000b784
 801a620:	2000b378 	.word	0x2000b378
 801a624:	20001a48 	.word	0x20001a48
 801a628:	2000b788 	.word	0x2000b788
 801a62c:	00000000 	.word	0x00000000

0801a630 <comm_can_init>:
void comm_can_init(void) {
 801a630:	b510      	push	{r4, lr}
 801a632:	4b1f      	ldr	r3, [pc, #124]	; (801a6b0 <comm_can_init+0x80>)
 801a634:	b082      	sub	sp, #8
		stat_msgs[i].id = -1;
 801a636:	f04f 31ff 	mov.w	r1, #4294967295
 801a63a:	f103 02c8 	add.w	r2, r3, #200	; 0xc8
 801a63e:	f843 1b14 	str.w	r1, [r3], #20
	for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 801a642:	4293      	cmp	r3, r2
 801a644:	d1fb      	bne.n	801a63e <comm_can_init+0xe>
	rx_frame_write = 0;
 801a646:	4b1b      	ldr	r3, [pc, #108]	; (801a6b4 <comm_can_init+0x84>)
	rx_frame_read = 0;
 801a648:	4a1b      	ldr	r2, [pc, #108]	; (801a6b8 <comm_can_init+0x88>)
	chMtxObjectInit(&can_mtx);
 801a64a:	481c      	ldr	r0, [pc, #112]	; (801a6bc <comm_can_init+0x8c>)
	rx_frame_read = 0;
 801a64c:	2400      	movs	r4, #0
	rx_frame_write = 0;
 801a64e:	601c      	str	r4, [r3, #0]
	rx_frame_read = 0;
 801a650:	6014      	str	r4, [r2, #0]
	chMtxObjectInit(&can_mtx);
 801a652:	f7f3 fafd 	bl	800dc50 <chMtxObjectInit>
	palSetPadMode(GPIOB, 8,
 801a656:	f240 428a 	movw	r2, #1162	; 0x48a
 801a65a:	f44f 7180 	mov.w	r1, #256	; 0x100
 801a65e:	4818      	ldr	r0, [pc, #96]	; (801a6c0 <comm_can_init+0x90>)
 801a660:	f7f5 fbfe 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 9,
 801a664:	f240 428a 	movw	r2, #1162	; 0x48a
 801a668:	f44f 7100 	mov.w	r1, #512	; 0x200
 801a66c:	4814      	ldr	r0, [pc, #80]	; (801a6c0 <comm_can_init+0x90>)
 801a66e:	f7f5 fbf7 	bl	800fe60 <_pal_lld_setgroupmode>
	canStart(&CANDx, &cancfg);
 801a672:	4914      	ldr	r1, [pc, #80]	; (801a6c4 <comm_can_init+0x94>)
 801a674:	4814      	ldr	r0, [pc, #80]	; (801a6c8 <comm_can_init+0x98>)
 801a676:	f7f3 feeb 	bl	800e450 <canStart>
	chThdCreateStatic(cancom_read_thread_wa, sizeof(cancom_read_thread_wa), NORMALPRIO + 1,
 801a67a:	9400      	str	r4, [sp, #0]
 801a67c:	4b13      	ldr	r3, [pc, #76]	; (801a6cc <comm_can_init+0x9c>)
 801a67e:	4814      	ldr	r0, [pc, #80]	; (801a6d0 <comm_can_init+0xa0>)
 801a680:	2241      	movs	r2, #65	; 0x41
 801a682:	f44f 7166 	mov.w	r1, #920	; 0x398
 801a686:	f7f3 f973 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(cancom_status_thread_wa, sizeof(cancom_status_thread_wa), NORMALPRIO,
 801a68a:	9400      	str	r4, [sp, #0]
 801a68c:	4b11      	ldr	r3, [pc, #68]	; (801a6d4 <comm_can_init+0xa4>)
 801a68e:	4812      	ldr	r0, [pc, #72]	; (801a6d8 <comm_can_init+0xa8>)
 801a690:	2240      	movs	r2, #64	; 0x40
 801a692:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 801a696:	f7f3 f96b 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(cancom_process_thread_wa, sizeof(cancom_process_thread_wa), NORMALPRIO,
 801a69a:	9400      	str	r4, [sp, #0]
 801a69c:	4b0f      	ldr	r3, [pc, #60]	; (801a6dc <comm_can_init+0xac>)
 801a69e:	4810      	ldr	r0, [pc, #64]	; (801a6e0 <comm_can_init+0xb0>)
 801a6a0:	2240      	movs	r2, #64	; 0x40
 801a6a2:	f241 1198 	movw	r1, #4504	; 0x1198
 801a6a6:	f7f3 f963 	bl	800d970 <chThdCreateStatic>
}
 801a6aa:	b002      	add	sp, #8
 801a6ac:	bd10      	pop	{r4, pc}
 801a6ae:	bf00      	nop
 801a6b0:	2000bf5c 	.word	0x2000bf5c
 801a6b4:	2000b784 	.word	0x2000b784
 801a6b8:	2000b780 	.word	0x2000b780
 801a6bc:	200098a0 	.word	0x200098a0
 801a6c0:	40020400 	.word	0x40020400
 801a6c4:	2000103c 	.word	0x2000103c
 801a6c8:	20001d4c 	.word	0x20001d4c
 801a6cc:	0801a561 	.word	0x0801a561
 801a6d0:	2000aa48 	.word	0x2000aa48
 801a6d4:	0801a7b1 	.word	0x0801a7b1
 801a6d8:	2000ade0 	.word	0x2000ade0
 801a6dc:	0801a1b1 	.word	0x0801a1b1
 801a6e0:	200098b0 	.word	0x200098b0
	...

0801a6f0 <comm_can_set_baud>:
void comm_can_set_baud(CAN_BAUD baud) {
 801a6f0:	b510      	push	{r4, lr}
	switch (baud) {
 801a6f2:	2803      	cmp	r0, #3
 801a6f4:	d818      	bhi.n	801a728 <comm_can_set_baud+0x38>
 801a6f6:	e8df f000 	tbb	[pc, r0]
 801a6fa:	1114      	.short	0x1114
 801a6fc:	020e      	.short	0x020e
static void set_timing(int brp, int ts1, int ts2) {
	brp &= 0b1111111111;
	ts1 &= 0b1111;
	ts2 &= 0b111;

	cancfg.btr = CAN_BTR_SJW(3) | CAN_BTR_TS2(ts2) |
 801a6fe:	4c0b      	ldr	r4, [pc, #44]	; (801a72c <comm_can_set_baud+0x3c>)
 801a700:	4b0b      	ldr	r3, [pc, #44]	; (801a730 <comm_can_set_baud+0x40>)
		CAN_BTR_TS1(ts1) | CAN_BTR_BRP(brp);

	canStop(&CANDx);
 801a702:	480c      	ldr	r0, [pc, #48]	; (801a734 <comm_can_set_baud+0x44>)
	cancfg.btr = CAN_BTR_SJW(3) | CAN_BTR_TS2(ts2) |
 801a704:	6063      	str	r3, [r4, #4]
	canStop(&CANDx);
 801a706:	f7f3 feb3 	bl	800e470 <canStop>
	canStart(&CANDx, &cancfg);
 801a70a:	4621      	mov	r1, r4
 801a70c:	4809      	ldr	r0, [pc, #36]	; (801a734 <comm_can_set_baud+0x44>)
}
 801a70e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	canStart(&CANDx, &cancfg);
 801a712:	f7f3 be9d 	b.w	800e450 <canStart>
	cancfg.btr = CAN_BTR_SJW(3) | CAN_BTR_TS2(ts2) |
 801a716:	4c05      	ldr	r4, [pc, #20]	; (801a72c <comm_can_set_baud+0x3c>)
 801a718:	4b07      	ldr	r3, [pc, #28]	; (801a738 <comm_can_set_baud+0x48>)
 801a71a:	e7f2      	b.n	801a702 <comm_can_set_baud+0x12>
 801a71c:	4c03      	ldr	r4, [pc, #12]	; (801a72c <comm_can_set_baud+0x3c>)
 801a71e:	4b07      	ldr	r3, [pc, #28]	; (801a73c <comm_can_set_baud+0x4c>)
 801a720:	e7ef      	b.n	801a702 <comm_can_set_baud+0x12>
 801a722:	4c02      	ldr	r4, [pc, #8]	; (801a72c <comm_can_set_baud+0x3c>)
 801a724:	4b06      	ldr	r3, [pc, #24]	; (801a740 <comm_can_set_baud+0x50>)
 801a726:	e7ec      	b.n	801a702 <comm_can_set_baud+0x12>
}
 801a728:	bd10      	pop	{r4, pc}
 801a72a:	bf00      	nop
 801a72c:	2000103c 	.word	0x2000103c
 801a730:	03290002 	.word	0x03290002
 801a734:	20001d4c 	.word	0x20001d4c
 801a738:	03290005 	.word	0x03290005
 801a73c:	034e0007 	.word	0x034e0007
 801a740:	034e000f 	.word	0x034e000f
	...

0801a750 <comm_can_transmit_eid>:
void comm_can_transmit_eid(uint32_t id, uint8_t *data, uint8_t len) {
 801a750:	b570      	push	{r4, r5, r6, lr}
 801a752:	b084      	sub	sp, #16
 801a754:	2a08      	cmp	r2, #8
	txmsg.IDE = CAN_IDE_EXT;
 801a756:	f89d 3000 	ldrb.w	r3, [sp]
	txmsg.EID = id;
 801a75a:	9e01      	ldr	r6, [sp, #4]
	chMtxLock(&can_mtx);
 801a75c:	4d0f      	ldr	r5, [pc, #60]	; (801a79c <comm_can_transmit_eid+0x4c>)
	txmsg.RTR = CAN_RTR_DATA;
 801a75e:	f043 0320 	orr.w	r3, r3, #32
 801a762:	bf28      	it	cs
 801a764:	2208      	movcs	r2, #8
	txmsg.DLC = len;
 801a766:	ac04      	add	r4, sp, #16
 801a768:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 801a76c:	f362 0303 	bfi	r3, r2, #0, #4
 801a770:	f804 3d10 	strb.w	r3, [r4, #-16]!
	txmsg.EID = id;
 801a774:	f360 061c 	bfi	r6, r0, #0, #29
	memcpy(txmsg.data8, data, len);
 801a778:	a802      	add	r0, sp, #8
	txmsg.EID = id;
 801a77a:	9601      	str	r6, [sp, #4]
	memcpy(txmsg.data8, data, len);
 801a77c:	f7f2 f9d0 	bl	800cb20 <memcpy>
	chMtxLock(&can_mtx);
 801a780:	4628      	mov	r0, r5
 801a782:	f7f3 fad5 	bl	800dd30 <chMtxLock>
	canTransmit(&CANDx, CAN_ANY_MAILBOX, &txmsg, MS2ST(20));
 801a786:	4622      	mov	r2, r4
 801a788:	23c8      	movs	r3, #200	; 0xc8
 801a78a:	2100      	movs	r1, #0
 801a78c:	4804      	ldr	r0, [pc, #16]	; (801a7a0 <comm_can_transmit_eid+0x50>)
 801a78e:	f7f3 fe8f 	bl	800e4b0 <canTransmit>
	chMtxUnlock(&can_mtx);
 801a792:	4628      	mov	r0, r5
 801a794:	f7f3 fadc 	bl	800dd50 <chMtxUnlock>
}
 801a798:	b004      	add	sp, #16
 801a79a:	bd70      	pop	{r4, r5, r6, pc}
 801a79c:	200098a0 	.word	0x200098a0
 801a7a0:	20001d4c 	.word	0x20001d4c
	...

0801a7b0 <cancom_status_thread>:
static THD_FUNCTION(cancom_status_thread, arg) {
 801a7b0:	b510      	push	{r4, lr}
 801a7b2:	4b27      	ldr	r3, [pc, #156]	; (801a850 <cancom_status_thread+0xa0>)
 801a7b4:	4a27      	ldr	r2, [pc, #156]	; (801a854 <cancom_status_thread+0xa4>)
 801a7b6:	699b      	ldr	r3, [r3, #24]
 801a7b8:	ed2d 8b02 	vpush	{d8}
			int32_t send_index = 0;
 801a7bc:	2400      	movs	r4, #0
static THD_FUNCTION(cancom_status_thread, arg) {
 801a7be:	b084      	sub	sp, #16
			buffer_append_int16(buffer, (int16_t)(mc_interface_get_duty_cycle_now() * 1000.0), &send_index);
 801a7c0:	eddf 8a25 	vldr	s17, [pc, #148]	; 801a858 <cancom_status_thread+0xa8>
 801a7c4:	619a      	str	r2, [r3, #24]
			buffer_append_int16(buffer, (int16_t)(mc_interface_get_tot_current() * 10.0), &send_index);
 801a7c6:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
 801a7ca:	e00b      	b.n	801a7e4 <cancom_status_thread+0x34>
		systime_t sleep_time = CH_CFG_ST_FREQUENCY / app_get_configuration()->send_can_status_rate_hz;
 801a7cc:	f005 fee8 	bl	80205a0 <app_get_configuration>
 801a7d0:	f242 7310 	movw	r3, #10000	; 0x2710
 801a7d4:	6900      	ldr	r0, [r0, #16]
 801a7d6:	fbb3 f0f0 	udiv	r0, r3, r0
			sleep_time = 1;
 801a7da:	2800      	cmp	r0, #0
		chThdSleep(sleep_time);
 801a7dc:	bf08      	it	eq
 801a7de:	2001      	moveq	r0, #1
 801a7e0:	f7f3 f8fe 	bl	800d9e0 <chThdSleep>
		if (app_get_configuration()->send_can_status) {
 801a7e4:	f005 fedc 	bl	80205a0 <app_get_configuration>
 801a7e8:	7b03      	ldrb	r3, [r0, #12]
 801a7ea:	2b00      	cmp	r3, #0
 801a7ec:	d0ee      	beq.n	801a7cc <cancom_status_thread+0x1c>
			int32_t send_index = 0;
 801a7ee:	9401      	str	r4, [sp, #4]
			buffer_append_int32(buffer, (int32_t)mc_interface_get_rpm(), &send_index);
 801a7f0:	f000 fe96 	bl	801b520 <mc_interface_get_rpm>
 801a7f4:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 801a7f8:	aa01      	add	r2, sp, #4
 801a7fa:	ee17 1a90 	vmov	r1, s15
 801a7fe:	a802      	add	r0, sp, #8
 801a800:	f7f7 f9be 	bl	8011b80 <buffer_append_int32>
			buffer_append_int16(buffer, (int16_t)(mc_interface_get_tot_current() * 10.0), &send_index);
 801a804:	f000 feec 	bl	801b5e0 <mc_interface_get_tot_current>
 801a808:	ee20 0a08 	vmul.f32	s0, s0, s16
 801a80c:	aa01      	add	r2, sp, #4
 801a80e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 801a812:	a802      	add	r0, sp, #8
 801a814:	ee10 3a10 	vmov	r3, s0
 801a818:	b219      	sxth	r1, r3
 801a81a:	f7f7 f991 	bl	8011b40 <buffer_append_int16>
			buffer_append_int16(buffer, (int16_t)(mc_interface_get_duty_cycle_now() * 1000.0), &send_index);
 801a81e:	f000 fe47 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 801a822:	ee20 0a28 	vmul.f32	s0, s0, s17
 801a826:	aa01      	add	r2, sp, #4
 801a828:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 801a82c:	a802      	add	r0, sp, #8
 801a82e:	ee10 3a10 	vmov	r3, s0
 801a832:	b219      	sxth	r1, r3
 801a834:	f7f7 f984 	bl	8011b40 <buffer_append_int16>
			comm_can_transmit_eid(app_get_configuration()->controller_id |
 801a838:	f005 feb2 	bl	80205a0 <app_get_configuration>
 801a83c:	7800      	ldrb	r0, [r0, #0]
 801a83e:	f89d 2004 	ldrb.w	r2, [sp, #4]
 801a842:	f440 6010 	orr.w	r0, r0, #2304	; 0x900
 801a846:	a902      	add	r1, sp, #8
 801a848:	f7ff ff82 	bl	801a750 <comm_can_transmit_eid>
 801a84c:	e7be      	b.n	801a7cc <cancom_status_thread+0x1c>
 801a84e:	bf00      	nop
 801a850:	20001a48 	.word	0x20001a48
 801a854:	0802f270 	.word	0x0802f270
 801a858:	447a0000 	.word	0x447a0000
 801a85c:	00000000 	.word	0x00000000

0801a860 <comm_can_send_buffer>:
void comm_can_send_buffer(uint8_t controller_id, uint8_t *data, unsigned int len, bool send) {
 801a860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a864:	b087      	sub	sp, #28
	if (len <= 6) {
 801a866:	2a06      	cmp	r2, #6
void comm_can_send_buffer(uint8_t controller_id, uint8_t *data, unsigned int len, bool send) {
 801a868:	4615      	mov	r5, r2
 801a86a:	4682      	mov	sl, r0
 801a86c:	460e      	mov	r6, r1
 801a86e:	9301      	str	r3, [sp, #4]
	if (len <= 6) {
 801a870:	d948      	bls.n	801a904 <comm_can_send_buffer+0xa4>
 801a872:	b2d3      	uxtb	r3, r2
 801a874:	f440 67a0 	orr.w	r7, r0, #1280	; 0x500
 801a878:	9302      	str	r3, [sp, #8]
		unsigned int end_a = 0;
 801a87a:	2100      	movs	r1, #0
			if (i > 255) {
 801a87c:	f240 1803 	movw	r8, #259	; 0x103
 801a880:	e001      	b.n	801a886 <comm_can_send_buffer+0x26>
 801a882:	4544      	cmp	r4, r8
 801a884:	d057      	beq.n	801a936 <comm_can_send_buffer+0xd6>
			end_a = i + 7;
 801a886:	1dcc      	adds	r4, r1, #7
 801a888:	fa5f f984 	uxtb.w	r9, r4
			send_buffer[0] = i;
 801a88c:	f1a9 0307 	sub.w	r3, r9, #7
			if ((i + 7) <= len) {
 801a890:	42a5      	cmp	r5, r4
 801a892:	4431      	add	r1, r6
			send_buffer[0] = i;
 801a894:	f88d 3010 	strb.w	r3, [sp, #16]
			if ((i + 7) <= len) {
 801a898:	f0c0 8081 	bcc.w	801a99e <comm_can_send_buffer+0x13e>
				memcpy(send_buffer + 1, data + i, send_len);
 801a89c:	888a      	ldrh	r2, [r1, #4]
 801a89e:	6808      	ldr	r0, [r1, #0]
 801a8a0:	798b      	ldrb	r3, [r1, #6]
 801a8a2:	f8ad 2015 	strh.w	r2, [sp, #21]
 801a8a6:	f8cd 0011 	str.w	r0, [sp, #17]
 801a8aa:	f88d 3017 	strb.w	r3, [sp, #23]
 801a8ae:	2208      	movs	r2, #8
			comm_can_transmit_eid(controller_id |
 801a8b0:	a904      	add	r1, sp, #16
 801a8b2:	4638      	mov	r0, r7
 801a8b4:	f7ff ff4c 	bl	801a750 <comm_can_transmit_eid>
		for (unsigned int i = 0;i < len;i += 7) {
 801a8b8:	42a5      	cmp	r5, r4
 801a8ba:	4621      	mov	r1, r4
 801a8bc:	d8e1      	bhi.n	801a882 <comm_can_send_buffer+0x22>
		send_buffer[ind++] = app_get_configuration()->controller_id;
 801a8be:	f005 fe6f 	bl	80205a0 <app_get_configuration>
		send_buffer[ind++] = send;
 801a8c2:	f89d 2004 	ldrb.w	r2, [sp, #4]
		send_buffer[ind++] = app_get_configuration()->controller_id;
 801a8c6:	7803      	ldrb	r3, [r0, #0]
 801a8c8:	f88d 3010 	strb.w	r3, [sp, #16]
		unsigned short crc = crc16(data, len);
 801a8cc:	4629      	mov	r1, r5
		send_buffer[ind++] = len >> 8;
 801a8ce:	0a2b      	lsrs	r3, r5, #8
		send_buffer[ind++] = send;
 801a8d0:	f88d 2011 	strb.w	r2, [sp, #17]
		unsigned short crc = crc16(data, len);
 801a8d4:	4630      	mov	r0, r6
		send_buffer[ind++] = len & 0xFF;
 801a8d6:	f89d 2008 	ldrb.w	r2, [sp, #8]
 801a8da:	f88d 2013 	strb.w	r2, [sp, #19]
		send_buffer[ind++] = len >> 8;
 801a8de:	f88d 3012 	strb.w	r3, [sp, #18]
		unsigned short crc = crc16(data, len);
 801a8e2:	f7f7 fb45 	bl	8011f70 <crc16>
		comm_can_transmit_eid(controller_id |
 801a8e6:	a904      	add	r1, sp, #16
		unsigned short crc = crc16(data, len);
 801a8e8:	4603      	mov	r3, r0
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 801a8ea:	0a04      	lsrs	r4, r0, #8
		comm_can_transmit_eid(controller_id |
 801a8ec:	2206      	movs	r2, #6
 801a8ee:	f44a 60e0 	orr.w	r0, sl, #1792	; 0x700
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
 801a8f2:	f88d 3015 	strb.w	r3, [sp, #21]
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 801a8f6:	f88d 4014 	strb.w	r4, [sp, #20]
		comm_can_transmit_eid(controller_id |
 801a8fa:	f7ff ff29 	bl	801a750 <comm_can_transmit_eid>
}
 801a8fe:	b007      	add	sp, #28
 801a900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		send_buffer[ind++] = app_get_configuration()->controller_id;
 801a904:	f005 fe4c 	bl	80205a0 <app_get_configuration>
 801a908:	7803      	ldrb	r3, [r0, #0]
 801a90a:	f88d 3010 	strb.w	r3, [sp, #16]
		memcpy(send_buffer + ind, data, len);
 801a90e:	4631      	mov	r1, r6
		send_buffer[ind++] = send;
 801a910:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801a914:	f88d 3011 	strb.w	r3, [sp, #17]
		memcpy(send_buffer + ind, data, len);
 801a918:	462a      	mov	r2, r5
 801a91a:	f10d 0012 	add.w	r0, sp, #18
 801a91e:	f7f2 f8ff 	bl	800cb20 <memcpy>
		ind += len;
 801a922:	1caa      	adds	r2, r5, #2
		comm_can_transmit_eid(controller_id |
 801a924:	b2d2      	uxtb	r2, r2
 801a926:	f44a 6000 	orr.w	r0, sl, #2048	; 0x800
 801a92a:	a904      	add	r1, sp, #16
 801a92c:	f7ff ff10 	bl	801a750 <comm_can_transmit_eid>
}
 801a930:	b007      	add	sp, #28
 801a932:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				memcpy(send_buffer + 2, data + i, send_len);
 801a936:	9b02      	ldr	r3, [sp, #8]
 801a938:	9603      	str	r6, [sp, #12]
 801a93a:	1d9f      	adds	r7, r3, #6
 801a93c:	3308      	adds	r3, #8
 801a93e:	f44a 69c0 	orr.w	r9, sl, #1536	; 0x600
 801a942:	f1a6 0806 	sub.w	r8, r6, #6
 801a946:	469b      	mov	fp, r3
 801a948:	e00c      	b.n	801a964 <comm_can_send_buffer+0x104>
				memcpy(send_buffer + 2, data + i, send_len);
 801a94a:	680a      	ldr	r2, [r1, #0]
 801a94c:	888b      	ldrh	r3, [r1, #4]
 801a94e:	f8cd 2012 	str.w	r2, [sp, #18]
			comm_can_transmit_eid(controller_id |
 801a952:	a904      	add	r1, sp, #16
				memcpy(send_buffer + 2, data + i, send_len);
 801a954:	2208      	movs	r2, #8
			comm_can_transmit_eid(controller_id |
 801a956:	4648      	mov	r0, r9
				memcpy(send_buffer + 2, data + i, send_len);
 801a958:	f8ad 3016 	strh.w	r3, [sp, #22]
			comm_can_transmit_eid(controller_id |
 801a95c:	f7ff fef8 	bl	801a750 <comm_can_transmit_eid>
		for (unsigned int i = end_a;i < len;i += 6) {
 801a960:	42a5      	cmp	r5, r4
 801a962:	d91a      	bls.n	801a99a <comm_can_send_buffer+0x13a>
			send_buffer[0] = i >> 8;
 801a964:	0a22      	lsrs	r2, r4, #8
			send_buffer[1] = i & 0xFF;
 801a966:	f88d 4011 	strb.w	r4, [sp, #17]
			if ((i + 6) <= len) {
 801a96a:	3406      	adds	r4, #6
 801a96c:	b2e6      	uxtb	r6, r4
 801a96e:	42a5      	cmp	r5, r4
			send_buffer[0] = i >> 8;
 801a970:	f88d 2010 	strb.w	r2, [sp, #16]
 801a974:	eb08 0104 	add.w	r1, r8, r4
				memcpy(send_buffer + 2, data + i, send_len);
 801a978:	eba7 0206 	sub.w	r2, r7, r6
			if ((i + 6) <= len) {
 801a97c:	d2e5      	bcs.n	801a94a <comm_can_send_buffer+0xea>
				memcpy(send_buffer + 2, data + i, send_len);
 801a97e:	b2d2      	uxtb	r2, r2
 801a980:	f10d 0012 	add.w	r0, sp, #18
 801a984:	f7f2 f8cc 	bl	800cb20 <memcpy>
 801a988:	ebab 0206 	sub.w	r2, fp, r6
 801a98c:	b2d2      	uxtb	r2, r2
			comm_can_transmit_eid(controller_id |
 801a98e:	a904      	add	r1, sp, #16
 801a990:	4648      	mov	r0, r9
 801a992:	f7ff fedd 	bl	801a750 <comm_can_transmit_eid>
		for (unsigned int i = end_a;i < len;i += 6) {
 801a996:	42a5      	cmp	r5, r4
 801a998:	d8e4      	bhi.n	801a964 <comm_can_send_buffer+0x104>
 801a99a:	9e03      	ldr	r6, [sp, #12]
 801a99c:	e78f      	b.n	801a8be <comm_can_send_buffer+0x5e>
				memcpy(send_buffer + 1, data + i, send_len);
 801a99e:	9b02      	ldr	r3, [sp, #8]
 801a9a0:	f1c9 0207 	rsb	r2, r9, #7
 801a9a4:	441a      	add	r2, r3
 801a9a6:	b2d2      	uxtb	r2, r2
 801a9a8:	f10d 0011 	add.w	r0, sp, #17
 801a9ac:	f7f2 f8b8 	bl	800cb20 <memcpy>
 801a9b0:	9b02      	ldr	r3, [sp, #8]
 801a9b2:	f1c9 0208 	rsb	r2, r9, #8
 801a9b6:	441a      	add	r2, r3
 801a9b8:	b2d2      	uxtb	r2, r2
 801a9ba:	e779      	b.n	801a8b0 <comm_can_send_buffer+0x50>
 801a9bc:	0000      	movs	r0, r0
	...

0801a9c0 <send_packet_wrapper>:
static void send_packet_wrapper(unsigned char *data, unsigned int len) {
 801a9c0:	b410      	push	{r4}
	comm_can_send_buffer(rx_buffer_last_id, data, len, true);
 801a9c2:	4c04      	ldr	r4, [pc, #16]	; (801a9d4 <send_packet_wrapper+0x14>)
 801a9c4:	460a      	mov	r2, r1
 801a9c6:	2301      	movs	r3, #1
 801a9c8:	4601      	mov	r1, r0
 801a9ca:	7820      	ldrb	r0, [r4, #0]
}
 801a9cc:	f85d 4b04 	ldr.w	r4, [sp], #4
	comm_can_send_buffer(rx_buffer_last_id, data, len, true);
 801a9d0:	f7ff bf46 	b.w	801a860 <comm_can_send_buffer>
 801a9d4:	2000b77c 	.word	0x2000b77c
	...

0801a9e0 <comm_can_set_duty>:
void comm_can_set_duty(uint8_t controller_id, float duty) {
 801a9e0:	b510      	push	{r4, lr}
	buffer_append_int32(buffer, (int32_t)(duty * 100000.0), &send_index);
 801a9e2:	eddf 7a0c 	vldr	s15, [pc, #48]	; 801aa14 <comm_can_set_duty+0x34>
 801a9e6:	ee20 0a27 	vmul.f32	s0, s0, s15
void comm_can_set_duty(uint8_t controller_id, float duty) {
 801a9ea:	b082      	sub	sp, #8
	int32_t send_index = 0;
 801a9ec:	aa02      	add	r2, sp, #8
	buffer_append_int32(buffer, (int32_t)(duty * 100000.0), &send_index);
 801a9ee:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	int32_t send_index = 0;
 801a9f2:	2300      	movs	r3, #0
 801a9f4:	f842 3d08 	str.w	r3, [r2, #-8]!
	buffer_append_int32(buffer, (int32_t)(duty * 100000.0), &send_index);
 801a9f8:	ee17 1a90 	vmov	r1, s15
void comm_can_set_duty(uint8_t controller_id, float duty) {
 801a9fc:	4604      	mov	r4, r0
	buffer_append_int32(buffer, (int32_t)(duty * 100000.0), &send_index);
 801a9fe:	a801      	add	r0, sp, #4
 801aa00:	f7f7 f8be 	bl	8011b80 <buffer_append_int32>
	comm_can_transmit_eid(controller_id |
 801aa04:	a901      	add	r1, sp, #4
 801aa06:	4620      	mov	r0, r4
 801aa08:	f89d 2000 	ldrb.w	r2, [sp]
 801aa0c:	f7ff fea0 	bl	801a750 <comm_can_transmit_eid>
}
 801aa10:	b002      	add	sp, #8
 801aa12:	bd10      	pop	{r4, pc}
 801aa14:	47c35000 	.word	0x47c35000
	...

0801aa20 <comm_can_set_current>:
void comm_can_set_current(uint8_t controller_id, float current) {
 801aa20:	b510      	push	{r4, lr}
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa22:	eddf 7a0d 	vldr	s15, [pc, #52]	; 801aa58 <comm_can_set_current+0x38>
 801aa26:	ee20 0a27 	vmul.f32	s0, s0, s15
void comm_can_set_current(uint8_t controller_id, float current) {
 801aa2a:	b082      	sub	sp, #8
	int32_t send_index = 0;
 801aa2c:	aa02      	add	r2, sp, #8
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa2e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	int32_t send_index = 0;
 801aa32:	2300      	movs	r3, #0
 801aa34:	f842 3d08 	str.w	r3, [r2, #-8]!
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa38:	ee17 1a90 	vmov	r1, s15
void comm_can_set_current(uint8_t controller_id, float current) {
 801aa3c:	4604      	mov	r4, r0
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa3e:	a801      	add	r0, sp, #4
 801aa40:	f7f7 f89e 	bl	8011b80 <buffer_append_int32>
	comm_can_transmit_eid(controller_id |
 801aa44:	a901      	add	r1, sp, #4
 801aa46:	f444 7080 	orr.w	r0, r4, #256	; 0x100
 801aa4a:	f89d 2000 	ldrb.w	r2, [sp]
 801aa4e:	f7ff fe7f 	bl	801a750 <comm_can_transmit_eid>
}
 801aa52:	b002      	add	sp, #8
 801aa54:	bd10      	pop	{r4, pc}
 801aa56:	bf00      	nop
 801aa58:	447a0000 	.word	0x447a0000
 801aa5c:	00000000 	.word	0x00000000

0801aa60 <comm_can_set_current_brake>:
void comm_can_set_current_brake(uint8_t controller_id, float current) {
 801aa60:	b510      	push	{r4, lr}
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa62:	eddf 7a0d 	vldr	s15, [pc, #52]	; 801aa98 <comm_can_set_current_brake+0x38>
 801aa66:	ee20 0a27 	vmul.f32	s0, s0, s15
void comm_can_set_current_brake(uint8_t controller_id, float current) {
 801aa6a:	b082      	sub	sp, #8
	int32_t send_index = 0;
 801aa6c:	aa02      	add	r2, sp, #8
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa6e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	int32_t send_index = 0;
 801aa72:	2300      	movs	r3, #0
 801aa74:	f842 3d08 	str.w	r3, [r2, #-8]!
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa78:	ee17 1a90 	vmov	r1, s15
void comm_can_set_current_brake(uint8_t controller_id, float current) {
 801aa7c:	4604      	mov	r4, r0
	buffer_append_int32(buffer, (int32_t)(current * 1000.0), &send_index);
 801aa7e:	a801      	add	r0, sp, #4
 801aa80:	f7f7 f87e 	bl	8011b80 <buffer_append_int32>
	comm_can_transmit_eid(controller_id |
 801aa84:	a901      	add	r1, sp, #4
 801aa86:	f444 7000 	orr.w	r0, r4, #512	; 0x200
 801aa8a:	f89d 2000 	ldrb.w	r2, [sp]
 801aa8e:	f7ff fe5f 	bl	801a750 <comm_can_transmit_eid>
}
 801aa92:	b002      	add	sp, #8
 801aa94:	bd10      	pop	{r4, pc}
 801aa96:	bf00      	nop
 801aa98:	447a0000 	.word	0x447a0000
 801aa9c:	00000000 	.word	0x00000000

0801aaa0 <comm_can_get_status_msg_index>:
	if (index < CAN_STATUS_MSGS_TO_STORE) {
 801aaa0:	2809      	cmp	r0, #9
		return &stat_msgs[index];
 801aaa2:	bfdd      	ittte	le
 801aaa4:	4b03      	ldrle	r3, [pc, #12]	; (801aab4 <comm_can_get_status_msg_index+0x14>)
 801aaa6:	eb00 0080 	addle.w	r0, r0, r0, lsl #2
 801aaaa:	eb03 0080 	addle.w	r0, r3, r0, lsl #2
		return 0;
 801aaae:	2000      	movgt	r0, #0
}
 801aab0:	4770      	bx	lr
 801aab2:	bf00      	nop
 801aab4:	2000bf5c 	.word	0x2000bf5c
	...

0801aac0 <led_external_set_state>:
	state = LED_EXT_OFF;
	chThdCreateStatic(led_thread_wa, sizeof(led_thread_wa), LOWPRIO, led_thread, NULL);
}

void led_external_set_state(LED_EXT_STATE new_state) {
	state = new_state;
 801aac0:	4b01      	ldr	r3, [pc, #4]	; (801aac8 <led_external_set_state+0x8>)
 801aac2:	7018      	strb	r0, [r3, #0]
}
 801aac4:	4770      	bx	lr
 801aac6:	bf00      	nop
 801aac8:	2000c025 	.word	0x2000c025
 801aacc:	00000000 	.word	0x00000000

0801aad0 <led_external_set_reversed>:

void led_external_set_reversed(bool newstate) {
	reverse_leds = newstate;
 801aad0:	4b01      	ldr	r3, [pc, #4]	; (801aad8 <led_external_set_reversed+0x8>)
 801aad2:	7018      	strb	r0, [r3, #0]
}
 801aad4:	4770      	bx	lr
 801aad6:	bf00      	nop
 801aad8:	2000c024 	.word	0x2000c024
 801aadc:	00000000 	.word	0x00000000

0801aae0 <encoder_deinit>:
static void spi_transfer(uint16_t *in_buf, const uint16_t *out_buf, int length);
static void spi_begin(void);
static void spi_end(void);
static void spi_delay(void);

void encoder_deinit(void) {
 801aae0:	b510      	push	{r4, lr}
	nvicDisableVector(HW_ENC_EXTI_CH);
 801aae2:	2028      	movs	r0, #40	; 0x28
 801aae4:	f7f4 fb44 	bl	800f170 <nvicDisableVector>
	nvicDisableVector(HW_ENC_TIM_ISR_CH);

	TIM_DeInit(HW_ENC_TIM);

	palSetPadMode(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN, PAL_MODE_INPUT_PULLUP);
 801aae8:	4c14      	ldr	r4, [pc, #80]	; (801ab3c <encoder_deinit+0x5c>)
	nvicDisableVector(HW_ENC_TIM_ISR_CH);
 801aaea:	201e      	movs	r0, #30
 801aaec:	f7f4 fb40 	bl	800f170 <nvicDisableVector>
	TIM_DeInit(HW_ENC_TIM);
 801aaf0:	4813      	ldr	r0, [pc, #76]	; (801ab40 <encoder_deinit+0x60>)
 801aaf2:	f009 fbf5 	bl	80242e0 <TIM_DeInit>
	palSetPadMode(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN, PAL_MODE_INPUT_PULLUP);
 801aaf6:	4620      	mov	r0, r4
 801aaf8:	2220      	movs	r2, #32
 801aafa:	2180      	movs	r1, #128	; 0x80
 801aafc:	f7f5 f9b0 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN, PAL_MODE_INPUT_PULLUP);
 801ab00:	4620      	mov	r0, r4
 801ab02:	2220      	movs	r2, #32
 801ab04:	2140      	movs	r1, #64	; 0x40
 801ab06:	f7f5 f9ab 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(SPI_SW_CS_GPIO, SPI_SW_CS_PIN, PAL_MODE_INPUT_PULLUP);
 801ab0a:	2220      	movs	r2, #32
 801ab0c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801ab10:	480c      	ldr	r0, [pc, #48]	; (801ab44 <encoder_deinit+0x64>)
 801ab12:	f7f5 f9a5 	bl	800fe60 <_pal_lld_setgroupmode>

	palSetPadMode(HW_HALL_ENC_GPIO1, HW_HALL_ENC_PIN1, PAL_MODE_INPUT_PULLUP);
 801ab16:	4620      	mov	r0, r4
 801ab18:	2220      	movs	r2, #32
 801ab1a:	2140      	movs	r1, #64	; 0x40
 801ab1c:	f7f5 f9a0 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_HALL_ENC_GPIO2, HW_HALL_ENC_PIN2, PAL_MODE_INPUT_PULLUP);
 801ab20:	4620      	mov	r0, r4
 801ab22:	2220      	movs	r2, #32
 801ab24:	2180      	movs	r1, #128	; 0x80
 801ab26:	f7f5 f99b 	bl	800fe60 <_pal_lld_setgroupmode>

	index_found = false;
 801ab2a:	4c07      	ldr	r4, [pc, #28]	; (801ab48 <encoder_deinit+0x68>)
	mode = ENCODER_MODE_NONE;
 801ab2c:	4807      	ldr	r0, [pc, #28]	; (801ab4c <encoder_deinit+0x6c>)
	last_enc_angle = 0.0;
 801ab2e:	4a08      	ldr	r2, [pc, #32]	; (801ab50 <encoder_deinit+0x70>)
	index_found = false;
 801ab30:	2300      	movs	r3, #0
	last_enc_angle = 0.0;
 801ab32:	2100      	movs	r1, #0
	index_found = false;
 801ab34:	7023      	strb	r3, [r4, #0]
	mode = ENCODER_MODE_NONE;
 801ab36:	7003      	strb	r3, [r0, #0]
	last_enc_angle = 0.0;
 801ab38:	6011      	str	r1, [r2, #0]
}
 801ab3a:	bd10      	pop	{r4, pc}
 801ab3c:	40020400 	.word	0x40020400
 801ab40:	40000800 	.word	0x40000800
 801ab44:	40020800 	.word	0x40020800
 801ab48:	2000c030 	.word	0x2000c030
 801ab4c:	2000c038 	.word	0x2000c038
 801ab50:	2000c034 	.word	0x2000c034
	...

0801ab60 <encoder_init_abi>:

void encoder_init_abi(uint32_t counts) {
 801ab60:	b570      	push	{r4, r5, r6, lr}
	EXTI_InitTypeDef   EXTI_InitStructure;

	// Initialize variables
	index_found = false;
	enc_counts = counts;
 801ab62:	4e28      	ldr	r6, [pc, #160]	; (801ac04 <encoder_init_abi+0xa4>)

	palSetPadMode(HW_HALL_ENC_GPIO1, HW_HALL_ENC_PIN1, PAL_MODE_ALTERNATE(HW_ENC_TIM_AF));
 801ab64:	4c28      	ldr	r4, [pc, #160]	; (801ac08 <encoder_init_abi+0xa8>)
	index_found = false;
 801ab66:	4b29      	ldr	r3, [pc, #164]	; (801ac0c <encoder_init_abi+0xac>)
	enc_counts = counts;
 801ab68:	6030      	str	r0, [r6, #0]
void encoder_init_abi(uint32_t counts) {
 801ab6a:	b082      	sub	sp, #8
	index_found = false;
 801ab6c:	2500      	movs	r5, #0
	palSetPadMode(HW_HALL_ENC_GPIO1, HW_HALL_ENC_PIN1, PAL_MODE_ALTERNATE(HW_ENC_TIM_AF));
 801ab6e:	4620      	mov	r0, r4
 801ab70:	f44f 7281 	mov.w	r2, #258	; 0x102
 801ab74:	2140      	movs	r1, #64	; 0x40
	index_found = false;
 801ab76:	701d      	strb	r5, [r3, #0]
	palSetPadMode(HW_HALL_ENC_GPIO1, HW_HALL_ENC_PIN1, PAL_MODE_ALTERNATE(HW_ENC_TIM_AF));
 801ab78:	f7f5 f972 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_HALL_ENC_GPIO2, HW_HALL_ENC_PIN2, PAL_MODE_ALTERNATE(HW_ENC_TIM_AF));
 801ab7c:	f44f 7281 	mov.w	r2, #258	; 0x102
 801ab80:	4620      	mov	r0, r4
 801ab82:	2180      	movs	r1, #128	; 0x80
 801ab84:	f7f5 f96c 	bl	800fe60 <_pal_lld_setgroupmode>
//	palSetPadMode(HW_HALL_ENC_GPIO3, HW_HALL_ENC_PIN3, PAL_MODE_ALTERNATE(HW_ENC_TIM_AF));

	// Enable timer clock
	HW_ENC_TIM_CLK_EN();
 801ab88:	2101      	movs	r1, #1
 801ab8a:	2004      	movs	r0, #4

	// Enable SYSCFG clock
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	TIM_EncoderInterfaceConfig (HW_ENC_TIM, TIM_EncoderMode_TI12,
 801ab8c:	f5a4 34fe 	sub.w	r4, r4, #130048	; 0x1fc00
	HW_ENC_TIM_CLK_EN();
 801ab90:	f009 fb4e 	bl	8024230 <RCC_APB1PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 801ab94:	2101      	movs	r1, #1
 801ab96:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801ab9a:	f009 fb59 	bl	8024250 <RCC_APB2PeriphClockCmd>
	TIM_EncoderInterfaceConfig (HW_ENC_TIM, TIM_EncoderMode_TI12,
 801ab9e:	462a      	mov	r2, r5
 801aba0:	462b      	mov	r3, r5
 801aba2:	4620      	mov	r0, r4
 801aba4:	2103      	movs	r1, #3
 801aba6:	f009 ff13 	bl	80249d0 <TIM_EncoderInterfaceConfig>
			TIM_ICPolarity_Rising,
			TIM_ICPolarity_Rising);
	TIM_SetAutoreload(HW_ENC_TIM, enc_counts - 1);
 801abaa:	6831      	ldr	r1, [r6, #0]
 801abac:	4620      	mov	r0, r4
 801abae:	3901      	subs	r1, #1
 801abb0:	f009 fcc6 	bl	8024540 <TIM_SetAutoreload>

	// Filter
	HW_ENC_TIM->CCMR1 |= 6 << 12 | 6 << 4;
 801abb4:	69a3      	ldr	r3, [r4, #24]
 801abb6:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
 801abba:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 801abbe:	61a3      	str	r3, [r4, #24]
	HW_ENC_TIM->CCMR2 |= 6 << 4;
 801abc0:	69e3      	ldr	r3, [r4, #28]
 801abc2:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 801abc6:	61e3      	str	r3, [r4, #28]

	TIM_Cmd(HW_ENC_TIM, ENABLE);
 801abc8:	4620      	mov	r0, r4
 801abca:	2101      	movs	r1, #1
 801abcc:	f009 fcd0 	bl	8024570 <TIM_Cmd>

	// Interrupt on index pulse

	// Connect EXTI Line to pin
	SYSCFG_EXTILineConfig(HW_ENC_EXTI_PORTSRC, HW_ENC_EXTI_PINSRC);
 801abd0:	210b      	movs	r1, #11
 801abd2:	2002      	movs	r0, #2
 801abd4:	f009 fb6c 	bl	80242b0 <SYSCFG_EXTILineConfig>

	// Configure EXTI Line
	EXTI_InitStructure.EXTI_Line = HW_ENC_EXTI_LINE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 801abd8:	2401      	movs	r4, #1
	EXTI_InitStructure.EXTI_Line = HW_ENC_EXTI_LINE;
 801abda:	f44f 6200 	mov.w	r2, #2048	; 0x800
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 801abde:	2308      	movs	r3, #8
	EXTI_Init(&EXTI_InitStructure);
 801abe0:	4668      	mov	r0, sp
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 801abe2:	f88d 3005 	strb.w	r3, [sp, #5]
	EXTI_InitStructure.EXTI_Line = HW_ENC_EXTI_LINE;
 801abe6:	9200      	str	r2, [sp, #0]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 801abe8:	f88d 5004 	strb.w	r5, [sp, #4]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 801abec:	f88d 4006 	strb.w	r4, [sp, #6]
	EXTI_Init(&EXTI_InitStructure);
 801abf0:	f009 f9e6 	bl	8023fc0 <EXTI_Init>

	// Enable and set EXTI Line Interrupt to the highest priority
	nvicEnableVector(HW_ENC_EXTI_CH, 0);
 801abf4:	4629      	mov	r1, r5
 801abf6:	2028      	movs	r0, #40	; 0x28
 801abf8:	f7f4 fa9a 	bl	800f130 <nvicEnableVector>

	mode = ENCODER_MODE_ABI;
 801abfc:	4b04      	ldr	r3, [pc, #16]	; (801ac10 <encoder_init_abi+0xb0>)
 801abfe:	701c      	strb	r4, [r3, #0]
}
 801ac00:	b002      	add	sp, #8
 801ac02:	bd70      	pop	{r4, r5, r6, pc}
 801ac04:	20001044 	.word	0x20001044
 801ac08:	40020400 	.word	0x40020400
 801ac0c:	2000c030 	.word	0x2000c030
 801ac10:	2000c038 	.word	0x2000c038
	...

0801ac20 <encoder_init_as5047p_spi>:

void encoder_init_as5047p_spi(void) {
 801ac20:	b530      	push	{r4, r5, lr}
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	palSetPadMode(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN, PAL_MODE_INPUT);
 801ac22:	4d1c      	ldr	r5, [pc, #112]	; (801ac94 <encoder_init_as5047p_spi+0x74>)
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period = ((168000000 / 2 / AS5047_SAMPLE_RATE_HZ) - 1);
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(HW_ENC_TIM, &TIM_TimeBaseStructure);
 801ac24:	4c1c      	ldr	r4, [pc, #112]	; (801ac98 <encoder_init_as5047p_spi+0x78>)
void encoder_init_as5047p_spi(void) {
 801ac26:	b085      	sub	sp, #20
	palSetPadMode(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN, PAL_MODE_INPUT);
 801ac28:	4628      	mov	r0, r5
 801ac2a:	2200      	movs	r2, #0
 801ac2c:	2180      	movs	r1, #128	; 0x80
 801ac2e:	f7f5 f917 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 801ac32:	4628      	mov	r0, r5
 801ac34:	2219      	movs	r2, #25
 801ac36:	2140      	movs	r1, #64	; 0x40
 801ac38:	f7f5 f912 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(SPI_SW_CS_GPIO, SPI_SW_CS_PIN, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 801ac3c:	2219      	movs	r2, #25
 801ac3e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801ac42:	4816      	ldr	r0, [pc, #88]	; (801ac9c <encoder_init_as5047p_spi+0x7c>)
 801ac44:	f7f5 f90c 	bl	800fe60 <_pal_lld_setgroupmode>
	HW_ENC_TIM_CLK_EN();
 801ac48:	2101      	movs	r1, #1
 801ac4a:	2004      	movs	r0, #4
 801ac4c:	f009 faf0 	bl	8024230 <RCC_APB1PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 801ac50:	2300      	movs	r3, #0
	TIM_TimeBaseInit(HW_ENC_TIM, &TIM_TimeBaseStructure);
 801ac52:	4620      	mov	r0, r4
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801ac54:	f241 0267 	movw	r2, #4199	; 0x1067
	TIM_TimeBaseInit(HW_ENC_TIM, &TIM_TimeBaseStructure);
 801ac58:	a901      	add	r1, sp, #4
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 801ac5a:	9301      	str	r3, [sp, #4]
	TIM_TimeBaseStructure.TIM_Period = ((168000000 / 2 / AS5047_SAMPLE_RATE_HZ) - 1);
 801ac5c:	f8ad 300c 	strh.w	r3, [sp, #12]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 801ac60:	f88d 300e 	strb.w	r3, [sp, #14]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801ac64:	9202      	str	r2, [sp, #8]
	TIM_TimeBaseInit(HW_ENC_TIM, &TIM_TimeBaseStructure);
 801ac66:	f009 fc1b 	bl	80244a0 <TIM_TimeBaseInit>

	// Enable overflow interrupt
	TIM_ITConfig(HW_ENC_TIM, TIM_IT_Update, ENABLE);
 801ac6a:	2201      	movs	r2, #1
 801ac6c:	4611      	mov	r1, r2
 801ac6e:	4620      	mov	r0, r4
 801ac70:	f009 fe6e 	bl	8024950 <TIM_ITConfig>

	// Enable timer
	TIM_Cmd(HW_ENC_TIM, ENABLE);
 801ac74:	4620      	mov	r0, r4
 801ac76:	2101      	movs	r1, #1
 801ac78:	f009 fc7a 	bl	8024570 <TIM_Cmd>

	nvicEnableVector(HW_ENC_TIM_ISR_CH, 6);
 801ac7c:	2106      	movs	r1, #6
 801ac7e:	201e      	movs	r0, #30
 801ac80:	f7f4 fa56 	bl	800f130 <nvicEnableVector>

	mode = ENCODER_MODE_AS5047P_SPI;
 801ac84:	4906      	ldr	r1, [pc, #24]	; (801aca0 <encoder_init_as5047p_spi+0x80>)
	index_found = true;
 801ac86:	4b07      	ldr	r3, [pc, #28]	; (801aca4 <encoder_init_as5047p_spi+0x84>)
	mode = ENCODER_MODE_AS5047P_SPI;
 801ac88:	2002      	movs	r0, #2
	index_found = true;
 801ac8a:	2201      	movs	r2, #1
	mode = ENCODER_MODE_AS5047P_SPI;
 801ac8c:	7008      	strb	r0, [r1, #0]
	index_found = true;
 801ac8e:	701a      	strb	r2, [r3, #0]
}
 801ac90:	b005      	add	sp, #20
 801ac92:	bd30      	pop	{r4, r5, pc}
 801ac94:	40020400 	.word	0x40020400
 801ac98:	40000800 	.word	0x40000800
 801ac9c:	40020800 	.word	0x40020800
 801aca0:	2000c038 	.word	0x2000c038
 801aca4:	2000c030 	.word	0x2000c030
	...

0801acb0 <encoder_is_configured>:

bool encoder_is_configured(void) {
	return mode != ENCODER_MODE_NONE;
 801acb0:	4b02      	ldr	r3, [pc, #8]	; (801acbc <encoder_is_configured+0xc>)
 801acb2:	7818      	ldrb	r0, [r3, #0]
}
 801acb4:	3000      	adds	r0, #0
 801acb6:	bf18      	it	ne
 801acb8:	2001      	movne	r0, #1
 801acba:	4770      	bx	lr
 801acbc:	2000c038 	.word	0x2000c038

0801acc0 <encoder_read_deg>:

float encoder_read_deg(void) {
	static float angle = 0.0;

	switch (mode) {
 801acc0:	4b12      	ldr	r3, [pc, #72]	; (801ad0c <encoder_read_deg+0x4c>)
 801acc2:	781b      	ldrb	r3, [r3, #0]
 801acc4:	2b01      	cmp	r3, #1
 801acc6:	d00c      	beq.n	801ace2 <encoder_read_deg+0x22>
 801acc8:	2b02      	cmp	r3, #2
 801acca:	d106      	bne.n	801acda <encoder_read_deg+0x1a>
	case ENCODER_MODE_ABI:
		angle = ((float)HW_ENC_TIM->CNT * 360.0) / (float)enc_counts;
		break;

	case ENCODER_MODE_AS5047P_SPI:
		angle = last_enc_angle;
 801accc:	4a10      	ldr	r2, [pc, #64]	; (801ad10 <encoder_read_deg+0x50>)
 801acce:	4b11      	ldr	r3, [pc, #68]	; (801ad14 <encoder_read_deg+0x54>)
 801acd0:	ed92 0a00 	vldr	s0, [r2]
 801acd4:	ed83 0a00 	vstr	s0, [r3]
	default:
		break;
	}

	return angle;
}
 801acd8:	4770      	bx	lr
 801acda:	4b0e      	ldr	r3, [pc, #56]	; (801ad14 <encoder_read_deg+0x54>)
 801acdc:	ed93 0a00 	vldr	s0, [r3]
 801ace0:	4770      	bx	lr
		angle = ((float)HW_ENC_TIM->CNT * 360.0) / (float)enc_counts;
 801ace2:	4a0d      	ldr	r2, [pc, #52]	; (801ad18 <encoder_read_deg+0x58>)
 801ace4:	4b0d      	ldr	r3, [pc, #52]	; (801ad1c <encoder_read_deg+0x5c>)
 801ace6:	edd2 7a09 	vldr	s15, [r2, #36]	; 0x24
 801acea:	ed93 7a00 	vldr	s14, [r3]
 801acee:	eddf 6a0c 	vldr	s13, [pc, #48]	; 801ad20 <encoder_read_deg+0x60>
 801acf2:	4b08      	ldr	r3, [pc, #32]	; (801ad14 <encoder_read_deg+0x54>)
 801acf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801acf8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801acfc:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801ad00:	ee87 0a87 	vdiv.f32	s0, s15, s14
 801ad04:	ed83 0a00 	vstr	s0, [r3]
		break;
 801ad08:	4770      	bx	lr
 801ad0a:	bf00      	nop
 801ad0c:	2000c038 	.word	0x2000c038
 801ad10:	2000c034 	.word	0x2000c034
 801ad14:	2000c028 	.word	0x2000c028
 801ad18:	40000800 	.word	0x40000800
 801ad1c:	20001044 	.word	0x20001044
 801ad20:	43b40000 	.word	0x43b40000
	...

0801ad30 <encoder_reset>:

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 801ad30:	bf00      	nop
 801ad32:	bf00      	nop
 801ad34:	bf00      	nop
 801ad36:	bf00      	nop
	// most likely are noise.
	__NOP();
	__NOP();
	__NOP();
	__NOP();
	if (palReadPad(HW_HALL_ENC_GPIO3, HW_HALL_ENC_PIN3)) {
 801ad38:	4b14      	ldr	r3, [pc, #80]	; (801ad8c <encoder_reset+0x5c>)
 801ad3a:	691b      	ldr	r3, [r3, #16]
 801ad3c:	051b      	lsls	r3, r3, #20
 801ad3e:	d51d      	bpl.n	801ad7c <encoder_reset+0x4c>
		const unsigned int cnt = HW_ENC_TIM->CNT;
		static int bad_pulses = 0;
		const unsigned int lim = enc_counts / 20;

		if (index_found) {
 801ad40:	4a13      	ldr	r2, [pc, #76]	; (801ad90 <encoder_reset+0x60>)
		const unsigned int cnt = HW_ENC_TIM->CNT;
 801ad42:	4914      	ldr	r1, [pc, #80]	; (801ad94 <encoder_reset+0x64>)
		if (index_found) {
 801ad44:	7813      	ldrb	r3, [r2, #0]
		const unsigned int cnt = HW_ENC_TIM->CNT;
 801ad46:	6a48      	ldr	r0, [r1, #36]	; 0x24
		if (index_found) {
 801ad48:	b19b      	cbz	r3, 801ad72 <encoder_reset+0x42>
		const unsigned int lim = enc_counts / 20;
 801ad4a:	4913      	ldr	r1, [pc, #76]	; (801ad98 <encoder_reset+0x68>)
 801ad4c:	4b13      	ldr	r3, [pc, #76]	; (801ad9c <encoder_reset+0x6c>)
 801ad4e:	6809      	ldr	r1, [r1, #0]
 801ad50:	fba3 c301 	umull	ip, r3, r3, r1
 801ad54:	091b      	lsrs	r3, r3, #4
			// Some plausibility filtering.
			if (cnt > (enc_counts - lim) || cnt < lim) {
 801ad56:	1ac9      	subs	r1, r1, r3
 801ad58:	4281      	cmp	r1, r0
 801ad5a:	d310      	bcc.n	801ad7e <encoder_reset+0x4e>
 801ad5c:	4298      	cmp	r0, r3
 801ad5e:	d30e      	bcc.n	801ad7e <encoder_reset+0x4e>
				HW_ENC_TIM->CNT = 0;
				bad_pulses = 0;
			} else {
				bad_pulses++;
 801ad60:	490f      	ldr	r1, [pc, #60]	; (801ada0 <encoder_reset+0x70>)
 801ad62:	680b      	ldr	r3, [r1, #0]
 801ad64:	3301      	adds	r3, #1

				if (bad_pulses > 5) {
 801ad66:	2b05      	cmp	r3, #5
				bad_pulses++;
 801ad68:	600b      	str	r3, [r1, #0]
				if (bad_pulses > 5) {
 801ad6a:	dd07      	ble.n	801ad7c <encoder_reset+0x4c>
					index_found = 0;
 801ad6c:	2300      	movs	r3, #0
 801ad6e:	7013      	strb	r3, [r2, #0]
 801ad70:	4770      	bx	lr
				}
			}
		} else {
			HW_ENC_TIM->CNT = 0;
			index_found = true;
			bad_pulses = 0;
 801ad72:	480b      	ldr	r0, [pc, #44]	; (801ada0 <encoder_reset+0x70>)
			HW_ENC_TIM->CNT = 0;
 801ad74:	624b      	str	r3, [r1, #36]	; 0x24
			index_found = true;
 801ad76:	2101      	movs	r1, #1
			bad_pulses = 0;
 801ad78:	6003      	str	r3, [r0, #0]
			index_found = true;
 801ad7a:	7011      	strb	r1, [r2, #0]
		}
	}
}
 801ad7c:	4770      	bx	lr
				HW_ENC_TIM->CNT = 0;
 801ad7e:	4905      	ldr	r1, [pc, #20]	; (801ad94 <encoder_reset+0x64>)
				bad_pulses = 0;
 801ad80:	4a07      	ldr	r2, [pc, #28]	; (801ada0 <encoder_reset+0x70>)
				HW_ENC_TIM->CNT = 0;
 801ad82:	2300      	movs	r3, #0
 801ad84:	624b      	str	r3, [r1, #36]	; 0x24
				bad_pulses = 0;
 801ad86:	6013      	str	r3, [r2, #0]
 801ad88:	4770      	bx	lr
 801ad8a:	bf00      	nop
 801ad8c:	40020800 	.word	0x40020800
 801ad90:	2000c030 	.word	0x2000c030
 801ad94:	40000800 	.word	0x40000800
 801ad98:	20001044 	.word	0x20001044
 801ad9c:	cccccccd 	.word	0xcccccccd
 801ada0:	2000c02c 	.word	0x2000c02c
	...

0801adb0 <encoder_tim_isr>:
		}
	}
}

static void spi_begin(void) {
	palClearPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801adb0:	4b22      	ldr	r3, [pc, #136]	; (801ae3c <encoder_tim_isr+0x8c>)
void encoder_tim_isr(void) {
 801adb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	palClearPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801adb6:	f44f 6200 	mov.w	r2, #2048	; 0x800
			palSetPad(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN);
 801adba:	2740      	movs	r7, #64	; 0x40
 801adbc:	4d20      	ldr	r5, [pc, #128]	; (801ae40 <encoder_tim_isr+0x90>)
	palClearPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801adbe:	835a      	strh	r2, [r3, #26]
			palSetPad(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN);
 801adc0:	46b8      	mov	r8, r7
	palClearPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801adc2:	2610      	movs	r6, #16
 801adc4:	2400      	movs	r4, #0
 801adc6:	bf00      	nop
 801adc8:	bf00      	nop
 801adca:	bf00      	nop
 801adcc:	bf00      	nop
			palSetPad(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN);
 801adce:	f8a5 8018 	strh.w	r8, [r5, #24]
 801add2:	bf00      	nop
 801add4:	bf00      	nop
 801add6:	bf00      	nop
 801add8:	bf00      	nop
			r1 = palReadPad(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN);
 801adda:	6928      	ldr	r0, [r5, #16]
 801addc:	bf00      	nop
			r2 = palReadPad(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN);
 801adde:	6929      	ldr	r1, [r5, #16]
 801ade0:	bf00      	nop
			r3 = palReadPad(SPI_SW_MISO_GPIO, SPI_SW_MISO_PIN);
 801ade2:	692a      	ldr	r2, [r5, #16]
			recieve <<= 1;
 801ade4:	0064      	lsls	r4, r4, #1
			if (utils_middle_of_3_int(r1, r2, r3)) {
 801ade6:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 801adea:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 801adee:	f3c2 12c0 	ubfx	r2, r2, #7, #1
			recieve <<= 1;
 801adf2:	b2a4      	uxth	r4, r4
			if (utils_middle_of_3_int(r1, r2, r3)) {
 801adf4:	f7fa ff54 	bl	8015ca0 <utils_middle_of_3_int>
 801adf8:	b108      	cbz	r0, 801adfe <encoder_tim_isr+0x4e>
				recieve |= 1;
 801adfa:	f044 0401 	orr.w	r4, r4, #1
			palClearPad(SPI_SW_SCK_GPIO, SPI_SW_SCK_PIN);
 801adfe:	836f      	strh	r7, [r5, #26]
 801ae00:	bf00      	nop
 801ae02:	bf00      	nop
 801ae04:	bf00      	nop
 801ae06:	bf00      	nop
		for (int bit = 0;bit < 16;bit++) {
 801ae08:	3e01      	subs	r6, #1
 801ae0a:	d1dc      	bne.n	801adc6 <encoder_tim_isr+0x16>
	last_enc_angle = ((float)pos * 360.0) / 16384.0;
 801ae0c:	f3c4 030d 	ubfx	r3, r4, #0, #14
 801ae10:	ee07 3a90 	vmov	s15, r3
 801ae14:	eddf 6a0b 	vldr	s13, [pc, #44]	; 801ae44 <encoder_tim_isr+0x94>
 801ae18:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 801ae48 <encoder_tim_isr+0x98>
}

static void spi_end(void) {
	palSetPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801ae1c:	4a07      	ldr	r2, [pc, #28]	; (801ae3c <encoder_tim_isr+0x8c>)
	last_enc_angle = ((float)pos * 360.0) / 16384.0;
 801ae1e:	4b0b      	ldr	r3, [pc, #44]	; (801ae4c <encoder_tim_isr+0x9c>)
 801ae20:	eef8 7a67 	vcvt.f32.u32	s15, s15
	palSetPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801ae24:	f44f 6100 	mov.w	r1, #2048	; 0x800
	last_enc_angle = ((float)pos * 360.0) / 16384.0;
 801ae28:	ee67 7aa6 	vmul.f32	s15, s15, s13
	palSetPad(SPI_SW_CS_GPIO, SPI_SW_CS_PIN);
 801ae2c:	8311      	strh	r1, [r2, #24]
	last_enc_angle = ((float)pos * 360.0) / 16384.0;
 801ae2e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ae32:	edc3 7a00 	vstr	s15, [r3]
}
 801ae36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801ae3a:	bf00      	nop
 801ae3c:	40020800 	.word	0x40020800
 801ae40:	40020400 	.word	0x40020400
 801ae44:	43b40000 	.word	0x43b40000
 801ae48:	38800000 	.word	0x38800000
 801ae4c:	2000c034 	.word	0x2000c034

0801ae50 <encoder_set_counts>:
	if (counts != enc_counts) {
 801ae50:	4a07      	ldr	r2, [pc, #28]	; (801ae70 <encoder_set_counts+0x20>)
void encoder_set_counts(uint32_t counts) {
 801ae52:	b508      	push	{r3, lr}
	if (counts != enc_counts) {
 801ae54:	6813      	ldr	r3, [r2, #0]
 801ae56:	4283      	cmp	r3, r0
 801ae58:	d008      	beq.n	801ae6c <encoder_set_counts+0x1c>
 801ae5a:	4603      	mov	r3, r0
		TIM_SetAutoreload(HW_ENC_TIM, enc_counts - 1);
 801ae5c:	1e41      	subs	r1, r0, #1
 801ae5e:	4805      	ldr	r0, [pc, #20]	; (801ae74 <encoder_set_counts+0x24>)
		enc_counts = counts;
 801ae60:	6013      	str	r3, [r2, #0]
		TIM_SetAutoreload(HW_ENC_TIM, enc_counts - 1);
 801ae62:	f009 fb6d 	bl	8024540 <TIM_SetAutoreload>
		index_found = false;
 801ae66:	4b04      	ldr	r3, [pc, #16]	; (801ae78 <encoder_set_counts+0x28>)
 801ae68:	2200      	movs	r2, #0
 801ae6a:	701a      	strb	r2, [r3, #0]
}
 801ae6c:	bd08      	pop	{r3, pc}
 801ae6e:	bf00      	nop
 801ae70:	20001044 	.word	0x20001044
 801ae74:	40000800 	.word	0x40000800
 801ae78:	2000c030 	.word	0x2000c030
 801ae7c:	00000000 	.word	0x00000000

0801ae80 <encoder_index_found>:
	return index_found;
 801ae80:	4b01      	ldr	r3, [pc, #4]	; (801ae88 <encoder_index_found+0x8>)
}
 801ae82:	7818      	ldrb	r0, [r3, #0]
 801ae84:	4770      	bx	lr
 801ae86:	bf00      	nop
 801ae88:	2000c030 	.word	0x2000c030
 801ae8c:	00000000 	.word	0x00000000

0801ae90 <flash_helper_erase_new_app>:
		FLASH_Sector_9,
		FLASH_Sector_10,
		FLASH_Sector_11
};

uint16_t flash_helper_erase_new_app(uint32_t new_app_size) {
 801ae90:	b510      	push	{r4, lr}
 801ae92:	4604      	mov	r4, r0
	FLASH_Unlock();
 801ae94:	f009 f8ec 	bl	8024070 <FLASH_Unlock>
	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 801ae98:	20f2      	movs	r0, #242	; 0xf2
 801ae9a:	f009 f8f9 	bl	8024090 <FLASH_ClearFlag>
			FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);

	new_app_size += flash_addr[NEW_APP_BASE];

	mc_interface_unlock();
 801ae9e:	f000 facf 	bl	801b440 <mc_interface_unlock>
	mc_interface_release_motor();
 801aea2:	f001 fa65 	bl	801c370 <mc_interface_release_motor>
	utils_sys_lock_cnt();
 801aea6:	f7fb f8fb 	bl	80160a0 <utils_sys_lock_cnt>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, DISABLE);
 801aeaa:	2100      	movs	r1, #0
 801aeac:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801aeb0:	f009 f9be 	bl	8024230 <RCC_APB1PeriphClockCmd>
	new_app_size += flash_addr[NEW_APP_BASE];
 801aeb4:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000

	for (int i = 0;i < NEW_APP_SECTORS;i++) {
		if (new_app_size > flash_addr[NEW_APP_BASE + i]) {
 801aeb8:	4b14      	ldr	r3, [pc, #80]	; (801af0c <flash_helper_erase_new_app+0x7c>)
	new_app_size += flash_addr[NEW_APP_BASE];
 801aeba:	f504 2400 	add.w	r4, r4, #524288	; 0x80000
		if (new_app_size > flash_addr[NEW_APP_BASE + i]) {
 801aebe:	429c      	cmp	r4, r3
 801aec0:	d91a      	bls.n	801aef8 <flash_helper_erase_new_app+0x68>
			uint16_t res = FLASH_EraseSector(flash_sector[NEW_APP_BASE + i], VoltageRange_3);
 801aec2:	2102      	movs	r1, #2
 801aec4:	2040      	movs	r0, #64	; 0x40
 801aec6:	f009 f923 	bl	8024110 <FLASH_EraseSector>
 801aeca:	b280      	uxth	r0, r0
			if (res != FLASH_COMPLETE) {
 801aecc:	2809      	cmp	r0, #9
 801aece:	d11b      	bne.n	801af08 <flash_helper_erase_new_app+0x78>
		if (new_app_size > flash_addr[NEW_APP_BASE + i]) {
 801aed0:	4b0f      	ldr	r3, [pc, #60]	; (801af10 <flash_helper_erase_new_app+0x80>)
 801aed2:	429c      	cmp	r4, r3
 801aed4:	d910      	bls.n	801aef8 <flash_helper_erase_new_app+0x68>
			uint16_t res = FLASH_EraseSector(flash_sector[NEW_APP_BASE + i], VoltageRange_3);
 801aed6:	2102      	movs	r1, #2
 801aed8:	2048      	movs	r0, #72	; 0x48
 801aeda:	f009 f919 	bl	8024110 <FLASH_EraseSector>
 801aede:	b280      	uxth	r0, r0
			if (res != FLASH_COMPLETE) {
 801aee0:	2809      	cmp	r0, #9
 801aee2:	d111      	bne.n	801af08 <flash_helper_erase_new_app+0x78>
		if (new_app_size > flash_addr[NEW_APP_BASE + i]) {
 801aee4:	4b0b      	ldr	r3, [pc, #44]	; (801af14 <flash_helper_erase_new_app+0x84>)
 801aee6:	429c      	cmp	r4, r3
 801aee8:	d906      	bls.n	801aef8 <flash_helper_erase_new_app+0x68>
			uint16_t res = FLASH_EraseSector(flash_sector[NEW_APP_BASE + i], VoltageRange_3);
 801aeea:	2102      	movs	r1, #2
 801aeec:	2050      	movs	r0, #80	; 0x50
 801aeee:	f009 f90f 	bl	8024110 <FLASH_EraseSector>
 801aef2:	b280      	uxth	r0, r0
			if (res != FLASH_COMPLETE) {
 801aef4:	2809      	cmp	r0, #9
 801aef6:	d107      	bne.n	801af08 <flash_helper_erase_new_app+0x78>
		} else {
			break;
		}
	}

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 801aef8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801aefc:	2101      	movs	r1, #1
 801aefe:	f009 f997 	bl	8024230 <RCC_APB1PeriphClockCmd>
	utils_sys_unlock_cnt();
 801af02:	f7fb f8dd 	bl	80160c0 <utils_sys_unlock_cnt>

	return FLASH_COMPLETE;
 801af06:	2009      	movs	r0, #9
}
 801af08:	bd10      	pop	{r4, pc}
 801af0a:	bf00      	nop
 801af0c:	08080000 	.word	0x08080000
 801af10:	080a0000 	.word	0x080a0000
 801af14:	080c0000 	.word	0x080c0000
	...

0801af20 <flash_helper_write_new_app_data>:

uint16_t flash_helper_write_new_app_data(uint32_t offset, uint8_t *data, uint32_t len) {
 801af20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801af22:	4605      	mov	r5, r0
	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 801af24:	20f2      	movs	r0, #242	; 0xf2
uint16_t flash_helper_write_new_app_data(uint32_t offset, uint8_t *data, uint32_t len) {
 801af26:	460f      	mov	r7, r1
 801af28:	4616      	mov	r6, r2
	FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR |
 801af2a:	f009 f8b1 	bl	8024090 <FLASH_ClearFlag>
			FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);

	mc_interface_unlock();
 801af2e:	f000 fa87 	bl	801b440 <mc_interface_unlock>
	mc_interface_release_motor();
 801af32:	f001 fa1d 	bl	801c370 <mc_interface_release_motor>
	utils_sys_lock_cnt();
 801af36:	f7fb f8b3 	bl	80160a0 <utils_sys_lock_cnt>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, DISABLE);
 801af3a:	2100      	movs	r1, #0
 801af3c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801af40:	f009 f976 	bl	8024230 <RCC_APB1PeriphClockCmd>

	for (uint32_t i = 0;i < len;i++) {
 801af44:	b196      	cbz	r6, 801af6c <flash_helper_write_new_app_data+0x4c>
 801af46:	f1a5 35f7 	sub.w	r5, r5, #4160223223	; 0xf7f7f7f7
 801af4a:	f6a5 0508 	subw	r5, r5, #2056	; 0x808
 801af4e:	1e7c      	subs	r4, r7, #1
 801af50:	1bed      	subs	r5, r5, r7
 801af52:	4426      	add	r6, r4
 801af54:	e001      	b.n	801af5a <flash_helper_write_new_app_data+0x3a>
 801af56:	42b4      	cmp	r4, r6
 801af58:	d008      	beq.n	801af6c <flash_helper_write_new_app_data+0x4c>
 801af5a:	1928      	adds	r0, r5, r4
		uint16_t res = FLASH_ProgramByte(flash_addr[NEW_APP_BASE] + offset + i, data[i]);
 801af5c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 801af60:	f009 f936 	bl	80241d0 <FLASH_ProgramByte>
 801af64:	b280      	uxth	r0, r0
		if (res != FLASH_COMPLETE) {
 801af66:	2809      	cmp	r0, #9
 801af68:	d0f5      	beq.n	801af56 <flash_helper_write_new_app_data+0x36>

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
	utils_sys_unlock_cnt();

	return FLASH_COMPLETE;
}
 801af6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 801af6c:	2101      	movs	r1, #1
 801af6e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801af72:	f009 f95d 	bl	8024230 <RCC_APB1PeriphClockCmd>
	utils_sys_unlock_cnt();
 801af76:	f7fb f8a3 	bl	80160c0 <utils_sys_unlock_cnt>
	return FLASH_COMPLETE;
 801af7a:	2009      	movs	r0, #9
}
 801af7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801af7e:	bf00      	nop

0801af80 <flash_helper_jump_to_bootloader>:

/**
 * Stop the system and jump to the bootloader.
 */
void flash_helper_jump_to_bootloader(void) {
 801af80:	b580      	push	{r7, lr}
 801af82:	af00      	add	r7, sp, #0
	typedef void (*pFunction)(void);

	mc_interface_unlock();
 801af84:	f000 fa5c 	bl	801b440 <mc_interface_unlock>
	mc_interface_release_motor();
 801af88:	f001 f9f2 	bl	801c370 <mc_interface_release_motor>
	usbDisconnectBus(&USBD1);
 801af8c:	481a      	ldr	r0, [pc, #104]	; (801aff8 <flash_helper_jump_to_bootloader+0x78>)
 801af8e:	6d02      	ldr	r2, [r0, #80]	; 0x50
 801af90:	6b93      	ldr	r3, [r2, #56]	; 0x38
 801af92:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 801af96:	6393      	str	r3, [r2, #56]	; 0x38
	usbStop(&USBD1);
 801af98:	f7f3 fdda 	bl	800eb50 <usbStop>

	uartStop(&HW_UART_DEV);
 801af9c:	4817      	ldr	r0, [pc, #92]	; (801affc <flash_helper_jump_to_bootloader+0x7c>)
 801af9e:	f7f3 fd87 	bl	800eab0 <uartStop>
	palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT);
 801afa2:	2200      	movs	r2, #0
 801afa4:	2140      	movs	r1, #64	; 0x40
 801afa6:	4816      	ldr	r0, [pc, #88]	; (801b000 <flash_helper_jump_to_bootloader+0x80>)
 801afa8:	f7f4 ff5a 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_INPUT);
 801afac:	2200      	movs	r2, #0
 801afae:	2180      	movs	r1, #128	; 0x80
 801afb0:	4813      	ldr	r0, [pc, #76]	; (801b000 <flash_helper_jump_to_bootloader+0x80>)
 801afb2:	f7f4 ff55 	bl	800fe60 <_pal_lld_setgroupmode>

	// Disable watchdog
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, DISABLE);
 801afb6:	2100      	movs	r1, #0
 801afb8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801afbc:	f009 f938 	bl	8024230 <RCC_APB1PeriphClockCmd>
  __ASM volatile ("cpsid i" : : : "memory");
 801afc0:	b672      	cpsid	i
	// Variable that will be loaded with the start address of the application
	volatile uint32_t* jump_address;
	const volatile uint32_t* bootloader_address = (volatile uint32_t*)0x080E0000;

	// Get jump address from application vector table
	jump_address = (volatile uint32_t*) bootloader_address[1];
 801afc2:	4a10      	ldr	r2, [pc, #64]	; (801b004 <flash_helper_jump_to_bootloader+0x84>)

	// Load this address into function pointer
	jump_to_bootloader = (pFunction) jump_address;

	// Clear pending interrupts
	SCB->ICSR = SCB_ICSR_PENDSVCLR_Msk;
 801afc4:	4b10      	ldr	r3, [pc, #64]	; (801b008 <flash_helper_jump_to_bootloader+0x88>)
	jump_address = (volatile uint32_t*) bootloader_address[1];
 801afc6:	6810      	ldr	r0, [r2, #0]
	SCB->ICSR = SCB_ICSR_PENDSVCLR_Msk;
 801afc8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 801afcc:	605a      	str	r2, [r3, #4]

	// Disable all interrupts
	for(int i = 0;i < 8;i++) {
 801afce:	2200      	movs	r2, #0
 801afd0:	0093      	lsls	r3, r2, #2
 801afd2:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 801afd6:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 801afda:	3201      	adds	r2, #1
		NVIC->ICER[i] = NVIC->IABR[i];
 801afdc:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 801afe0:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	for(int i = 0;i < 8;i++) {
 801afe4:	2a08      	cmp	r2, #8
 801afe6:	d1f3      	bne.n	801afd0 <flash_helper_jump_to_bootloader+0x50>
	}

	// Set stack pointer
	__set_MSP((uint32_t) (bootloader_address[0]));
 801afe8:	4b08      	ldr	r3, [pc, #32]	; (801b00c <flash_helper_jump_to_bootloader+0x8c>)
 801afea:	681b      	ldr	r3, [r3, #0]
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 801afec:	f383 8808 	msr	MSP, r3

	// Jump to the bootloader
	jump_to_bootloader();
}
 801aff0:	46bd      	mov	sp, r7
 801aff2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
	jump_to_bootloader();
 801aff6:	4700      	bx	r0
 801aff8:	20001db8 	.word	0x20001db8
 801affc:	200020bc 	.word	0x200020bc
 801b000:	40020800 	.word	0x40020800
 801b004:	080e0004 	.word	0x080e0004
 801b008:	e000ed00 	.word	0xe000ed00
 801b00c:	080e0000 	.word	0x080e0000

0801b010 <flash_helper_get_sector_address>:

uint8_t* flash_helper_get_sector_address(uint32_t fsector) {
 801b010:	2200      	movs	r2, #0
 801b012:	4908      	ldr	r1, [pc, #32]	; (801b034 <flash_helper_get_sector_address+0x24>)
	uint8_t *res = 0;

	for (int i = 0;i < FLASH_SECTORS;i++) {
 801b014:	4613      	mov	r3, r2
 801b016:	e001      	b.n	801b01c <flash_helper_get_sector_address+0xc>
 801b018:	f831 2f02 	ldrh.w	r2, [r1, #2]!
		if (flash_sector[i] == fsector) {
 801b01c:	4282      	cmp	r2, r0
 801b01e:	d004      	beq.n	801b02a <flash_helper_get_sector_address+0x1a>
	for (int i = 0;i < FLASH_SECTORS;i++) {
 801b020:	3301      	adds	r3, #1
 801b022:	2b0c      	cmp	r3, #12
 801b024:	d1f8      	bne.n	801b018 <flash_helper_get_sector_address+0x8>
	uint8_t *res = 0;
 801b026:	2000      	movs	r0, #0
			break;
		}
	}

	return res;
}
 801b028:	4770      	bx	lr
			res = (uint8_t *)flash_addr[i];
 801b02a:	4a03      	ldr	r2, [pc, #12]	; (801b038 <flash_helper_get_sector_address+0x28>)
 801b02c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
			break;
 801b030:	4770      	bx	lr
 801b032:	bf00      	nop
 801b034:	0802f2b0 	.word	0x0802f2b0
 801b038:	0802f280 	.word	0x0802f280
 801b03c:	00000000 	.word	0x00000000

0801b040 <sample_send_thread>:

		chThdSleepMilliseconds(1);
	}
}

static THD_FUNCTION(sample_send_thread, arg) {
 801b040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b044:	4b7b      	ldr	r3, [pc, #492]	; (801b234 <sample_send_thread+0x1f4>)
	(void)arg;

	chRegSetThreadName("SampleSender");

	sample_send_tp = chThdGetSelfX();
 801b046:	4a7c      	ldr	r2, [pc, #496]	; (801b238 <sample_send_thread+0x1f8>)
 801b048:	699b      	ldr	r3, [r3, #24]
 801b04a:	497c      	ldr	r1, [pc, #496]	; (801b23c <sample_send_thread+0x1fc>)
 801b04c:	4e7c      	ldr	r6, [pc, #496]	; (801b240 <sample_send_thread+0x200>)
 801b04e:	f8df b228 	ldr.w	fp, [pc, #552]	; 801b278 <sample_send_thread+0x238>
 801b052:	f8df a228 	ldr.w	sl, [pc, #552]	; 801b27c <sample_send_thread+0x23c>
static THD_FUNCTION(sample_send_thread, arg) {
 801b056:	ed2d 8b06 	vpush	{d8-d10}
			while (ind_samp < 0) {
				ind_samp += ADC_SAMPLE_MAX_LEN;
			}

			buffer[index++] = COMM_SAMPLE_PRINT;
			buffer_append_float32_auto(buffer, (float)m_curr0_samples[ind_samp] * FAC_CURRENT, &index);
 801b05a:	eddf 9a7a 	vldr	s19, [pc, #488]	; 801b244 <sample_send_thread+0x204>
			buffer_append_float32_auto(buffer, (float)m_curr1_samples[ind_samp] * FAC_CURRENT, &index);
			buffer_append_float32_auto(buffer, ((float)m_ph1_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b05e:	ed9f 9a7a 	vldr	s18, [pc, #488]	; 801b248 <sample_send_thread+0x208>
 801b062:	eddf 8a7a 	vldr	s17, [pc, #488]	; 801b24c <sample_send_thread+0x20c>
 801b066:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 801b250 <sample_send_thread+0x210>
			buffer_append_float32_auto(buffer, ((float)m_ph2_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
			buffer_append_float32_auto(buffer, ((float)m_ph3_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
			buffer_append_float32_auto(buffer, ((float)m_vzero_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
			buffer_append_float32_auto(buffer, (float)m_curr_fir_samples[ind_samp] / (8.0 / FAC_CURRENT), &index);
 801b06a:	ed9f aa7a 	vldr	s20, [pc, #488]	; 801b254 <sample_send_thread+0x214>
 801b06e:	6199      	str	r1, [r3, #24]
static THD_FUNCTION(sample_send_thread, arg) {
 801b070:	b08d      	sub	sp, #52	; 0x34
	sample_send_tp = chThdGetSelfX();
 801b072:	6013      	str	r3, [r2, #0]
		chEvtWaitAny((eventmask_t) 1);
 801b074:	2001      	movs	r0, #1
 801b076:	f7f2 ff13 	bl	800dea0 <chEvtWaitAny>
		switch (m_sample_mode_last) {
 801b07a:	4b77      	ldr	r3, [pc, #476]	; (801b258 <sample_send_thread+0x218>)
 801b07c:	781b      	ldrb	r3, [r3, #0]
 801b07e:	3b01      	subs	r3, #1
 801b080:	2b05      	cmp	r3, #5
 801b082:	d8f7      	bhi.n	801b074 <sample_send_thread+0x34>
 801b084:	e8df f003 	tbb	[pc, r3]
 801b088:	cccc0303 	.word	0xcccc0303
 801b08c:	cccc      	.short	0xcccc
			len = m_sample_len;
 801b08e:	4b73      	ldr	r3, [pc, #460]	; (801b25c <sample_send_thread+0x21c>)
 801b090:	f8d3 8000 	ldr.w	r8, [r3]
		for (int i = 0;i < len;i++) {
 801b094:	f1b8 0f00 	cmp.w	r8, #0
		int offset = 0;
 801b098:	bfc8      	it	gt
 801b09a:	f04f 0900 	movgt.w	r9, #0
		for (int i = 0;i < len;i++) {
 801b09e:	dde9      	ble.n	801b074 <sample_send_thread+0x34>
			while (ind_samp >= ADC_SAMPLE_MAX_LEN) {
 801b0a0:	f5b9 6ffa 	cmp.w	r9, #2000	; 0x7d0
			len = ADC_SAMPLE_MAX_LEN;
 801b0a4:	f04f 0700 	mov.w	r7, #0
			int ind_samp = i + offset;
 801b0a8:	464c      	mov	r4, r9
			while (ind_samp >= ADC_SAMPLE_MAX_LEN) {
 801b0aa:	f2c0 80b1 	blt.w	801b210 <sample_send_thread+0x1d0>
				ind_samp -= ADC_SAMPLE_MAX_LEN;
 801b0ae:	f5a4 64fa 	sub.w	r4, r4, #2000	; 0x7d0
			while (ind_samp >= ADC_SAMPLE_MAX_LEN) {
 801b0b2:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 801b0b6:	dafa      	bge.n	801b0ae <sample_send_thread+0x6e>
			buffer_append_float32_auto(buffer, (float)m_curr0_samples[ind_samp] * FAC_CURRENT, &index);
 801b0b8:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
 801b0bc:	b21b      	sxth	r3, r3
 801b0be:	ee07 3a90 	vmov	s15, r3
 801b0c2:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
			buffer[index++] = COMM_SAMPLE_PRINT;
 801b0c6:	2201      	movs	r2, #1
			buffer_append_float32_auto(buffer, (float)m_curr1_samples[ind_samp] * FAC_CURRENT, &index);
 801b0c8:	fa04 f502 	lsl.w	r5, r4, r2
			buffer[index++] = COMM_SAMPLE_PRINT;
 801b0cc:	2313      	movs	r3, #19
			buffer_append_float32_auto(buffer, (float)m_curr0_samples[ind_samp] * FAC_CURRENT, &index);
 801b0ce:	ee20 0a29 	vmul.f32	s0, s0, s19
 801b0d2:	a901      	add	r1, sp, #4
 801b0d4:	a802      	add	r0, sp, #8
			buffer[index++] = COMM_SAMPLE_PRINT;
 801b0d6:	9201      	str	r2, [sp, #4]
 801b0d8:	f88d 3008 	strb.w	r3, [sp, #8]
			buffer_append_float32_auto(buffer, (float)m_curr0_samples[ind_samp] * FAC_CURRENT, &index);
 801b0dc:	f7f6 fda8 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, (float)m_curr1_samples[ind_samp] * FAC_CURRENT, &index);
 801b0e0:	1973      	adds	r3, r6, r5
 801b0e2:	a901      	add	r1, sp, #4
 801b0e4:	f8b3 3fa0 	ldrh.w	r3, [r3, #4000]	; 0xfa0
 801b0e8:	b21b      	sxth	r3, r3
 801b0ea:	ee07 3a90 	vmov	s15, r3
 801b0ee:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801b0f2:	a802      	add	r0, sp, #8
 801b0f4:	ee20 0a29 	vmul.f32	s0, s0, s19
 801b0f8:	f7f6 fd9a 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, ((float)m_ph1_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b0fc:	eb0b 0305 	add.w	r3, fp, r5
 801b100:	a901      	add	r1, sp, #4
 801b102:	f8b3 3e48 	ldrh.w	r3, [r3, #3656]	; 0xe48
 801b106:	b21b      	sxth	r3, r3
 801b108:	ee00 3a10 	vmov	s0, r3
 801b10c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801b110:	a802      	add	r0, sp, #8
 801b112:	ee20 0a09 	vmul.f32	s0, s0, s18
		for (int i = 0;i < len;i++) {
 801b116:	3701      	adds	r7, #1
			buffer_append_float32_auto(buffer, ((float)m_ph1_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b118:	ee20 0a28 	vmul.f32	s0, s0, s17
 801b11c:	f109 0901 	add.w	r9, r9, #1
 801b120:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b124:	f7f6 fd84 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, ((float)m_ph2_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b128:	eb0a 0305 	add.w	r3, sl, r5
 801b12c:	a901      	add	r1, sp, #4
 801b12e:	f8b3 3cf0 	ldrh.w	r3, [r3, #3312]	; 0xcf0
 801b132:	b21b      	sxth	r3, r3
 801b134:	ee00 3a10 	vmov	s0, r3
 801b138:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801b13c:	a802      	add	r0, sp, #8
 801b13e:	ee20 0a09 	vmul.f32	s0, s0, s18
 801b142:	ee20 0a28 	vmul.f32	s0, s0, s17
 801b146:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b14a:	f7f6 fd71 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, ((float)m_ph3_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b14e:	4b44      	ldr	r3, [pc, #272]	; (801b260 <sample_send_thread+0x220>)
 801b150:	442b      	add	r3, r5
 801b152:	a901      	add	r1, sp, #4
 801b154:	f8b3 3b98 	ldrh.w	r3, [r3, #2968]	; 0xb98
 801b158:	b21b      	sxth	r3, r3
 801b15a:	ee00 3a10 	vmov	s0, r3
 801b15e:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801b162:	a802      	add	r0, sp, #8
 801b164:	ee20 0a09 	vmul.f32	s0, s0, s18
 801b168:	ee20 0a28 	vmul.f32	s0, s0, s17
 801b16c:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b170:	f7f6 fd5e 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, ((float)m_vzero_samples[ind_samp] / 4096.0 * V_REG) * ((VIN_R1 + VIN_R2) / VIN_R2), &index);
 801b174:	4b3b      	ldr	r3, [pc, #236]	; (801b264 <sample_send_thread+0x224>)
 801b176:	442b      	add	r3, r5
 801b178:	a901      	add	r1, sp, #4
 801b17a:	f8b3 3a40 	ldrh.w	r3, [r3, #2624]	; 0xa40
 801b17e:	b21b      	sxth	r3, r3
 801b180:	ee00 3a10 	vmov	s0, r3
 801b184:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801b188:	a802      	add	r0, sp, #8
 801b18a:	ee20 0a09 	vmul.f32	s0, s0, s18
 801b18e:	ee20 0a28 	vmul.f32	s0, s0, s17
 801b192:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b196:	f7f6 fd4b 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, (float)m_curr_fir_samples[ind_samp] / (8.0 / FAC_CURRENT), &index);
 801b19a:	4b33      	ldr	r3, [pc, #204]	; (801b268 <sample_send_thread+0x228>)
 801b19c:	442b      	add	r3, r5
 801b19e:	a901      	add	r1, sp, #4
 801b1a0:	f8b3 38e8 	ldrh.w	r3, [r3, #2280]	; 0x8e8
 801b1a4:	b21b      	sxth	r3, r3
 801b1a6:	ee07 3a90 	vmov	s15, r3
 801b1aa:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801b1ae:	a802      	add	r0, sp, #8
 801b1b0:	ee80 0a0a 	vdiv.f32	s0, s0, s20
 801b1b4:	f7f6 fd3c 	bl	8011c30 <buffer_append_float32_auto>
			buffer_append_float32_auto(buffer, (float)m_f_sw_samples[ind_samp] * 10.0, &index);
 801b1b8:	4b2c      	ldr	r3, [pc, #176]	; (801b26c <sample_send_thread+0x22c>)
 801b1ba:	441d      	add	r5, r3
 801b1bc:	a901      	add	r1, sp, #4
 801b1be:	f8b5 3790 	ldrh.w	r3, [r5, #1936]	; 0x790
 801b1c2:	b21b      	sxth	r3, r3
 801b1c4:	a802      	add	r0, sp, #8
 801b1c6:	ee07 3a90 	vmov	s15, r3
 801b1ca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801b1ce:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801b1d2:	ee27 0a80 	vmul.f32	s0, s15, s0
 801b1d6:	f7f6 fd2b 	bl	8011c30 <buffer_append_float32_auto>
			buffer[index++] = m_status_samples[ind_samp];
 801b1da:	4a25      	ldr	r2, [pc, #148]	; (801b270 <sample_send_thread+0x230>)
 801b1dc:	9b01      	ldr	r3, [sp, #4]
 801b1de:	4414      	add	r4, r2
 801b1e0:	aa0c      	add	r2, sp, #48	; 0x30
 801b1e2:	441a      	add	r2, r3
 801b1e4:	f894 1638 	ldrb.w	r1, [r4, #1592]	; 0x638
 801b1e8:	f802 1c28 	strb.w	r1, [r2, #-40]
			buffer[index++] = m_phase_samples[ind_samp];
 801b1ec:	3302      	adds	r3, #2
 801b1ee:	f894 4e08 	ldrb.w	r4, [r4, #3592]	; 0xe08
 801b1f2:	f802 4c27 	strb.w	r4, [r2, #-39]

			commands_send_packet(buffer, index);
 801b1f6:	4619      	mov	r1, r3
 801b1f8:	a802      	add	r0, sp, #8
			buffer[index++] = m_phase_samples[ind_samp];
 801b1fa:	9301      	str	r3, [sp, #4]
			commands_send_packet(buffer, index);
 801b1fc:	f7fd fa18 	bl	8018630 <commands_send_packet>
		for (int i = 0;i < len;i++) {
 801b200:	4547      	cmp	r7, r8
 801b202:	f6bf af37 	bge.w	801b074 <sample_send_thread+0x34>
			while (ind_samp >= ADC_SAMPLE_MAX_LEN) {
 801b206:	f5b9 6ffa 	cmp.w	r9, #2000	; 0x7d0
			int ind_samp = i + offset;
 801b20a:	464c      	mov	r4, r9
			while (ind_samp >= ADC_SAMPLE_MAX_LEN) {
 801b20c:	f6bf af4f 	bge.w	801b0ae <sample_send_thread+0x6e>
			while (ind_samp < 0) {
 801b210:	f1b9 0f00 	cmp.w	r9, #0
 801b214:	f6bf af50 	bge.w	801b0b8 <sample_send_thread+0x78>
 801b218:	f514 64fa 	adds.w	r4, r4, #2000	; 0x7d0
 801b21c:	d4fc      	bmi.n	801b218 <sample_send_thread+0x1d8>
 801b21e:	e74b      	b.n	801b0b8 <sample_send_thread+0x78>
			offset = m_sample_trigger - m_sample_len;
 801b220:	4b14      	ldr	r3, [pc, #80]	; (801b274 <sample_send_thread+0x234>)
 801b222:	4a0e      	ldr	r2, [pc, #56]	; (801b25c <sample_send_thread+0x21c>)
 801b224:	681b      	ldr	r3, [r3, #0]
 801b226:	6812      	ldr	r2, [r2, #0]
			len = ADC_SAMPLE_MAX_LEN;
 801b228:	f44f 68fa 	mov.w	r8, #2000	; 0x7d0
			offset = m_sample_trigger - m_sample_len;
 801b22c:	eba3 0902 	sub.w	r9, r3, r2
 801b230:	e736      	b.n	801b0a0 <sample_send_thread+0x60>
 801b232:	bf00      	nop
 801b234:	20001a48 	.word	0x20001a48
 801b238:	2000c7e0 	.word	0x2000c7e0
 801b23c:	0802f300 	.word	0x0802f300
 801b240:	10000000 	.word	0x10000000
 801b244:	3da50a50 	.word	0x3da50a50
 801b248:	39800000 	.word	0x39800000
 801b24c:	40533333 	.word	0x40533333
 801b250:	4195d174 	.word	0x4195d174
 801b254:	42c68ba4 	.word	0x42c68ba4
 801b258:	2000c229 	.word	0x2000c229
 801b25c:	2000c224 	.word	0x2000c224
 801b260:	100032e8 	.word	0x100032e8
 801b264:	100043e0 	.word	0x100043e0
 801b268:	100054d8 	.word	0x100054d8
 801b26c:	100065d0 	.word	0x100065d0
 801b270:	100076c8 	.word	0x100076c8
 801b274:	2000c230 	.word	0x2000c230
 801b278:	100010f8 	.word	0x100010f8
 801b27c:	100021f0 	.word	0x100021f0

0801b280 <mc_interface_init>:
void mc_interface_init(mc_configuration *configuration) {
 801b280:	b5f0      	push	{r4, r5, r6, r7, lr}
	m_conf = *configuration;
 801b282:	4d3d      	ldr	r5, [pc, #244]	; (801b378 <mc_interface_init+0xf8>)
	m_motor_current_sum = 0.0;
 801b284:	4e3d      	ldr	r6, [pc, #244]	; (801b37c <mc_interface_init+0xfc>)
	m_sample_len = 1000;
 801b286:	4f3e      	ldr	r7, [pc, #248]	; (801b380 <mc_interface_init+0x100>)
void mc_interface_init(mc_configuration *configuration) {
 801b288:	b083      	sub	sp, #12
	m_conf = *configuration;
 801b28a:	4601      	mov	r1, r0
 801b28c:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801b290:	4628      	mov	r0, r5
 801b292:	f7f1 fc45 	bl	800cb20 <memcpy>
	m_cycles_running = 0;
 801b296:	483b      	ldr	r0, [pc, #236]	; (801b384 <mc_interface_init+0x104>)
	m_lock_enabled = false;
 801b298:	493b      	ldr	r1, [pc, #236]	; (801b388 <mc_interface_init+0x108>)
	m_lock_override_once = false;
 801b29a:	4a3c      	ldr	r2, [pc, #240]	; (801b38c <mc_interface_init+0x10c>)
	m_fault_now = FAULT_CODE_NONE;
 801b29c:	2400      	movs	r4, #0
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801b29e:	9400      	str	r4, [sp, #0]
	m_cycles_running = 0;
 801b2a0:	6004      	str	r4, [r0, #0]
	m_input_current_sum = 0.0;
 801b2a2:	483b      	ldr	r0, [pc, #236]	; (801b390 <mc_interface_init+0x110>)
	m_lock_enabled = false;
 801b2a4:	700c      	strb	r4, [r1, #0]
	m_motor_current_sum = 0.0;
 801b2a6:	2300      	movs	r3, #0
	m_lock_override_once = false;
 801b2a8:	7014      	strb	r4, [r2, #0]
	m_motor_current_iterations = 0.0;
 801b2aa:	493a      	ldr	r1, [pc, #232]	; (801b394 <mc_interface_init+0x114>)
	m_input_current_iterations = 0.0;
 801b2ac:	4a3a      	ldr	r2, [pc, #232]	; (801b398 <mc_interface_init+0x118>)
	m_motor_current_sum = 0.0;
 801b2ae:	6033      	str	r3, [r6, #0]
	m_input_current_sum = 0.0;
 801b2b0:	6003      	str	r3, [r0, #0]
	m_motor_id_sum = 0.0;
 801b2b2:	4e3a      	ldr	r6, [pc, #232]	; (801b39c <mc_interface_init+0x11c>)
	m_motor_iq_sum = 0.0;
 801b2b4:	483a      	ldr	r0, [pc, #232]	; (801b3a0 <mc_interface_init+0x120>)
	m_motor_current_iterations = 0.0;
 801b2b6:	600b      	str	r3, [r1, #0]
	m_input_current_iterations = 0.0;
 801b2b8:	6013      	str	r3, [r2, #0]
	m_motor_id_iterations = 0.0;
 801b2ba:	493a      	ldr	r1, [pc, #232]	; (801b3a4 <mc_interface_init+0x124>)
	m_motor_iq_iterations = 0.0;
 801b2bc:	4a3a      	ldr	r2, [pc, #232]	; (801b3a8 <mc_interface_init+0x128>)
	m_motor_id_sum = 0.0;
 801b2be:	6033      	str	r3, [r6, #0]
	m_motor_iq_sum = 0.0;
 801b2c0:	6003      	str	r3, [r0, #0]
	m_amp_seconds = 0.0;
 801b2c2:	4e3a      	ldr	r6, [pc, #232]	; (801b3ac <mc_interface_init+0x12c>)
	m_amp_seconds_charged = 0.0;
 801b2c4:	483a      	ldr	r0, [pc, #232]	; (801b3b0 <mc_interface_init+0x130>)
	m_motor_id_iterations = 0.0;
 801b2c6:	600b      	str	r3, [r1, #0]
	m_motor_iq_iterations = 0.0;
 801b2c8:	6013      	str	r3, [r2, #0]
	m_watt_seconds = 0.0;
 801b2ca:	493a      	ldr	r1, [pc, #232]	; (801b3b4 <mc_interface_init+0x134>)
	m_watt_seconds_charged = 0.0;
 801b2cc:	4a3a      	ldr	r2, [pc, #232]	; (801b3b8 <mc_interface_init+0x138>)
	m_amp_seconds = 0.0;
 801b2ce:	6033      	str	r3, [r6, #0]
	m_amp_seconds_charged = 0.0;
 801b2d0:	6003      	str	r3, [r0, #0]
	m_position_set = 0.0;
 801b2d2:	4e3a      	ldr	r6, [pc, #232]	; (801b3bc <mc_interface_init+0x13c>)
	m_last_adc_duration_sample = 0.0;
 801b2d4:	483a      	ldr	r0, [pc, #232]	; (801b3c0 <mc_interface_init+0x140>)
	m_watt_seconds = 0.0;
 801b2d6:	600b      	str	r3, [r1, #0]
	m_watt_seconds_charged = 0.0;
 801b2d8:	6013      	str	r3, [r2, #0]
	m_temp_fet = 0.0;
 801b2da:	493a      	ldr	r1, [pc, #232]	; (801b3c4 <mc_interface_init+0x144>)
	m_temp_motor = 0.0;
 801b2dc:	4a3a      	ldr	r2, [pc, #232]	; (801b3c8 <mc_interface_init+0x148>)
	m_position_set = 0.0;
 801b2de:	6033      	str	r3, [r6, #0]
	m_sample_len = 1000;
 801b2e0:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
	m_last_adc_duration_sample = 0.0;
 801b2e4:	6003      	str	r3, [r0, #0]
	m_sample_now = 0;
 801b2e6:	4e39      	ldr	r6, [pc, #228]	; (801b3cc <mc_interface_init+0x14c>)
	m_sample_int = 1;
 801b2e8:	4839      	ldr	r0, [pc, #228]	; (801b3d0 <mc_interface_init+0x150>)
	m_temp_fet = 0.0;
 801b2ea:	600b      	str	r3, [r1, #0]
	m_temp_motor = 0.0;
 801b2ec:	6013      	str	r3, [r2, #0]
	m_sample_len = 1000;
 801b2ee:	f8c7 c000 	str.w	ip, [r7]
	m_sample_int = 1;
 801b2f2:	2701      	movs	r7, #1
 801b2f4:	6007      	str	r7, [r0, #0]
	m_sample_trigger = 0;
 801b2f6:	4b37      	ldr	r3, [pc, #220]	; (801b3d4 <mc_interface_init+0x154>)
	m_sample_now = 0;
 801b2f8:	6034      	str	r4, [r6, #0]
	m_sample_mode = DEBUG_SAMPLING_OFF;
 801b2fa:	4a37      	ldr	r2, [pc, #220]	; (801b3d8 <mc_interface_init+0x158>)
	m_fault_now = FAULT_CODE_NONE;
 801b2fc:	4937      	ldr	r1, [pc, #220]	; (801b3dc <mc_interface_init+0x15c>)
	m_ignore_iterations = 0;
 801b2fe:	4838      	ldr	r0, [pc, #224]	; (801b3e0 <mc_interface_init+0x160>)
	m_sample_mode_last = DEBUG_SAMPLING_OFF;
 801b300:	4e38      	ldr	r6, [pc, #224]	; (801b3e4 <mc_interface_init+0x164>)
	m_sample_trigger = 0;
 801b302:	601c      	str	r4, [r3, #0]
	m_fault_now = FAULT_CODE_NONE;
 801b304:	700c      	strb	r4, [r1, #0]
	m_sample_mode = DEBUG_SAMPLING_OFF;
 801b306:	7014      	strb	r4, [r2, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801b308:	4b37      	ldr	r3, [pc, #220]	; (801b3e8 <mc_interface_init+0x168>)
	m_ignore_iterations = 0;
 801b30a:	6004      	str	r4, [r0, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801b30c:	2240      	movs	r2, #64	; 0x40
 801b30e:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 801b312:	4836      	ldr	r0, [pc, #216]	; (801b3ec <mc_interface_init+0x16c>)
	m_sample_mode_last = DEBUG_SAMPLING_OFF;
 801b314:	7034      	strb	r4, [r6, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801b316:	f7f2 fb2b 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(sample_send_thread_wa, sizeof(sample_send_thread_wa), NORMALPRIO - 1, sample_send_thread, NULL);
 801b31a:	4b35      	ldr	r3, [pc, #212]	; (801b3f0 <mc_interface_init+0x170>)
 801b31c:	9400      	str	r4, [sp, #0]
 801b31e:	4835      	ldr	r0, [pc, #212]	; (801b3f4 <mc_interface_init+0x174>)
 801b320:	223f      	movs	r2, #63	; 0x3f
 801b322:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 801b326:	f7f2 fb23 	bl	800d970 <chThdCreateStatic>
	switch (m_conf.m_sensor_port_mode) {
 801b32a:	f895 315c 	ldrb.w	r3, [r5, #348]	; 0x15c
 801b32e:	b2db      	uxtb	r3, r3
 801b330:	42bb      	cmp	r3, r7
 801b332:	d01b      	beq.n	801b36c <mc_interface_init+0xec>
 801b334:	2b02      	cmp	r3, #2
 801b336:	d00b      	beq.n	801b350 <mc_interface_init+0xd0>
	switch (m_conf.motor_type) {
 801b338:	78ab      	ldrb	r3, [r5, #2]
 801b33a:	b2db      	uxtb	r3, r3
 801b33c:	2b01      	cmp	r3, #1
 801b33e:	d90d      	bls.n	801b35c <mc_interface_init+0xdc>
 801b340:	2b02      	cmp	r3, #2
 801b342:	d111      	bne.n	801b368 <mc_interface_init+0xe8>
		mcpwm_foc_init(&m_conf);
 801b344:	480c      	ldr	r0, [pc, #48]	; (801b378 <mc_interface_init+0xf8>)
}
 801b346:	b003      	add	sp, #12
 801b348:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		mcpwm_foc_init(&m_conf);
 801b34c:	f002 b838 	b.w	801d3c0 <mcpwm_foc_init>
		encoder_init_as5047p_spi();
 801b350:	f7ff fc66 	bl	801ac20 <encoder_init_as5047p_spi>
	switch (m_conf.motor_type) {
 801b354:	78ab      	ldrb	r3, [r5, #2]
 801b356:	b2db      	uxtb	r3, r3
 801b358:	2b01      	cmp	r3, #1
 801b35a:	d8f1      	bhi.n	801b340 <mc_interface_init+0xc0>
		mcpwm_init(&m_conf);
 801b35c:	4806      	ldr	r0, [pc, #24]	; (801b378 <mc_interface_init+0xf8>)
}
 801b35e:	b003      	add	sp, #12
 801b360:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		mcpwm_init(&m_conf);
 801b364:	f7f7 bfdc 	b.w	8013320 <mcpwm_init>
}
 801b368:	b003      	add	sp, #12
 801b36a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		encoder_init_abi(m_conf.m_encoder_counts);
 801b36c:	f8d5 0158 	ldr.w	r0, [r5, #344]	; 0x158
 801b370:	f7ff fbf6 	bl	801ab60 <encoder_init_abi>
		break;
 801b374:	e7e0      	b.n	801b338 <mc_interface_init+0xb8>
 801b376:	bf00      	nop
 801b378:	2000c074 	.word	0x2000c074
 801b37c:	2000c208 	.word	0x2000c208
 801b380:	2000c224 	.word	0x2000c224
 801b384:	2000c1e8 	.word	0x2000c1e8
 801b388:	2000c200 	.word	0x2000c200
 801b38c:	2000c201 	.word	0x2000c201
 801b390:	2000c1f8 	.word	0x2000c1f8
 801b394:	2000c204 	.word	0x2000c204
 801b398:	2000c1f4 	.word	0x2000c1f4
 801b39c:	2000c210 	.word	0x2000c210
 801b3a0:	2000c218 	.word	0x2000c218
 801b3a4:	2000c20c 	.word	0x2000c20c
 801b3a8:	2000c214 	.word	0x2000c214
 801b3ac:	2000c06c 	.word	0x2000c06c
 801b3b0:	2000c070 	.word	0x2000c070
 801b3b4:	2000c23c 	.word	0x2000c23c
 801b3b8:	2000c240 	.word	0x2000c240
 801b3bc:	2000c21c 	.word	0x2000c21c
 801b3c0:	2000c1fc 	.word	0x2000c1fc
 801b3c4:	2000c234 	.word	0x2000c234
 801b3c8:	2000c238 	.word	0x2000c238
 801b3cc:	2000c22c 	.word	0x2000c22c
 801b3d0:	2000c220 	.word	0x2000c220
 801b3d4:	2000c230 	.word	0x2000c230
 801b3d8:	2000c228 	.word	0x2000c228
 801b3dc:	2000c1ec 	.word	0x2000c1ec
 801b3e0:	2000c1f0 	.word	0x2000c1f0
 801b3e4:	2000c229 	.word	0x2000c229
 801b3e8:	0801bf01 	.word	0x0801bf01
 801b3ec:	2000c7e8 	.word	0x2000c7e8
 801b3f0:	0801b041 	.word	0x0801b041
 801b3f4:	2000c248 	.word	0x2000c248
	...

0801b400 <mc_interface_get_configuration>:
}
 801b400:	4800      	ldr	r0, [pc, #0]	; (801b404 <mc_interface_get_configuration+0x4>)
 801b402:	4770      	bx	lr
 801b404:	2000c074 	.word	0x2000c074
	...

0801b410 <mc_interface_dccal_done>:
	switch (m_conf.motor_type) {
 801b410:	4b06      	ldr	r3, [pc, #24]	; (801b42c <mc_interface_dccal_done+0x1c>)
 801b412:	789b      	ldrb	r3, [r3, #2]
 801b414:	b2db      	uxtb	r3, r3
 801b416:	2b01      	cmp	r3, #1
 801b418:	d905      	bls.n	801b426 <mc_interface_dccal_done+0x16>
 801b41a:	2b02      	cmp	r3, #2
 801b41c:	d101      	bne.n	801b422 <mc_interface_dccal_done+0x12>
		ret = mcpwm_foc_is_dccal_done();
 801b41e:	f002 baf7 	b.w	801da10 <mcpwm_foc_is_dccal_done>
}
 801b422:	2000      	movs	r0, #0
 801b424:	4770      	bx	lr
		ret = mcpwm_is_dccal_done();
 801b426:	f7f8 bf23 	b.w	8014270 <mcpwm_is_dccal_done>
 801b42a:	bf00      	nop
 801b42c:	2000c074 	.word	0x2000c074

0801b430 <mc_interface_lock>:
	m_lock_enabled = true;
 801b430:	4b01      	ldr	r3, [pc, #4]	; (801b438 <mc_interface_lock+0x8>)
 801b432:	2201      	movs	r2, #1
 801b434:	701a      	strb	r2, [r3, #0]
}
 801b436:	4770      	bx	lr
 801b438:	2000c200 	.word	0x2000c200
 801b43c:	00000000 	.word	0x00000000

0801b440 <mc_interface_unlock>:
	m_lock_enabled = false;
 801b440:	4b01      	ldr	r3, [pc, #4]	; (801b448 <mc_interface_unlock+0x8>)
 801b442:	2200      	movs	r2, #0
 801b444:	701a      	strb	r2, [r3, #0]
}
 801b446:	4770      	bx	lr
 801b448:	2000c200 	.word	0x2000c200
 801b44c:	00000000 	.word	0x00000000

0801b450 <mc_interface_lock_override_once>:
	m_lock_override_once = true;
 801b450:	4b01      	ldr	r3, [pc, #4]	; (801b458 <mc_interface_lock_override_once+0x8>)
 801b452:	2201      	movs	r2, #1
 801b454:	701a      	strb	r2, [r3, #0]
}
 801b456:	4770      	bx	lr
 801b458:	2000c201 	.word	0x2000c201
 801b45c:	00000000 	.word	0x00000000

0801b460 <mc_interface_get_fault>:
	return m_fault_now;
 801b460:	4b01      	ldr	r3, [pc, #4]	; (801b468 <mc_interface_get_fault+0x8>)
}
 801b462:	7818      	ldrb	r0, [r3, #0]
 801b464:	4770      	bx	lr
 801b466:	bf00      	nop
 801b468:	2000c1ec 	.word	0x2000c1ec
 801b46c:	00000000 	.word	0x00000000

0801b470 <mc_interface_fault_to_string>:
const char* mc_interface_fault_to_string(mc_fault_code fault) {
 801b470:	2806      	cmp	r0, #6
 801b472:	bf9a      	itte	ls
 801b474:	4b02      	ldrls	r3, [pc, #8]	; (801b480 <mc_interface_fault_to_string+0x10>)
 801b476:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
 801b47a:	4802      	ldrhi	r0, [pc, #8]	; (801b484 <mc_interface_fault_to_string+0x14>)
}
 801b47c:	4770      	bx	lr
 801b47e:	bf00      	nop
 801b480:	0802f2d0 	.word	0x0802f2d0
 801b484:	0802f2f0 	.word	0x0802f2f0
	...

0801b490 <mc_interface_get_state>:
	switch (m_conf.motor_type) {
 801b490:	4b06      	ldr	r3, [pc, #24]	; (801b4ac <mc_interface_get_state+0x1c>)
 801b492:	789b      	ldrb	r3, [r3, #2]
 801b494:	b2db      	uxtb	r3, r3
 801b496:	2b01      	cmp	r3, #1
 801b498:	d905      	bls.n	801b4a6 <mc_interface_get_state+0x16>
 801b49a:	2b02      	cmp	r3, #2
 801b49c:	d101      	bne.n	801b4a2 <mc_interface_get_state+0x12>
		ret = mcpwm_foc_get_state();
 801b49e:	f002 baaf 	b.w	801da00 <mcpwm_foc_get_state>
}
 801b4a2:	2000      	movs	r0, #0
 801b4a4:	4770      	bx	lr
		ret = mcpwm_get_state();
 801b4a6:	f7f8 bb33 	b.w	8013b10 <mcpwm_get_state>
 801b4aa:	bf00      	nop
 801b4ac:	2000c074 	.word	0x2000c074

0801b4b0 <mc_interface_get_duty_cycle_now>:
float mc_interface_get_duty_cycle_now(void) {
 801b4b0:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801b4b2:	4c0b      	ldr	r4, [pc, #44]	; (801b4e0 <mc_interface_get_duty_cycle_now+0x30>)
 801b4b4:	78a3      	ldrb	r3, [r4, #2]
 801b4b6:	b2db      	uxtb	r3, r3
 801b4b8:	2b01      	cmp	r3, #1
 801b4ba:	d90d      	bls.n	801b4d8 <mc_interface_get_duty_cycle_now+0x28>
 801b4bc:	2b02      	cmp	r3, #2
 801b4be:	d008      	beq.n	801b4d2 <mc_interface_get_duty_cycle_now+0x22>
	float ret = 0.0;
 801b4c0:	ed9f 0a08 	vldr	s0, [pc, #32]	; 801b4e4 <mc_interface_get_duty_cycle_now+0x34>
	return DIR_MULT * ret;
 801b4c4:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801b4c8:	b903      	cbnz	r3, 801b4cc <mc_interface_get_duty_cycle_now+0x1c>
}
 801b4ca:	bd10      	pop	{r4, pc}
 801b4cc:	eeb1 0a40 	vneg.f32	s0, s0
 801b4d0:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_duty_cycle_now();
 801b4d2:	f002 fbbd 	bl	801dc50 <mcpwm_foc_get_duty_cycle_now>
		break;
 801b4d6:	e7f5      	b.n	801b4c4 <mc_interface_get_duty_cycle_now+0x14>
		ret = mcpwm_get_duty_cycle_now();
 801b4d8:	f7f8 faf2 	bl	8013ac0 <mcpwm_get_duty_cycle_now>
		break;
 801b4dc:	e7f2      	b.n	801b4c4 <mc_interface_get_duty_cycle_now+0x14>
 801b4de:	bf00      	nop
 801b4e0:	2000c074 	.word	0x2000c074
	...

0801b4f0 <mc_interface_get_sampling_frequency_now>:
	switch (m_conf.motor_type) {
 801b4f0:	4b06      	ldr	r3, [pc, #24]	; (801b50c <mc_interface_get_sampling_frequency_now+0x1c>)
 801b4f2:	789b      	ldrb	r3, [r3, #2]
 801b4f4:	b2db      	uxtb	r3, r3
 801b4f6:	2b01      	cmp	r3, #1
 801b4f8:	d906      	bls.n	801b508 <mc_interface_get_sampling_frequency_now+0x18>
 801b4fa:	2b02      	cmp	r3, #2
 801b4fc:	d101      	bne.n	801b502 <mc_interface_get_sampling_frequency_now+0x12>
		ret = mcpwm_foc_get_sampling_frequency_now();
 801b4fe:	f002 bbb7 	b.w	801dc70 <mcpwm_foc_get_sampling_frequency_now>
}
 801b502:	ed9f 0a03 	vldr	s0, [pc, #12]	; 801b510 <mc_interface_get_sampling_frequency_now+0x20>
 801b506:	4770      	bx	lr
		ret = mcpwm_get_switching_frequency_now();
 801b508:	f7f8 bae2 	b.w	8013ad0 <mcpwm_get_switching_frequency_now>
 801b50c:	2000c074 	.word	0x2000c074
	...

0801b520 <mc_interface_get_rpm>:
float mc_interface_get_rpm(void) {
 801b520:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801b522:	4c0b      	ldr	r4, [pc, #44]	; (801b550 <mc_interface_get_rpm+0x30>)
 801b524:	78a3      	ldrb	r3, [r4, #2]
 801b526:	b2db      	uxtb	r3, r3
 801b528:	2b01      	cmp	r3, #1
 801b52a:	d90d      	bls.n	801b548 <mc_interface_get_rpm+0x28>
 801b52c:	2b02      	cmp	r3, #2
 801b52e:	d008      	beq.n	801b542 <mc_interface_get_rpm+0x22>
	float ret = 0.0;
 801b530:	ed9f 0a08 	vldr	s0, [pc, #32]	; 801b554 <mc_interface_get_rpm+0x34>
	return DIR_MULT * ret;
 801b534:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801b538:	b903      	cbnz	r3, 801b53c <mc_interface_get_rpm+0x1c>
}
 801b53a:	bd10      	pop	{r4, pc}
 801b53c:	eeb1 0a40 	vneg.f32	s0, s0
 801b540:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_rpm();
 801b542:	f002 fba5 	bl	801dc90 <mcpwm_foc_get_rpm>
		break;
 801b546:	e7f5      	b.n	801b534 <mc_interface_get_rpm+0x14>
		ret = mcpwm_get_rpm();
 801b548:	f7f8 faca 	bl	8013ae0 <mcpwm_get_rpm>
		break;
 801b54c:	e7f2      	b.n	801b534 <mc_interface_get_rpm+0x14>
 801b54e:	bf00      	nop
 801b550:	2000c074 	.word	0x2000c074
	...

0801b560 <mc_interface_get_amp_hours>:
	float val = m_amp_seconds / 3600;
 801b560:	4b05      	ldr	r3, [pc, #20]	; (801b578 <mc_interface_get_amp_hours+0x18>)
 801b562:	eddf 7a06 	vldr	s15, [pc, #24]	; 801b57c <mc_interface_get_amp_hours+0x1c>
 801b566:	ed93 7a00 	vldr	s14, [r3]
 801b56a:	ee87 0a27 	vdiv.f32	s0, s14, s15
	if (reset) {
 801b56e:	b108      	cbz	r0, 801b574 <mc_interface_get_amp_hours+0x14>
		m_amp_seconds = 0.0;
 801b570:	2200      	movs	r2, #0
 801b572:	601a      	str	r2, [r3, #0]
}
 801b574:	4770      	bx	lr
 801b576:	bf00      	nop
 801b578:	2000c06c 	.word	0x2000c06c
 801b57c:	45610000 	.word	0x45610000

0801b580 <mc_interface_get_amp_hours_charged>:
	float val = m_amp_seconds_charged / 3600;
 801b580:	4b05      	ldr	r3, [pc, #20]	; (801b598 <mc_interface_get_amp_hours_charged+0x18>)
 801b582:	eddf 7a06 	vldr	s15, [pc, #24]	; 801b59c <mc_interface_get_amp_hours_charged+0x1c>
 801b586:	ed93 7a00 	vldr	s14, [r3]
 801b58a:	ee87 0a27 	vdiv.f32	s0, s14, s15
	if (reset) {
 801b58e:	b108      	cbz	r0, 801b594 <mc_interface_get_amp_hours_charged+0x14>
		m_amp_seconds_charged = 0.0;
 801b590:	2200      	movs	r2, #0
 801b592:	601a      	str	r2, [r3, #0]
}
 801b594:	4770      	bx	lr
 801b596:	bf00      	nop
 801b598:	2000c070 	.word	0x2000c070
 801b59c:	45610000 	.word	0x45610000

0801b5a0 <mc_interface_get_watt_hours>:
	float val = m_watt_seconds / 3600;
 801b5a0:	4b05      	ldr	r3, [pc, #20]	; (801b5b8 <mc_interface_get_watt_hours+0x18>)
 801b5a2:	eddf 7a06 	vldr	s15, [pc, #24]	; 801b5bc <mc_interface_get_watt_hours+0x1c>
 801b5a6:	ed93 7a00 	vldr	s14, [r3]
 801b5aa:	ee87 0a27 	vdiv.f32	s0, s14, s15
	if (reset) {
 801b5ae:	b108      	cbz	r0, 801b5b4 <mc_interface_get_watt_hours+0x14>
		m_watt_seconds = 0.0;
 801b5b0:	2200      	movs	r2, #0
 801b5b2:	601a      	str	r2, [r3, #0]
}
 801b5b4:	4770      	bx	lr
 801b5b6:	bf00      	nop
 801b5b8:	2000c23c 	.word	0x2000c23c
 801b5bc:	45610000 	.word	0x45610000

0801b5c0 <mc_interface_get_watt_hours_charged>:
	float val = m_watt_seconds_charged / 3600;
 801b5c0:	4b05      	ldr	r3, [pc, #20]	; (801b5d8 <mc_interface_get_watt_hours_charged+0x18>)
 801b5c2:	eddf 7a06 	vldr	s15, [pc, #24]	; 801b5dc <mc_interface_get_watt_hours_charged+0x1c>
 801b5c6:	ed93 7a00 	vldr	s14, [r3]
 801b5ca:	ee87 0a27 	vdiv.f32	s0, s14, s15
	if (reset) {
 801b5ce:	b108      	cbz	r0, 801b5d4 <mc_interface_get_watt_hours_charged+0x14>
		m_watt_seconds_charged = 0.0;
 801b5d0:	2200      	movs	r2, #0
 801b5d2:	601a      	str	r2, [r3, #0]
}
 801b5d4:	4770      	bx	lr
 801b5d6:	bf00      	nop
 801b5d8:	2000c240 	.word	0x2000c240
 801b5dc:	45610000 	.word	0x45610000

0801b5e0 <mc_interface_get_tot_current>:
	switch (m_conf.motor_type) {
 801b5e0:	4b06      	ldr	r3, [pc, #24]	; (801b5fc <mc_interface_get_tot_current+0x1c>)
 801b5e2:	789b      	ldrb	r3, [r3, #2]
 801b5e4:	b2db      	uxtb	r3, r3
 801b5e6:	2b01      	cmp	r3, #1
 801b5e8:	d906      	bls.n	801b5f8 <mc_interface_get_tot_current+0x18>
 801b5ea:	2b02      	cmp	r3, #2
 801b5ec:	d101      	bne.n	801b5f2 <mc_interface_get_tot_current+0x12>
		ret = mcpwm_foc_get_tot_current();
 801b5ee:	f002 bb5f 	b.w	801dcb0 <mcpwm_foc_get_tot_current>
}
 801b5f2:	ed9f 0a03 	vldr	s0, [pc, #12]	; 801b600 <mc_interface_get_tot_current+0x20>
 801b5f6:	4770      	bx	lr
		ret = mcpwm_get_tot_current();
 801b5f8:	f7f8 baa2 	b.w	8013b40 <mcpwm_get_tot_current>
 801b5fc:	2000c074 	.word	0x2000c074
	...

0801b610 <mc_interface_get_tot_current_filtered>:
	switch (m_conf.motor_type) {
 801b610:	4b06      	ldr	r3, [pc, #24]	; (801b62c <mc_interface_get_tot_current_filtered+0x1c>)
 801b612:	789b      	ldrb	r3, [r3, #2]
 801b614:	b2db      	uxtb	r3, r3
 801b616:	2b01      	cmp	r3, #1
 801b618:	d906      	bls.n	801b628 <mc_interface_get_tot_current_filtered+0x18>
 801b61a:	2b02      	cmp	r3, #2
 801b61c:	d101      	bne.n	801b622 <mc_interface_get_tot_current_filtered+0x12>
		ret = mcpwm_foc_get_tot_current_filtered();
 801b61e:	f002 bb5f 	b.w	801dce0 <mcpwm_foc_get_tot_current_filtered>
}
 801b622:	ed9f 0a03 	vldr	s0, [pc, #12]	; 801b630 <mc_interface_get_tot_current_filtered+0x20>
 801b626:	4770      	bx	lr
		ret = mcpwm_get_tot_current_filtered();
 801b628:	f7f8 ba92 	b.w	8013b50 <mcpwm_get_tot_current_filtered>
 801b62c:	2000c074 	.word	0x2000c074
	...

0801b640 <mc_interface_get_tot_current_directional>:
float mc_interface_get_tot_current_directional(void) {
 801b640:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801b642:	4c0b      	ldr	r4, [pc, #44]	; (801b670 <mc_interface_get_tot_current_directional+0x30>)
 801b644:	78a3      	ldrb	r3, [r4, #2]
 801b646:	b2db      	uxtb	r3, r3
 801b648:	2b01      	cmp	r3, #1
 801b64a:	d90d      	bls.n	801b668 <mc_interface_get_tot_current_directional+0x28>
 801b64c:	2b02      	cmp	r3, #2
 801b64e:	d008      	beq.n	801b662 <mc_interface_get_tot_current_directional+0x22>
	float ret = 0.0;
 801b650:	ed9f 0a08 	vldr	s0, [pc, #32]	; 801b674 <mc_interface_get_tot_current_directional+0x34>
	return DIR_MULT * ret;
 801b654:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801b658:	b903      	cbnz	r3, 801b65c <mc_interface_get_tot_current_directional+0x1c>
}
 801b65a:	bd10      	pop	{r4, pc}
 801b65c:	eeb1 0a40 	vneg.f32	s0, s0
 801b660:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_tot_current_directional();
 801b662:	f002 fb65 	bl	801dd30 <mcpwm_foc_get_tot_current_directional>
		break;
 801b666:	e7f5      	b.n	801b654 <mc_interface_get_tot_current_directional+0x14>
		ret = mcpwm_get_tot_current_directional();
 801b668:	f7f8 fa7a 	bl	8013b60 <mcpwm_get_tot_current_directional>
		break;
 801b66c:	e7f2      	b.n	801b654 <mc_interface_get_tot_current_directional+0x14>
 801b66e:	bf00      	nop
 801b670:	2000c074 	.word	0x2000c074
	...

0801b680 <mc_interface_get_tot_current_directional_filtered>:
float mc_interface_get_tot_current_directional_filtered(void) {
 801b680:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801b682:	4c0b      	ldr	r4, [pc, #44]	; (801b6b0 <mc_interface_get_tot_current_directional_filtered+0x30>)
 801b684:	78a3      	ldrb	r3, [r4, #2]
 801b686:	b2db      	uxtb	r3, r3
 801b688:	2b01      	cmp	r3, #1
 801b68a:	d90d      	bls.n	801b6a8 <mc_interface_get_tot_current_directional_filtered+0x28>
 801b68c:	2b02      	cmp	r3, #2
 801b68e:	d008      	beq.n	801b6a2 <mc_interface_get_tot_current_directional_filtered+0x22>
	float ret = 0.0;
 801b690:	ed9f 0a08 	vldr	s0, [pc, #32]	; 801b6b4 <mc_interface_get_tot_current_directional_filtered+0x34>
	return DIR_MULT * ret;
 801b694:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801b698:	b903      	cbnz	r3, 801b69c <mc_interface_get_tot_current_directional_filtered+0x1c>
}
 801b69a:	bd10      	pop	{r4, pc}
 801b69c:	eeb1 0a40 	vneg.f32	s0, s0
 801b6a0:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_tot_current_directional_filtered();
 801b6a2:	f002 fb4d 	bl	801dd40 <mcpwm_foc_get_tot_current_directional_filtered>
		break;
 801b6a6:	e7f5      	b.n	801b694 <mc_interface_get_tot_current_directional_filtered+0x14>
		ret = mcpwm_get_tot_current_directional_filtered();
 801b6a8:	f7f8 fa72 	bl	8013b90 <mcpwm_get_tot_current_directional_filtered>
		break;
 801b6ac:	e7f2      	b.n	801b694 <mc_interface_get_tot_current_directional_filtered+0x14>
 801b6ae:	bf00      	nop
 801b6b0:	2000c074 	.word	0x2000c074
	...

0801b6c0 <mc_interface_get_tot_current_in_filtered>:
	switch (m_conf.motor_type) {
 801b6c0:	4b06      	ldr	r3, [pc, #24]	; (801b6dc <mc_interface_get_tot_current_in_filtered+0x1c>)
 801b6c2:	789b      	ldrb	r3, [r3, #2]
 801b6c4:	b2db      	uxtb	r3, r3
 801b6c6:	2b01      	cmp	r3, #1
 801b6c8:	d906      	bls.n	801b6d8 <mc_interface_get_tot_current_in_filtered+0x18>
 801b6ca:	2b02      	cmp	r3, #2
 801b6cc:	d101      	bne.n	801b6d2 <mc_interface_get_tot_current_in_filtered+0x12>
		ret = mcpwm_foc_get_tot_current_in_filtered();
 801b6ce:	f002 bb4f 	b.w	801dd70 <mcpwm_foc_get_tot_current_in_filtered>
}
 801b6d2:	ed9f 0a03 	vldr	s0, [pc, #12]	; 801b6e0 <mc_interface_get_tot_current_in_filtered+0x20>
 801b6d6:	4770      	bx	lr
		ret = mcpwm_get_tot_current_in_filtered();
 801b6d8:	f7f8 ba72 	b.w	8013bc0 <mcpwm_get_tot_current_in_filtered>
 801b6dc:	2000c074 	.word	0x2000c074
	...

0801b6f0 <mc_interface_get_tachometer_value>:
int mc_interface_get_tachometer_value(bool reset) {
 801b6f0:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801b6f2:	4c10      	ldr	r4, [pc, #64]	; (801b734 <mc_interface_get_tachometer_value+0x44>)
 801b6f4:	78a3      	ldrb	r3, [r4, #2]
 801b6f6:	b2db      	uxtb	r3, r3
 801b6f8:	2b01      	cmp	r3, #1
 801b6fa:	d914      	bls.n	801b726 <mc_interface_get_tachometer_value+0x36>
 801b6fc:	2b02      	cmp	r3, #2
 801b6fe:	d00b      	beq.n	801b718 <mc_interface_get_tachometer_value+0x28>
 801b700:	eddf 7a0d 	vldr	s15, [pc, #52]	; 801b738 <mc_interface_get_tachometer_value+0x48>
	return DIR_MULT * ret;
 801b704:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801b708:	b10b      	cbz	r3, 801b70e <mc_interface_get_tachometer_value+0x1e>
 801b70a:	eef1 7a67 	vneg.f32	s15, s15
}
 801b70e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801b712:	ee17 0a90 	vmov	r0, s15
 801b716:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_tachometer_value(reset);
 801b718:	f002 fb32 	bl	801dd80 <mcpwm_foc_get_tachometer_value>
 801b71c:	ee07 0a90 	vmov	s15, r0
 801b720:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		break;
 801b724:	e7ee      	b.n	801b704 <mc_interface_get_tachometer_value+0x14>
		ret = mcpwm_get_tachometer_value(reset);
 801b726:	f7f8 fa5b 	bl	8013be0 <mcpwm_get_tachometer_value>
 801b72a:	ee07 0a90 	vmov	s15, r0
 801b72e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		break;
 801b732:	e7e7      	b.n	801b704 <mc_interface_get_tachometer_value+0x14>
 801b734:	2000c074 	.word	0x2000c074
	...

0801b740 <mc_interface_fault_stop.part.3>:
void mc_interface_fault_stop(mc_fault_code fault) {
 801b740:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b742:	b093      	sub	sp, #76	; 0x4c
 801b744:	4605      	mov	r5, r0
	if (mc_interface_dccal_done() && m_fault_now == FAULT_CODE_NONE) {
 801b746:	f7ff fe63 	bl	801b410 <mc_interface_dccal_done>
 801b74a:	4c3f      	ldr	r4, [pc, #252]	; (801b848 <mc_interface_fault_stop.part.3+0x108>)
 801b74c:	b108      	cbz	r0, 801b752 <mc_interface_fault_stop.part.3+0x12>
 801b74e:	7826      	ldrb	r6, [r4, #0]
 801b750:	b1a6      	cbz	r6, 801b77c <mc_interface_fault_stop.part.3+0x3c>
	m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801b752:	4b3e      	ldr	r3, [pc, #248]	; (801b84c <mc_interface_fault_stop.part.3+0x10c>)
 801b754:	4a3e      	ldr	r2, [pc, #248]	; (801b850 <mc_interface_fault_stop.part.3+0x110>)
 801b756:	f8d3 114c 	ldr.w	r1, [r3, #332]	; 0x14c
	switch (m_conf.motor_type) {
 801b75a:	789b      	ldrb	r3, [r3, #2]
	m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801b75c:	6011      	str	r1, [r2, #0]
	switch (m_conf.motor_type) {
 801b75e:	b2db      	uxtb	r3, r3
 801b760:	2b01      	cmp	r3, #1
 801b762:	d906      	bls.n	801b772 <mc_interface_fault_stop.part.3+0x32>
 801b764:	2b02      	cmp	r3, #2
 801b766:	d101      	bne.n	801b76c <mc_interface_fault_stop.part.3+0x2c>
		mcpwm_foc_stop_pwm();
 801b768:	f002 f9ca 	bl	801db00 <mcpwm_foc_stop_pwm>
	m_fault_now = fault;
 801b76c:	7025      	strb	r5, [r4, #0]
}
 801b76e:	b013      	add	sp, #76	; 0x4c
 801b770:	bdf0      	pop	{r4, r5, r6, r7, pc}
		mcpwm_stop_pwm();
 801b772:	f7f8 fa55 	bl	8013c20 <mcpwm_stop_pwm>
	m_fault_now = fault;
 801b776:	7025      	strb	r5, [r4, #0]
}
 801b778:	b013      	add	sp, #76	; 0x4c
 801b77a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		utils_sys_lock_cnt();
 801b77c:	f7fa fc90 	bl	80160a0 <utils_sys_lock_cnt>
		volatile int val_samp = TIM8->CCR1;
 801b780:	4a34      	ldr	r2, [pc, #208]	; (801b854 <mc_interface_fault_stop.part.3+0x114>)
		volatile int current_samp = TIM1->CCR4;
 801b782:	4b35      	ldr	r3, [pc, #212]	; (801b858 <mc_interface_fault_stop.part.3+0x118>)
		volatile int val_samp = TIM8->CCR1;
 801b784:	6b52      	ldr	r2, [r2, #52]	; 0x34
 801b786:	9201      	str	r2, [sp, #4]
		volatile int current_samp = TIM1->CCR4;
 801b788:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801b78a:	9202      	str	r2, [sp, #8]
		volatile int tim_top = TIM1->ARR;
 801b78c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b78e:	9303      	str	r3, [sp, #12]
		utils_sys_unlock_cnt();
 801b790:	f7fa fc96 	bl	80160c0 <utils_sys_unlock_cnt>
		fdata.fault = fault;
 801b794:	f88d 5010 	strb.w	r5, [sp, #16]
		fdata.current = mc_interface_get_tot_current();
 801b798:	f7ff ff22 	bl	801b5e0 <mc_interface_get_tot_current>
		fdata.voltage = GET_INPUT_VOLTAGE();
 801b79c:	4f2f      	ldr	r7, [pc, #188]	; (801b85c <mc_interface_fault_stop.part.3+0x11c>)
		fdata.current = mc_interface_get_tot_current();
 801b79e:	ed8d 0a05 	vstr	s0, [sp, #20]
		fdata.current_filtered = mc_interface_get_tot_current_filtered();
 801b7a2:	f7ff ff35 	bl	801b610 <mc_interface_get_tot_current_filtered>
		fdata.voltage = GET_INPUT_VOLTAGE();
 801b7a6:	8a3b      	ldrh	r3, [r7, #16]
 801b7a8:	eddf 6a2d 	vldr	s13, [pc, #180]	; 801b860 <mc_interface_fault_stop.part.3+0x120>
 801b7ac:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 801b864 <mc_interface_fault_stop.part.3+0x124>
		fdata.current_filtered = mc_interface_get_tot_current_filtered();
 801b7b0:	ed8d 0a06 	vstr	s0, [sp, #24]
		fdata.voltage = GET_INPUT_VOLTAGE();
 801b7b4:	ee07 3a90 	vmov	s15, r3
 801b7b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801b7bc:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801b7c0:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b7c4:	edcd 7a07 	vstr	s15, [sp, #28]
		fdata.duty = mc_interface_get_duty_cycle_now();
 801b7c8:	f7ff fe72 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
 801b7cc:	ed8d 0a08 	vstr	s0, [sp, #32]
		fdata.rpm = mc_interface_get_rpm();
 801b7d0:	f7ff fea6 	bl	801b520 <mc_interface_get_rpm>
		fdata.tacho = mc_interface_get_tachometer_value(false);
 801b7d4:	4630      	mov	r0, r6
		fdata.rpm = mc_interface_get_rpm();
 801b7d6:	ed8d 0a09 	vstr	s0, [sp, #36]	; 0x24
		fdata.tacho = mc_interface_get_tachometer_value(false);
 801b7da:	f7ff ff89 	bl	801b6f0 <mc_interface_get_tachometer_value>
		fdata.cycles_running = m_cycles_running;
 801b7de:	4b22      	ldr	r3, [pc, #136]	; (801b868 <mc_interface_fault_stop.part.3+0x128>)
		fdata.tacho = mc_interface_get_tachometer_value(false);
 801b7e0:	900a      	str	r0, [sp, #40]	; 0x28
		fdata.cycles_running = m_cycles_running;
 801b7e2:	681b      	ldr	r3, [r3, #0]
		fdata.tim_val_samp = val_samp;
 801b7e4:	9901      	ldr	r1, [sp, #4]
		fdata.tim_current_samp = current_samp;
 801b7e6:	9a02      	ldr	r2, [sp, #8]
		fdata.cycles_running = m_cycles_running;
 801b7e8:	930b      	str	r3, [sp, #44]	; 0x2c
		fdata.tim_top = tim_top;
 801b7ea:	9b03      	ldr	r3, [sp, #12]
 801b7ec:	930e      	str	r3, [sp, #56]	; 0x38
		fdata.tim_current_samp = current_samp;
 801b7ee:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
		fdata.comm_step = mcpwm_get_comm_step();
 801b7f2:	f7f8 f95d 	bl	8013ab0 <mcpwm_get_comm_step>
		fdata.temperature = NTC_TEMP(ADC_IND_TEMP_MOS);
 801b7f6:	897b      	ldrh	r3, [r7, #10]
 801b7f8:	eddf 6a1c 	vldr	s13, [pc, #112]	; 801b86c <mc_interface_fault_stop.part.3+0x12c>
 801b7fc:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 801b870 <mc_interface_fault_stop.part.3+0x130>
		fdata.comm_step = mcpwm_get_comm_step();
 801b800:	900f      	str	r0, [sp, #60]	; 0x3c
		fdata.temperature = NTC_TEMP(ADC_IND_TEMP_MOS);
 801b802:	ee07 3a10 	vmov	s14, r3
 801b806:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801b80a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801b80e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 801b812:	ee87 0a80 	vdiv.f32	s0, s15, s0
 801b816:	f009 faeb 	bl	8024df0 <logf>
		terminal_add_fault_data(&fdata);
 801b81a:	a804      	add	r0, sp, #16
		fdata.temperature = NTC_TEMP(ADC_IND_TEMP_MOS);
 801b81c:	eddf 6a15 	vldr	s13, [pc, #84]	; 801b874 <mc_interface_fault_stop.part.3+0x134>
 801b820:	eddf 7a15 	vldr	s15, [pc, #84]	; 801b878 <mc_interface_fault_stop.part.3+0x138>
 801b824:	ed9f 7a15 	vldr	s14, [pc, #84]	; 801b87c <mc_interface_fault_stop.part.3+0x13c>
 801b828:	ee80 0a26 	vdiv.f32	s0, s0, s13
 801b82c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801b830:	ee30 0a27 	vadd.f32	s0, s0, s15
 801b834:	eec6 7a80 	vdiv.f32	s15, s13, s0
 801b838:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801b83c:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
		terminal_add_fault_data(&fdata);
 801b840:	f7fb fe0e 	bl	8017460 <terminal_add_fault_data>
 801b844:	e785      	b.n	801b752 <mc_interface_fault_stop.part.3+0x12>
 801b846:	bf00      	nop
 801b848:	2000c1ec 	.word	0x2000c1ec
 801b84c:	2000c074 	.word	0x2000c074
 801b850:	2000c1f0 	.word	0x2000c1f0
 801b854:	40010400 	.word	0x40010400
 801b858:	40010000 	.word	0x40010000
 801b85c:	2000c03c 	.word	0x2000c03c
 801b860:	3a534067 	.word	0x3a534067
 801b864:	4195d174 	.word	0x4195d174
 801b868:	2000c1e8 	.word	0x2000c1e8
 801b86c:	4c1c363c 	.word	0x4c1c363c
 801b870:	461c4000 	.word	0x461c4000
 801b874:	4556a000 	.word	0x4556a000
 801b878:	3b5bcf0f 	.word	0x3b5bcf0f
 801b87c:	43889333 	.word	0x43889333

0801b880 <update_override_limits.constprop.4>:
static void update_override_limits(volatile mc_configuration *conf) {
 801b880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const float v_in = GET_INPUT_VOLTAGE();
 801b882:	4fdc      	ldr	r7, [pc, #880]	; (801bbf4 <update_override_limits.constprop.4+0x374>)
 801b884:	ed9f 7adc 	vldr	s14, [pc, #880]	; 801bbf8 <update_override_limits.constprop.4+0x378>
 801b888:	8a3b      	ldrh	r3, [r7, #16]
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b88a:	4edc      	ldr	r6, [pc, #880]	; (801bbfc <update_override_limits.constprop.4+0x37c>)
	const float v_in = GET_INPUT_VOLTAGE();
 801b88c:	eddf 7adc 	vldr	s15, [pc, #880]	; 801bc00 <update_override_limits.constprop.4+0x380>
	UTILS_LP_FAST(m_temp_motor, NTC_TEMP_MOTOR(conf->m_ntc_motor_beta), 0.1);
 801b890:	4ddc      	ldr	r5, [pc, #880]	; (801bc04 <update_override_limits.constprop.4+0x384>)
 801b892:	4cdd      	ldr	r4, [pc, #884]	; (801bc08 <update_override_limits.constprop.4+0x388>)
static void update_override_limits(volatile mc_configuration *conf) {
 801b894:	ed2d 8b0a 	vpush	{d8-d12}
	const float v_in = GET_INPUT_VOLTAGE();
 801b898:	ee08 3a10 	vmov	s16, r3
 801b89c:	eeb8 8a48 	vcvt.f32.u32	s16, s16
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b8a0:	eddf 8ada 	vldr	s17, [pc, #872]	; 801bc0c <update_override_limits.constprop.4+0x38c>
 801b8a4:	eddf bada 	vldr	s23, [pc, #872]	; 801bc10 <update_override_limits.constprop.4+0x390>
 801b8a8:	ed9f bada 	vldr	s22, [pc, #872]	; 801bc14 <update_override_limits.constprop.4+0x394>
 801b8ac:	eddf aada 	vldr	s21, [pc, #872]	; 801bc18 <update_override_limits.constprop.4+0x398>
	const float v_in = GET_INPUT_VOLTAGE();
 801b8b0:	ee28 8a07 	vmul.f32	s16, s16, s14
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b8b4:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
	const float v_in = GET_INPUT_VOLTAGE();
 801b8b8:	ee28 8a27 	vmul.f32	s16, s16, s15
	const float rpm_now = mc_interface_get_rpm();
 801b8bc:	f7ff fe30 	bl	801b520 <mc_interface_get_rpm>
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b8c0:	edd6 9a00 	vldr	s19, [r6]
 801b8c4:	897b      	ldrh	r3, [r7, #10]
 801b8c6:	ed9f 7ad5 	vldr	s14, [pc, #852]	; 801bc1c <update_override_limits.constprop.4+0x39c>
 801b8ca:	ee07 3a90 	vmov	s15, r3
 801b8ce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	const float rpm_now = mc_interface_get_rpm();
 801b8d2:	eeb0 9a40 	vmov.f32	s18, s0
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b8d6:	ee87 0a27 	vdiv.f32	s0, s14, s15
 801b8da:	ee30 0a68 	vsub.f32	s0, s0, s17
 801b8de:	ee80 0a28 	vdiv.f32	s0, s0, s17
 801b8e2:	f009 fa85 	bl	8024df0 <logf>
 801b8e6:	ed9f 7ace 	vldr	s14, [pc, #824]	; 801bc20 <update_override_limits.constprop.4+0x3a0>
 801b8ea:	edd6 7a00 	vldr	s15, [r6]
	UTILS_LP_FAST(m_temp_motor, NTC_TEMP_MOTOR(conf->m_ntc_motor_beta), 0.1);
 801b8ee:	eddf 6acd 	vldr	s13, [pc, #820]	; 801bc24 <update_override_limits.constprop.4+0x3a4>
	UTILS_LP_FAST(m_temp_fet, NTC_TEMP(ADC_IND_TEMP_MOS), 0.1);
 801b8f2:	ee80 0a07 	vdiv.f32	s0, s0, s14
 801b8f6:	ee30 0a2b 	vadd.f32	s0, s0, s23
 801b8fa:	ee8a 7a00 	vdiv.f32	s14, s20, s0
 801b8fe:	ee37 7a4b 	vsub.f32	s14, s14, s22
 801b902:	ee79 9ac7 	vsub.f32	s19, s19, s14
 801b906:	eee9 7aea 	vfms.f32	s15, s19, s21
 801b90a:	edc6 7a00 	vstr	s15, [r6]
	UTILS_LP_FAST(m_temp_motor, NTC_TEMP_MOTOR(conf->m_ntc_motor_beta), 0.1);
 801b90e:	edd5 9a00 	vldr	s19, [r5]
 801b912:	8afb      	ldrh	r3, [r7, #22]
 801b914:	ee07 3a10 	vmov	s14, r3
 801b918:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801b91c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801b920:	ee77 7aca 	vsub.f32	s15, s15, s20
 801b924:	ee88 0aa7 	vdiv.f32	s0, s17, s15
 801b928:	ee80 0a28 	vdiv.f32	s0, s0, s17
 801b92c:	f009 fa60 	bl	8024df0 <logf>
 801b930:	ed94 7a5c 	vldr	s14, [r4, #368]	; 0x170
 801b934:	edd5 7a00 	vldr	s15, [r5]
 801b938:	ee80 0a07 	vdiv.f32	s0, s0, s14
 801b93c:	ee30 0a2b 	vadd.f32	s0, s0, s23
 801b940:	ee8a 7a00 	vdiv.f32	s14, s20, s0
 801b944:	ee37 7a4b 	vsub.f32	s14, s14, s22
 801b948:	ee79 9ac7 	vsub.f32	s19, s19, s14
 801b94c:	eee9 7aea 	vfms.f32	s15, s19, s21
 801b950:	edc5 7a00 	vstr	s15, [r5]
	if (m_temp_fet < conf->l_temp_fet_start) {
 801b954:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 801b958:	edd6 7a00 	vldr	s15, [r6]
 801b95c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b960:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b964:	f340 80f0 	ble.w	801bb48 <update_override_limits.constprop.4+0x2c8>
		lo_min_mos = conf->l_current_min;
 801b968:	edd4 8a02 	vldr	s17, [r4, #8]
		lo_max_mos = conf->l_current_max;
 801b96c:	ed94 ba01 	vldr	s22, [r4, #4]
	if (m_temp_motor < conf->l_temp_motor_start) {
 801b970:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
 801b974:	edd5 7a00 	vldr	s15, [r5]
 801b978:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b97c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b980:	f340 8121 	ble.w	801bbc6 <update_override_limits.constprop.4+0x346>
		lo_min_mot = conf->l_current_min;
 801b984:	edd4 9a02 	vldr	s19, [r4, #8]
		lo_max_mot = conf->l_current_max;
 801b988:	ed94 ca01 	vldr	s24, [r4, #4]
	const float temp_fet_accel_start = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_fet_start, 25.0);
 801b98c:	ed94 0a14 	vldr	s0, [r4, #80]	; 0x50
 801b990:	eddf 0aa7 	vldr	s1, [pc, #668]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801b994:	edd4 1a10 	vldr	s3, [r4, #64]	; 0x40
 801b998:	eeb3 2a09 	vmov.f32	s4, #57	; 0x41c80000  25.0
 801b99c:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801b9a0:	f7fa f8ae 	bl	8015b00 <utils_map>
	const float temp_fet_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_fet_end, 25.0);
 801b9a4:	eddf 0aa2 	vldr	s1, [pc, #648]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
	const float temp_fet_accel_start = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_fet_start, 25.0);
 801b9a8:	eef0 aa40 	vmov.f32	s21, s0
	const float temp_fet_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_fet_end, 25.0);
 801b9ac:	eeb3 2a09 	vmov.f32	s4, #57	; 0x41c80000  25.0
 801b9b0:	ed94 0a14 	vldr	s0, [r4, #80]	; 0x50
 801b9b4:	edd4 1a11 	vldr	s3, [r4, #68]	; 0x44
 801b9b8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801b9bc:	f7fa f8a0 	bl	8015b00 <utils_map>
	const float temp_motor_accel_start = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_start, 25.0);
 801b9c0:	eddf 0a9b 	vldr	s1, [pc, #620]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801b9c4:	eeb3 2a09 	vmov.f32	s4, #57	; 0x41c80000  25.0
 801b9c8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
	const float temp_fet_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_fet_end, 25.0);
 801b9cc:	eef0 ca40 	vmov.f32	s25, s0
	const float temp_motor_accel_start = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_start, 25.0);
 801b9d0:	ed94 0a14 	vldr	s0, [r4, #80]	; 0x50
 801b9d4:	edd4 1a12 	vldr	s3, [r4, #72]	; 0x48
 801b9d8:	f7fa f892 	bl	8015b00 <utils_map>
	const float temp_motor_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_end, 25.0);
 801b9dc:	eddf 0a94 	vldr	s1, [pc, #592]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
	const float temp_motor_accel_start = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_start, 25.0);
 801b9e0:	eeb0 aa40 	vmov.f32	s20, s0
	const float temp_motor_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_end, 25.0);
 801b9e4:	eeb3 2a09 	vmov.f32	s4, #57	; 0x41c80000  25.0
 801b9e8:	ed94 0a14 	vldr	s0, [r4, #80]	; 0x50
 801b9ec:	edd4 1a13 	vldr	s3, [r4, #76]	; 0x4c
 801b9f0:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801b9f4:	f7fa f884 	bl	8015b00 <utils_map>
	if (m_temp_fet < temp_fet_accel_start) {
 801b9f8:	edd6 7a00 	vldr	s15, [r6]
 801b9fc:	eef4 aae7 	vcmpe.f32	s21, s15
 801ba00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	const float temp_motor_accel_end = utils_map(conf->l_temp_accel_dec, 0.0, 1.0, conf->l_temp_motor_end, 25.0);
 801ba04:	eef0 ba40 	vmov.f32	s23, s0
	if (m_temp_fet < temp_fet_accel_start) {
 801ba08:	f340 80d2 	ble.w	801bbb0 <update_override_limits.constprop.4+0x330>
		lo_fet_temp_accel = conf->l_current_max;
 801ba0c:	edd4 aa01 	vldr	s21, [r4, #4]
	if (m_temp_motor < temp_motor_accel_start) {
 801ba10:	edd5 7a00 	vldr	s15, [r5]
 801ba14:	eeb4 aae7 	vcmpe.f32	s20, s15
 801ba18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ba1c:	f340 80bd 	ble.w	801bb9a <update_override_limits.constprop.4+0x31a>
		lo_motor_temp_accel = conf->l_current_max;
 801ba20:	ed94 aa01 	vldr	s20, [r4, #4]
	const float rpm_pos_cut_start = conf->l_max_erpm * conf->l_erpm_start;
 801ba24:	edd4 0a07 	vldr	s1, [r4, #28]
 801ba28:	edd4 7a08 	vldr	s15, [r4, #32]
	const float rpm_pos_cut_end = conf->l_max_erpm;
 801ba2c:	ed94 1a07 	vldr	s2, [r4, #28]
	const float rpm_pos_cut_start = conf->l_max_erpm * conf->l_erpm_start;
 801ba30:	ee60 0aa7 	vmul.f32	s1, s1, s15
	if (rpm_now < rpm_pos_cut_start) {
 801ba34:	eeb4 9ae0 	vcmpe.f32	s18, s1
 801ba38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ba3c:	f140 80a4 	bpl.w	801bb88 <update_override_limits.constprop.4+0x308>
		lo_max_rpm = conf->l_current_max;
 801ba40:	edd4 ba01 	vldr	s23, [r4, #4]
	const float rpm_neg_cut_start = conf->l_min_erpm * conf->l_erpm_start;
 801ba44:	edd4 0a06 	vldr	s1, [r4, #24]
 801ba48:	edd4 7a08 	vldr	s15, [r4, #32]
	const float rpm_neg_cut_end = conf->l_min_erpm;
 801ba4c:	ed94 1a06 	vldr	s2, [r4, #24]
	const float rpm_neg_cut_start = conf->l_min_erpm * conf->l_erpm_start;
 801ba50:	ee60 0aa7 	vmul.f32	s1, s1, s15
	if (rpm_now > rpm_neg_cut_start) {
 801ba54:	eeb4 9ae0 	vcmpe.f32	s18, s1
 801ba58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ba5c:	f340 808b 	ble.w	801bb76 <update_override_limits.constprop.4+0x2f6>
		lo_min_rpm = conf->l_current_max;
 801ba60:	ed94 9a01 	vldr	s18, [r4, #4]
	float lo_max = utils_min_abs(lo_max_mos, lo_max_mot);
 801ba64:	eef0 0a4c 	vmov.f32	s1, s24
 801ba68:	eeb0 0a4b 	vmov.f32	s0, s22
 801ba6c:	f7fa fa50 	bl	8015f10 <utils_min_abs>
	float lo_min = utils_min_abs(lo_min_mos, lo_min_mot);
 801ba70:	eef0 0a69 	vmov.f32	s1, s19
	float lo_max = utils_min_abs(lo_max_mos, lo_max_mot);
 801ba74:	eeb0 ba40 	vmov.f32	s22, s0
	float lo_min = utils_min_abs(lo_min_mos, lo_min_mot);
 801ba78:	eeb0 0a68 	vmov.f32	s0, s17
 801ba7c:	f7fa fa48 	bl	8015f10 <utils_min_abs>
	lo_max = utils_min_abs(lo_max, lo_max_rpm);
 801ba80:	eef0 0a6b 	vmov.f32	s1, s23
	float lo_min = utils_min_abs(lo_min_mos, lo_min_mot);
 801ba84:	eef0 8a40 	vmov.f32	s17, s0
	lo_max = utils_min_abs(lo_max, lo_max_rpm);
 801ba88:	eeb0 0a4b 	vmov.f32	s0, s22
 801ba8c:	f7fa fa40 	bl	8015f10 <utils_min_abs>
	lo_max = utils_min_abs(lo_max, lo_min_rpm);
 801ba90:	eef0 0a49 	vmov.f32	s1, s18
 801ba94:	f7fa fa3c 	bl	8015f10 <utils_min_abs>
	lo_max = utils_min_abs(lo_max, lo_fet_temp_accel);
 801ba98:	eef0 0a6a 	vmov.f32	s1, s21
 801ba9c:	f7fa fa38 	bl	8015f10 <utils_min_abs>
	lo_max = utils_min_abs(lo_max, lo_motor_temp_accel);
 801baa0:	eef0 0a4a 	vmov.f32	s1, s20
 801baa4:	f7fa fa34 	bl	8015f10 <utils_min_abs>
	if (lo_max < conf->cc_min_current) {
 801baa8:	edd4 7a50 	vldr	s15, [r4, #320]	; 0x140
 801baac:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801bab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		lo_max = conf->cc_min_current;
 801bab4:	bf48      	it	mi
 801bab6:	ed94 0a50 	vldrmi	s0, [r4, #320]	; 0x140
	if (lo_min > -conf->cc_min_current) {
 801baba:	edd4 7a50 	vldr	s15, [r4, #320]	; 0x140
 801babe:	eef1 7a67 	vneg.f32	s15, s15
 801bac2:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bac6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		lo_min = -conf->cc_min_current;
 801baca:	bfc8      	it	gt
 801bacc:	edd4 8a50 	vldrgt	s17, [r4, #320]	; 0x140
	conf->lo_current_max = lo_max;
 801bad0:	ed84 0a19 	vstr	s0, [r4, #100]	; 0x64
		lo_min = -conf->cc_min_current;
 801bad4:	bfc8      	it	gt
 801bad6:	eef1 8a68 	vneggt.f32	s17, s17
	conf->lo_current_min = lo_min;
 801bada:	edc4 8a1a 	vstr	s17, [r4, #104]	; 0x68
	if (v_in > conf->l_battery_cut_start) {
 801bade:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
 801bae2:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801bae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801baea:	f300 811f 	bgt.w	801bd2c <update_override_limits.constprop.4+0x4ac>
	} else if (v_in < conf->l_battery_cut_end) {
 801baee:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
 801baf2:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801baf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bafa:	f140 811a 	bpl.w	801bd32 <update_override_limits.constprop.4+0x4b2>
		lo_in_max_batt = 0.0;
 801bafe:	eddf 0a4c 	vldr	s1, [pc, #304]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
	const float lo_in_max_watt = conf->l_watt_max / v_in;
 801bb02:	ed94 0a17 	vldr	s0, [r4, #92]	; 0x5c
	const float lo_in_min_watt = conf->l_watt_min / v_in;
 801bb06:	ed94 7a18 	vldr	s14, [r4, #96]	; 0x60
 801bb0a:	eec7 8a08 	vdiv.f32	s17, s14, s16
	const float lo_in_max = utils_min_abs(lo_in_max_watt, lo_in_max_batt);
 801bb0e:	ee80 0a08 	vdiv.f32	s0, s0, s16
 801bb12:	f7fa f9fd 	bl	8015f10 <utils_min_abs>
	conf->lo_in_current_max = utils_min_abs(conf->l_in_current_max, lo_in_max);
 801bb16:	edd4 7a03 	vldr	s15, [r4, #12]
 801bb1a:	eef0 0a40 	vmov.f32	s1, s0
 801bb1e:	eeb0 0a67 	vmov.f32	s0, s15
 801bb22:	f7fa f9f5 	bl	8015f10 <utils_min_abs>
 801bb26:	ed84 0a1b 	vstr	s0, [r4, #108]	; 0x6c
	conf->lo_in_current_min = utils_min_abs(conf->l_in_current_min, lo_in_min);
 801bb2a:	eef0 0a68 	vmov.f32	s1, s17
 801bb2e:	ed94 0a04 	vldr	s0, [r4, #16]
 801bb32:	f7fa f9ed 	bl	8015f10 <utils_min_abs>
}
 801bb36:	ecbd 8b0a 	vpop	{d8-d12}
	conf->lo_in_current_min = utils_min_abs(conf->l_in_current_min, lo_in_min);
 801bb3a:	ed84 0a1c 	vstr	s0, [r4, #112]	; 0x70
	conf->lo_current_motor_max_now = conf->lo_current_max;
 801bb3e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801bb40:	6763      	str	r3, [r4, #116]	; 0x74
	conf->lo_current_motor_min_now = conf->lo_current_min;
 801bb42:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 801bb44:	67a3      	str	r3, [r4, #120]	; 0x78
}
 801bb46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (m_temp_fet > conf->l_temp_fet_end) {
 801bb48:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
 801bb4c:	edd6 7a00 	vldr	s15, [r6]
 801bb50:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bb54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bb58:	d56c      	bpl.n	801bc34 <update_override_limits.constprop.4+0x3b4>
	if (m_fault_now == fault) {
 801bb5a:	4b33      	ldr	r3, [pc, #204]	; (801bc28 <update_override_limits.constprop.4+0x3a8>)
 801bb5c:	781b      	ldrb	r3, [r3, #0]
 801bb5e:	2b05      	cmp	r3, #5
 801bb60:	f040 814a 	bne.w	801bdf8 <update_override_limits.constprop.4+0x578>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801bb64:	4b31      	ldr	r3, [pc, #196]	; (801bc2c <update_override_limits.constprop.4+0x3ac>)
		lo_min_mos = 0.0;
 801bb66:	eddf 8a32 	vldr	s17, [pc, #200]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801bb6a:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
 801bb6e:	601a      	str	r2, [r3, #0]
		lo_max_mos = 0.0;
 801bb70:	eeb0 ba68 	vmov.f32	s22, s17
 801bb74:	e6fc      	b.n	801b970 <update_override_limits.constprop.4+0xf0>
	} else if (rpm_now < rpm_neg_cut_end) {
 801bb76:	eeb4 9ac1 	vcmpe.f32	s18, s2
 801bb7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bb7e:	f140 8110 	bpl.w	801bda2 <update_override_limits.constprop.4+0x522>
		lo_min_rpm = 0.0;
 801bb82:	ed9f 9a2b 	vldr	s18, [pc, #172]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bb86:	e76d      	b.n	801ba64 <update_override_limits.constprop.4+0x1e4>
	} else if (rpm_now > rpm_pos_cut_end) {
 801bb88:	eeb4 9ac1 	vcmpe.f32	s18, s2
 801bb8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bb90:	f340 80de 	ble.w	801bd50 <update_override_limits.constprop.4+0x4d0>
		lo_max_rpm = 0.0;
 801bb94:	eddf ba26 	vldr	s23, [pc, #152]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bb98:	e754      	b.n	801ba44 <update_override_limits.constprop.4+0x1c4>
	} else if (m_temp_motor > temp_motor_accel_end) {
 801bb9a:	edd5 7a00 	vldr	s15, [r5]
 801bb9e:	eef4 bae7 	vcmpe.f32	s23, s15
 801bba2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bba6:	f140 80de 	bpl.w	801bd66 <update_override_limits.constprop.4+0x4e6>
		lo_motor_temp_accel = 0.0;
 801bbaa:	ed9f aa21 	vldr	s20, [pc, #132]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bbae:	e739      	b.n	801ba24 <update_override_limits.constprop.4+0x1a4>
	} else if (m_temp_fet > temp_fet_accel_end) {
 801bbb0:	edd6 7a00 	vldr	s15, [r6]
 801bbb4:	eef4 cae7 	vcmpe.f32	s25, s15
 801bbb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bbbc:	f140 80e2 	bpl.w	801bd84 <update_override_limits.constprop.4+0x504>
		lo_fet_temp_accel = 0.0;
 801bbc0:	eddf aa1b 	vldr	s21, [pc, #108]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bbc4:	e724      	b.n	801ba10 <update_override_limits.constprop.4+0x190>
	} else if (m_temp_motor > conf->l_temp_motor_end) {
 801bbc6:	ed94 7a13 	vldr	s14, [r4, #76]	; 0x4c
 801bbca:	edd5 7a00 	vldr	s15, [r5]
 801bbce:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bbd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bbd6:	d56c      	bpl.n	801bcb2 <update_override_limits.constprop.4+0x432>
	if (m_fault_now == fault) {
 801bbd8:	4b13      	ldr	r3, [pc, #76]	; (801bc28 <update_override_limits.constprop.4+0x3a8>)
 801bbda:	781b      	ldrb	r3, [r3, #0]
 801bbdc:	2b06      	cmp	r3, #6
 801bbde:	f040 8103 	bne.w	801bde8 <update_override_limits.constprop.4+0x568>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801bbe2:	4b12      	ldr	r3, [pc, #72]	; (801bc2c <update_override_limits.constprop.4+0x3ac>)
		lo_min_mot = 0.0;
 801bbe4:	eddf 9a12 	vldr	s19, [pc, #72]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801bbe8:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
 801bbec:	601a      	str	r2, [r3, #0]
		lo_max_mot = 0.0;
 801bbee:	eeb0 ca69 	vmov.f32	s24, s19
 801bbf2:	e6cb      	b.n	801b98c <update_override_limits.constprop.4+0x10c>
 801bbf4:	2000c03c 	.word	0x2000c03c
 801bbf8:	3a534067 	.word	0x3a534067
 801bbfc:	2000c234 	.word	0x2000c234
 801bc00:	4195d174 	.word	0x4195d174
 801bc04:	2000c238 	.word	0x2000c238
 801bc08:	2000c074 	.word	0x2000c074
 801bc0c:	461c4000 	.word	0x461c4000
 801bc10:	3b5bcf0f 	.word	0x3b5bcf0f
 801bc14:	43889333 	.word	0x43889333
 801bc18:	3dcccccd 	.word	0x3dcccccd
 801bc1c:	4c1c363c 	.word	0x4c1c363c
 801bc20:	4556a000 	.word	0x4556a000
 801bc24:	457ff000 	.word	0x457ff000
 801bc28:	2000c1ec 	.word	0x2000c1ec
 801bc2c:	2000c1f0 	.word	0x2000c1f0
 801bc30:	00000000 	.word	0x00000000
		float maxc = fabsf(conf->l_current_max);
 801bc34:	edd4 1a01 	vldr	s3, [r4, #4]
		if (fabsf(conf->l_current_min) > maxc) {
 801bc38:	edd4 7a02 	vldr	s15, [r4, #8]
		maxc = utils_map(m_temp_fet, conf->l_temp_fet_start, conf->l_temp_fet_end, maxc, 0.0);
 801bc3c:	ed1f 2a04 	vldr	s4, [pc, #-16]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		float maxc = fabsf(conf->l_current_max);
 801bc40:	eef0 1ae1 	vabs.f32	s3, s3
		if (fabsf(conf->l_current_min) > maxc) {
 801bc44:	eef0 7ae7 	vabs.f32	s15, s15
 801bc48:	eef4 1ae7 	vcmpe.f32	s3, s15
 801bc4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			maxc = fabsf(conf->l_current_min);
 801bc50:	bf48      	it	mi
 801bc52:	edd4 1a02 	vldrmi	s3, [r4, #8]
		maxc = utils_map(m_temp_fet, conf->l_temp_fet_start, conf->l_temp_fet_end, maxc, 0.0);
 801bc56:	ed96 0a00 	vldr	s0, [r6]
 801bc5a:	edd4 0a10 	vldr	s1, [r4, #64]	; 0x40
 801bc5e:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
			maxc = fabsf(conf->l_current_min);
 801bc62:	bf48      	it	mi
 801bc64:	eef0 1ae1 	vabsmi.f32	s3, s3
		maxc = utils_map(m_temp_fet, conf->l_temp_fet_start, conf->l_temp_fet_end, maxc, 0.0);
 801bc68:	f7f9 ff4a 	bl	8015b00 <utils_map>
		if (fabsf(conf->l_current_max) > maxc) {
 801bc6c:	edd4 7a01 	vldr	s15, [r4, #4]
 801bc70:	eef0 7ae7 	vabs.f32	s15, s15
 801bc74:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801bc78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		maxc = utils_map(m_temp_fet, conf->l_temp_fet_start, conf->l_temp_fet_end, maxc, 0.0);
 801bc7c:	eef0 8a40 	vmov.f32	s17, s0
		if (fabsf(conf->l_current_max) > maxc) {
 801bc80:	f100 80a6 	bmi.w	801bdd0 <update_override_limits.constprop.4+0x550>
	float lo_max_mos = 0.0;
 801bc84:	ed1f ba16 	vldr	s22, [pc, #-88]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		if (fabsf(conf->l_current_min) > maxc) {
 801bc88:	edd4 7a02 	vldr	s15, [r4, #8]
 801bc8c:	eef0 7ae7 	vabs.f32	s15, s15
 801bc90:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bc94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc98:	f140 80b9 	bpl.w	801be0e <update_override_limits.constprop.4+0x58e>
			lo_min_mos = SIGN(conf->l_current_min) * maxc;
 801bc9c:	edd4 7a02 	vldr	s15, [r4, #8]
 801bca0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801bca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bca8:	f57f ae62 	bpl.w	801b970 <update_override_limits.constprop.4+0xf0>
 801bcac:	eef1 8a68 	vneg.f32	s17, s17
 801bcb0:	e65e      	b.n	801b970 <update_override_limits.constprop.4+0xf0>
		float maxc = fabsf(conf->l_current_max);
 801bcb2:	edd4 1a01 	vldr	s3, [r4, #4]
		if (fabsf(conf->l_current_min) > maxc) {
 801bcb6:	edd4 7a02 	vldr	s15, [r4, #8]
		maxc = utils_map(m_temp_motor, conf->l_temp_motor_start, conf->l_temp_motor_end, maxc, 0.0);
 801bcba:	ed1f 2a23 	vldr	s4, [pc, #-140]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		float maxc = fabsf(conf->l_current_max);
 801bcbe:	eef0 1ae1 	vabs.f32	s3, s3
		if (fabsf(conf->l_current_min) > maxc) {
 801bcc2:	eef0 7ae7 	vabs.f32	s15, s15
 801bcc6:	eef4 1ae7 	vcmpe.f32	s3, s15
 801bcca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			maxc = fabsf(conf->l_current_min);
 801bcce:	bf48      	it	mi
 801bcd0:	edd4 1a02 	vldrmi	s3, [r4, #8]
		maxc = utils_map(m_temp_motor, conf->l_temp_motor_start, conf->l_temp_motor_end, maxc, 0.0);
 801bcd4:	ed95 0a00 	vldr	s0, [r5]
 801bcd8:	edd4 0a12 	vldr	s1, [r4, #72]	; 0x48
 801bcdc:	ed94 1a13 	vldr	s2, [r4, #76]	; 0x4c
			maxc = fabsf(conf->l_current_min);
 801bce0:	bf48      	it	mi
 801bce2:	eef0 1ae1 	vabsmi.f32	s3, s3
		maxc = utils_map(m_temp_motor, conf->l_temp_motor_start, conf->l_temp_motor_end, maxc, 0.0);
 801bce6:	f7f9 ff0b 	bl	8015b00 <utils_map>
		if (fabsf(conf->l_current_max) > maxc) {
 801bcea:	edd4 7a01 	vldr	s15, [r4, #4]
 801bcee:	eef0 7ae7 	vabs.f32	s15, s15
 801bcf2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801bcf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		maxc = utils_map(m_temp_motor, conf->l_temp_motor_start, conf->l_temp_motor_end, maxc, 0.0);
 801bcfa:	eef0 9a40 	vmov.f32	s19, s0
		if (fabsf(conf->l_current_max) > maxc) {
 801bcfe:	d45b      	bmi.n	801bdb8 <update_override_limits.constprop.4+0x538>
	float lo_max_mot = 0.0;
 801bd00:	ed1f ca35 	vldr	s24, [pc, #-212]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
		if (fabsf(conf->l_current_min) > maxc) {
 801bd04:	edd4 7a02 	vldr	s15, [r4, #8]
 801bd08:	eef0 7ae7 	vabs.f32	s15, s15
 801bd0c:	eef4 9ae7 	vcmpe.f32	s19, s15
 801bd10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd14:	d578      	bpl.n	801be08 <update_override_limits.constprop.4+0x588>
			lo_min_mot = SIGN(conf->l_current_min) * maxc;
 801bd16:	edd4 7a02 	vldr	s15, [r4, #8]
 801bd1a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801bd1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd22:	f57f ae33 	bpl.w	801b98c <update_override_limits.constprop.4+0x10c>
 801bd26:	eef1 9a69 	vneg.f32	s19, s19
 801bd2a:	e62f      	b.n	801b98c <update_override_limits.constprop.4+0x10c>
		lo_in_max_batt = conf->l_in_current_max;
 801bd2c:	edd4 0a03 	vldr	s1, [r4, #12]
 801bd30:	e6e7      	b.n	801bb02 <update_override_limits.constprop.4+0x282>
		lo_in_max_batt = utils_map(v_in, conf->l_battery_cut_start,
 801bd32:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 801bd36:	ed1f 2a42 	vldr	s4, [pc, #-264]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bd3a:	ed94 1a0e 	vldr	s2, [r4, #56]	; 0x38
 801bd3e:	edd4 1a03 	vldr	s3, [r4, #12]
 801bd42:	eeb0 0a48 	vmov.f32	s0, s16
 801bd46:	f7f9 fedb 	bl	8015b00 <utils_map>
 801bd4a:	eef0 0a40 	vmov.f32	s1, s0
 801bd4e:	e6d8      	b.n	801bb02 <update_override_limits.constprop.4+0x282>
		lo_max_rpm = utils_map(rpm_now, rpm_pos_cut_start, rpm_pos_cut_end, conf->l_current_max, 0.0);
 801bd50:	edd4 1a01 	vldr	s3, [r4, #4]
 801bd54:	ed1f 2a4a 	vldr	s4, [pc, #-296]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bd58:	eeb0 0a49 	vmov.f32	s0, s18
 801bd5c:	f7f9 fed0 	bl	8015b00 <utils_map>
 801bd60:	eef0 ba40 	vmov.f32	s23, s0
 801bd64:	e66e      	b.n	801ba44 <update_override_limits.constprop.4+0x1c4>
		lo_motor_temp_accel = utils_map(m_temp_motor, temp_motor_accel_start,
 801bd66:	ed95 0a00 	vldr	s0, [r5]
 801bd6a:	ed1f 2a4f 	vldr	s4, [pc, #-316]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bd6e:	edd4 1a01 	vldr	s3, [r4, #4]
 801bd72:	eef0 0a4a 	vmov.f32	s1, s20
 801bd76:	eeb0 1a6b 	vmov.f32	s2, s23
 801bd7a:	f7f9 fec1 	bl	8015b00 <utils_map>
 801bd7e:	eeb0 aa40 	vmov.f32	s20, s0
 801bd82:	e64f      	b.n	801ba24 <update_override_limits.constprop.4+0x1a4>
		lo_fet_temp_accel = utils_map(m_temp_fet, temp_fet_accel_start,
 801bd84:	ed96 0a00 	vldr	s0, [r6]
 801bd88:	ed1f 2a57 	vldr	s4, [pc, #-348]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bd8c:	edd4 1a01 	vldr	s3, [r4, #4]
 801bd90:	eef0 0a6a 	vmov.f32	s1, s21
 801bd94:	eeb0 1a6c 	vmov.f32	s2, s25
 801bd98:	f7f9 feb2 	bl	8015b00 <utils_map>
 801bd9c:	eef0 aa40 	vmov.f32	s21, s0
 801bda0:	e636      	b.n	801ba10 <update_override_limits.constprop.4+0x190>
		lo_min_rpm = utils_map(rpm_now, rpm_neg_cut_start, rpm_neg_cut_end, conf->l_current_max, 0.0);
 801bda2:	eeb0 0a49 	vmov.f32	s0, s18
 801bda6:	edd4 1a01 	vldr	s3, [r4, #4]
 801bdaa:	ed1f 2a5f 	vldr	s4, [pc, #-380]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bdae:	f7f9 fea7 	bl	8015b00 <utils_map>
 801bdb2:	eeb0 9a40 	vmov.f32	s18, s0
 801bdb6:	e655      	b.n	801ba64 <update_override_limits.constprop.4+0x1e4>
			lo_max_mot = SIGN(conf->l_current_max) * maxc;
 801bdb8:	edd4 7a01 	vldr	s15, [r4, #4]
 801bdbc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801bdc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bdc4:	bf4c      	ite	mi
 801bdc6:	eeb1 ca40 	vnegmi.f32	s24, s0
 801bdca:	eeb0 ca40 	vmovpl.f32	s24, s0
 801bdce:	e799      	b.n	801bd04 <update_override_limits.constprop.4+0x484>
			lo_max_mos = SIGN(conf->l_current_max) * maxc;
 801bdd0:	edd4 7a01 	vldr	s15, [r4, #4]
 801bdd4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801bdd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bddc:	bf4c      	ite	mi
 801bdde:	eeb1 ba40 	vnegmi.f32	s22, s0
 801bde2:	eeb0 ba40 	vmovpl.f32	s22, s0
 801bde6:	e74f      	b.n	801bc88 <update_override_limits.constprop.4+0x408>
		lo_min_mot = 0.0;
 801bde8:	ed5f 9a6f 	vldr	s19, [pc, #-444]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bdec:	2006      	movs	r0, #6
		lo_max_mot = 0.0;
 801bdee:	eeb0 ca69 	vmov.f32	s24, s19
 801bdf2:	f7ff fca5 	bl	801b740 <mc_interface_fault_stop.part.3>
 801bdf6:	e5c9      	b.n	801b98c <update_override_limits.constprop.4+0x10c>
		lo_min_mos = 0.0;
 801bdf8:	ed5f 8a73 	vldr	s17, [pc, #-460]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801bdfc:	2005      	movs	r0, #5
		lo_max_mos = 0.0;
 801bdfe:	eeb0 ba68 	vmov.f32	s22, s17
 801be02:	f7ff fc9d 	bl	801b740 <mc_interface_fault_stop.part.3>
 801be06:	e5b3      	b.n	801b970 <update_override_limits.constprop.4+0xf0>
	float lo_min_mot = 0.0;
 801be08:	ed5f 9a77 	vldr	s19, [pc, #-476]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801be0c:	e5be      	b.n	801b98c <update_override_limits.constprop.4+0x10c>
	float lo_min_mos = 0.0;
 801be0e:	ed5f 8a78 	vldr	s17, [pc, #-480]	; 801bc30 <update_override_limits.constprop.4+0x3b0>
 801be12:	e5ad      	b.n	801b970 <update_override_limits.constprop.4+0xf0>
	...

0801be20 <mc_interface_set_configuration>:
void mc_interface_set_configuration(mc_configuration *configuration) {
 801be20:	b538      	push	{r3, r4, r5, lr}
	if (m_conf.m_sensor_port_mode != configuration->m_sensor_port_mode) {
 801be22:	4d35      	ldr	r5, [pc, #212]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801be24:	f890 315c 	ldrb.w	r3, [r0, #348]	; 0x15c
 801be28:	f895 215c 	ldrb.w	r2, [r5, #348]	; 0x15c
 801be2c:	429a      	cmp	r2, r3
void mc_interface_set_configuration(mc_configuration *configuration) {
 801be2e:	4604      	mov	r4, r0
	if (m_conf.m_sensor_port_mode != configuration->m_sensor_port_mode) {
 801be30:	d11e      	bne.n	801be70 <mc_interface_set_configuration+0x50>
	if (configuration->m_sensor_port_mode == SENSOR_PORT_MODE_ABI) {
 801be32:	2b01      	cmp	r3, #1
 801be34:	d02a      	beq.n	801be8c <mc_interface_set_configuration+0x6c>
	if (m_conf.motor_type == MOTOR_TYPE_FOC
 801be36:	78ab      	ldrb	r3, [r5, #2]
 801be38:	2b02      	cmp	r3, #2
 801be3a:	d02e      	beq.n	801be9a <mc_interface_set_configuration+0x7a>
	} else if (m_conf.motor_type != MOTOR_TYPE_FOC
 801be3c:	78ab      	ldrb	r3, [r5, #2]
 801be3e:	2b02      	cmp	r3, #2
 801be40:	d002      	beq.n	801be48 <mc_interface_set_configuration+0x28>
			&& configuration->motor_type == MOTOR_TYPE_FOC) {
 801be42:	78a3      	ldrb	r3, [r4, #2]
 801be44:	2b02      	cmp	r3, #2
 801be46:	d02e      	beq.n	801bea6 <mc_interface_set_configuration+0x86>
		m_conf = *configuration;
 801be48:	4621      	mov	r1, r4
 801be4a:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801be4e:	482a      	ldr	r0, [pc, #168]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801be50:	f7f0 fe66 	bl	800cb20 <memcpy>
	update_override_limits(&m_conf);
 801be54:	f7ff fd14 	bl	801b880 <update_override_limits.constprop.4>
	switch (m_conf.motor_type) {
 801be58:	78ab      	ldrb	r3, [r5, #2]
 801be5a:	b2db      	uxtb	r3, r3
 801be5c:	2b01      	cmp	r3, #1
 801be5e:	d933      	bls.n	801bec8 <mc_interface_set_configuration+0xa8>
 801be60:	2b02      	cmp	r3, #2
 801be62:	d104      	bne.n	801be6e <mc_interface_set_configuration+0x4e>
		mcpwm_foc_set_configuration(&m_conf);
 801be64:	4824      	ldr	r0, [pc, #144]	; (801bef8 <mc_interface_set_configuration+0xd8>)
}
 801be66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mcpwm_foc_set_configuration(&m_conf);
 801be6a:	f001 bd91 	b.w	801d990 <mcpwm_foc_set_configuration>
}
 801be6e:	bd38      	pop	{r3, r4, r5, pc}
		encoder_deinit();
 801be70:	f7fe fe36 	bl	801aae0 <encoder_deinit>
		switch (configuration->m_sensor_port_mode) {
 801be74:	f894 315c 	ldrb.w	r3, [r4, #348]	; 0x15c
 801be78:	2b01      	cmp	r3, #1
 801be7a:	d036      	beq.n	801beea <mc_interface_set_configuration+0xca>
 801be7c:	2b02      	cmp	r3, #2
 801be7e:	d1da      	bne.n	801be36 <mc_interface_set_configuration+0x16>
			encoder_init_as5047p_spi();
 801be80:	f7fe fece 	bl	801ac20 <encoder_init_as5047p_spi>
 801be84:	f894 315c 	ldrb.w	r3, [r4, #348]	; 0x15c
	if (configuration->m_sensor_port_mode == SENSOR_PORT_MODE_ABI) {
 801be88:	2b01      	cmp	r3, #1
 801be8a:	d1d4      	bne.n	801be36 <mc_interface_set_configuration+0x16>
		encoder_set_counts(configuration->m_encoder_counts);
 801be8c:	f8d4 0158 	ldr.w	r0, [r4, #344]	; 0x158
 801be90:	f7fe ffde 	bl	801ae50 <encoder_set_counts>
	if (m_conf.motor_type == MOTOR_TYPE_FOC
 801be94:	78ab      	ldrb	r3, [r5, #2]
 801be96:	2b02      	cmp	r3, #2
 801be98:	d1d0      	bne.n	801be3c <mc_interface_set_configuration+0x1c>
			&& configuration->motor_type != MOTOR_TYPE_FOC) {
 801be9a:	78a3      	ldrb	r3, [r4, #2]
 801be9c:	2b02      	cmp	r3, #2
 801be9e:	d118      	bne.n	801bed2 <mc_interface_set_configuration+0xb2>
	} else if (m_conf.motor_type != MOTOR_TYPE_FOC
 801bea0:	78ab      	ldrb	r3, [r5, #2]
 801bea2:	2b02      	cmp	r3, #2
 801bea4:	d0d0      	beq.n	801be48 <mc_interface_set_configuration+0x28>
		mcpwm_deinit();
 801bea6:	f7f7 f9cb 	bl	8013240 <mcpwm_deinit>
		m_conf = *configuration;
 801beaa:	4621      	mov	r1, r4
 801beac:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801beb0:	4811      	ldr	r0, [pc, #68]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801beb2:	f7f0 fe35 	bl	800cb20 <memcpy>
		mcpwm_foc_init(&m_conf);
 801beb6:	4810      	ldr	r0, [pc, #64]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801beb8:	f001 fa82 	bl	801d3c0 <mcpwm_foc_init>
	update_override_limits(&m_conf);
 801bebc:	f7ff fce0 	bl	801b880 <update_override_limits.constprop.4>
	switch (m_conf.motor_type) {
 801bec0:	78ab      	ldrb	r3, [r5, #2]
 801bec2:	b2db      	uxtb	r3, r3
 801bec4:	2b01      	cmp	r3, #1
 801bec6:	d8cb      	bhi.n	801be60 <mc_interface_set_configuration+0x40>
		mcpwm_set_configuration(&m_conf);
 801bec8:	480b      	ldr	r0, [pc, #44]	; (801bef8 <mc_interface_set_configuration+0xd8>)
}
 801beca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mcpwm_set_configuration(&m_conf);
 801bece:	f7f7 bd47 	b.w	8013960 <mcpwm_set_configuration>
		mcpwm_foc_deinit();
 801bed2:	f001 fd1d 	bl	801d910 <mcpwm_foc_deinit>
		m_conf = *configuration;
 801bed6:	4621      	mov	r1, r4
 801bed8:	f44f 72ba 	mov.w	r2, #372	; 0x174
 801bedc:	4806      	ldr	r0, [pc, #24]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801bede:	f7f0 fe1f 	bl	800cb20 <memcpy>
		mcpwm_init(&m_conf);
 801bee2:	4805      	ldr	r0, [pc, #20]	; (801bef8 <mc_interface_set_configuration+0xd8>)
 801bee4:	f7f7 fa1c 	bl	8013320 <mcpwm_init>
 801bee8:	e7b4      	b.n	801be54 <mc_interface_set_configuration+0x34>
			encoder_init_abi(configuration->m_encoder_counts);
 801beea:	f8d4 0158 	ldr.w	r0, [r4, #344]	; 0x158
 801beee:	f7fe fe37 	bl	801ab60 <encoder_init_abi>
 801bef2:	f894 315c 	ldrb.w	r3, [r4, #348]	; 0x15c
			break;
 801bef6:	e79c      	b.n	801be32 <mc_interface_set_configuration+0x12>
 801bef8:	2000c074 	.word	0x2000c074
 801befc:	00000000 	.word	0x00000000

0801bf00 <timer_thread>:
 801bf00:	4b0c      	ldr	r3, [pc, #48]	; (801bf34 <timer_thread+0x34>)
 801bf02:	4a0d      	ldr	r2, [pc, #52]	; (801bf38 <timer_thread+0x38>)
 801bf04:	699b      	ldr	r3, [r3, #24]
 801bf06:	4c0d      	ldr	r4, [pc, #52]	; (801bf3c <timer_thread+0x3c>)
			if (!IS_DRV_FAULT()) {
 801bf08:	4d0d      	ldr	r5, [pc, #52]	; (801bf40 <timer_thread+0x40>)
static THD_FUNCTION(timer_thread, arg) {
 801bf0a:	b580      	push	{r7, lr}
				m_fault_now = FAULT_CODE_NONE;
 801bf0c:	2600      	movs	r6, #0
 801bf0e:	4f0d      	ldr	r7, [pc, #52]	; (801bf44 <timer_thread+0x44>)
 801bf10:	619a      	str	r2, [r3, #24]
 801bf12:	e005      	b.n	801bf20 <timer_thread+0x20>
			m_ignore_iterations--;
 801bf14:	6023      	str	r3, [r4, #0]
		update_override_limits(&m_conf);
 801bf16:	f7ff fcb3 	bl	801b880 <update_override_limits.constprop.4>
		chThdSleepMilliseconds(1);
 801bf1a:	200a      	movs	r0, #10
 801bf1c:	f7f1 fd60 	bl	800d9e0 <chThdSleep>
		if (m_ignore_iterations > 0) {
 801bf20:	6823      	ldr	r3, [r4, #0]
 801bf22:	2b00      	cmp	r3, #0
			m_ignore_iterations--;
 801bf24:	f103 33ff 	add.w	r3, r3, #4294967295
		if (m_ignore_iterations > 0) {
 801bf28:	dcf4      	bgt.n	801bf14 <timer_thread+0x14>
			if (!IS_DRV_FAULT()) {
 801bf2a:	692b      	ldr	r3, [r5, #16]
 801bf2c:	04db      	lsls	r3, r3, #19
				m_fault_now = FAULT_CODE_NONE;
 801bf2e:	bf48      	it	mi
 801bf30:	703e      	strbmi	r6, [r7, #0]
 801bf32:	e7f0      	b.n	801bf16 <timer_thread+0x16>
 801bf34:	20001a48 	.word	0x20001a48
 801bf38:	0802f3c0 	.word	0x0802f3c0
 801bf3c:	2000c1f0 	.word	0x2000c1f0
 801bf40:	40020800 	.word	0x40020800
 801bf44:	2000c1ec 	.word	0x2000c1ec
	...

0801bf50 <mc_interface_get_tachometer_abs_value>:
	switch (m_conf.motor_type) {
 801bf50:	4b06      	ldr	r3, [pc, #24]	; (801bf6c <mc_interface_get_tachometer_abs_value+0x1c>)
 801bf52:	789b      	ldrb	r3, [r3, #2]
 801bf54:	b2db      	uxtb	r3, r3
 801bf56:	2b01      	cmp	r3, #1
 801bf58:	d905      	bls.n	801bf66 <mc_interface_get_tachometer_abs_value+0x16>
 801bf5a:	2b02      	cmp	r3, #2
 801bf5c:	d101      	bne.n	801bf62 <mc_interface_get_tachometer_abs_value+0x12>
		ret = mcpwm_foc_get_tachometer_abs_value(reset);
 801bf5e:	f001 bf1f 	b.w	801dda0 <mcpwm_foc_get_tachometer_abs_value>
}
 801bf62:	2000      	movs	r0, #0
 801bf64:	4770      	bx	lr
		ret = mcpwm_get_tachometer_abs_value(reset);
 801bf66:	f7f7 be4b 	b.w	8013c00 <mcpwm_get_tachometer_abs_value>
 801bf6a:	bf00      	nop
 801bf6c:	2000c074 	.word	0x2000c074

0801bf70 <mc_interface_get_last_inj_adc_isr_duration>:
	switch (m_conf.motor_type) {
 801bf70:	4b06      	ldr	r3, [pc, #24]	; (801bf8c <mc_interface_get_last_inj_adc_isr_duration+0x1c>)
 801bf72:	789b      	ldrb	r3, [r3, #2]
 801bf74:	b2db      	uxtb	r3, r3
 801bf76:	2b01      	cmp	r3, #1
 801bf78:	d906      	bls.n	801bf88 <mc_interface_get_last_inj_adc_isr_duration+0x18>
 801bf7a:	2b02      	cmp	r3, #2
 801bf7c:	d101      	bne.n	801bf82 <mc_interface_get_last_inj_adc_isr_duration+0x12>
		ret = mcpwm_foc_get_last_inj_adc_isr_duration();
 801bf7e:	f002 be6f 	b.w	801ec60 <mcpwm_foc_get_last_inj_adc_isr_duration>
}
 801bf82:	ed9f 0a03 	vldr	s0, [pc, #12]	; 801bf90 <mc_interface_get_last_inj_adc_isr_duration+0x20>
 801bf86:	4770      	bx	lr
		ret = mcpwm_get_last_inj_adc_isr_duration();
 801bf88:	f7f8 b95a 	b.w	8014240 <mcpwm_get_last_inj_adc_isr_duration>
 801bf8c:	2000c074 	.word	0x2000c074
	...

0801bfa0 <mc_interface_read_reset_avg_motor_current>:
	float res = m_motor_current_sum / m_motor_current_iterations;
 801bfa0:	4905      	ldr	r1, [pc, #20]	; (801bfb8 <mc_interface_read_reset_avg_motor_current+0x18>)
 801bfa2:	4b06      	ldr	r3, [pc, #24]	; (801bfbc <mc_interface_read_reset_avg_motor_current+0x1c>)
 801bfa4:	ed91 0a00 	vldr	s0, [r1]
 801bfa8:	edd3 7a00 	vldr	s15, [r3]
	m_motor_current_sum = 0.0;
 801bfac:	2200      	movs	r2, #0
 801bfae:	600a      	str	r2, [r1, #0]
}
 801bfb0:	ee80 0a27 	vdiv.f32	s0, s0, s15
	m_motor_current_iterations = 0.0;
 801bfb4:	601a      	str	r2, [r3, #0]
}
 801bfb6:	4770      	bx	lr
 801bfb8:	2000c208 	.word	0x2000c208
 801bfbc:	2000c204 	.word	0x2000c204

0801bfc0 <mc_interface_read_reset_avg_input_current>:
	float res = m_input_current_sum / m_input_current_iterations;
 801bfc0:	4905      	ldr	r1, [pc, #20]	; (801bfd8 <mc_interface_read_reset_avg_input_current+0x18>)
 801bfc2:	4b06      	ldr	r3, [pc, #24]	; (801bfdc <mc_interface_read_reset_avg_input_current+0x1c>)
 801bfc4:	ed91 0a00 	vldr	s0, [r1]
 801bfc8:	edd3 7a00 	vldr	s15, [r3]
	m_input_current_sum = 0.0;
 801bfcc:	2200      	movs	r2, #0
 801bfce:	600a      	str	r2, [r1, #0]
}
 801bfd0:	ee80 0a27 	vdiv.f32	s0, s0, s15
	m_input_current_iterations = 0.0;
 801bfd4:	601a      	str	r2, [r3, #0]
}
 801bfd6:	4770      	bx	lr
 801bfd8:	2000c1f8 	.word	0x2000c1f8
 801bfdc:	2000c1f4 	.word	0x2000c1f4

0801bfe0 <mc_interface_read_reset_avg_id>:
	float res = m_motor_id_sum / m_motor_id_iterations;
 801bfe0:	4b08      	ldr	r3, [pc, #32]	; (801c004 <mc_interface_read_reset_avg_id+0x24>)
 801bfe2:	4909      	ldr	r1, [pc, #36]	; (801c008 <mc_interface_read_reset_avg_id+0x28>)
	return DIR_MULT * res; // TODO: DIR_MULT?
 801bfe4:	4809      	ldr	r0, [pc, #36]	; (801c00c <mc_interface_read_reset_avg_id+0x2c>)
	float res = m_motor_id_sum / m_motor_id_iterations;
 801bfe6:	ed91 7a00 	vldr	s14, [r1]
 801bfea:	edd3 7a00 	vldr	s15, [r3]
	m_motor_id_sum = 0.0;
 801bfee:	2200      	movs	r2, #0
 801bff0:	600a      	str	r2, [r1, #0]
	m_motor_id_iterations = 0.0;
 801bff2:	601a      	str	r2, [r3, #0]
	return DIR_MULT * res; // TODO: DIR_MULT?
 801bff4:	f890 315d 	ldrb.w	r3, [r0, #349]	; 0x15d
	float res = m_motor_id_sum / m_motor_id_iterations;
 801bff8:	ee87 0a27 	vdiv.f32	s0, s14, s15
	return DIR_MULT * res; // TODO: DIR_MULT?
 801bffc:	b10b      	cbz	r3, 801c002 <mc_interface_read_reset_avg_id+0x22>
 801bffe:	eeb1 0a40 	vneg.f32	s0, s0
}
 801c002:	4770      	bx	lr
 801c004:	2000c20c 	.word	0x2000c20c
 801c008:	2000c210 	.word	0x2000c210
 801c00c:	2000c074 	.word	0x2000c074

0801c010 <mc_interface_read_reset_avg_iq>:
	float res = m_motor_iq_sum / m_motor_iq_iterations;
 801c010:	4b08      	ldr	r3, [pc, #32]	; (801c034 <mc_interface_read_reset_avg_iq+0x24>)
 801c012:	4909      	ldr	r1, [pc, #36]	; (801c038 <mc_interface_read_reset_avg_iq+0x28>)
	return DIR_MULT * res;
 801c014:	4809      	ldr	r0, [pc, #36]	; (801c03c <mc_interface_read_reset_avg_iq+0x2c>)
	float res = m_motor_iq_sum / m_motor_iq_iterations;
 801c016:	ed91 7a00 	vldr	s14, [r1]
 801c01a:	edd3 7a00 	vldr	s15, [r3]
	m_motor_iq_sum = 0.0;
 801c01e:	2200      	movs	r2, #0
 801c020:	600a      	str	r2, [r1, #0]
	m_motor_iq_iterations = 0.0;
 801c022:	601a      	str	r2, [r3, #0]
	return DIR_MULT * res;
 801c024:	f890 315d 	ldrb.w	r3, [r0, #349]	; 0x15d
	float res = m_motor_iq_sum / m_motor_iq_iterations;
 801c028:	ee87 0a27 	vdiv.f32	s0, s14, s15
	return DIR_MULT * res;
 801c02c:	b10b      	cbz	r3, 801c032 <mc_interface_read_reset_avg_iq+0x22>
 801c02e:	eeb1 0a40 	vneg.f32	s0, s0
}
 801c032:	4770      	bx	lr
 801c034:	2000c214 	.word	0x2000c214
 801c038:	2000c218 	.word	0x2000c218
 801c03c:	2000c074 	.word	0x2000c074

0801c040 <mc_interface_get_pid_pos_set>:
	return m_position_set;
 801c040:	4b01      	ldr	r3, [pc, #4]	; (801c048 <mc_interface_get_pid_pos_set+0x8>)
 801c042:	ed93 0a00 	vldr	s0, [r3]
}
 801c046:	4770      	bx	lr
 801c048:	2000c21c 	.word	0x2000c21c
 801c04c:	00000000 	.word	0x00000000

0801c050 <mc_interface_get_pid_pos_now>:
float mc_interface_get_pid_pos_now(void) {
 801c050:	b510      	push	{r4, lr}
	switch (m_conf.motor_type) {
 801c052:	4c0b      	ldr	r4, [pc, #44]	; (801c080 <mc_interface_get_pid_pos_now+0x30>)
 801c054:	78a3      	ldrb	r3, [r4, #2]
 801c056:	b2db      	uxtb	r3, r3
 801c058:	2b01      	cmp	r3, #1
 801c05a:	d90d      	bls.n	801c078 <mc_interface_get_pid_pos_now+0x28>
 801c05c:	2b02      	cmp	r3, #2
 801c05e:	d008      	beq.n	801c072 <mc_interface_get_pid_pos_now+0x22>
	float ret = 0.0;
 801c060:	ed9f 0a08 	vldr	s0, [pc, #32]	; 801c084 <mc_interface_get_pid_pos_now+0x34>
	return DIR_MULT * ret;
 801c064:	f894 315d 	ldrb.w	r3, [r4, #349]	; 0x15d
 801c068:	b903      	cbnz	r3, 801c06c <mc_interface_get_pid_pos_now+0x1c>
}
 801c06a:	bd10      	pop	{r4, pc}
 801c06c:	eeb1 0a40 	vneg.f32	s0, s0
 801c070:	bd10      	pop	{r4, pc}
		ret = mcpwm_foc_get_pid_pos_now();
 801c072:	f001 fdf5 	bl	801dc60 <mcpwm_foc_get_pid_pos_now>
		break;
 801c076:	e7f5      	b.n	801c064 <mc_interface_get_pid_pos_now+0x14>
		ret = encoder_read_deg();
 801c078:	f7fe fe22 	bl	801acc0 <encoder_read_deg>
		break;
 801c07c:	e7f2      	b.n	801c064 <mc_interface_get_pid_pos_now+0x14>
 801c07e:	bf00      	nop
 801c080:	2000c074 	.word	0x2000c074
	...

0801c090 <mc_interface_get_last_sample_adc_isr_duration>:
	return m_last_adc_duration_sample;
 801c090:	4b01      	ldr	r3, [pc, #4]	; (801c098 <mc_interface_get_last_sample_adc_isr_duration+0x8>)
 801c092:	ed93 0a00 	vldr	s0, [r3]
}
 801c096:	4770      	bx	lr
 801c098:	2000c1fc 	.word	0x2000c1fc
 801c09c:	00000000 	.word	0x00000000

0801c0a0 <mc_interface_sample_print_data>:
void mc_interface_sample_print_data(debug_sampling_mode mode, uint16_t len, uint8_t decimation) {
 801c0a0:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
 801c0a4:	bf28      	it	cs
 801c0a6:	f44f 61fa 	movcs.w	r1, #2000	; 0x7d0
	if (mode == DEBUG_SAMPLING_SEND_LAST_SAMPLES) {
 801c0aa:	2807      	cmp	r0, #7
 801c0ac:	d00f      	beq.n	801c0ce <mc_interface_sample_print_data+0x2e>
void mc_interface_sample_print_data(debug_sampling_mode mode, uint16_t len, uint8_t decimation) {
 801c0ae:	b4f0      	push	{r4, r5, r6, r7}
		m_sample_trigger = -1;
 801c0b0:	4e09      	ldr	r6, [pc, #36]	; (801c0d8 <mc_interface_sample_print_data+0x38>)
		m_sample_now = 0;
 801c0b2:	4b0a      	ldr	r3, [pc, #40]	; (801c0dc <mc_interface_sample_print_data+0x3c>)
		m_sample_len = len;
 801c0b4:	4d0a      	ldr	r5, [pc, #40]	; (801c0e0 <mc_interface_sample_print_data+0x40>)
		m_sample_int = decimation;
 801c0b6:	4c0b      	ldr	r4, [pc, #44]	; (801c0e4 <mc_interface_sample_print_data+0x44>)
		m_sample_trigger = -1;
 801c0b8:	f04f 37ff 	mov.w	r7, #4294967295
 801c0bc:	6037      	str	r7, [r6, #0]
		m_sample_now = 0;
 801c0be:	2600      	movs	r6, #0
 801c0c0:	601e      	str	r6, [r3, #0]
		m_sample_mode = mode;
 801c0c2:	4b09      	ldr	r3, [pc, #36]	; (801c0e8 <mc_interface_sample_print_data+0x48>)
		m_sample_len = len;
 801c0c4:	6029      	str	r1, [r5, #0]
		m_sample_int = decimation;
 801c0c6:	6022      	str	r2, [r4, #0]
		m_sample_mode = mode;
 801c0c8:	7018      	strb	r0, [r3, #0]
}
 801c0ca:	bcf0      	pop	{r4, r5, r6, r7}
 801c0cc:	4770      	bx	lr
		chEvtSignal(sample_send_tp, (eventmask_t) 1);
 801c0ce:	4b07      	ldr	r3, [pc, #28]	; (801c0ec <mc_interface_sample_print_data+0x4c>)
 801c0d0:	2101      	movs	r1, #1
 801c0d2:	6818      	ldr	r0, [r3, #0]
 801c0d4:	f7f1 bed4 	b.w	800de80 <chEvtSignal>
 801c0d8:	2000c230 	.word	0x2000c230
 801c0dc:	2000c22c 	.word	0x2000c22c
 801c0e0:	2000c224 	.word	0x2000c224
 801c0e4:	2000c220 	.word	0x2000c220
 801c0e8:	2000c228 	.word	0x2000c228
 801c0ec:	2000c7e0 	.word	0x2000c7e0

0801c0f0 <mc_interface_temp_fet_filtered>:
	return m_temp_fet;
 801c0f0:	4b01      	ldr	r3, [pc, #4]	; (801c0f8 <mc_interface_temp_fet_filtered+0x8>)
 801c0f2:	ed93 0a00 	vldr	s0, [r3]
}
 801c0f6:	4770      	bx	lr
 801c0f8:	2000c234 	.word	0x2000c234
 801c0fc:	00000000 	.word	0x00000000

0801c100 <mc_interface_temp_motor_filtered>:
	return m_temp_motor;
 801c100:	4b01      	ldr	r3, [pc, #4]	; (801c108 <mc_interface_temp_motor_filtered+0x8>)
 801c102:	ed93 0a00 	vldr	s0, [r3]
}
 801c106:	4770      	bx	lr
 801c108:	2000c238 	.word	0x2000c238
 801c10c:	00000000 	.word	0x00000000

0801c110 <mc_interface_try_input>:
int mc_interface_try_input(void) {
 801c110:	b510      	push	{r4, lr}
	if (mc_interface_get_state() == MC_STATE_DETECTING) {
 801c112:	f7ff f9bd 	bl	801b490 <mc_interface_get_state>
 801c116:	2801      	cmp	r0, #1
 801c118:	d022      	beq.n	801c160 <mc_interface_try_input+0x50>
	int retval = m_ignore_iterations;
 801c11a:	4b16      	ldr	r3, [pc, #88]	; (801c174 <mc_interface_try_input+0x64>)
 801c11c:	681c      	ldr	r4, [r3, #0]
	if (!m_ignore_iterations && m_lock_enabled) {
 801c11e:	b914      	cbnz	r4, 801c126 <mc_interface_try_input+0x16>
 801c120:	4b15      	ldr	r3, [pc, #84]	; (801c178 <mc_interface_try_input+0x68>)
 801c122:	781b      	ldrb	r3, [r3, #0]
 801c124:	b963      	cbnz	r3, 801c140 <mc_interface_try_input+0x30>
	switch (m_conf.motor_type) {
 801c126:	4b15      	ldr	r3, [pc, #84]	; (801c17c <mc_interface_try_input+0x6c>)
 801c128:	789b      	ldrb	r3, [r3, #2]
 801c12a:	b2db      	uxtb	r3, r3
 801c12c:	2b01      	cmp	r3, #1
 801c12e:	d911      	bls.n	801c154 <mc_interface_try_input+0x44>
 801c130:	2b02      	cmp	r3, #2
 801c132:	d103      	bne.n	801c13c <mc_interface_try_input+0x2c>
		if (!mcpwm_foc_init_done()) {
 801c134:	f001 fc24 	bl	801d980 <mcpwm_foc_init_done>
 801c138:	b900      	cbnz	r0, 801c13c <mc_interface_try_input+0x2c>
			retval = 1;
 801c13a:	2401      	movs	r4, #1
}
 801c13c:	4620      	mov	r0, r4
 801c13e:	bd10      	pop	{r4, pc}
		if (!m_lock_override_once) {
 801c140:	4b0f      	ldr	r3, [pc, #60]	; (801c180 <mc_interface_try_input+0x70>)
 801c142:	781a      	ldrb	r2, [r3, #0]
 801c144:	b99a      	cbnz	r2, 801c16e <mc_interface_try_input+0x5e>
	switch (m_conf.motor_type) {
 801c146:	4b0d      	ldr	r3, [pc, #52]	; (801c17c <mc_interface_try_input+0x6c>)
 801c148:	789b      	ldrb	r3, [r3, #2]
 801c14a:	b2db      	uxtb	r3, r3
 801c14c:	2b01      	cmp	r3, #1
			retval = 1;
 801c14e:	f04f 0401 	mov.w	r4, #1
	switch (m_conf.motor_type) {
 801c152:	d8ed      	bhi.n	801c130 <mc_interface_try_input+0x20>
		if (!mcpwm_init_done()) {
 801c154:	f7f7 f8b4 	bl	80132c0 <mcpwm_init_done>
 801c158:	2800      	cmp	r0, #0
 801c15a:	d1ef      	bne.n	801c13c <mc_interface_try_input+0x2c>
			retval = 1;
 801c15c:	2401      	movs	r4, #1
 801c15e:	e7ed      	b.n	801c13c <mc_interface_try_input+0x2c>
		mcpwm_stop_pwm();
 801c160:	f7f7 fd5e 	bl	8013c20 <mcpwm_stop_pwm>
		m_ignore_iterations = MCPWM_DETECT_STOP_TIME;
 801c164:	4b03      	ldr	r3, [pc, #12]	; (801c174 <mc_interface_try_input+0x64>)
 801c166:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
 801c16a:	601c      	str	r4, [r3, #0]
 801c16c:	e7db      	b.n	801c126 <mc_interface_try_input+0x16>
			m_lock_override_once = false;
 801c16e:	701c      	strb	r4, [r3, #0]
 801c170:	e7d9      	b.n	801c126 <mc_interface_try_input+0x16>
 801c172:	bf00      	nop
 801c174:	2000c1f0 	.word	0x2000c1f0
 801c178:	2000c200 	.word	0x2000c200
 801c17c:	2000c074 	.word	0x2000c074
 801c180:	2000c201 	.word	0x2000c201
	...

0801c190 <mc_interface_set_duty>:
void mc_interface_set_duty(float dutyCycle) {
 801c190:	b508      	push	{r3, lr}
 801c192:	ed2d 8b02 	vpush	{d8}
 801c196:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c19a:	f7ff ffb9 	bl	801c110 <mc_interface_try_input>
 801c19e:	b998      	cbnz	r0, 801c1c8 <mc_interface_set_duty+0x38>
	switch (m_conf.motor_type) {
 801c1a0:	4a11      	ldr	r2, [pc, #68]	; (801c1e8 <mc_interface_set_duty+0x58>)
 801c1a2:	7893      	ldrb	r3, [r2, #2]
 801c1a4:	b2db      	uxtb	r3, r3
 801c1a6:	2b01      	cmp	r3, #1
 801c1a8:	d911      	bls.n	801c1ce <mc_interface_set_duty+0x3e>
 801c1aa:	2b02      	cmp	r3, #2
 801c1ac:	d10c      	bne.n	801c1c8 <mc_interface_set_duty+0x38>
		mcpwm_foc_set_duty(DIR_MULT * dutyCycle);
 801c1ae:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c1b2:	b10b      	cbz	r3, 801c1b8 <mc_interface_set_duty+0x28>
 801c1b4:	eeb1 8a48 	vneg.f32	s16, s16
 801c1b8:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c1bc:	ecbd 8b02 	vpop	{d8}
 801c1c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_duty(DIR_MULT * dutyCycle);
 801c1c4:	f001 bc2c 	b.w	801da20 <mcpwm_foc_set_duty>
}
 801c1c8:	ecbd 8b02 	vpop	{d8}
 801c1cc:	bd08      	pop	{r3, pc}
		mcpwm_set_duty(DIR_MULT * dutyCycle);
 801c1ce:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c1d2:	b10b      	cbz	r3, 801c1d8 <mc_interface_set_duty+0x48>
 801c1d4:	eeb1 8a48 	vneg.f32	s16, s16
 801c1d8:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c1dc:	ecbd 8b02 	vpop	{d8}
 801c1e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_duty(DIR_MULT * dutyCycle);
 801c1e4:	f7f8 ba3c 	b.w	8014660 <mcpwm_set_duty>
 801c1e8:	2000c074 	.word	0x2000c074
 801c1ec:	00000000 	.word	0x00000000

0801c1f0 <mc_interface_set_pid_speed>:
void mc_interface_set_pid_speed(float rpm) {
 801c1f0:	b508      	push	{r3, lr}
 801c1f2:	ed2d 8b02 	vpush	{d8}
 801c1f6:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c1fa:	f7ff ff89 	bl	801c110 <mc_interface_try_input>
 801c1fe:	b998      	cbnz	r0, 801c228 <mc_interface_set_pid_speed+0x38>
	switch (m_conf.motor_type) {
 801c200:	4a11      	ldr	r2, [pc, #68]	; (801c248 <mc_interface_set_pid_speed+0x58>)
 801c202:	7893      	ldrb	r3, [r2, #2]
 801c204:	b2db      	uxtb	r3, r3
 801c206:	2b01      	cmp	r3, #1
 801c208:	d911      	bls.n	801c22e <mc_interface_set_pid_speed+0x3e>
 801c20a:	2b02      	cmp	r3, #2
 801c20c:	d10c      	bne.n	801c228 <mc_interface_set_pid_speed+0x38>
		mcpwm_foc_set_pid_speed(DIR_MULT * rpm);
 801c20e:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c212:	b10b      	cbz	r3, 801c218 <mc_interface_set_pid_speed+0x28>
 801c214:	eeb1 8a48 	vneg.f32	s16, s16
 801c218:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c21c:	ecbd 8b02 	vpop	{d8}
 801c220:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_pid_speed(DIR_MULT * rpm);
 801c224:	f001 bc14 	b.w	801da50 <mcpwm_foc_set_pid_speed>
}
 801c228:	ecbd 8b02 	vpop	{d8}
 801c22c:	bd08      	pop	{r3, pc}
		mcpwm_set_pid_speed(DIR_MULT * rpm);
 801c22e:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c232:	b10b      	cbz	r3, 801c238 <mc_interface_set_pid_speed+0x48>
 801c234:	eeb1 8a48 	vneg.f32	s16, s16
 801c238:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c23c:	ecbd 8b02 	vpop	{d8}
 801c240:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_pid_speed(DIR_MULT * rpm);
 801c244:	f7f7 bbb4 	b.w	80139b0 <mcpwm_set_pid_speed>
 801c248:	2000c074 	.word	0x2000c074
 801c24c:	00000000 	.word	0x00000000

0801c250 <mc_interface_set_pid_pos>:
void mc_interface_set_pid_pos(float pos) {
 801c250:	b508      	push	{r3, lr}
 801c252:	ed2d 8b02 	vpush	{d8}
 801c256:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c25a:	f7ff ff59 	bl	801c110 <mc_interface_try_input>
 801c25e:	b9e8      	cbnz	r0, 801c29c <mc_interface_set_pid_pos+0x4c>
	m_position_set = pos;
 801c260:	4a1a      	ldr	r2, [pc, #104]	; (801c2cc <mc_interface_set_pid_pos+0x7c>)
	switch (m_conf.motor_type) {
 801c262:	491b      	ldr	r1, [pc, #108]	; (801c2d0 <mc_interface_set_pid_pos+0x80>)
	m_position_set = pos;
 801c264:	ed82 8a00 	vstr	s16, [r2]
	switch (m_conf.motor_type) {
 801c268:	788b      	ldrb	r3, [r1, #2]
 801c26a:	b2db      	uxtb	r3, r3
 801c26c:	2b01      	cmp	r3, #1
 801c26e:	d918      	bls.n	801c2a2 <mc_interface_set_pid_pos+0x52>
 801c270:	2b02      	cmp	r3, #2
 801c272:	d113      	bne.n	801c29c <mc_interface_set_pid_pos+0x4c>
}
 801c274:	ecbd 8b02 	vpop	{d8}
		mcpwm_foc_set_pid_pos(DIR_MULT * m_position_set);
 801c278:	f891 315d 	ldrb.w	r3, [r1, #349]	; 0x15d
 801c27c:	ed92 0a00 	vldr	s0, [r2]
 801c280:	2b00      	cmp	r3, #0
 801c282:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801c286:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801c28a:	bf08      	it	eq
 801c28c:	eef0 7a47 	vmoveq.f32	s15, s14
 801c290:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 801c294:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_pid_pos(DIR_MULT * m_position_set);
 801c298:	f001 bbf2 	b.w	801da80 <mcpwm_foc_set_pid_pos>
}
 801c29c:	ecbd 8b02 	vpop	{d8}
 801c2a0:	bd08      	pop	{r3, pc}
 801c2a2:	ecbd 8b02 	vpop	{d8}
		mcpwm_set_pid_pos(DIR_MULT * m_position_set);
 801c2a6:	f891 315d 	ldrb.w	r3, [r1, #349]	; 0x15d
 801c2aa:	ed92 0a00 	vldr	s0, [r2]
 801c2ae:	2b00      	cmp	r3, #0
 801c2b0:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801c2b4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801c2b8:	bf08      	it	eq
 801c2ba:	eef0 7a47 	vmoveq.f32	s15, s14
 801c2be:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 801c2c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_pid_pos(DIR_MULT * m_position_set);
 801c2c6:	f7f8 bbbb 	b.w	8014a40 <mcpwm_set_pid_pos>
 801c2ca:	bf00      	nop
 801c2cc:	2000c21c 	.word	0x2000c21c
 801c2d0:	2000c074 	.word	0x2000c074
	...

0801c2e0 <mc_interface_set_current>:
void mc_interface_set_current(float current) {
 801c2e0:	b508      	push	{r3, lr}
 801c2e2:	ed2d 8b02 	vpush	{d8}
 801c2e6:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c2ea:	f7ff ff11 	bl	801c110 <mc_interface_try_input>
 801c2ee:	b998      	cbnz	r0, 801c318 <mc_interface_set_current+0x38>
	switch (m_conf.motor_type) {
 801c2f0:	4a11      	ldr	r2, [pc, #68]	; (801c338 <mc_interface_set_current+0x58>)
 801c2f2:	7893      	ldrb	r3, [r2, #2]
 801c2f4:	b2db      	uxtb	r3, r3
 801c2f6:	2b01      	cmp	r3, #1
 801c2f8:	d911      	bls.n	801c31e <mc_interface_set_current+0x3e>
 801c2fa:	2b02      	cmp	r3, #2
 801c2fc:	d10c      	bne.n	801c318 <mc_interface_set_current+0x38>
		mcpwm_foc_set_current(DIR_MULT * current);
 801c2fe:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c302:	b10b      	cbz	r3, 801c308 <mc_interface_set_current+0x28>
 801c304:	eeb1 8a48 	vneg.f32	s16, s16
 801c308:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c30c:	ecbd 8b02 	vpop	{d8}
 801c310:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_current(DIR_MULT * current);
 801c314:	f001 bbcc 	b.w	801dab0 <mcpwm_foc_set_current>
}
 801c318:	ecbd 8b02 	vpop	{d8}
 801c31c:	bd08      	pop	{r3, pc}
		mcpwm_set_current(DIR_MULT * current);
 801c31e:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c322:	b10b      	cbz	r3, 801c328 <mc_interface_set_current+0x48>
 801c324:	eeb1 8a48 	vneg.f32	s16, s16
 801c328:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c32c:	ecbd 8b02 	vpop	{d8}
 801c330:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_current(DIR_MULT * current);
 801c334:	f7f8 bba4 	b.w	8014a80 <mcpwm_set_current>
 801c338:	2000c074 	.word	0x2000c074
 801c33c:	00000000 	.word	0x00000000

0801c340 <mc_interface_set_current_rel>:
	if (val > 0.0) {
 801c340:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801c344:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		mc_interface_set_current(val * m_conf.lo_current_motor_max_now);
 801c348:	4b07      	ldr	r3, [pc, #28]	; (801c368 <mc_interface_set_current_rel+0x28>)
	if (val > 0.0) {
 801c34a:	dd05      	ble.n	801c358 <mc_interface_set_current_rel+0x18>
		mc_interface_set_current(val * m_conf.lo_current_motor_max_now);
 801c34c:	edd3 7a1d 	vldr	s15, [r3, #116]	; 0x74
 801c350:	ee27 0a80 	vmul.f32	s0, s15, s0
 801c354:	f7ff bfc4 	b.w	801c2e0 <mc_interface_set_current>
		mc_interface_set_current(val * fabsf(m_conf.lo_current_motor_min_now));
 801c358:	edd3 7a1e 	vldr	s15, [r3, #120]	; 0x78
 801c35c:	eef0 7ae7 	vabs.f32	s15, s15
 801c360:	ee27 0a80 	vmul.f32	s0, s15, s0
 801c364:	f7ff bfbc 	b.w	801c2e0 <mc_interface_set_current>
 801c368:	2000c074 	.word	0x2000c074
 801c36c:	00000000 	.word	0x00000000

0801c370 <mc_interface_release_motor>:
	mc_interface_set_current(0.0);
 801c370:	ed9f 0a01 	vldr	s0, [pc, #4]	; 801c378 <mc_interface_release_motor+0x8>
 801c374:	f7ff bfb4 	b.w	801c2e0 <mc_interface_set_current>
	...

0801c380 <mc_interface_set_brake_current>:
void mc_interface_set_brake_current(float current) {
 801c380:	b508      	push	{r3, lr}
 801c382:	ed2d 8b02 	vpush	{d8}
 801c386:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c38a:	f7ff fec1 	bl	801c110 <mc_interface_try_input>
 801c38e:	b998      	cbnz	r0, 801c3b8 <mc_interface_set_brake_current+0x38>
	switch (m_conf.motor_type) {
 801c390:	4a11      	ldr	r2, [pc, #68]	; (801c3d8 <mc_interface_set_brake_current+0x58>)
 801c392:	7893      	ldrb	r3, [r2, #2]
 801c394:	b2db      	uxtb	r3, r3
 801c396:	2b01      	cmp	r3, #1
 801c398:	d911      	bls.n	801c3be <mc_interface_set_brake_current+0x3e>
 801c39a:	2b02      	cmp	r3, #2
 801c39c:	d10c      	bne.n	801c3b8 <mc_interface_set_brake_current+0x38>
		mcpwm_foc_set_brake_current(DIR_MULT * current);
 801c39e:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c3a2:	b10b      	cbz	r3, 801c3a8 <mc_interface_set_brake_current+0x28>
 801c3a4:	eeb1 8a48 	vneg.f32	s16, s16
 801c3a8:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c3ac:	ecbd 8b02 	vpop	{d8}
 801c3b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_brake_current(DIR_MULT * current);
 801c3b4:	f001 bbac 	b.w	801db10 <mcpwm_foc_set_brake_current>
}
 801c3b8:	ecbd 8b02 	vpop	{d8}
 801c3bc:	bd08      	pop	{r3, pc}
		mcpwm_set_brake_current(DIR_MULT * current);
 801c3be:	f892 315d 	ldrb.w	r3, [r2, #349]	; 0x15d
 801c3c2:	b10b      	cbz	r3, 801c3c8 <mc_interface_set_brake_current+0x48>
 801c3c4:	eeb1 8a48 	vneg.f32	s16, s16
 801c3c8:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c3cc:	ecbd 8b02 	vpop	{d8}
 801c3d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_brake_current(DIR_MULT * current);
 801c3d4:	f7f7 bafc 	b.w	80139d0 <mcpwm_set_brake_current>
 801c3d8:	2000c074 	.word	0x2000c074
 801c3dc:	00000000 	.word	0x00000000

0801c3e0 <mc_interface_set_brake_current_rel>:
	mc_interface_set_brake_current(val * m_conf.lo_current_motor_max_now);
 801c3e0:	4b03      	ldr	r3, [pc, #12]	; (801c3f0 <mc_interface_set_brake_current_rel+0x10>)
 801c3e2:	edd3 7a1d 	vldr	s15, [r3, #116]	; 0x74
 801c3e6:	ee27 0a80 	vmul.f32	s0, s15, s0
 801c3ea:	f7ff bfc9 	b.w	801c380 <mc_interface_set_brake_current>
 801c3ee:	bf00      	nop
 801c3f0:	2000c074 	.word	0x2000c074
	...

0801c400 <mc_interface_set_handbrake>:
void mc_interface_set_handbrake(float current) {
 801c400:	b508      	push	{r3, lr}
 801c402:	ed2d 8b02 	vpush	{d8}
 801c406:	eeb0 8a40 	vmov.f32	s16, s0
	if (mc_interface_try_input()) {
 801c40a:	f7ff fe81 	bl	801c110 <mc_interface_try_input>
 801c40e:	b970      	cbnz	r0, 801c42e <mc_interface_set_handbrake+0x2e>
	switch (m_conf.motor_type) {
 801c410:	4b0c      	ldr	r3, [pc, #48]	; (801c444 <mc_interface_set_handbrake+0x44>)
 801c412:	789b      	ldrb	r3, [r3, #2]
 801c414:	b2db      	uxtb	r3, r3
 801c416:	2b01      	cmp	r3, #1
 801c418:	d90c      	bls.n	801c434 <mc_interface_set_handbrake+0x34>
 801c41a:	2b02      	cmp	r3, #2
 801c41c:	d107      	bne.n	801c42e <mc_interface_set_handbrake+0x2e>
		mcpwm_foc_set_handbrake(current);
 801c41e:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c422:	ecbd 8b02 	vpop	{d8}
 801c426:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_foc_set_handbrake(current);
 801c42a:	f001 bb99 	b.w	801db60 <mcpwm_foc_set_handbrake>
}
 801c42e:	ecbd 8b02 	vpop	{d8}
 801c432:	bd08      	pop	{r3, pc}
		mcpwm_set_brake_current(current);
 801c434:	eeb0 0a48 	vmov.f32	s0, s16
}
 801c438:	ecbd 8b02 	vpop	{d8}
 801c43c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		mcpwm_set_brake_current(current);
 801c440:	f7f7 bac6 	b.w	80139d0 <mcpwm_set_brake_current>
 801c444:	2000c074 	.word	0x2000c074
	...

0801c450 <mc_interface_mc_timer_isr>:
void mc_interface_mc_timer_isr(void) {
 801c450:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801c454:	ed2d 8b04 	vpush	{d8-d9}
	const float input_voltage = GET_INPUT_VOLTAGE();
 801c458:	4e7e      	ldr	r6, [pc, #504]	; (801c654 <mc_interface_mc_timer_isr+0x204>)
	if (input_voltage < m_conf.l_min_vin ||
 801c45a:	4c7f      	ldr	r4, [pc, #508]	; (801c658 <mc_interface_mc_timer_isr+0x208>)
void mc_interface_mc_timer_isr(void) {
 801c45c:	b083      	sub	sp, #12
	ledpwm_update_pwm(); // LED PWM Driver update
 801c45e:	f7f6 f80f 	bl	8012480 <ledpwm_update_pwm>
	const float input_voltage = GET_INPUT_VOLTAGE();
 801c462:	8a33      	ldrh	r3, [r6, #16]
 801c464:	eddf 6a7d 	vldr	s13, [pc, #500]	; 801c65c <mc_interface_mc_timer_isr+0x20c>
 801c468:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 801c660 <mc_interface_mc_timer_isr+0x210>
	if (input_voltage < m_conf.l_min_vin ||
 801c46c:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
	const float input_voltage = GET_INPUT_VOLTAGE();
 801c470:	ee08 3a10 	vmov	s16, r3
 801c474:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 801c478:	ee28 8a26 	vmul.f32	s16, s16, s13
 801c47c:	ee28 8a07 	vmul.f32	s16, s16, s14
	if (input_voltage < m_conf.l_min_vin ||
 801c480:	eef4 7ac8 	vcmpe.f32	s15, s16
 801c484:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c488:	dc07      	bgt.n	801c49a <mc_interface_mc_timer_isr+0x4a>
			input_voltage > m_conf.l_max_vin) {
 801c48a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
	if (input_voltage < m_conf.l_min_vin ||
 801c48e:	eef4 7ac8 	vcmpe.f32	s15, s16
 801c492:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c496:	f140 81d8 	bpl.w	801c84a <mc_interface_mc_timer_isr+0x3fa>
		wrong_voltage_iterations++;
 801c49a:	4a72      	ldr	r2, [pc, #456]	; (801c664 <mc_interface_mc_timer_isr+0x214>)
 801c49c:	6813      	ldr	r3, [r2, #0]
 801c49e:	3301      	adds	r3, #1
		if ((wrong_voltage_iterations >= 8)) {
 801c4a0:	2b07      	cmp	r3, #7
		wrong_voltage_iterations++;
 801c4a2:	6013      	str	r3, [r2, #0]
		if ((wrong_voltage_iterations >= 8)) {
 801c4a4:	f300 81b6 	bgt.w	801c814 <mc_interface_mc_timer_isr+0x3c4>
	if (mc_interface_get_state() == MC_STATE_RUNNING) {
 801c4a8:	f7fe fff2 	bl	801b490 <mc_interface_get_state>
 801c4ac:	2802      	cmp	r0, #2
 801c4ae:	f000 81c7 	beq.w	801c840 <mc_interface_mc_timer_isr+0x3f0>
		m_cycles_running = 0;
 801c4b2:	4b6d      	ldr	r3, [pc, #436]	; (801c668 <mc_interface_mc_timer_isr+0x218>)
 801c4b4:	2200      	movs	r2, #0
 801c4b6:	601a      	str	r2, [r3, #0]
	if (pwn_done_func) {
 801c4b8:	4b6c      	ldr	r3, [pc, #432]	; (801c66c <mc_interface_mc_timer_isr+0x21c>)
 801c4ba:	681b      	ldr	r3, [r3, #0]
 801c4bc:	b103      	cbz	r3, 801c4c0 <mc_interface_mc_timer_isr+0x70>
		pwn_done_func();
 801c4be:	4798      	blx	r3
	const float current = mc_interface_get_tot_current_filtered();
 801c4c0:	f7ff f8a6 	bl	801b610 <mc_interface_get_tot_current_filtered>
 801c4c4:	eef0 8a40 	vmov.f32	s17, s0
	const float current_in = mc_interface_get_tot_current_in_filtered();
 801c4c8:	f7ff f8fa 	bl	801b6c0 <mc_interface_get_tot_current_in_filtered>
	m_motor_current_sum += current;
 801c4cc:	4868      	ldr	r0, [pc, #416]	; (801c670 <mc_interface_mc_timer_isr+0x220>)
	m_input_current_sum += current_in;
 801c4ce:	4969      	ldr	r1, [pc, #420]	; (801c674 <mc_interface_mc_timer_isr+0x224>)
	m_motor_current_sum += current;
 801c4d0:	edd0 7a00 	vldr	s15, [r0]
	m_motor_current_iterations++;
 801c4d4:	4a68      	ldr	r2, [pc, #416]	; (801c678 <mc_interface_mc_timer_isr+0x228>)
	m_input_current_iterations++;
 801c4d6:	4b69      	ldr	r3, [pc, #420]	; (801c67c <mc_interface_mc_timer_isr+0x22c>)
	m_motor_current_sum += current;
 801c4d8:	ee77 7aa8 	vadd.f32	s15, s15, s17
	m_motor_current_iterations++;
 801c4dc:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
	m_motor_current_sum += current;
 801c4e0:	edc0 7a00 	vstr	s15, [r0]
	m_input_current_sum += current_in;
 801c4e4:	edd1 7a00 	vldr	s15, [r1]
 801c4e8:	ee77 7a80 	vadd.f32	s15, s15, s0
	const float current_in = mc_interface_get_tot_current_in_filtered();
 801c4ec:	eef0 9a40 	vmov.f32	s19, s0
	m_input_current_sum += current_in;
 801c4f0:	edc1 7a00 	vstr	s15, [r1]
	m_motor_current_iterations++;
 801c4f4:	edd2 7a00 	vldr	s15, [r2]
 801c4f8:	ee77 7a89 	vadd.f32	s15, s15, s18
 801c4fc:	edc2 7a00 	vstr	s15, [r2]
	m_input_current_iterations++;
 801c500:	edd3 7a00 	vldr	s15, [r3]
 801c504:	ee77 7a89 	vadd.f32	s15, s15, s18
 801c508:	edc3 7a00 	vstr	s15, [r3]
	m_motor_id_sum += mcpwm_foc_get_id();
 801c50c:	f001 fc20 	bl	801dd50 <mcpwm_foc_get_id>
 801c510:	4b5b      	ldr	r3, [pc, #364]	; (801c680 <mc_interface_mc_timer_isr+0x230>)
 801c512:	edd3 7a00 	vldr	s15, [r3]
 801c516:	ee37 0a80 	vadd.f32	s0, s15, s0
 801c51a:	ed83 0a00 	vstr	s0, [r3]
	m_motor_iq_sum += mcpwm_foc_get_iq();
 801c51e:	f001 fc1f 	bl	801dd60 <mcpwm_foc_get_iq>
 801c522:	4958      	ldr	r1, [pc, #352]	; (801c684 <mc_interface_mc_timer_isr+0x234>)
	m_motor_id_iterations++;
 801c524:	4a58      	ldr	r2, [pc, #352]	; (801c688 <mc_interface_mc_timer_isr+0x238>)
	m_motor_iq_sum += mcpwm_foc_get_iq();
 801c526:	edd1 7a00 	vldr	s15, [r1]
	m_motor_iq_iterations++;
 801c52a:	4b58      	ldr	r3, [pc, #352]	; (801c68c <mc_interface_mc_timer_isr+0x23c>)
	m_motor_iq_sum += mcpwm_foc_get_iq();
 801c52c:	ee37 0a80 	vadd.f32	s0, s15, s0
 801c530:	ed81 0a00 	vstr	s0, [r1]
	m_motor_id_iterations++;
 801c534:	edd2 7a00 	vldr	s15, [r2]
 801c538:	ee77 7a89 	vadd.f32	s15, s15, s18
 801c53c:	edc2 7a00 	vstr	s15, [r2]
	m_motor_iq_iterations++;
 801c540:	edd3 7a00 	vldr	s15, [r3]
 801c544:	ee37 9a89 	vadd.f32	s18, s15, s18
 801c548:	ed83 9a00 	vstr	s18, [r3]
	float abs_current = mc_interface_get_tot_current();
 801c54c:	f7ff f848 	bl	801b5e0 <mc_interface_get_tot_current>
	if (m_conf.motor_type == MOTOR_TYPE_FOC) {
 801c550:	78a3      	ldrb	r3, [r4, #2]
 801c552:	2b02      	cmp	r3, #2
	float abs_current = mc_interface_get_tot_current();
 801c554:	eeb0 9a40 	vmov.f32	s18, s0
	if (m_conf.motor_type == MOTOR_TYPE_FOC) {
 801c558:	f000 81cb 	beq.w	801c8f2 <mc_interface_mc_timer_isr+0x4a2>
	float abs_current_filtered = current;
 801c55c:	eeb0 0a68 	vmov.f32	s0, s17
	if (m_conf.l_slow_abs_current) {
 801c560:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
		if (fabsf(abs_current_filtered) > m_conf.l_abs_current_max) {
 801c564:	edd4 7a05 	vldr	s15, [r4, #20]
	if (m_conf.l_slow_abs_current) {
 801c568:	2b00      	cmp	r3, #0
 801c56a:	f000 8145 	beq.w	801c7f8 <mc_interface_mc_timer_isr+0x3a8>
		if (fabsf(abs_current_filtered) > m_conf.l_abs_current_max) {
 801c56e:	eeb0 0ac0 	vabs.f32	s0, s0
 801c572:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801c576:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c57a:	dd5c      	ble.n	801c636 <mc_interface_mc_timer_isr+0x1e6>
	if (m_fault_now == fault) {
 801c57c:	4b44      	ldr	r3, [pc, #272]	; (801c690 <mc_interface_mc_timer_isr+0x240>)
 801c57e:	781b      	ldrb	r3, [r3, #0]
 801c580:	2b04      	cmp	r3, #4
 801c582:	d155      	bne.n	801c630 <mc_interface_mc_timer_isr+0x1e0>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801c584:	4b43      	ldr	r3, [pc, #268]	; (801c694 <mc_interface_mc_timer_isr+0x244>)
 801c586:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
 801c58a:	601a      	str	r2, [r3, #0]
	if (IS_DRV_FAULT()) {
 801c58c:	4b42      	ldr	r3, [pc, #264]	; (801c698 <mc_interface_mc_timer_isr+0x248>)
 801c58e:	691b      	ldr	r3, [r3, #16]
 801c590:	04db      	lsls	r3, r3, #19
 801c592:	f140 81aa 	bpl.w	801c8ea <mc_interface_mc_timer_isr+0x49a>
	const float f_samp = mc_interface_get_sampling_frequency_now();
 801c596:	f7fe ffab 	bl	801b4f0 <mc_interface_get_sampling_frequency_now>
	if (fabsf(current) > 1.0) {
 801c59a:	eef0 8ae8 	vabs.f32	s17, s17
 801c59e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801c5a2:	eef4 8ae6 	vcmpe.f32	s17, s13
 801c5a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	const float f_samp = mc_interface_get_sampling_frequency_now();
 801c5aa:	eeb0 9a40 	vmov.f32	s18, s0
	if (fabsf(current) > 1.0) {
 801c5ae:	dd31      	ble.n	801c614 <mc_interface_mc_timer_isr+0x1c4>
		curr_diff_samples += 1.0 / f_samp;
 801c5b0:	ee86 7a80 	vdiv.f32	s14, s13, s0
 801c5b4:	4a39      	ldr	r2, [pc, #228]	; (801c69c <mc_interface_mc_timer_isr+0x24c>)
		curr_diff_sum += current_in / f_samp;
 801c5b6:	4b3a      	ldr	r3, [pc, #232]	; (801c6a0 <mc_interface_mc_timer_isr+0x250>)
 801c5b8:	eec9 7a80 	vdiv.f32	s15, s19, s0
		curr_diff_samples += 1.0 / f_samp;
 801c5bc:	ed92 6a00 	vldr	s12, [r2]
		curr_diff_sum += current_in / f_samp;
 801c5c0:	edd3 5a00 	vldr	s11, [r3]
		if (curr_diff_samples >= 0.01) {
 801c5c4:	eddf 6a37 	vldr	s13, [pc, #220]	; 801c6a4 <mc_interface_mc_timer_isr+0x254>
		curr_diff_samples += 1.0 / f_samp;
 801c5c8:	ee37 7a06 	vadd.f32	s14, s14, s12
		curr_diff_sum += current_in / f_samp;
 801c5cc:	ee77 7aa5 	vadd.f32	s15, s15, s11
		if (curr_diff_samples >= 0.01) {
 801c5d0:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801c5d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		curr_diff_sum += current_in / f_samp;
 801c5d8:	edc3 7a00 	vstr	s15, [r3]
		curr_diff_samples += 1.0 / f_samp;
 801c5dc:	ed82 7a00 	vstr	s14, [r2]
		if (curr_diff_samples >= 0.01) {
 801c5e0:	db18      	blt.n	801c614 <mc_interface_mc_timer_isr+0x1c4>
			if (curr_diff_sum > 0.0) {
 801c5e2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801c5e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c5ea:	ee27 8a88 	vmul.f32	s16, s15, s16
 801c5ee:	f340 81a0 	ble.w	801c932 <mc_interface_mc_timer_isr+0x4e2>
				m_amp_seconds += curr_diff_sum;
 801c5f2:	482d      	ldr	r0, [pc, #180]	; (801c6a8 <mc_interface_mc_timer_isr+0x258>)
				m_watt_seconds += curr_diff_sum * input_voltage;
 801c5f4:	492d      	ldr	r1, [pc, #180]	; (801c6ac <mc_interface_mc_timer_isr+0x25c>)
				m_amp_seconds += curr_diff_sum;
 801c5f6:	ed90 7a00 	vldr	s14, [r0]
 801c5fa:	ee77 7a87 	vadd.f32	s15, s15, s14
 801c5fe:	edc0 7a00 	vstr	s15, [r0]
				m_watt_seconds += curr_diff_sum * input_voltage;
 801c602:	edd1 7a00 	vldr	s15, [r1]
 801c606:	ee37 8a88 	vadd.f32	s16, s15, s16
 801c60a:	ed81 8a00 	vstr	s16, [r1]
			curr_diff_samples = 0.0;
 801c60e:	2100      	movs	r1, #0
 801c610:	6011      	str	r1, [r2, #0]
			curr_diff_sum = 0.0;
 801c612:	6019      	str	r1, [r3, #0]
	switch (m_sample_mode) {
 801c614:	4f26      	ldr	r7, [pc, #152]	; (801c6b0 <mc_interface_mc_timer_isr+0x260>)
 801c616:	783b      	ldrb	r3, [r7, #0]
 801c618:	3b01      	subs	r3, #1
 801c61a:	2b05      	cmp	r3, #5
 801c61c:	f200 80e7 	bhi.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c620:	e8df f013 	tbh	[pc, r3, lsl #1]
 801c624:	0126014d 	.word	0x0126014d
 801c628:	00480117 	.word	0x00480117
 801c62c:	00480117 	.word	0x00480117
 801c630:	2004      	movs	r0, #4
 801c632:	f7ff f885 	bl	801b740 <mc_interface_fault_stop.part.3>
	if (IS_DRV_FAULT()) {
 801c636:	4b18      	ldr	r3, [pc, #96]	; (801c698 <mc_interface_mc_timer_isr+0x248>)
 801c638:	691b      	ldr	r3, [r3, #16]
 801c63a:	04da      	lsls	r2, r3, #19
 801c63c:	d4ab      	bmi.n	801c596 <mc_interface_mc_timer_isr+0x146>
	if (m_fault_now == fault) {
 801c63e:	4b14      	ldr	r3, [pc, #80]	; (801c690 <mc_interface_mc_timer_isr+0x240>)
 801c640:	781b      	ldrb	r3, [r3, #0]
 801c642:	2b03      	cmp	r3, #3
 801c644:	f040 8151 	bne.w	801c8ea <mc_interface_mc_timer_isr+0x49a>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801c648:	4b12      	ldr	r3, [pc, #72]	; (801c694 <mc_interface_mc_timer_isr+0x244>)
 801c64a:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
 801c64e:	601a      	str	r2, [r3, #0]
 801c650:	e7a1      	b.n	801c596 <mc_interface_mc_timer_isr+0x146>
 801c652:	bf00      	nop
 801c654:	2000c03c 	.word	0x2000c03c
 801c658:	2000c074 	.word	0x2000c074
 801c65c:	3a534067 	.word	0x3a534067
 801c660:	4195d174 	.word	0x4195d174
 801c664:	2000cd80 	.word	0x2000cd80
 801c668:	2000c1e8 	.word	0x2000c1e8
 801c66c:	2000c244 	.word	0x2000c244
 801c670:	2000c208 	.word	0x2000c208
 801c674:	2000c1f8 	.word	0x2000c1f8
 801c678:	2000c204 	.word	0x2000c204
 801c67c:	2000c1f4 	.word	0x2000c1f4
 801c680:	2000c210 	.word	0x2000c210
 801c684:	2000c218 	.word	0x2000c218
 801c688:	2000c20c 	.word	0x2000c20c
 801c68c:	2000c214 	.word	0x2000c214
 801c690:	2000c1ec 	.word	0x2000c1ec
 801c694:	2000c1f0 	.word	0x2000c1f0
 801c698:	40020800 	.word	0x40020800
 801c69c:	2000c064 	.word	0x2000c064
 801c6a0:	2000c068 	.word	0x2000c068
 801c6a4:	3c23d70a 	.word	0x3c23d70a
 801c6a8:	2000c06c 	.word	0x2000c06c
 801c6ac:	2000c23c 	.word	0x2000c23c
 801c6b0:	2000c228 	.word	0x2000c228
		if (m_sample_trigger >= 0) {
 801c6b4:	f8df 8350 	ldr.w	r8, [pc, #848]	; 801ca08 <mc_interface_mc_timer_isr+0x5b8>
 801c6b8:	f8d8 3000 	ldr.w	r3, [r8]
 801c6bc:	2b00      	cmp	r3, #0
 801c6be:	f280 8122 	bge.w	801c906 <mc_interface_mc_timer_isr+0x4b6>
		int sample_last = -1;
 801c6c2:	f04f 33ff 	mov.w	r3, #4294967295
		if (m_sample_now == sample_last) {
 801c6c6:	4db9      	ldr	r5, [pc, #740]	; (801c9ac <mc_interface_mc_timer_isr+0x55c>)
 801c6c8:	682a      	ldr	r2, [r5, #0]
 801c6ca:	429a      	cmp	r2, r3
 801c6cc:	f000 8158 	beq.w	801c980 <mc_interface_mc_timer_isr+0x530>
		if (m_fault_now != FAULT_CODE_NONE && m_sample_trigger < 0) {
 801c6d0:	4bb7      	ldr	r3, [pc, #732]	; (801c9b0 <mc_interface_mc_timer_isr+0x560>)
 801c6d2:	781b      	ldrb	r3, [r3, #0]
 801c6d4:	b133      	cbz	r3, 801c6e4 <mc_interface_mc_timer_isr+0x294>
 801c6d6:	f8d8 3000 	ldr.w	r3, [r8]
 801c6da:	2b00      	cmp	r3, #0
			m_sample_trigger = m_sample_now;
 801c6dc:	bfbc      	itt	lt
 801c6de:	682b      	ldrlt	r3, [r5, #0]
 801c6e0:	f8c8 3000 	strlt.w	r3, [r8]
		a++;
 801c6e4:	4ab3      	ldr	r2, [pc, #716]	; (801c9b4 <mc_interface_mc_timer_isr+0x564>)
		if (a >= m_sample_int) {
 801c6e6:	49b4      	ldr	r1, [pc, #720]	; (801c9b8 <mc_interface_mc_timer_isr+0x568>)
		a++;
 801c6e8:	6813      	ldr	r3, [r2, #0]
		if (a >= m_sample_int) {
 801c6ea:	6809      	ldr	r1, [r1, #0]
		a++;
 801c6ec:	3301      	adds	r3, #1
		if (a >= m_sample_int) {
 801c6ee:	428b      	cmp	r3, r1
		a++;
 801c6f0:	6013      	str	r3, [r2, #0]
		if (a >= m_sample_int) {
 801c6f2:	db7c      	blt.n	801c7ee <mc_interface_mc_timer_isr+0x39e>
			if (m_sample_now >= ADC_SAMPLE_MAX_LEN) {
 801c6f4:	6829      	ldr	r1, [r5, #0]
			a = 0;
 801c6f6:	2300      	movs	r3, #0
			if (m_sample_now >= ADC_SAMPLE_MAX_LEN) {
 801c6f8:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
				m_sample_now = 0;
 801c6fc:	bfa8      	it	ge
 801c6fe:	602b      	strge	r3, [r5, #0]
			a = 0;
 801c700:	6013      	str	r3, [r2, #0]
			if (m_conf.motor_type == MOTOR_TYPE_FOC) {
 801c702:	78a3      	ldrb	r3, [r4, #2]
 801c704:	2b02      	cmp	r3, #2
 801c706:	f000 8183 	beq.w	801ca10 <mc_interface_mc_timer_isr+0x5c0>
				zero = mcpwm_vzero;
 801c70a:	4bac      	ldr	r3, [pc, #688]	; (801c9bc <mc_interface_mc_timer_isr+0x56c>)
				m_phase_samples[m_sample_now] = 0;
 801c70c:	4fac      	ldr	r7, [pc, #688]	; (801c9c0 <mc_interface_mc_timer_isr+0x570>)
				zero = mcpwm_vzero;
 801c70e:	681c      	ldr	r4, [r3, #0]
				m_phase_samples[m_sample_now] = 0;
 801c710:	682b      	ldr	r3, [r5, #0]
 801c712:	443b      	add	r3, r7
 801c714:	2200      	movs	r2, #0
				zero = mcpwm_vzero;
 801c716:	b224      	sxth	r4, r4
				m_phase_samples[m_sample_now] = 0;
 801c718:	f883 2e08 	strb.w	r2, [r3, #3592]	; 0xe08
			if (mc_interface_get_state() == MC_STATE_DETECTING) {
 801c71c:	f7fe feb8 	bl	801b490 <mc_interface_get_state>
 801c720:	2801      	cmp	r0, #1
 801c722:	f000 8195 	beq.w	801ca50 <mc_interface_mc_timer_isr+0x600>
				m_curr0_samples[m_sample_now] = ADC_curr_norm_value[0];
 801c726:	48a7      	ldr	r0, [pc, #668]	; (801c9c4 <mc_interface_mc_timer_isr+0x574>)
 801c728:	4ba7      	ldr	r3, [pc, #668]	; (801c9c8 <mc_interface_mc_timer_isr+0x578>)
 801c72a:	6802      	ldr	r2, [r0, #0]
 801c72c:	f8d5 c000 	ldr.w	ip, [r5]
				m_ph1_samples[m_sample_now] = ADC_V_L1 - zero;
 801c730:	49a6      	ldr	r1, [pc, #664]	; (801c9cc <mc_interface_mc_timer_isr+0x57c>)
				m_curr0_samples[m_sample_now] = ADC_curr_norm_value[0];
 801c732:	b212      	sxth	r2, r2
 801c734:	f823 201c 	strh.w	r2, [r3, ip, lsl #1]
				m_curr1_samples[m_sample_now] = ADC_curr_norm_value[1];
 801c738:	6842      	ldr	r2, [r0, #4]
 801c73a:	6828      	ldr	r0, [r5, #0]
				m_ph2_samples[m_sample_now] = ADC_V_L2 - zero;
 801c73c:	f8df c2cc 	ldr.w	ip, [pc, #716]	; 801ca0c <mc_interface_mc_timer_isr+0x5bc>
				m_curr1_samples[m_sample_now] = ADC_curr_norm_value[1];
 801c740:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 801c744:	b212      	sxth	r2, r2
 801c746:	f8a3 2fa0 	strh.w	r2, [r3, #4000]	; 0xfa0
				m_ph1_samples[m_sample_now] = ADC_V_L1 - zero;
 801c74a:	88b2      	ldrh	r2, [r6, #4]
 801c74c:	682b      	ldr	r3, [r5, #0]
 801c74e:	b2a0      	uxth	r0, r4
 801c750:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 801c754:	1a12      	subs	r2, r2, r0
 801c756:	b212      	sxth	r2, r2
 801c758:	f8a3 2e48 	strh.w	r2, [r3, #3656]	; 0xe48
				m_ph2_samples[m_sample_now] = ADC_V_L2 - zero;
 801c75c:	8872      	ldrh	r2, [r6, #2]
 801c75e:	682b      	ldr	r3, [r5, #0]
				m_ph3_samples[m_sample_now] = ADC_V_L3 - zero;
 801c760:	499b      	ldr	r1, [pc, #620]	; (801c9d0 <mc_interface_mc_timer_isr+0x580>)
				m_ph2_samples[m_sample_now] = ADC_V_L2 - zero;
 801c762:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
 801c766:	1a12      	subs	r2, r2, r0
 801c768:	b212      	sxth	r2, r2
 801c76a:	f8a3 2cf0 	strh.w	r2, [r3, #3312]	; 0xcf0
				m_ph3_samples[m_sample_now] = ADC_V_L3 - zero;
 801c76e:	8833      	ldrh	r3, [r6, #0]
 801c770:	682a      	ldr	r2, [r5, #0]
 801c772:	1a1b      	subs	r3, r3, r0
 801c774:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 801c778:	b21b      	sxth	r3, r3
 801c77a:	f8a2 3b98 	strh.w	r3, [r2, #2968]	; 0xb98
			m_vzero_samples[m_sample_now] = zero;
 801c77e:	682a      	ldr	r2, [r5, #0]
 801c780:	4b94      	ldr	r3, [pc, #592]	; (801c9d4 <mc_interface_mc_timer_isr+0x584>)
 801c782:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 801c786:	f8a3 4a40 	strh.w	r4, [r3, #2624]	; 0xa40
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c78a:	f7fe ff29 	bl	801b5e0 <mc_interface_get_tot_current>
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c78e:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 801c792:	ee89 7a27 	vdiv.f32	s14, s18, s15
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c796:	682b      	ldr	r3, [r5, #0]
 801c798:	488f      	ldr	r0, [pc, #572]	; (801c9d8 <mc_interface_mc_timer_isr+0x588>)
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c79a:	4990      	ldr	r1, [pc, #576]	; (801c9dc <mc_interface_mc_timer_isr+0x58c>)
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c79c:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 801c7a0:	eddf 7a8f 	vldr	s15, [pc, #572]	; 801c9e0 <mc_interface_mc_timer_isr+0x590>
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c7a4:	eebd 7ac7 	vcvt.s32.f32	s14, s14
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c7a8:	ee20 0a27 	vmul.f32	s0, s0, s15
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c7ac:	ee17 3a10 	vmov	r3, s14
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c7b0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c7b4:	b21a      	sxth	r2, r3
			m_curr_fir_samples[m_sample_now] = (int16_t)(mc_interface_get_tot_current() * (8.0 / FAC_CURRENT));
 801c7b6:	ee10 3a10 	vmov	r3, s0
 801c7ba:	b21b      	sxth	r3, r3
 801c7bc:	f8a0 38e8 	strh.w	r3, [r0, #2280]	; 0x8e8
			m_f_sw_samples[m_sample_now] = (int16_t)(f_samp / 10.0);
 801c7c0:	682b      	ldr	r3, [r5, #0]
 801c7c2:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 801c7c6:	f8a3 2790 	strh.w	r2, [r3, #1936]	; 0x790
			m_status_samples[m_sample_now] = mcpwm_get_comm_step() | (mcpwm_read_hall_phase() << 3);
 801c7ca:	f7f7 f971 	bl	8013ab0 <mcpwm_get_comm_step>
 801c7ce:	4604      	mov	r4, r0
 801c7d0:	f7f7 fdc6 	bl	8014360 <mcpwm_read_hall_phase>
 801c7d4:	682b      	ldr	r3, [r5, #0]
	return m_last_adc_duration_sample;
 801c7d6:	4a83      	ldr	r2, [pc, #524]	; (801c9e4 <mc_interface_mc_timer_isr+0x594>)
			m_status_samples[m_sample_now] = mcpwm_get_comm_step() | (mcpwm_read_hall_phase() << 3);
 801c7d8:	441f      	add	r7, r3
 801c7da:	ea44 00c0 	orr.w	r0, r4, r0, lsl #3
 801c7de:	b2c0      	uxtb	r0, r0
 801c7e0:	f887 0638 	strb.w	r0, [r7, #1592]	; 0x638
			m_sample_now++;
 801c7e4:	682b      	ldr	r3, [r5, #0]
 801c7e6:	3301      	adds	r3, #1
 801c7e8:	602b      	str	r3, [r5, #0]
	return m_last_adc_duration_sample;
 801c7ea:	6813      	ldr	r3, [r2, #0]
			m_last_adc_duration_sample = mc_interface_get_last_sample_adc_isr_duration();
 801c7ec:	6013      	str	r3, [r2, #0]
}
 801c7ee:	b003      	add	sp, #12
 801c7f0:	ecbd 8b04 	vpop	{d8-d9}
 801c7f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fabsf(abs_current) > m_conf.l_abs_current_max) {
 801c7f8:	eeb0 9ac9 	vabs.f32	s18, s18
 801c7fc:	eeb4 9ae7 	vcmpe.f32	s18, s15
 801c800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c804:	f77f af17 	ble.w	801c636 <mc_interface_mc_timer_isr+0x1e6>
	if (m_fault_now == fault) {
 801c808:	4b69      	ldr	r3, [pc, #420]	; (801c9b0 <mc_interface_mc_timer_isr+0x560>)
 801c80a:	781b      	ldrb	r3, [r3, #0]
 801c80c:	2b04      	cmp	r3, #4
 801c80e:	f43f aeb9 	beq.w	801c584 <mc_interface_mc_timer_isr+0x134>
 801c812:	e70d      	b.n	801c630 <mc_interface_mc_timer_isr+0x1e0>
			mc_interface_fault_stop(input_voltage < m_conf.l_min_vin ?
 801c814:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
	if (m_fault_now == fault) {
 801c818:	4b65      	ldr	r3, [pc, #404]	; (801c9b0 <mc_interface_mc_timer_isr+0x560>)
			mc_interface_fault_stop(input_voltage < m_conf.l_min_vin ?
 801c81a:	eef4 7ac8 	vcmpe.f32	s15, s16
 801c81e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if (m_fault_now == fault) {
 801c822:	781b      	ldrb	r3, [r3, #0]
			mc_interface_fault_stop(input_voltage < m_conf.l_min_vin ?
 801c824:	bfcc      	ite	gt
 801c826:	2002      	movgt	r0, #2
 801c828:	2001      	movle	r0, #1
	if (m_fault_now == fault) {
 801c82a:	4283      	cmp	r3, r0
 801c82c:	d168      	bne.n	801c900 <mc_interface_mc_timer_isr+0x4b0>
		m_ignore_iterations = m_conf.m_fault_stop_time_ms;
 801c82e:	4b6e      	ldr	r3, [pc, #440]	; (801c9e8 <mc_interface_mc_timer_isr+0x598>)
 801c830:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
 801c834:	601a      	str	r2, [r3, #0]
	if (mc_interface_get_state() == MC_STATE_RUNNING) {
 801c836:	f7fe fe2b 	bl	801b490 <mc_interface_get_state>
 801c83a:	2802      	cmp	r0, #2
 801c83c:	f47f ae39 	bne.w	801c4b2 <mc_interface_mc_timer_isr+0x62>
		m_cycles_running++;
 801c840:	4a6a      	ldr	r2, [pc, #424]	; (801c9ec <mc_interface_mc_timer_isr+0x59c>)
 801c842:	6813      	ldr	r3, [r2, #0]
 801c844:	3301      	adds	r3, #1
 801c846:	6013      	str	r3, [r2, #0]
 801c848:	e636      	b.n	801c4b8 <mc_interface_mc_timer_isr+0x68>
		wrong_voltage_iterations = 0;
 801c84a:	4b69      	ldr	r3, [pc, #420]	; (801c9f0 <mc_interface_mc_timer_isr+0x5a0>)
 801c84c:	2200      	movs	r2, #0
 801c84e:	601a      	str	r2, [r3, #0]
 801c850:	e62a      	b.n	801c4a8 <mc_interface_mc_timer_isr+0x58>
		if (m_sample_trigger >= 0) {
 801c852:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 801ca08 <mc_interface_mc_timer_isr+0x5b8>
 801c856:	f8d8 3000 	ldr.w	r3, [r8]
 801c85a:	2b00      	cmp	r3, #0
 801c85c:	db5d      	blt.n	801c91a <mc_interface_mc_timer_isr+0x4ca>
			sample_last = m_sample_trigger - m_sample_len;
 801c85e:	4a65      	ldr	r2, [pc, #404]	; (801c9f4 <mc_interface_mc_timer_isr+0x5a4>)
 801c860:	f8d8 3000 	ldr.w	r3, [r8]
 801c864:	6812      	ldr	r2, [r2, #0]
			if (sample_last < 0) {
 801c866:	1a9b      	subs	r3, r3, r2
 801c868:	d559      	bpl.n	801c91e <mc_interface_mc_timer_isr+0x4ce>
				sample_last += ADC_SAMPLE_MAX_LEN;
 801c86a:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 801c86e:	e056      	b.n	801c91e <mc_interface_mc_timer_isr+0x4ce>
		if (mc_interface_get_state() == MC_STATE_RUNNING || m_sample_now > 0) {
 801c870:	f7fe fe0e 	bl	801b490 <mc_interface_get_state>
 801c874:	2802      	cmp	r0, #2
 801c876:	4d4d      	ldr	r5, [pc, #308]	; (801c9ac <mc_interface_mc_timer_isr+0x55c>)
 801c878:	d003      	beq.n	801c882 <mc_interface_mc_timer_isr+0x432>
 801c87a:	682b      	ldr	r3, [r5, #0]
 801c87c:	2b00      	cmp	r3, #0
 801c87e:	f340 8133 	ble.w	801cae8 <mc_interface_mc_timer_isr+0x698>
		if (m_sample_now == m_sample_len) {
 801c882:	4b5c      	ldr	r3, [pc, #368]	; (801c9f4 <mc_interface_mc_timer_isr+0x5a4>)
 801c884:	682a      	ldr	r2, [r5, #0]
 801c886:	681b      	ldr	r3, [r3, #0]
 801c888:	429a      	cmp	r2, r3
 801c88a:	f47f af2b 	bne.w	801c6e4 <mc_interface_mc_timer_isr+0x294>
 801c88e:	f04f 0901 	mov.w	r9, #1
			m_sample_mode_last = m_sample_mode;
 801c892:	783b      	ldrb	r3, [r7, #0]
 801c894:	4a58      	ldr	r2, [pc, #352]	; (801c9f8 <mc_interface_mc_timer_isr+0x5a8>)
 801c896:	b2db      	uxtb	r3, r3
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c898:	f04f 0800 	mov.w	r8, #0
			m_sample_mode_last = m_sample_mode;
 801c89c:	7013      	strb	r3, [r2, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 801c89e:	2320      	movs	r3, #32
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c8a0:	f887 8000 	strb.w	r8, [r7]
 801c8a4:	f383 8811 	msr	BASEPRI, r3
			chEvtSignalI(sample_send_tp, (eventmask_t) 1);
 801c8a8:	4b54      	ldr	r3, [pc, #336]	; (801c9fc <mc_interface_mc_timer_isr+0x5ac>)
 801c8aa:	2101      	movs	r1, #1
 801c8ac:	6818      	ldr	r0, [r3, #0]
 801c8ae:	f7f1 fab7 	bl	800de20 <chEvtSignalI>
 801c8b2:	f388 8811 	msr	BASEPRI, r8
	if (sample) {
 801c8b6:	f1b9 0f00 	cmp.w	r9, #0
 801c8ba:	d098      	beq.n	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c8bc:	e712      	b.n	801c6e4 <mc_interface_mc_timer_isr+0x294>
		if (m_sample_now == m_sample_len) {
 801c8be:	4d3b      	ldr	r5, [pc, #236]	; (801c9ac <mc_interface_mc_timer_isr+0x55c>)
 801c8c0:	4b4c      	ldr	r3, [pc, #304]	; (801c9f4 <mc_interface_mc_timer_isr+0x5a4>)
 801c8c2:	682a      	ldr	r2, [r5, #0]
 801c8c4:	681b      	ldr	r3, [r3, #0]
 801c8c6:	429a      	cmp	r2, r3
 801c8c8:	f47f af0c 	bne.w	801c6e4 <mc_interface_mc_timer_isr+0x294>
			m_sample_mode_last = DEBUG_SAMPLING_NOW;
 801c8cc:	4a4a      	ldr	r2, [pc, #296]	; (801c9f8 <mc_interface_mc_timer_isr+0x5a8>)
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c8ce:	2400      	movs	r4, #0
			m_sample_mode_last = DEBUG_SAMPLING_NOW;
 801c8d0:	2101      	movs	r1, #1
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c8d2:	703c      	strb	r4, [r7, #0]
 801c8d4:	2320      	movs	r3, #32
			m_sample_mode_last = DEBUG_SAMPLING_NOW;
 801c8d6:	7011      	strb	r1, [r2, #0]
 801c8d8:	f383 8811 	msr	BASEPRI, r3
			chEvtSignalI(sample_send_tp, (eventmask_t) 1);
 801c8dc:	4b47      	ldr	r3, [pc, #284]	; (801c9fc <mc_interface_mc_timer_isr+0x5ac>)
 801c8de:	6818      	ldr	r0, [r3, #0]
 801c8e0:	f7f1 fa9e 	bl	800de20 <chEvtSignalI>
 801c8e4:	f384 8811 	msr	BASEPRI, r4
 801c8e8:	e781      	b.n	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c8ea:	2003      	movs	r0, #3
 801c8ec:	f7fe ff28 	bl	801b740 <mc_interface_fault_stop.part.3>
 801c8f0:	e651      	b.n	801c596 <mc_interface_mc_timer_isr+0x146>
		abs_current = mcpwm_foc_get_abs_motor_current();
 801c8f2:	f001 fa0d 	bl	801dd10 <mcpwm_foc_get_abs_motor_current>
 801c8f6:	eeb0 9a40 	vmov.f32	s18, s0
		abs_current_filtered = mcpwm_foc_get_abs_motor_current_filtered();
 801c8fa:	f001 fa11 	bl	801dd20 <mcpwm_foc_get_abs_motor_current_filtered>
 801c8fe:	e62f      	b.n	801c560 <mc_interface_mc_timer_isr+0x110>
 801c900:	f7fe ff1e 	bl	801b740 <mc_interface_fault_stop.part.3>
 801c904:	e5d0      	b.n	801c4a8 <mc_interface_mc_timer_isr+0x58>
			sample_last = m_sample_trigger - m_sample_len;
 801c906:	4a3b      	ldr	r2, [pc, #236]	; (801c9f4 <mc_interface_mc_timer_isr+0x5a4>)
 801c908:	f8d8 3000 	ldr.w	r3, [r8]
 801c90c:	6812      	ldr	r2, [r2, #0]
			if (sample_last < 0) {
 801c90e:	1a9b      	subs	r3, r3, r2
 801c910:	f57f aed9 	bpl.w	801c6c6 <mc_interface_mc_timer_isr+0x276>
				sample_last += ADC_SAMPLE_MAX_LEN;
 801c914:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 801c918:	e6d5      	b.n	801c6c6 <mc_interface_mc_timer_isr+0x276>
		int sample_last = -1;
 801c91a:	f04f 33ff 	mov.w	r3, #4294967295
		if (m_sample_now == sample_last) {
 801c91e:	4d23      	ldr	r5, [pc, #140]	; (801c9ac <mc_interface_mc_timer_isr+0x55c>)
 801c920:	682a      	ldr	r2, [r5, #0]
 801c922:	429a      	cmp	r2, r3
 801c924:	d014      	beq.n	801c950 <mc_interface_mc_timer_isr+0x500>
		if (mc_interface_get_state() == MC_STATE_RUNNING && m_sample_trigger < 0) {
 801c926:	f7fe fdb3 	bl	801b490 <mc_interface_get_state>
 801c92a:	2802      	cmp	r0, #2
 801c92c:	f47f aeda 	bne.w	801c6e4 <mc_interface_mc_timer_isr+0x294>
 801c930:	e6d1      	b.n	801c6d6 <mc_interface_mc_timer_isr+0x286>
				m_amp_seconds_charged -= curr_diff_sum;
 801c932:	4833      	ldr	r0, [pc, #204]	; (801ca00 <mc_interface_mc_timer_isr+0x5b0>)
				m_watt_seconds_charged -= curr_diff_sum * input_voltage;
 801c934:	4933      	ldr	r1, [pc, #204]	; (801ca04 <mc_interface_mc_timer_isr+0x5b4>)
				m_amp_seconds_charged -= curr_diff_sum;
 801c936:	ed90 7a00 	vldr	s14, [r0]
 801c93a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c93e:	edc0 7a00 	vstr	s15, [r0]
				m_watt_seconds_charged -= curr_diff_sum * input_voltage;
 801c942:	edd1 7a00 	vldr	s15, [r1]
 801c946:	ee37 8ac8 	vsub.f32	s16, s15, s16
 801c94a:	ed81 8a00 	vstr	s16, [r1]
 801c94e:	e65e      	b.n	801c60e <mc_interface_mc_timer_isr+0x1be>
			m_sample_mode_last = m_sample_mode;
 801c950:	783b      	ldrb	r3, [r7, #0]
 801c952:	4a29      	ldr	r2, [pc, #164]	; (801c9f8 <mc_interface_mc_timer_isr+0x5a8>)
 801c954:	b2db      	uxtb	r3, r3
 801c956:	7013      	strb	r3, [r2, #0]
			if (m_sample_mode == DEBUG_SAMPLING_TRIGGER_START) {
 801c958:	783b      	ldrb	r3, [r7, #0]
 801c95a:	2b03      	cmp	r3, #3
 801c95c:	f000 80cd 	beq.w	801cafa <mc_interface_mc_timer_isr+0x6aa>
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c960:	2300      	movs	r3, #0
 801c962:	703b      	strb	r3, [r7, #0]
		if (mc_interface_get_state() == MC_STATE_RUNNING && m_sample_trigger < 0) {
 801c964:	f7fe fd94 	bl	801b490 <mc_interface_get_state>
 801c968:	2802      	cmp	r0, #2
 801c96a:	f47f af40 	bne.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c96e:	f8d8 3000 	ldr.w	r3, [r8]
 801c972:	2b00      	cmp	r3, #0
 801c974:	f6bf af3b 	bge.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
			m_sample_trigger = m_sample_now;
 801c978:	682b      	ldr	r3, [r5, #0]
 801c97a:	f8c8 3000 	str.w	r3, [r8]
 801c97e:	e736      	b.n	801c7ee <mc_interface_mc_timer_isr+0x39e>
			m_sample_mode_last = m_sample_mode;
 801c980:	783b      	ldrb	r3, [r7, #0]
 801c982:	4a1d      	ldr	r2, [pc, #116]	; (801c9f8 <mc_interface_mc_timer_isr+0x5a8>)
 801c984:	b2db      	uxtb	r3, r3
 801c986:	7013      	strb	r3, [r2, #0]
			if (m_sample_mode == DEBUG_SAMPLING_TRIGGER_FAULT) {
 801c988:	783b      	ldrb	r3, [r7, #0]
 801c98a:	2b04      	cmp	r3, #4
 801c98c:	f000 80c1 	beq.w	801cb12 <mc_interface_mc_timer_isr+0x6c2>
		if (m_fault_now != FAULT_CODE_NONE && m_sample_trigger < 0) {
 801c990:	4b07      	ldr	r3, [pc, #28]	; (801c9b0 <mc_interface_mc_timer_isr+0x560>)
 801c992:	781b      	ldrb	r3, [r3, #0]
			m_sample_mode = DEBUG_SAMPLING_OFF;
 801c994:	2200      	movs	r2, #0
 801c996:	703a      	strb	r2, [r7, #0]
		if (m_fault_now != FAULT_CODE_NONE && m_sample_trigger < 0) {
 801c998:	2b00      	cmp	r3, #0
 801c99a:	f43f af28 	beq.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c99e:	f8d8 3000 	ldr.w	r3, [r8]
 801c9a2:	4293      	cmp	r3, r2
 801c9a4:	f6bf af23 	bge.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
 801c9a8:	e7e6      	b.n	801c978 <mc_interface_mc_timer_isr+0x528>
 801c9aa:	bf00      	nop
 801c9ac:	2000c22c 	.word	0x2000c22c
 801c9b0:	2000c1ec 	.word	0x2000c1ec
 801c9b4:	2000c060 	.word	0x2000c060
 801c9b8:	2000c220 	.word	0x2000c220
 801c9bc:	20005408 	.word	0x20005408
 801c9c0:	100076c8 	.word	0x100076c8
 801c9c4:	2000c054 	.word	0x2000c054
 801c9c8:	10000000 	.word	0x10000000
 801c9cc:	100010f8 	.word	0x100010f8
 801c9d0:	100032e8 	.word	0x100032e8
 801c9d4:	100043e0 	.word	0x100043e0
 801c9d8:	100054d8 	.word	0x100054d8
 801c9dc:	100065d0 	.word	0x100065d0
 801c9e0:	42c68ba4 	.word	0x42c68ba4
 801c9e4:	2000c1fc 	.word	0x2000c1fc
 801c9e8:	2000c1f0 	.word	0x2000c1f0
 801c9ec:	2000c1e8 	.word	0x2000c1e8
 801c9f0:	2000cd80 	.word	0x2000cd80
 801c9f4:	2000c224 	.word	0x2000c224
 801c9f8:	2000c229 	.word	0x2000c229
 801c9fc:	2000c7e0 	.word	0x2000c7e0
 801ca00:	2000c070 	.word	0x2000c070
 801ca04:	2000c240 	.word	0x2000c240
 801ca08:	2000c230 	.word	0x2000c230
 801ca0c:	100021f0 	.word	0x100021f0
				zero = (ADC_V_L1 + ADC_V_L2 + ADC_V_L3) / 3;
 801ca10:	88b1      	ldrh	r1, [r6, #4]
 801ca12:	8874      	ldrh	r4, [r6, #2]
 801ca14:	8832      	ldrh	r2, [r6, #0]
 801ca16:	4b45      	ldr	r3, [pc, #276]	; (801cb2c <mc_interface_mc_timer_isr+0x6dc>)
				m_phase_samples[m_sample_now] = (uint8_t)(mcpwm_foc_get_phase() / 360.0 * 250.0);
 801ca18:	4f45      	ldr	r7, [pc, #276]	; (801cb30 <mc_interface_mc_timer_isr+0x6e0>)
				zero = (ADC_V_L1 + ADC_V_L2 + ADC_V_L3) / 3;
 801ca1a:	440c      	add	r4, r1
 801ca1c:	4414      	add	r4, r2
 801ca1e:	fba3 3404 	umull	r3, r4, r3, r4
				m_phase_samples[m_sample_now] = (uint8_t)(mcpwm_foc_get_phase() / 360.0 * 250.0);
 801ca22:	f001 f9cd 	bl	801ddc0 <mcpwm_foc_get_phase>
 801ca26:	ed9f 7a43 	vldr	s14, [pc, #268]	; 801cb34 <mc_interface_mc_timer_isr+0x6e4>
 801ca2a:	eddf 7a43 	vldr	s15, [pc, #268]	; 801cb38 <mc_interface_mc_timer_isr+0x6e8>
 801ca2e:	682b      	ldr	r3, [r5, #0]
 801ca30:	ee80 0a07 	vdiv.f32	s0, s0, s14
 801ca34:	443b      	add	r3, r7
				zero = (ADC_V_L1 + ADC_V_L2 + ADC_V_L3) / 3;
 801ca36:	f344 044f 	sbfx	r4, r4, #1, #16
				m_phase_samples[m_sample_now] = (uint8_t)(mcpwm_foc_get_phase() / 360.0 * 250.0);
 801ca3a:	ee20 0a27 	vmul.f32	s0, s0, s15
 801ca3e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801ca42:	edcd 7a01 	vstr	s15, [sp, #4]
 801ca46:	f99d 2004 	ldrsb.w	r2, [sp, #4]
 801ca4a:	f883 2e08 	strb.w	r2, [r3, #3592]	; 0xe08
 801ca4e:	e665      	b.n	801c71c <mc_interface_mc_timer_isr+0x2cc>
				m_curr0_samples[m_sample_now] = (int16_t)mcpwm_detect_currents[mcpwm_get_comm_step() - 1];
 801ca50:	f7f7 f82e 	bl	8013ab0 <mcpwm_get_comm_step>
 801ca54:	4b39      	ldr	r3, [pc, #228]	; (801cb3c <mc_interface_mc_timer_isr+0x6ec>)
 801ca56:	4e3a      	ldr	r6, [pc, #232]	; (801cb40 <mc_interface_mc_timer_isr+0x6f0>)
 801ca58:	3801      	subs	r0, #1
 801ca5a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801ca5e:	edd3 7a00 	vldr	s15, [r3]
 801ca62:	682a      	ldr	r2, [r5, #0]
 801ca64:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ca68:	ee17 3a90 	vmov	r3, s15
 801ca6c:	b21b      	sxth	r3, r3
 801ca6e:	f826 3012 	strh.w	r3, [r6, r2, lsl #1]
				m_curr1_samples[m_sample_now] = (int16_t)mcpwm_detect_currents_diff[mcpwm_get_comm_step() - 1];
 801ca72:	f7f7 f81d 	bl	8013ab0 <mcpwm_get_comm_step>
 801ca76:	4b33      	ldr	r3, [pc, #204]	; (801cb44 <mc_interface_mc_timer_isr+0x6f4>)
				m_ph1_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[0];
 801ca78:	4933      	ldr	r1, [pc, #204]	; (801cb48 <mc_interface_mc_timer_isr+0x6f8>)
 801ca7a:	4a34      	ldr	r2, [pc, #208]	; (801cb4c <mc_interface_mc_timer_isr+0x6fc>)
				m_curr1_samples[m_sample_now] = (int16_t)mcpwm_detect_currents_diff[mcpwm_get_comm_step() - 1];
 801ca7c:	3801      	subs	r0, #1
 801ca7e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801ca82:	edd3 7a00 	vldr	s15, [r3]
 801ca86:	682b      	ldr	r3, [r5, #0]
				m_ph2_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[1];
 801ca88:	4831      	ldr	r0, [pc, #196]	; (801cb50 <mc_interface_mc_timer_isr+0x700>)
				m_curr1_samples[m_sample_now] = (int16_t)mcpwm_detect_currents_diff[mcpwm_get_comm_step() - 1];
 801ca8a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ca8e:	eb06 0643 	add.w	r6, r6, r3, lsl #1
 801ca92:	ee17 3a90 	vmov	r3, s15
 801ca96:	b21b      	sxth	r3, r3
 801ca98:	f8a6 3fa0 	strh.w	r3, [r6, #4000]	; 0xfa0
				m_ph1_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[0];
 801ca9c:	edd1 7a00 	vldr	s15, [r1]
 801caa0:	682b      	ldr	r3, [r5, #0]
 801caa2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801caa6:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801caaa:	ee17 3a90 	vmov	r3, s15
 801caae:	b21b      	sxth	r3, r3
 801cab0:	f8a2 3e48 	strh.w	r3, [r2, #3656]	; 0xe48
				m_ph2_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[1];
 801cab4:	edd1 7a01 	vldr	s15, [r1, #4]
 801cab8:	682b      	ldr	r3, [r5, #0]
				m_ph3_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[2];
 801caba:	4a26      	ldr	r2, [pc, #152]	; (801cb54 <mc_interface_mc_timer_isr+0x704>)
				m_ph2_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[1];
 801cabc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cac0:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 801cac4:	ee17 3a90 	vmov	r3, s15
 801cac8:	b21b      	sxth	r3, r3
 801caca:	f8a0 3cf0 	strh.w	r3, [r0, #3312]	; 0xcf0
				m_ph3_samples[m_sample_now] = (int16_t)mcpwm_detect_voltages[2];
 801cace:	edd1 7a02 	vldr	s15, [r1, #8]
 801cad2:	682b      	ldr	r3, [r5, #0]
 801cad4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cad8:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801cadc:	ee17 3a90 	vmov	r3, s15
 801cae0:	b21b      	sxth	r3, r3
 801cae2:	f8a2 3b98 	strh.w	r3, [r2, #2968]	; 0xb98
 801cae6:	e64a      	b.n	801c77e <mc_interface_mc_timer_isr+0x32e>
		if (m_sample_now == m_sample_len) {
 801cae8:	4b1b      	ldr	r3, [pc, #108]	; (801cb58 <mc_interface_mc_timer_isr+0x708>)
 801caea:	682a      	ldr	r2, [r5, #0]
 801caec:	681b      	ldr	r3, [r3, #0]
 801caee:	429a      	cmp	r2, r3
 801caf0:	f47f ae7d 	bne.w	801c7ee <mc_interface_mc_timer_isr+0x39e>
	bool sample = false;
 801caf4:	f04f 0900 	mov.w	r9, #0
 801caf8:	e6cb      	b.n	801c892 <mc_interface_mc_timer_isr+0x442>
 801cafa:	2320      	movs	r3, #32
 801cafc:	f383 8811 	msr	BASEPRI, r3
				chEvtSignalI(sample_send_tp, (eventmask_t) 1);
 801cb00:	4b16      	ldr	r3, [pc, #88]	; (801cb5c <mc_interface_mc_timer_isr+0x70c>)
 801cb02:	2101      	movs	r1, #1
 801cb04:	6818      	ldr	r0, [r3, #0]
 801cb06:	f7f1 f98b 	bl	800de20 <chEvtSignalI>
 801cb0a:	2300      	movs	r3, #0
 801cb0c:	f383 8811 	msr	BASEPRI, r3
 801cb10:	e726      	b.n	801c960 <mc_interface_mc_timer_isr+0x510>
 801cb12:	2320      	movs	r3, #32
 801cb14:	f383 8811 	msr	BASEPRI, r3
				chEvtSignalI(sample_send_tp, (eventmask_t) 1);
 801cb18:	4b10      	ldr	r3, [pc, #64]	; (801cb5c <mc_interface_mc_timer_isr+0x70c>)
 801cb1a:	2101      	movs	r1, #1
 801cb1c:	6818      	ldr	r0, [r3, #0]
 801cb1e:	f7f1 f97f 	bl	800de20 <chEvtSignalI>
 801cb22:	2300      	movs	r3, #0
 801cb24:	f383 8811 	msr	BASEPRI, r3
 801cb28:	e732      	b.n	801c990 <mc_interface_mc_timer_isr+0x540>
 801cb2a:	bf00      	nop
 801cb2c:	aaaaaaab 	.word	0xaaaaaaab
 801cb30:	100076c8 	.word	0x100076c8
 801cb34:	43b40000 	.word	0x43b40000
 801cb38:	437a0000 	.word	0x437a0000
 801cb3c:	200053a8 	.word	0x200053a8
 801cb40:	10000000 	.word	0x10000000
 801cb44:	200053d8 	.word	0x200053d8
 801cb48:	200053f0 	.word	0x200053f0
 801cb4c:	100010f8 	.word	0x100010f8
 801cb50:	100021f0 	.word	0x100021f0
 801cb54:	100032e8 	.word	0x100032e8
 801cb58:	2000c224 	.word	0x2000c224
 801cb5c:	2000c7e0 	.word	0x2000c7e0

0801cb60 <mc_interface_adc_inj_int_handler>:
	switch (m_conf.motor_type) {
 801cb60:	4b03      	ldr	r3, [pc, #12]	; (801cb70 <mc_interface_adc_inj_int_handler+0x10>)
 801cb62:	789b      	ldrb	r3, [r3, #2]
 801cb64:	2b01      	cmp	r3, #1
 801cb66:	d900      	bls.n	801cb6a <mc_interface_adc_inj_int_handler+0xa>
}
 801cb68:	4770      	bx	lr
		mcpwm_adc_inj_int_handler();
 801cb6a:	f7f7 b871 	b.w	8013c50 <mcpwm_adc_inj_int_handler>
 801cb6e:	bf00      	nop
 801cb70:	2000c074 	.word	0x2000c074
	...

0801cb80 <correct_encoder>:
			(utils_middle_of_3_int(h2_1, h2_2, h2_3) << 1) |
			(utils_middle_of_3_int(h3_1, h3_2, h3_3) << 2);
}

static float correct_encoder(float obs_angle, float enc_angle, float speed) {
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cb80:	eddf 6a14 	vldr	s13, [pc, #80]	; 801cbd4 <correct_encoder+0x54>
	static bool using_encoder = true;

	// Hysteresis 5 % of total speed
	float hyst = m_conf->foc_sl_erpm * 0.05;
 801cb84:	4b14      	ldr	r3, [pc, #80]	; (801cbd8 <correct_encoder+0x58>)
	if (using_encoder) {
 801cb86:	4a15      	ldr	r2, [pc, #84]	; (801cbdc <correct_encoder+0x5c>)
	float hyst = m_conf->foc_sl_erpm * 0.05;
 801cb88:	681b      	ldr	r3, [r3, #0]
 801cb8a:	ed9f 7a15 	vldr	s14, [pc, #84]	; 801cbe0 <correct_encoder+0x60>
 801cb8e:	edd3 7a41 	vldr	s15, [r3, #260]	; 0x104
	if (using_encoder) {
 801cb92:	7811      	ldrb	r1, [r2, #0]
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cb94:	ee81 1a26 	vdiv.f32	s2, s2, s13
	float hyst = m_conf->foc_sl_erpm * 0.05;
 801cb98:	ee67 7a87 	vmul.f32	s15, s15, s14
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cb9c:	eeb0 1ac1 	vabs.f32	s2, s2
		if (rpm_abs > (m_conf->foc_sl_erpm + hyst)) {
 801cba0:	ed93 7a41 	vldr	s14, [r3, #260]	; 0x104
	if (using_encoder) {
 801cba4:	b149      	cbz	r1, 801cbba <correct_encoder+0x3a>
		if (rpm_abs > (m_conf->foc_sl_erpm + hyst)) {
 801cba6:	ee77 7a27 	vadd.f32	s15, s14, s15
 801cbaa:	eef4 7ac1 	vcmpe.f32	s15, s2
 801cbae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cbb2:	d40c      	bmi.n	801cbce <correct_encoder+0x4e>
		if (rpm_abs < (m_conf->foc_sl_erpm - hyst)) {
			using_encoder = true;
		}
	}

	return using_encoder ? enc_angle : obs_angle;
 801cbb4:	eeb0 0a60 	vmov.f32	s0, s1
}
 801cbb8:	4770      	bx	lr
		if (rpm_abs < (m_conf->foc_sl_erpm - hyst)) {
 801cbba:	ee77 7a67 	vsub.f32	s15, s14, s15
 801cbbe:	eef4 7ac1 	vcmpe.f32	s15, s2
 801cbc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cbc6:	ddf7      	ble.n	801cbb8 <correct_encoder+0x38>
			using_encoder = true;
 801cbc8:	2301      	movs	r3, #1
 801cbca:	7013      	strb	r3, [r2, #0]
 801cbcc:	e7f2      	b.n	801cbb4 <correct_encoder+0x34>
			using_encoder = false;
 801cbce:	2300      	movs	r3, #0
 801cbd0:	7013      	strb	r3, [r2, #0]
 801cbd2:	4770      	bx	lr
 801cbd4:	3dd67750 	.word	0x3dd67750
 801cbd8:	2000cda8 	.word	0x2000cda8
 801cbdc:	2000104c 	.word	0x2000104c
 801cbe0:	3d4ccccd 	.word	0x3d4ccccd
	...

0801cbf0 <start_pwm_hw>:
static void start_pwm_hw(void) {
 801cbf0:	b510      	push	{r4, lr}
	TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
 801cbf2:	4c19      	ldr	r4, [pc, #100]	; (801cc58 <start_pwm_hw+0x68>)
 801cbf4:	2260      	movs	r2, #96	; 0x60
 801cbf6:	4620      	mov	r0, r4
 801cbf8:	2100      	movs	r1, #0
 801cbfa:	f007 fdc9 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 801cbfe:	4620      	mov	r0, r4
 801cc00:	2201      	movs	r2, #1
 801cc02:	2100      	movs	r1, #0
 801cc04:	f007 fe1c 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);
 801cc08:	4620      	mov	r0, r4
 801cc0a:	2204      	movs	r2, #4
 801cc0c:	2100      	movs	r1, #0
 801cc0e:	f007 fe27 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
 801cc12:	4620      	mov	r0, r4
 801cc14:	2260      	movs	r2, #96	; 0x60
 801cc16:	2104      	movs	r1, #4
 801cc18:	f007 fdba 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 801cc1c:	4620      	mov	r0, r4
 801cc1e:	2201      	movs	r2, #1
 801cc20:	2104      	movs	r1, #4
 801cc22:	f007 fe0d 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
 801cc26:	2204      	movs	r2, #4
 801cc28:	4611      	mov	r1, r2
 801cc2a:	4620      	mov	r0, r4
 801cc2c:	f007 fe18 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
 801cc30:	4620      	mov	r0, r4
 801cc32:	2260      	movs	r2, #96	; 0x60
 801cc34:	2108      	movs	r1, #8
 801cc36:	f007 fdab 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 801cc3a:	4620      	mov	r0, r4
 801cc3c:	2201      	movs	r2, #1
 801cc3e:	2108      	movs	r1, #8
 801cc40:	f007 fdfe 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
 801cc44:	2204      	movs	r2, #4
 801cc46:	4620      	mov	r0, r4
 801cc48:	2108      	movs	r1, #8
 801cc4a:	f007 fe09 	bl	8024860 <TIM_CCxNCmd>
	m_output_on = true;
 801cc4e:	4b03      	ldr	r3, [pc, #12]	; (801cc5c <start_pwm_hw+0x6c>)
 801cc50:	2201      	movs	r2, #1
 801cc52:	701a      	strb	r2, [r3, #0]
}
 801cc54:	bd10      	pop	{r4, pc}
 801cc56:	bf00      	nop
 801cc58:	40010000 	.word	0x40010000
 801cc5c:	2000ce48 	.word	0x2000ce48

0801cc60 <stop_pwm_hw>:
static void stop_pwm_hw(void) {
 801cc60:	b510      	push	{r4, lr}
	TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);
 801cc62:	4c1b      	ldr	r4, [pc, #108]	; (801ccd0 <stop_pwm_hw+0x70>)
 801cc64:	2240      	movs	r2, #64	; 0x40
 801cc66:	4620      	mov	r0, r4
 801cc68:	2100      	movs	r1, #0
 801cc6a:	f007 fd91 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 801cc6e:	4620      	mov	r0, r4
 801cc70:	2201      	movs	r2, #1
 801cc72:	2100      	movs	r1, #0
 801cc74:	f007 fde4 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
 801cc78:	2200      	movs	r2, #0
 801cc7a:	4611      	mov	r1, r2
 801cc7c:	4620      	mov	r0, r4
 801cc7e:	f007 fdef 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);
 801cc82:	4620      	mov	r0, r4
 801cc84:	2240      	movs	r2, #64	; 0x40
 801cc86:	2104      	movs	r1, #4
 801cc88:	f007 fd82 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 801cc8c:	4620      	mov	r0, r4
 801cc8e:	2201      	movs	r2, #1
 801cc90:	2104      	movs	r1, #4
 801cc92:	f007 fdd5 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
 801cc96:	4620      	mov	r0, r4
 801cc98:	2200      	movs	r2, #0
 801cc9a:	2104      	movs	r1, #4
 801cc9c:	f007 fde0 	bl	8024860 <TIM_CCxNCmd>
	TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
 801cca0:	4620      	mov	r0, r4
 801cca2:	2240      	movs	r2, #64	; 0x40
 801cca4:	2108      	movs	r1, #8
 801cca6:	f007 fd73 	bl	8024790 <TIM_SelectOCxM>
	TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 801ccaa:	4620      	mov	r0, r4
 801ccac:	2201      	movs	r2, #1
 801ccae:	2108      	movs	r1, #8
 801ccb0:	f007 fdc6 	bl	8024840 <TIM_CCxCmd>
	TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
 801ccb4:	2200      	movs	r2, #0
 801ccb6:	4620      	mov	r0, r4
 801ccb8:	2108      	movs	r1, #8
 801ccba:	f007 fdd1 	bl	8024860 <TIM_CCxNCmd>
	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 801ccbe:	4620      	mov	r0, r4
 801ccc0:	2120      	movs	r1, #32
 801ccc2:	f007 fe15 	bl	80248f0 <TIM_GenerateEvent>
	m_output_on = false;
 801ccc6:	4b03      	ldr	r3, [pc, #12]	; (801ccd4 <stop_pwm_hw+0x74>)
 801ccc8:	2200      	movs	r2, #0
 801ccca:	701a      	strb	r2, [r3, #0]
}
 801cccc:	bd10      	pop	{r4, pc}
 801ccce:	bf00      	nop
 801ccd0:	40010000 	.word	0x40010000
 801ccd4:	2000ce48 	.word	0x2000ce48
	...

0801cce0 <read_hall>:
static int read_hall(void) {
 801cce0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int h1_1 = READ_HALL1();
 801cce4:	4b16      	ldr	r3, [pc, #88]	; (801cd40 <read_hall+0x60>)
	int h3_1 = READ_HALL3();
 801cce6:	4c17      	ldr	r4, [pc, #92]	; (801cd44 <read_hall+0x64>)
	int h1_1 = READ_HALL1();
 801cce8:	6918      	ldr	r0, [r3, #16]
	int h2_1 = READ_HALL2();
 801ccea:	691d      	ldr	r5, [r3, #16]
	int h3_1 = READ_HALL3();
 801ccec:	6926      	ldr	r6, [r4, #16]
	int h1_2 = READ_HALL1();
 801ccee:	6919      	ldr	r1, [r3, #16]
	int h2_2 = READ_HALL2();
 801ccf0:	f8d3 9010 	ldr.w	r9, [r3, #16]
	int h3_2 = READ_HALL3();
 801ccf4:	6927      	ldr	r7, [r4, #16]
	int h1_3 = READ_HALL1();
 801ccf6:	691a      	ldr	r2, [r3, #16]
	int h2_3 = READ_HALL2();
 801ccf8:	f8d3 a010 	ldr.w	sl, [r3, #16]
	int h3_3 = READ_HALL3();
 801ccfc:	f8d4 8010 	ldr.w	r8, [r4, #16]
	return utils_middle_of_3_int(h1_1, h1_2, h1_3) |
 801cd00:	f3c1 1180 	ubfx	r1, r1, #6, #1
 801cd04:	f3c2 1280 	ubfx	r2, r2, #6, #1
 801cd08:	f3c0 1080 	ubfx	r0, r0, #6, #1
 801cd0c:	f7f8 ffc8 	bl	8015ca0 <utils_middle_of_3_int>
			(utils_middle_of_3_int(h2_1, h2_2, h2_3) << 1) |
 801cd10:	f3ca 12c0 	ubfx	r2, sl, #7, #1
	return utils_middle_of_3_int(h1_1, h1_2, h1_3) |
 801cd14:	4604      	mov	r4, r0
			(utils_middle_of_3_int(h2_1, h2_2, h2_3) << 1) |
 801cd16:	f3c9 11c0 	ubfx	r1, r9, #7, #1
 801cd1a:	f3c5 10c0 	ubfx	r0, r5, #7, #1
 801cd1e:	f7f8 ffbf 	bl	8015ca0 <utils_middle_of_3_int>
			(utils_middle_of_3_int(h3_1, h3_2, h3_3) << 2);
 801cd22:	f3c8 22c0 	ubfx	r2, r8, #11, #1
			(utils_middle_of_3_int(h2_1, h2_2, h2_3) << 1) |
 801cd26:	4605      	mov	r5, r0
			(utils_middle_of_3_int(h3_1, h3_2, h3_3) << 2);
 801cd28:	f3c7 21c0 	ubfx	r1, r7, #11, #1
 801cd2c:	f3c6 20c0 	ubfx	r0, r6, #11, #1
 801cd30:	f7f8 ffb6 	bl	8015ca0 <utils_middle_of_3_int>
 801cd34:	0080      	lsls	r0, r0, #2
			(utils_middle_of_3_int(h2_1, h2_2, h2_3) << 1) |
 801cd36:	ea40 0045 	orr.w	r0, r0, r5, lsl #1
}
 801cd3a:	4320      	orrs	r0, r4
 801cd3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801cd40:	40020400 	.word	0x40020400
 801cd44:	40020800 	.word	0x40020800
	...

0801cd50 <correct_hall>:

static float correct_hall(float angle, float speed, float dt) {
 801cd50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static int ang_hall_int_prev = -1;
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cd52:	eddf 6a6b 	vldr	s13, [pc, #428]	; 801cf00 <correct_hall+0x1b0>
	static bool using_hall = true;

	// Hysteresis 5 % of total speed
	float hyst = m_conf->foc_sl_erpm * 0.1;
 801cd56:	4a6b      	ldr	r2, [pc, #428]	; (801cf04 <correct_hall+0x1b4>)
	if (using_hall) {
 801cd58:	4b6b      	ldr	r3, [pc, #428]	; (801cf08 <correct_hall+0x1b8>)
	float hyst = m_conf->foc_sl_erpm * 0.1;
 801cd5a:	6815      	ldr	r5, [r2, #0]
 801cd5c:	ed9f 7a6b 	vldr	s14, [pc, #428]	; 801cf0c <correct_hall+0x1bc>
 801cd60:	edd5 7a41 	vldr	s15, [r5, #260]	; 0x104
	if (using_hall) {
 801cd64:	781a      	ldrb	r2, [r3, #0]
static float correct_hall(float angle, float speed, float dt) {
 801cd66:	ed2d 8b02 	vpush	{d8}
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cd6a:	ee80 8aa6 	vdiv.f32	s16, s1, s13
	float hyst = m_conf->foc_sl_erpm * 0.1;
 801cd6e:	ee67 7a87 	vmul.f32	s15, s15, s14
	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
 801cd72:	eeb0 8ac8 	vabs.f32	s16, s16
		if (rpm_abs > (m_conf->foc_sl_erpm + hyst)) {
 801cd76:	ed95 7a41 	vldr	s14, [r5, #260]	; 0x104
	if (using_hall) {
 801cd7a:	b17a      	cbz	r2, 801cd9c <correct_hall+0x4c>
		if (rpm_abs > (m_conf->foc_sl_erpm + hyst)) {
 801cd7c:	ee77 7a27 	vadd.f32	s15, s14, s15
 801cd80:	eef4 7ac8 	vcmpe.f32	s15, s16
 801cd84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cd88:	d511      	bpl.n	801cdae <correct_hall+0x5e>
			using_hall = false;
 801cd8a:	2200      	movs	r2, #0
 801cd8c:	701a      	strb	r2, [r3, #0]
				angle = m_phase_now_observer_override;
			}
		}
	} else {
		// We are running sensorless.
		ang_hall_int_prev = -2;
 801cd8e:	4b60      	ldr	r3, [pc, #384]	; (801cf10 <correct_hall+0x1c0>)
 801cd90:	f06f 0201 	mvn.w	r2, #1
 801cd94:	601a      	str	r2, [r3, #0]
	}

	return angle;
}
 801cd96:	ecbd 8b02 	vpop	{d8}
 801cd9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (rpm_abs < (m_conf->foc_sl_erpm - hyst)) {
 801cd9c:	ee77 7a67 	vsub.f32	s15, s14, s15
 801cda0:	eef4 7ac8 	vcmpe.f32	s15, s16
 801cda4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cda8:	ddf1      	ble.n	801cd8e <correct_hall+0x3e>
			using_hall = true;
 801cdaa:	2201      	movs	r2, #1
 801cdac:	701a      	strb	r2, [r3, #0]
 801cdae:	ee11 7a10 	vmov	r7, s2
 801cdb2:	ee10 4a10 	vmov	r4, s0
 801cdb6:	ee10 6a90 	vmov	r6, s1
		int ang_hall_int = m_conf->foc_hall_table[read_hall()];
 801cdba:	f7ff ff91 	bl	801cce0 <read_hall>
 801cdbe:	4428      	add	r0, r5
 801cdc0:	f890 30f9 	ldrb.w	r3, [r0, #249]	; 0xf9
 801cdc4:	b2db      	uxtb	r3, r3
		if (ang_hall_int < 201) {
 801cdc6:	2bc8      	cmp	r3, #200	; 0xc8
 801cdc8:	dc3f      	bgt.n	801ce4a <correct_hall+0xfa>
			float ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
 801cdca:	ee07 3a90 	vmov	s15, r3
 801cdce:	eddf 5a51 	vldr	s11, [pc, #324]	; 801cf14 <correct_hall+0x1c4>
 801cdd2:	ed9f 6a51 	vldr	s12, [pc, #324]	; 801cf18 <correct_hall+0x1c8>
			if (ang_hall_int_prev < 0) {
 801cdd6:	494e      	ldr	r1, [pc, #312]	; (801cf10 <correct_hall+0x1c0>)
			float ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
 801cdd8:	ed9f 7a50 	vldr	s14, [pc, #320]	; 801cf1c <correct_hall+0x1cc>
			if (ang_hall_int_prev < 0) {
 801cddc:	680a      	ldr	r2, [r1, #0]
			float ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
 801cdde:	eddf 6a50 	vldr	s13, [pc, #320]	; 801cf20 <correct_hall+0x1d0>
 801cde2:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
			if (ang_hall_int_prev < 0) {
 801cde6:	2a00      	cmp	r2, #0
			float ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
 801cde8:	eec5 7a25 	vdiv.f32	s15, s10, s11
 801cdec:	ee67 7a86 	vmul.f32	s15, s15, s12
 801cdf0:	ee67 7a87 	vmul.f32	s15, s15, s14
 801cdf4:	eec7 0aa6 	vdiv.f32	s1, s15, s13
			if (ang_hall_int_prev < 0) {
 801cdf8:	db37      	blt.n	801ce6a <correct_hall+0x11a>
			} else if (ang_hall_int != ang_hall_int_prev) {
 801cdfa:	429a      	cmp	r2, r3
 801cdfc:	d079      	beq.n	801cef2 <correct_hall+0x1a2>
				int ang_avg = abs(ang_hall_int - ang_hall_int_prev);
 801cdfe:	1a98      	subs	r0, r3, r2
 801ce00:	2800      	cmp	r0, #0
 801ce02:	bfb8      	it	lt
 801ce04:	4240      	neglt	r0, r0
				if (ang_avg < 100) {
 801ce06:	2863      	cmp	r0, #99	; 0x63
 801ce08:	dd5c      	ble.n	801cec4 <correct_hall+0x174>
				} else if (ang_avg != 100) {
 801ce0a:	2864      	cmp	r0, #100	; 0x64
 801ce0c:	d019      	beq.n	801ce42 <correct_hall+0xf2>
					ang_avg = (ang_hall_int + ang_hall_int_prev) / 2 + 100;
 801ce0e:	441a      	add	r2, r3
 801ce10:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 801ce14:	1052      	asrs	r2, r2, #1
 801ce16:	4c43      	ldr	r4, [pc, #268]	; (801cf24 <correct_hall+0x1d4>)
 801ce18:	3264      	adds	r2, #100	; 0x64
 801ce1a:	fb84 0402 	smull	r0, r4, r4, r2
 801ce1e:	17d0      	asrs	r0, r2, #31
 801ce20:	ebc0 10a4 	rsb	r0, r0, r4, asr #6
 801ce24:	24c8      	movs	r4, #200	; 0xc8
 801ce26:	fb04 2210 	mls	r2, r4, r0, r2
 801ce2a:	ee07 2a90 	vmov	s15, r2
 801ce2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801ce32:	ee87 5aa5 	vdiv.f32	s10, s15, s11
 801ce36:	ee25 6a06 	vmul.f32	s12, s10, s12
 801ce3a:	ee26 6a07 	vmul.f32	s12, s12, s14
 801ce3e:	ee86 7a26 	vdiv.f32	s14, s12, s13
				ang_hall = (((float)ang_avg / 200.0) * 360.0) * M_PI / 180.0;
 801ce42:	4c39      	ldr	r4, [pc, #228]	; (801cf28 <correct_hall+0x1d8>)
 801ce44:	ed84 7a00 	vstr	s14, [r4]
 801ce48:	e012      	b.n	801ce70 <correct_hall+0x120>
			if (m_phase_observer_override && m_state == MC_STATE_RUNNING) {
 801ce4a:	4b38      	ldr	r3, [pc, #224]	; (801cf2c <correct_hall+0x1dc>)
			ang_hall_int_prev = -1;
 801ce4c:	4a30      	ldr	r2, [pc, #192]	; (801cf10 <correct_hall+0x1c0>)
			if (m_phase_observer_override && m_state == MC_STATE_RUNNING) {
 801ce4e:	781b      	ldrb	r3, [r3, #0]
			ang_hall_int_prev = -1;
 801ce50:	f04f 31ff 	mov.w	r1, #4294967295
 801ce54:	6011      	str	r1, [r2, #0]
			if (m_phase_observer_override && m_state == MC_STATE_RUNNING) {
 801ce56:	b11b      	cbz	r3, 801ce60 <correct_hall+0x110>
 801ce58:	4b35      	ldr	r3, [pc, #212]	; (801cf30 <correct_hall+0x1e0>)
 801ce5a:	781b      	ldrb	r3, [r3, #0]
 801ce5c:	2b02      	cmp	r3, #2
 801ce5e:	d04a      	beq.n	801cef6 <correct_hall+0x1a6>
}
 801ce60:	ecbd 8b02 	vpop	{d8}
 801ce64:	ee00 4a10 	vmov	s0, r4
 801ce68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					ang_hall = ((ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
 801ce6a:	4c2f      	ldr	r4, [pc, #188]	; (801cf28 <correct_hall+0x1d8>)
 801ce6c:	edc4 0a00 	vstr	s1, [r4]
			if (rpm_abs < 100) {
 801ce70:	eddf 8a30 	vldr	s17, [pc, #192]	; 801cf34 <correct_hall+0x1e4>
			ang_hall_int_prev = ang_hall_int;
 801ce74:	600b      	str	r3, [r1, #0]
			if (rpm_abs < 100) {
 801ce76:	eeb4 8ae8 	vcmpe.f32	s16, s17
 801ce7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ce7e:	d509      	bpl.n	801ce94 <correct_hall+0x144>
				ang_hall = ang_hall_now;
 801ce80:	edc4 0a00 	vstr	s1, [r4]
			utils_norm_angle_rad(&ang_hall);
 801ce84:	4828      	ldr	r0, [pc, #160]	; (801cf28 <correct_hall+0x1d8>)
 801ce86:	f7f8 fdcb 	bl	8015a20 <utils_norm_angle_rad>
}
 801ce8a:	ecbd 8b02 	vpop	{d8}
			angle = ang_hall;
 801ce8e:	ed94 0a00 	vldr	s0, [r4]
}
 801ce92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				float diff = utils_angle_difference_rad(ang_hall, ang_hall_now);
 801ce94:	ed94 0a00 	vldr	s0, [r4]
 801ce98:	f7f8 fe9a 	bl	8015bd0 <utils_angle_difference_rad>
				if (fabsf(diff) < ((2.0 * M_PI) / 12.0)) {
 801ce9c:	eddf 7a26 	vldr	s15, [pc, #152]	; 801cf38 <correct_hall+0x1e8>
 801cea0:	eeb0 7ac0 	vabs.f32	s14, s0
 801cea4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801cea8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ceac:	d518      	bpl.n	801cee0 <correct_hall+0x190>
					ang_hall += speed * dt;
 801ceae:	edd4 7a00 	vldr	s15, [r4]
 801ceb2:	ee07 6a10 	vmov	s14, r6
 801ceb6:	ee06 7a90 	vmov	s13, r7
 801ceba:	eee7 7a26 	vfma.f32	s15, s14, s13
 801cebe:	edc4 7a00 	vstr	s15, [r4]
 801cec2:	e7df      	b.n	801ce84 <correct_hall+0x134>
					ang_avg = (ang_hall_int + ang_hall_int_prev) / 2;
 801cec4:	441a      	add	r2, r3
 801cec6:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 801ceca:	4816      	ldr	r0, [pc, #88]	; (801cf24 <correct_hall+0x1d4>)
 801cecc:	1054      	asrs	r4, r2, #1
 801cece:	fb80 5004 	smull	r5, r0, r0, r4
 801ced2:	17d2      	asrs	r2, r2, #31
 801ced4:	ebc2 12a0 	rsb	r2, r2, r0, asr #6
 801ced8:	20c8      	movs	r0, #200	; 0xc8
 801ceda:	fb00 4212 	mls	r2, r0, r2, r4
 801cede:	e7a4      	b.n	801ce2a <correct_hall+0xda>
					ang_hall -= diff / 100.0;
 801cee0:	ee80 7a28 	vdiv.f32	s14, s0, s17
 801cee4:	edd4 7a00 	vldr	s15, [r4]
 801cee8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801ceec:	edc4 7a00 	vstr	s15, [r4]
 801cef0:	e7c8      	b.n	801ce84 <correct_hall+0x134>
 801cef2:	4c0d      	ldr	r4, [pc, #52]	; (801cf28 <correct_hall+0x1d8>)
 801cef4:	e7bc      	b.n	801ce70 <correct_hall+0x120>
				angle = m_phase_now_observer_override;
 801cef6:	4b11      	ldr	r3, [pc, #68]	; (801cf3c <correct_hall+0x1ec>)
 801cef8:	ed93 0a00 	vldr	s0, [r3]
 801cefc:	e74b      	b.n	801cd96 <correct_hall+0x46>
 801cefe:	bf00      	nop
 801cf00:	3dd67750 	.word	0x3dd67750
 801cf04:	2000cda8 	.word	0x2000cda8
 801cf08:	2000104d 	.word	0x2000104d
 801cf0c:	3dcccccd 	.word	0x3dcccccd
 801cf10:	20001048 	.word	0x20001048
 801cf14:	43480000 	.word	0x43480000
 801cf18:	43b40000 	.word	0x43b40000
 801cf1c:	40490fdb 	.word	0x40490fdb
 801cf20:	43340000 	.word	0x43340000
 801cf24:	51eb851f 	.word	0x51eb851f
 801cf28:	2000cd84 	.word	0x2000cd84
 801cf2c:	2000ce60 	.word	0x2000ce60
 801cf30:	2000ce8c 	.word	0x2000ce8c
 801cf34:	42c80000 	.word	0x42c80000
 801cf38:	3f060a92 	.word	0x3f060a92
 801cf3c:	2000ce58 	.word	0x2000ce58

0801cf40 <timer_thread>:
 801cf40:	4bc3      	ldr	r3, [pc, #780]	; (801d250 <timer_thread+0x310>)
 801cf42:	49c4      	ldr	r1, [pc, #784]	; (801d254 <timer_thread+0x314>)
 801cf44:	699a      	ldr	r2, [r3, #24]
		if (timer_thd_stop) {
 801cf46:	4bc4      	ldr	r3, [pc, #784]	; (801d258 <timer_thread+0x318>)
 801cf48:	6191      	str	r1, [r2, #24]
 801cf4a:	781b      	ldrb	r3, [r3, #0]
 801cf4c:	2b00      	cmp	r3, #0
 801cf4e:	f040 8217 	bne.w	801d380 <timer_thread+0x440>
static THD_FUNCTION(timer_thread, arg) {
 801cf52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801cf56:	ed2d 8b0a 	vpush	{d8-d12}
 801cf5a:	4cc0      	ldr	r4, [pc, #768]	; (801d25c <timer_thread+0x31c>)
 801cf5c:	4dc0      	ldr	r5, [pc, #768]	; (801d260 <timer_thread+0x320>)
 801cf5e:	f8df a334 	ldr.w	sl, [pc, #820]	; 801d294 <timer_thread+0x354>
 801cf62:	4ec0      	ldr	r6, [pc, #768]	; (801d264 <timer_thread+0x324>)
 801cf64:	f8df 9344 	ldr.w	r9, [pc, #836]	; 801d2ac <timer_thread+0x36c>
 801cf68:	f8df b344 	ldr.w	fp, [pc, #836]	; 801d2b0 <timer_thread+0x370>
 801cf6c:	f8df 8344 	ldr.w	r8, [pc, #836]	; 801d2b4 <timer_thread+0x374>
 801cf70:	4fbd      	ldr	r7, [pc, #756]	; (801d268 <timer_thread+0x328>)
		float openloop_rpm = utils_map(fabsf(m_motor_state.iq_target),
 801cf72:	eddf 8abe 	vldr	s17, [pc, #760]	; 801d26c <timer_thread+0x32c>
		const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
 801cf76:	ed9f aabe 	vldr	s20, [pc, #760]	; 801d270 <timer_thread+0x330>
 801cf7a:	eddf 9abe 	vldr	s19, [pc, #760]	; 801d274 <timer_thread+0x334>
			add_min_speed = -min_rads * dt;
 801cf7e:	ed9f 9abe 	vldr	s18, [pc, #760]	; 801d278 <timer_thread+0x338>
		if (min_rpm_hyst_timer > m_conf->foc_sl_openloop_hyst && min_rpm_timer <= 0.0001) {
 801cf82:	eddf aabe 	vldr	s21, [pc, #760]	; 801d27c <timer_thread+0x33c>
static THD_FUNCTION(timer_thread, arg) {
 801cf86:	b089      	sub	sp, #36	; 0x24
 801cf88:	e081      	b.n	801d08e <timer_thread+0x14e>
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(m_motor_state.duty_now) < 0.001) {
 801cf8a:	f899 3000 	ldrb.w	r3, [r9]
			min_rpm_hyst_timer += dt;
 801cf8e:	ee77 7a89 	vadd.f32	s15, s15, s18
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(m_motor_state.duty_now) < 0.001) {
 801cf92:	2b03      	cmp	r3, #3
			min_rpm_hyst_timer += dt;
 801cf94:	edc6 7a00 	vstr	s15, [r6]
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(m_motor_state.duty_now) < 0.001) {
 801cf98:	f000 80ca 	beq.w	801d130 <timer_thread+0x1f0>
 801cf9c:	edd4 7a03 	vldr	s15, [r4, #12]
 801cfa0:	eef0 7ae7 	vabs.f32	s15, s15
 801cfa4:	eef4 7ac9 	vcmpe.f32	s15, s18
 801cfa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cfac:	f100 80c0 	bmi.w	801d130 <timer_thread+0x1f0>
 801cfb0:	edd6 6a00 	vldr	s13, [r6]
		if (min_rpm_hyst_timer > m_conf->foc_sl_openloop_hyst && min_rpm_timer <= 0.0001) {
 801cfb4:	682b      	ldr	r3, [r5, #0]
 801cfb6:	edd8 7a00 	vldr	s15, [r8]
 801cfba:	ed93 7a3a 	vldr	s14, [r3, #232]	; 0xe8
 801cfbe:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801cfc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cfc6:	f140 80bb 	bpl.w	801d140 <timer_thread+0x200>
 801cfca:	eef4 7aea 	vcmpe.f32	s15, s21
 801cfce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801cfd2:	f200 80b5 	bhi.w	801d140 <timer_thread+0x200>
			min_rpm_timer = m_conf->foc_sl_openloop_time;
 801cfd6:	edd3 7a3b 	vldr	s15, [r3, #236]	; 0xec
		if (min_rpm_timer > 0.0) {
 801cfda:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801cfde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			min_rpm_timer = m_conf->foc_sl_openloop_time;
 801cfe2:	edc8 7a00 	vstr	s15, [r8]
		if (min_rpm_timer > 0.0) {
 801cfe6:	f340 80b7 	ble.w	801d158 <timer_thread+0x218>
			m_phase_now_observer_override += add_min_speed;
 801cfea:	edd7 7a00 	vldr	s15, [r7]
 801cfee:	ee38 8a27 	vadd.f32	s16, s16, s15
 801cff2:	ed87 8a00 	vstr	s16, [r7]
				if (m_motor_state.duty_now > 0.0) {
 801cff6:	edd4 7a03 	vldr	s15, [r4, #12]
 801cffa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801cffe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d002:	f340 811c 	ble.w	801d23e <timer_thread+0x2fe>
					m_phase_now_observer_override += M_PI / 2.0;
 801d006:	ed97 7a00 	vldr	s14, [r7]
 801d00a:	eddf 7a9d 	vldr	s15, [pc, #628]	; 801d280 <timer_thread+0x340>
 801d00e:	ee77 7a27 	vadd.f32	s15, s14, s15
 801d012:	edc7 7a00 	vstr	s15, [r7]
			utils_norm_angle_rad((float*)&m_phase_now_observer_override);
 801d016:	4894      	ldr	r0, [pc, #592]	; (801d268 <timer_thread+0x328>)
 801d018:	f7f8 fd02 	bl	8015a20 <utils_norm_angle_rad>
			m_phase_observer_override = true;
 801d01c:	2301      	movs	r3, #1
		if (m_state == MC_STATE_RUNNING) {
 801d01e:	4a99      	ldr	r2, [pc, #612]	; (801d284 <timer_thread+0x344>)
			min_rpm_timer -= dt;
 801d020:	edd8 7a00 	vldr	s15, [r8]
			m_phase_observer_override = true;
 801d024:	f88b 3000 	strb.w	r3, [fp]
		if (m_state == MC_STATE_RUNNING) {
 801d028:	7812      	ldrb	r2, [r2, #0]
			min_rpm_hyst_timer = 0.0;
 801d02a:	edc6 8a00 	vstr	s17, [r6]
			min_rpm_timer -= dt;
 801d02e:	ee77 7ac9 	vsub.f32	s15, s15, s18
		if (m_state == MC_STATE_RUNNING) {
 801d032:	2a02      	cmp	r2, #2
			min_rpm_timer -= dt;
 801d034:	edc8 7a00 	vstr	s15, [r8]
 801d038:	682b      	ldr	r3, [r5, #0]
		if (m_state == MC_STATE_RUNNING) {
 801d03a:	f000 8098 	beq.w	801d16e <timer_thread+0x22e>
		m_gamma_now = utils_map(fabsf(m_motor_state.duty_now), 0.0, 1.0,
 801d03e:	ed94 0a03 	vldr	s0, [r4, #12]
				m_conf->foc_observer_gain * m_conf->foc_observer_gain_slow, m_conf->foc_observer_gain);
 801d042:	edd3 1a33 	vldr	s3, [r3, #204]	; 0xcc
 801d046:	edd3 7a34 	vldr	s15, [r3, #208]	; 0xd0
		m_gamma_now = utils_map(fabsf(m_motor_state.duty_now), 0.0, 1.0,
 801d04a:	ed93 2a33 	vldr	s4, [r3, #204]	; 0xcc
 801d04e:	eeb0 0ac0 	vabs.f32	s0, s0
 801d052:	ee61 1aa7 	vmul.f32	s3, s3, s15
 801d056:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801d05a:	eef0 0a68 	vmov.f32	s1, s17
 801d05e:	f7f8 fd4f 	bl	8015b00 <utils_map>
 801d062:	4b89      	ldr	r3, [pc, #548]	; (801d288 <timer_thread+0x348>)
 801d064:	ed83 0a00 	vstr	s0, [r3]
	if (m_control_mode != CONTROL_MODE_SPEED) {
 801d068:	f899 3000 	ldrb.w	r3, [r9]
 801d06c:	2b01      	cmp	r3, #1
 801d06e:	f000 80bf 	beq.w	801d1f0 <timer_thread+0x2b0>
		i_term = 0.0;
 801d072:	4b86      	ldr	r3, [pc, #536]	; (801d28c <timer_thread+0x34c>)
 801d074:	edc3 8a00 	vstr	s17, [r3]
		prev_error = 0.0;
 801d078:	4b85      	ldr	r3, [pc, #532]	; (801d290 <timer_thread+0x350>)
 801d07a:	edc3 8a00 	vstr	s17, [r3]
		chThdSleepMilliseconds(1);
 801d07e:	200a      	movs	r0, #10
 801d080:	f7f0 fcae 	bl	800d9e0 <chThdSleep>
		if (timer_thd_stop) {
 801d084:	4b74      	ldr	r3, [pc, #464]	; (801d258 <timer_thread+0x318>)
 801d086:	781b      	ldrb	r3, [r3, #0]
 801d088:	2b00      	cmp	r3, #0
 801d08a:	f040 80d0 	bne.w	801d22e <timer_thread+0x2ee>
				0.0, m_conf->l_current_max,
 801d08e:	682b      	ldr	r3, [r5, #0]
		float openloop_rpm = utils_map(fabsf(m_motor_state.iq_target),
 801d090:	ed94 0a01 	vldr	s0, [r4, #4]
 801d094:	eddf 0a75 	vldr	s1, [pc, #468]	; 801d26c <timer_thread+0x32c>
 801d098:	ed93 1a01 	vldr	s2, [r3, #4]
 801d09c:	ed93 2a39 	vldr	s4, [r3, #228]	; 0xe4
 801d0a0:	eef0 1a68 	vmov.f32	s3, s17
 801d0a4:	eeb0 0ac0 	vabs.f32	s0, s0
 801d0a8:	f7f8 fd2a 	bl	8015b00 <utils_map>
		utils_truncate_number_abs(&openloop_rpm, m_conf->foc_openloop_rpm);
 801d0ac:	682b      	ldr	r3, [r5, #0]
		float openloop_rpm = utils_map(fabsf(m_motor_state.iq_target),
 801d0ae:	ed8d 0a02 	vstr	s0, [sp, #8]
		utils_truncate_number_abs(&openloop_rpm, m_conf->foc_openloop_rpm);
 801d0b2:	edd3 7a39 	vldr	s15, [r3, #228]	; 0xe4
 801d0b6:	a802      	add	r0, sp, #8
 801d0b8:	eeb0 0a67 	vmov.f32	s0, s15
 801d0bc:	f7f8 fd08 	bl	8015ad0 <utils_truncate_number_abs>
		const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
 801d0c0:	eddd 7a02 	vldr	s15, [sp, #8]
		if (m_motor_state.duty_now > 0.0) {
 801d0c4:	ed94 7a03 	vldr	s14, [r4, #12]
		utils_norm_angle_rad((float*)&m_phase_now_encoder_no_index);
 801d0c8:	4872      	ldr	r0, [pc, #456]	; (801d294 <timer_thread+0x354>)
		const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
 801d0ca:	ee77 7aa7 	vadd.f32	s15, s15, s15
		if (m_motor_state.duty_now > 0.0) {
 801d0ce:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
		const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
 801d0d2:	ee67 7a8a 	vmul.f32	s15, s15, s20
		if (m_motor_state.duty_now > 0.0) {
 801d0d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
 801d0da:	ee87 baa9 	vdiv.f32	s22, s15, s19
		m_phase_now_encoder_no_index += add_min_speed;
 801d0de:	edda 7a00 	vldr	s15, [sl]
			add_min_speed = min_rads * dt;
 801d0e2:	bfcc      	ite	gt
 801d0e4:	ee2b 8a09 	vmulgt.f32	s16, s22, s18
			add_min_speed = -min_rads * dt;
 801d0e8:	ee2b 8a49 	vnmulle.f32	s16, s22, s18
		m_phase_now_encoder_no_index += add_min_speed;
 801d0ec:	ee77 7a88 	vadd.f32	s15, s15, s16
 801d0f0:	edca 7a00 	vstr	s15, [sl]
		utils_norm_angle_rad((float*)&m_phase_now_encoder_no_index);
 801d0f4:	f7f8 fc94 	bl	8015a20 <utils_norm_angle_rad>
		if (fabsf(m_pll_speed) < min_rads) {
 801d0f8:	4b67      	ldr	r3, [pc, #412]	; (801d298 <timer_thread+0x358>)
 801d0fa:	edd3 7a00 	vldr	s15, [r3]
 801d0fe:	eef0 7ae7 	vabs.f32	s15, s15
 801d102:	eef4 7acb 	vcmpe.f32	s15, s22
 801d106:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			min_rpm_hyst_timer += dt;
 801d10a:	edd6 7a00 	vldr	s15, [r6]
		if (fabsf(m_pll_speed) < min_rads) {
 801d10e:	f53f af3c 	bmi.w	801cf8a <timer_thread+0x4a>
		} else if (min_rpm_hyst_timer > 0.0) {
 801d112:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			min_rpm_hyst_timer -= dt;
 801d11a:	bfc8      	it	gt
 801d11c:	ee77 7ac9 	vsubgt.f32	s15, s15, s18
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(m_motor_state.duty_now) < 0.001) {
 801d120:	f899 3000 	ldrb.w	r3, [r9]
			min_rpm_hyst_timer -= dt;
 801d124:	bfc8      	it	gt
 801d126:	edc6 7a00 	vstrgt	s15, [r6]
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(m_motor_state.duty_now) < 0.001) {
 801d12a:	2b03      	cmp	r3, #3
 801d12c:	f47f af36 	bne.w	801cf9c <timer_thread+0x5c>
			m_phase_observer_override = false;
 801d130:	2300      	movs	r3, #0
 801d132:	eef0 6a68 	vmov.f32	s13, s17
			min_rpm_hyst_timer = 0.0;
 801d136:	edc6 8a00 	vstr	s17, [r6]
			m_phase_observer_override = false;
 801d13a:	f88b 3000 	strb.w	r3, [fp]
 801d13e:	e739      	b.n	801cfb4 <timer_thread+0x74>
		if (min_rpm_timer > 0.0) {
 801d140:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d144:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d148:	dd06      	ble.n	801d158 <timer_thread+0x218>
			m_phase_now_observer_override += add_min_speed;
 801d14a:	edd7 7a00 	vldr	s15, [r7]
 801d14e:	ee38 8a27 	vadd.f32	s16, s16, s15
 801d152:	ed87 8a00 	vstr	s16, [r7]
 801d156:	e75e      	b.n	801d016 <timer_thread+0xd6>
			m_phase_now_observer_override = m_phase_now_observer;
 801d158:	4a50      	ldr	r2, [pc, #320]	; (801d29c <timer_thread+0x35c>)
 801d15a:	6811      	ldr	r1, [r2, #0]
 801d15c:	6039      	str	r1, [r7, #0]
			m_phase_observer_override = false;
 801d15e:	2200      	movs	r2, #0
 801d160:	f88b 2000 	strb.w	r2, [fp]
		if (m_state == MC_STATE_RUNNING) {
 801d164:	4a47      	ldr	r2, [pc, #284]	; (801d284 <timer_thread+0x344>)
 801d166:	7812      	ldrb	r2, [r2, #0]
 801d168:	2a02      	cmp	r2, #2
 801d16a:	f47f af68 	bne.w	801d03e <timer_thread+0xfe>
			const volatile float vd_tmp = m_motor_state.vd;
 801d16e:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 801d170:	9203      	str	r2, [sp, #12]
			const volatile float vq_tmp = m_motor_state.vq;
 801d172:	6d22      	ldr	r2, [r4, #80]	; 0x50
 801d174:	9204      	str	r2, [sp, #16]
			const volatile float id_tmp = m_motor_state.id;
 801d176:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 801d178:	9205      	str	r2, [sp, #20]
			const volatile float iq_tmp = m_motor_state.iq;
 801d17a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 801d17c:	9206      	str	r2, [sp, #24]
			m_samples.avg_current_tot += sqrtf(SQ(id_tmp) + SQ(iq_tmp));
 801d17e:	eddd 6a05 	vldr	s13, [sp, #20]
 801d182:	ed9d 7a05 	vldr	s14, [sp, #20]
 801d186:	eddd 7a06 	vldr	s15, [sp, #24]
 801d18a:	ed9d 0a06 	vldr	s0, [sp, #24]
 801d18e:	ee27 0a80 	vmul.f32	s0, s15, s0
 801d192:	eea6 0a87 	vfma.f32	s0, s13, s14
 801d196:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801d19a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d19e:	eeb1 8ac0 	vsqrt.f32	s16, s0
 801d1a2:	f100 80f1 	bmi.w	801d388 <timer_thread+0x448>
 801d1a6:	4a3e      	ldr	r2, [pc, #248]	; (801d2a0 <timer_thread+0x360>)
 801d1a8:	edd2 7a01 	vldr	s15, [r2, #4]
 801d1ac:	ee37 8a88 	vadd.f32	s16, s15, s16
 801d1b0:	ed82 8a01 	vstr	s16, [r2, #4]
			m_samples.avg_voltage_tot += sqrtf(SQ(vd_tmp) + SQ(vq_tmp));
 801d1b4:	eddd 6a03 	vldr	s13, [sp, #12]
 801d1b8:	ed9d 7a03 	vldr	s14, [sp, #12]
 801d1bc:	eddd 7a04 	vldr	s15, [sp, #16]
 801d1c0:	ed9d 0a04 	vldr	s0, [sp, #16]
 801d1c4:	ee27 0a80 	vmul.f32	s0, s15, s0
 801d1c8:	eea6 0a87 	vfma.f32	s0, s13, s14
 801d1cc:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801d1d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d1d4:	eeb1 8ac0 	vsqrt.f32	s16, s0
 801d1d8:	f100 80db 	bmi.w	801d392 <timer_thread+0x452>
 801d1dc:	edd2 7a02 	vldr	s15, [r2, #8]
 801d1e0:	ee37 8a88 	vadd.f32	s16, s15, s16
 801d1e4:	ed82 8a02 	vstr	s16, [r2, #8]
			m_samples.sample_num++;
 801d1e8:	6811      	ldr	r1, [r2, #0]
 801d1ea:	3101      	adds	r1, #1
 801d1ec:	6011      	str	r1, [r2, #0]
 801d1ee:	e726      	b.n	801d03e <timer_thread+0xfe>
	return m_pll_speed / ((2.0 * M_PI) / 60.0);
 801d1f0:	4b29      	ldr	r3, [pc, #164]	; (801d298 <timer_thread+0x358>)
 801d1f2:	eddf 6a2c 	vldr	s13, [pc, #176]	; 801d2a4 <timer_thread+0x364>
 801d1f6:	ed93 6a00 	vldr	s12, [r3]
	float error = m_speed_pid_set_rpm - rpm;
 801d1fa:	4b2b      	ldr	r3, [pc, #172]	; (801d2a8 <timer_thread+0x368>)
	if (fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801d1fc:	682a      	ldr	r2, [r5, #0]
	float error = m_speed_pid_set_rpm - rpm;
 801d1fe:	ed93 8a00 	vldr	s16, [r3]
	if (fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801d202:	edd3 7a00 	vldr	s15, [r3]
 801d206:	ed92 7a49 	vldr	s14, [r2, #292]	; 0x124
	return m_pll_speed / ((2.0 * M_PI) / 60.0);
 801d20a:	eec6 ba26 	vdiv.f32	s23, s12, s13
	if (fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801d20e:	eef0 7ae7 	vabs.f32	s15, s15
 801d212:	eef4 7ac7 	vcmpe.f32	s15, s14
 801d216:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	float error = m_speed_pid_set_rpm - rpm;
 801d21a:	ee38 8a6b 	vsub.f32	s16, s16, s23
	if (fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801d21e:	d54b      	bpl.n	801d2b8 <timer_thread+0x378>
		i_term = 0.0;
 801d220:	4b1a      	ldr	r3, [pc, #104]	; (801d28c <timer_thread+0x34c>)
 801d222:	edc3 8a00 	vstr	s17, [r3]
		prev_error = error;
 801d226:	4b1a      	ldr	r3, [pc, #104]	; (801d290 <timer_thread+0x350>)
 801d228:	ed83 8a00 	vstr	s16, [r3]
 801d22c:	e727      	b.n	801d07e <timer_thread+0x13e>
			timer_thd_stop = false;
 801d22e:	4a0a      	ldr	r2, [pc, #40]	; (801d258 <timer_thread+0x318>)
 801d230:	2300      	movs	r3, #0
 801d232:	7013      	strb	r3, [r2, #0]
}
 801d234:	b009      	add	sp, #36	; 0x24
 801d236:	ecbd 8b0a 	vpop	{d8-d12}
 801d23a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					m_phase_now_observer_override -= M_PI / 2.0;
 801d23e:	ed97 7a00 	vldr	s14, [r7]
 801d242:	eddf 7a0f 	vldr	s15, [pc, #60]	; 801d280 <timer_thread+0x340>
 801d246:	ee77 7a67 	vsub.f32	s15, s14, s15
 801d24a:	edc7 7a00 	vstr	s15, [r7]
 801d24e:	e6e2      	b.n	801d016 <timer_thread+0xd6>
 801d250:	20001a48 	.word	0x20001a48
 801d254:	0802f5b0 	.word	0x0802f5b0
 801d258:	2000ceb4 	.word	0x2000ceb4
 801d25c:	2000cddc 	.word	0x2000cddc
 801d260:	2000cda8 	.word	0x2000cda8
 801d264:	2000ce98 	.word	0x2000ce98
 801d268:	2000ce58 	.word	0x2000ce58
 801d26c:	00000000 	.word	0x00000000
 801d270:	40490fdb 	.word	0x40490fdb
 801d274:	42700000 	.word	0x42700000
 801d278:	3a83126f 	.word	0x3a83126f
 801d27c:	38d1b717 	.word	0x38d1b717
 801d280:	3fc90fdb 	.word	0x3fc90fdb
 801d284:	2000ce8c 	.word	0x2000ce8c
 801d288:	2000cdcc 	.word	0x2000cdcc
 801d28c:	2000cd9c 	.word	0x2000cd9c
 801d290:	2000ceac 	.word	0x2000ceac
 801d294:	2000ce50 	.word	0x2000ce50
 801d298:	2000ce68 	.word	0x2000ce68
 801d29c:	2000ce54 	.word	0x2000ce54
 801d2a0:	2000ce74 	.word	0x2000ce74
 801d2a4:	3dd67750 	.word	0x3dd67750
 801d2a8:	2000ce88 	.word	0x2000ce88
 801d2ac:	2000cdac 	.word	0x2000cdac
 801d2b0:	2000ce60 	.word	0x2000ce60
 801d2b4:	2000ce9c 	.word	0x2000ce9c
	p_term = error * m_conf->s_pid_kp * (1.0 / 20.0);
 801d2b8:	edd2 ca46 	vldr	s25, [r2, #280]	; 0x118
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2bc:	ed92 7a47 	vldr	s14, [r2, #284]	; 0x11c
	d_term = (error - prev_error) * (m_conf->s_pid_kd / dt) * (1.0 / 20.0);
 801d2c0:	ed92 6a48 	vldr	s12, [r2, #288]	; 0x120
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2c4:	4b36      	ldr	r3, [pc, #216]	; (801d3a0 <timer_thread+0x460>)
 801d2c6:	ed9f ca37 	vldr	s24, [pc, #220]	; 801d3a4 <timer_thread+0x464>
 801d2ca:	edd3 6a00 	vldr	s13, [r3]
	d_term = (error - prev_error) * (m_conf->s_pid_kd / dt) * (1.0 / 20.0);
 801d2ce:	4a36      	ldr	r2, [pc, #216]	; (801d3a8 <timer_thread+0x468>)
 801d2d0:	eec6 7a09 	vdiv.f32	s15, s12, s18
	utils_truncate_number(&i_term, -1.0, 1.0);
 801d2d4:	4618      	mov	r0, r3
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2d6:	ee27 7a09 	vmul.f32	s14, s14, s18
	d_term = (error - prev_error) * (m_conf->s_pid_kd / dt) * (1.0 / 20.0);
 801d2da:	ed92 ba00 	vldr	s22, [r2]
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2de:	ee27 7a08 	vmul.f32	s14, s14, s16
	d_term = (error - prev_error) * (m_conf->s_pid_kd / dt) * (1.0 / 20.0);
 801d2e2:	ee38 ba4b 	vsub.f32	s22, s16, s22
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2e6:	eee7 6a0c 	vfma.f32	s13, s14, s24
	utils_truncate_number(&i_term, -1.0, 1.0);
 801d2ea:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 801d2ee:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	i_term += error * (m_conf->s_pid_ki * dt) * (1.0 / 20.0);
 801d2f2:	edc3 6a00 	vstr	s13, [r3]
	d_term = (error - prev_error) * (m_conf->s_pid_kd / dt) * (1.0 / 20.0);
 801d2f6:	ee2b ba27 	vmul.f32	s22, s22, s15
	utils_truncate_number(&i_term, -1.0, 1.0);
 801d2fa:	f7f8 fbc1 	bl	8015a80 <utils_truncate_number>
	float output = p_term + i_term + d_term;
 801d2fe:	4b28      	ldr	r3, [pc, #160]	; (801d3a0 <timer_thread+0x460>)
	prev_error = error;
 801d300:	4a29      	ldr	r2, [pc, #164]	; (801d3a8 <timer_thread+0x468>)
	float output = p_term + i_term + d_term;
 801d302:	edd3 7a00 	vldr	s15, [r3]
	prev_error = error;
 801d306:	ed82 8a00 	vstr	s16, [r2]
	p_term = error * m_conf->s_pid_kp * (1.0 / 20.0);
 801d30a:	ee68 ca2c 	vmul.f32	s25, s16, s25
	float output = p_term + i_term + d_term;
 801d30e:	a808      	add	r0, sp, #32
 801d310:	eeec 7a8c 	vfma.f32	s15, s25, s24
	utils_truncate_number(&output, -1.0, 1.0);
 801d314:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
	float output = p_term + i_term + d_term;
 801d318:	eeeb 7a0c 	vfma.f32	s15, s22, s24
	utils_truncate_number(&output, -1.0, 1.0);
 801d31c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	float output = p_term + i_term + d_term;
 801d320:	ed60 7a01 	vstmdb	r0!, {s15}
	utils_truncate_number(&output, -1.0, 1.0);
 801d324:	f7f8 fbac 	bl	8015a80 <utils_truncate_number>
	if (!m_conf->s_pid_allow_braking) {
 801d328:	682b      	ldr	r3, [r5, #0]
 801d32a:	eddd 7a07 	vldr	s15, [sp, #28]
 801d32e:	f893 2128 	ldrb.w	r2, [r3, #296]	; 0x128
 801d332:	b972      	cbnz	r2, 801d352 <timer_thread+0x412>
		if (rpm > 0.0 && output < 0.0) {
 801d334:	eef5 bac0 	vcmpe.f32	s23, #0.0
 801d338:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d33c:	dd04      	ble.n	801d348 <timer_thread+0x408>
 801d33e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d342:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d346:	d411      	bmi.n	801d36c <timer_thread+0x42c>
		if (rpm < 0.0 && output > 0.0) {
 801d348:	eef5 bac0 	vcmpe.f32	s23, #0.0
 801d34c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d350:	d407      	bmi.n	801d362 <timer_thread+0x422>
	m_iq_set = output * m_conf->lo_current_max;
 801d352:	ed93 7a19 	vldr	s14, [r3, #100]	; 0x64
 801d356:	4b15      	ldr	r3, [pc, #84]	; (801d3ac <timer_thread+0x46c>)
 801d358:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d35c:	edc3 7a00 	vstr	s15, [r3]
 801d360:	e68d      	b.n	801d07e <timer_thread+0x13e>
		if (rpm < 0.0 && output > 0.0) {
 801d362:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d366:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d36a:	ddf2      	ble.n	801d352 <timer_thread+0x412>
	m_iq_set = output * m_conf->lo_current_max;
 801d36c:	ed93 7a19 	vldr	s14, [r3, #100]	; 0x64
 801d370:	4b0e      	ldr	r3, [pc, #56]	; (801d3ac <timer_thread+0x46c>)
		if (rpm < 0.0 && output > 0.0) {
 801d372:	eef0 7a68 	vmov.f32	s15, s17
	m_iq_set = output * m_conf->lo_current_max;
 801d376:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d37a:	edc3 7a00 	vstr	s15, [r3]
 801d37e:	e67e      	b.n	801d07e <timer_thread+0x13e>
			timer_thd_stop = false;
 801d380:	4a0b      	ldr	r2, [pc, #44]	; (801d3b0 <timer_thread+0x470>)
 801d382:	2300      	movs	r3, #0
 801d384:	7013      	strb	r3, [r2, #0]
 801d386:	4770      	bx	lr
 801d388:	9300      	str	r3, [sp, #0]
			m_samples.avg_current_tot += sqrtf(SQ(id_tmp) + SQ(iq_tmp));
 801d38a:	f008 f9c9 	bl	8025720 <sqrtf>
 801d38e:	9b00      	ldr	r3, [sp, #0]
 801d390:	e709      	b.n	801d1a6 <timer_thread+0x266>
 801d392:	e9cd 3200 	strd	r3, r2, [sp]
			m_samples.avg_voltage_tot += sqrtf(SQ(vd_tmp) + SQ(vq_tmp));
 801d396:	f008 f9c3 	bl	8025720 <sqrtf>
 801d39a:	e9dd 3200 	ldrd	r3, r2, [sp]
 801d39e:	e71d      	b.n	801d1dc <timer_thread+0x29c>
 801d3a0:	2000cd9c 	.word	0x2000cd9c
 801d3a4:	3d4ccccd 	.word	0x3d4ccccd
 801d3a8:	2000ceac 	.word	0x2000ceac
 801d3ac:	2000cdd8 	.word	0x2000cdd8
 801d3b0:	2000ceb4 	.word	0x2000ceb4
	...

0801d3c0 <mcpwm_foc_init>:
void mcpwm_foc_init(volatile mc_configuration *configuration) {
 801d3c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d3c4:	b0ab      	sub	sp, #172	; 0xac
 801d3c6:	4681      	mov	r9, r0
	utils_sys_lock_cnt();
 801d3c8:	f7f8 fe6a 	bl	80160a0 <utils_sys_lock_cnt>
	m_init_done = false;
 801d3cc:	4bd0      	ldr	r3, [pc, #832]	; (801d710 <mcpwm_foc_init+0x350>)
	m_state = MC_STATE_OFF;
 801d3ce:	f8df e3cc 	ldr.w	lr, [pc, #972]	; 801d79c <mcpwm_foc_init+0x3dc>
	m_control_mode = CONTROL_MODE_NONE;
 801d3d2:	f8df c3cc 	ldr.w	ip, [pc, #972]	; 801d7a0 <mcpwm_foc_init+0x3e0>
	m_curr0_sum = 0;
 801d3d6:	f8df b3cc 	ldr.w	fp, [pc, #972]	; 801d7a4 <mcpwm_foc_init+0x3e4>
	m_curr_samples = 0;
 801d3da:	4fce      	ldr	r7, [pc, #824]	; (801d714 <mcpwm_foc_init+0x354>)
	m_phase_now_override = 0.0;
 801d3dc:	eddf 7ace 	vldr	s15, [pc, #824]	; 801d718 <mcpwm_foc_init+0x358>
	m_conf = configuration;
 801d3e0:	f8df 83c4 	ldr.w	r8, [pc, #964]	; 801d7a8 <mcpwm_foc_init+0x3e8>
	m_phase_override = false;
 801d3e4:	f8df a3c4 	ldr.w	sl, [pc, #964]	; 801d7ac <mcpwm_foc_init+0x3ec>
	m_duty_cycle_set = 0.0;
 801d3e8:	49cc      	ldr	r1, [pc, #816]	; (801d71c <mcpwm_foc_init+0x35c>)
	m_id_set = 0.0;
 801d3ea:	4acd      	ldr	r2, [pc, #820]	; (801d720 <mcpwm_foc_init+0x360>)
	m_iq_set = 0.0;
 801d3ec:	48cd      	ldr	r0, [pc, #820]	; (801d724 <mcpwm_foc_init+0x364>)
	m_conf = configuration;
 801d3ee:	f8c8 9000 	str.w	r9, [r8]
	m_init_done = false;
 801d3f2:	2400      	movs	r4, #0
 801d3f4:	701c      	strb	r4, [r3, #0]
	m_curr1_sum = 0;
 801d3f6:	4bcc      	ldr	r3, [pc, #816]	; (801d728 <mcpwm_foc_init+0x368>)
	m_state = MC_STATE_OFF;
 801d3f8:	f88e 4000 	strb.w	r4, [lr]
	m_control_mode = CONTROL_MODE_NONE;
 801d3fc:	f04f 0e07 	mov.w	lr, #7
 801d400:	f88c e000 	strb.w	lr, [ip]
	m_curr0_sum = 0;
 801d404:	f8cb 4000 	str.w	r4, [fp]
	m_curr1_sum = 0;
 801d408:	601c      	str	r4, [r3, #0]
	m_dccal_done = false;
 801d40a:	4bc8      	ldr	r3, [pc, #800]	; (801d72c <mcpwm_foc_init+0x36c>)
	m_curr_samples = 0;
 801d40c:	603c      	str	r4, [r7, #0]
	m_dccal_done = false;
 801d40e:	701c      	strb	r4, [r3, #0]
	m_phase_now_override = 0.0;
 801d410:	4bc7      	ldr	r3, [pc, #796]	; (801d730 <mcpwm_foc_init+0x370>)
	m_phase_override = false;
 801d412:	f88a 4000 	strb.w	r4, [sl]
	m_openloop_speed = 0.0;
 801d416:	f8df 9398 	ldr.w	r9, [pc, #920]	; 801d7b0 <mcpwm_foc_init+0x3f0>
	m_phase_now_override = 0.0;
 801d41a:	edc3 7a00 	vstr	s15, [r3]
	m_output_on = false;
 801d41e:	f8df e394 	ldr.w	lr, [pc, #916]	; 801d7b4 <mcpwm_foc_init+0x3f4>
	m_pos_pid_set = 0.0;
 801d422:	f8df c394 	ldr.w	ip, [pc, #916]	; 801d7b8 <mcpwm_foc_init+0x3f8>
	m_speed_pid_set_rpm = 0.0;
 801d426:	4bc3      	ldr	r3, [pc, #780]	; (801d734 <mcpwm_foc_init+0x374>)
	m_duty_cycle_set = 0.0;
 801d428:	edc1 7a00 	vstr	s15, [r1]
	m_id_set = 0.0;
 801d42c:	edc2 7a00 	vstr	s15, [r2]
	m_phase_now_observer = 0.0;
 801d430:	49c1      	ldr	r1, [pc, #772]	; (801d738 <mcpwm_foc_init+0x378>)
	m_iq_set = 0.0;
 801d432:	edc0 7a00 	vstr	s15, [r0]
	m_phase_now_observer_override = 0.0;
 801d436:	4ac1      	ldr	r2, [pc, #772]	; (801d73c <mcpwm_foc_init+0x37c>)
	m_phase_observer_override = false;
 801d438:	48c1      	ldr	r0, [pc, #772]	; (801d740 <mcpwm_foc_init+0x380>)
	m_openloop_speed = 0.0;
 801d43a:	edc9 7a00 	vstr	s15, [r9]
	m_output_on = false;
 801d43e:	f88e 4000 	strb.w	r4, [lr]
	m_phase_now_encoder = 0.0;
 801d442:	f8df 9378 	ldr.w	r9, [pc, #888]	; 801d7bc <mcpwm_foc_init+0x3fc>
	m_pos_pid_set = 0.0;
 801d446:	edcc 7a00 	vstr	s15, [ip]
	m_phase_now_encoder_no_index = 0.0;
 801d44a:	f8df e374 	ldr.w	lr, [pc, #884]	; 801d7c0 <mcpwm_foc_init+0x400>
	m_speed_pid_set_rpm = 0.0;
 801d44e:	edc3 7a00 	vstr	s15, [r3]
	m_observer_x1 = 0.0;
 801d452:	f8df c370 	ldr.w	ip, [pc, #880]	; 801d7c4 <mcpwm_foc_init+0x404>
	m_observer_x2 = 0.0;
 801d456:	4bbb      	ldr	r3, [pc, #748]	; (801d744 <mcpwm_foc_init+0x384>)
	m_phase_now_observer = 0.0;
 801d458:	edc1 7a00 	vstr	s15, [r1]
	m_phase_now_observer_override = 0.0;
 801d45c:	edc2 7a00 	vstr	s15, [r2]
	m_pll_phase = 0.0;
 801d460:	49b9      	ldr	r1, [pc, #740]	; (801d748 <mcpwm_foc_init+0x388>)
	m_phase_observer_override = false;
 801d462:	7004      	strb	r4, [r0, #0]
	m_pll_speed = 0.0;
 801d464:	4ab9      	ldr	r2, [pc, #740]	; (801d74c <mcpwm_foc_init+0x38c>)
	m_tachometer = 0;
 801d466:	48ba      	ldr	r0, [pc, #744]	; (801d750 <mcpwm_foc_init+0x390>)
	m_phase_now_encoder = 0.0;
 801d468:	edc9 7a00 	vstr	s15, [r9]
	m_phase_now_encoder_no_index = 0.0;
 801d46c:	edce 7a00 	vstr	s15, [lr]
	m_tachometer_abs = 0;
 801d470:	f8df 9354 	ldr.w	r9, [pc, #852]	; 801d7c8 <mcpwm_foc_init+0x408>
	last_inj_adc_isr_duration = 0;
 801d474:	f8df e354 	ldr.w	lr, [pc, #852]	; 801d7cc <mcpwm_foc_init+0x40c>
	m_observer_x1 = 0.0;
 801d478:	edcc 7a00 	vstr	s15, [ip]
	m_observer_x2 = 0.0;
 801d47c:	edc3 7a00 	vstr	s15, [r3]
	m_pos_pid_now = 0.0;
 801d480:	f8df c34c 	ldr.w	ip, [pc, #844]	; 801d7d0 <mcpwm_foc_init+0x410>
	m_gamma_now = 0.0;
 801d484:	4bb3      	ldr	r3, [pc, #716]	; (801d754 <mcpwm_foc_init+0x394>)
	m_pll_phase = 0.0;
 801d486:	edc1 7a00 	vstr	s15, [r1]
	m_pll_speed = 0.0;
 801d48a:	edc2 7a00 	vstr	s15, [r2]
	memset((void*)&m_motor_state, 0, sizeof(motor_state_t));
 801d48e:	4621      	mov	r1, r4
	m_tachometer = 0;
 801d490:	6004      	str	r4, [r0, #0]
	memset((void*)&m_motor_state, 0, sizeof(motor_state_t));
 801d492:	2260      	movs	r2, #96	; 0x60
 801d494:	48b0      	ldr	r0, [pc, #704]	; (801d758 <mcpwm_foc_init+0x398>)
	TIM_DeInit(TIM1);
 801d496:	4db1      	ldr	r5, [pc, #708]	; (801d75c <mcpwm_foc_init+0x39c>)
	m_tachometer_abs = 0;
 801d498:	f8c9 4000 	str.w	r4, [r9]
	last_inj_adc_isr_duration = 0;
 801d49c:	edce 7a00 	vstr	s15, [lr]
	m_pos_pid_now = 0.0;
 801d4a0:	edcc 7a00 	vstr	s15, [ip]
	m_gamma_now = 0.0;
 801d4a4:	edc3 7a00 	vstr	s15, [r3]
	memset((void*)&m_motor_state, 0, sizeof(motor_state_t));
 801d4a8:	f009 fbba 	bl	8026c20 <memset>
	memset((void*)&m_samples, 0, sizeof(mc_sample_t));
 801d4ac:	4bac      	ldr	r3, [pc, #688]	; (801d760 <mcpwm_foc_init+0x3a0>)
	TIM_DeInit(TIM8);
 801d4ae:	4ead      	ldr	r6, [pc, #692]	; (801d764 <mcpwm_foc_init+0x3a4>)
	memset((void*)&m_samples, 0, sizeof(mc_sample_t));
 801d4b0:	601c      	str	r4, [r3, #0]
	TIM_DeInit(TIM1);
 801d4b2:	4628      	mov	r0, r5
	memset((void*)&m_samples, 0, sizeof(mc_sample_t));
 801d4b4:	605c      	str	r4, [r3, #4]
 801d4b6:	609c      	str	r4, [r3, #8]
 801d4b8:	60dc      	str	r4, [r3, #12]
 801d4ba:	611c      	str	r4, [r3, #16]
	TIM_DeInit(TIM1);
 801d4bc:	f006 ff10 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM8);
 801d4c0:	4630      	mov	r0, r6
 801d4c2:	f006 ff0d 	bl	80242e0 <TIM_DeInit>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 801d4c6:	2101      	movs	r1, #1
	TIM1->CNT = 0;
 801d4c8:	626c      	str	r4, [r5, #36]	; 0x24
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 801d4ca:	4608      	mov	r0, r1
	TIM8->CNT = 0;
 801d4cc:	6274      	str	r4, [r6, #36]	; 0x24
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 801d4ce:	f006 febf 	bl	8024250 <RCC_APB2PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d4d2:	f8d8 3000 	ldr.w	r3, [r8]
 801d4d6:	4aa4      	ldr	r2, [pc, #656]	; (801d768 <mcpwm_foc_init+0x3a8>)
 801d4d8:	edd3 7a2b 	vldr	s15, [r3, #172]	; 0xac
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 801d4dc:	f8ad 401c 	strh.w	r4, [sp, #28]
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d4e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 801d4e4:	f44f 1c00 	mov.w	ip, #2097152	; 0x200000
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d4e8:	ee17 3a90 	vmov	r3, s15
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 801d4ec:	4628      	mov	r0, r5
 801d4ee:	a905      	add	r1, sp, #20
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 801d4f0:	f8cd c014 	str.w	ip, [sp, #20]
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d4f4:	fb92 f3f3 	sdiv	r3, r2, r3
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 801d4f8:	f88d 401e 	strb.w	r4, [sp, #30]
	TIM_TimeBaseStructure.TIM_Period = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d4fc:	9306      	str	r3, [sp, #24]
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 801d4fe:	f006 ffcf 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_OCInitStructure.TIM_Pulse = TIM1->ARR / 2;
 801d502:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 801d504:	4a99      	ldr	r2, [pc, #612]	; (801d76c <mcpwm_foc_init+0x3ac>)
 801d506:	9210      	str	r2, [sp, #64]	; 0x40
	TIM_OCInitStructure.TIM_Pulse = TIM1->ARR / 2;
 801d508:	085b      	lsrs	r3, r3, #1
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 801d50a:	4628      	mov	r0, r5
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 801d50c:	f04f 0904 	mov.w	r9, #4
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 801d510:	e9cd 3412 	strd	r3, r4, [sp, #72]	; 0x48
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 801d514:	a910      	add	r1, sp, #64	; 0x40
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 801d516:	4b96      	ldr	r3, [pc, #600]	; (801d770 <mcpwm_foc_init+0x3b0>)
 801d518:	9314      	str	r3, [sp, #80]	; 0x50
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 801d51a:	f8ad 9044 	strh.w	r9, [sp, #68]	; 0x44
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 801d51e:	f007 f837 	bl	8024590 <TIM_OC1Init>
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
 801d522:	4628      	mov	r0, r5
 801d524:	a910      	add	r1, sp, #64	; 0x40
 801d526:	f007 f873 	bl	8024610 <TIM_OC2Init>
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 801d52a:	4628      	mov	r0, r5
 801d52c:	a910      	add	r1, sp, #64	; 0x40
 801d52e:	f007 f8af 	bl	8024690 <TIM_OC3Init>
	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
 801d532:	4628      	mov	r0, r5
 801d534:	a910      	add	r1, sp, #64	; 0x40
 801d536:	f007 f8f3 	bl	8024720 <TIM_OC4Init>
	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
 801d53a:	4628      	mov	r0, r5
 801d53c:	2108      	movs	r1, #8
 801d53e:	f007 f94f 	bl	80247e0 <TIM_OC1PreloadConfig>
	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
 801d542:	4628      	mov	r0, r5
 801d544:	2108      	movs	r1, #8
 801d546:	f007 f953 	bl	80247f0 <TIM_OC2PreloadConfig>
	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
 801d54a:	4628      	mov	r0, r5
 801d54c:	2108      	movs	r1, #8
 801d54e:	f007 f95f 	bl	8024810 <TIM_OC3PreloadConfig>
	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
 801d552:	4628      	mov	r0, r5
 801d554:	2108      	movs	r1, #8
 801d556:	f007 f963 	bl	8024820 <TIM_OC4PreloadConfig>
	TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
 801d55a:	4a86      	ldr	r2, [pc, #536]	; (801d774 <mcpwm_foc_init+0x3b4>)
	TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
 801d55c:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
	TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
 801d560:	f44f 1370 	mov.w	r3, #3932160	; 0x3c0000
	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 801d564:	4628      	mov	r0, r5
	TIM_BDTRInitStructure.TIM_DeadTime = HW_DEAD_TIME_VALUE;
 801d566:	f04f 5a00 	mov.w	sl, #536870912	; 0x20000000
	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 801d56a:	a908      	add	r1, sp, #32
	TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
 801d56c:	e9cd 2308 	strd	r2, r3, [sp, #32]
	TIM_BDTRInitStructure.TIM_DeadTime = HW_DEAD_TIME_VALUE;
 801d570:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 801d574:	f007 f984 	bl	8024880 <TIM_BDTRConfig>
	TIM_CCPreloadControl(TIM1, ENABLE);
 801d578:	4628      	mov	r0, r5
 801d57a:	2101      	movs	r1, #1
 801d57c:	f007 f9a8 	bl	80248d0 <TIM_CCPreloadControl>
	TIM_ARRPreloadConfig(TIM1, ENABLE);
 801d580:	4628      	mov	r0, r5
 801d582:	2101      	movs	r1, #1
 801d584:	f006 ffe4 	bl	8024550 <TIM_ARRPreloadConfig>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC, ENABLE);
 801d588:	2101      	movs	r1, #1
 801d58a:	487b      	ldr	r0, [pc, #492]	; (801d778 <mcpwm_foc_init+0x3b8>)
 801d58c:	f006 fe40 	bl	8024210 <RCC_AHB1PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2 | RCC_APB2Periph_ADC3, ENABLE);
 801d590:	2101      	movs	r1, #1
 801d592:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 801d596:	f006 fe5b 	bl	8024250 <RCC_APB2PeriphClockCmd>
	dmaStreamAllocate(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)),
 801d59a:	4623      	mov	r3, r4
 801d59c:	4a77      	ldr	r2, [pc, #476]	; (801d77c <mcpwm_foc_init+0x3bc>)
 801d59e:	4878      	ldr	r0, [pc, #480]	; (801d780 <mcpwm_foc_init+0x3c0>)
 801d5a0:	2103      	movs	r1, #3
 801d5a2:	f7f1 ffb5 	bl	800f510 <dmaStreamAllocate>
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;
 801d5a6:	4a77      	ldr	r2, [pc, #476]	; (801d784 <mcpwm_foc_init+0x3c4>)
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC->CDR;
 801d5a8:	4977      	ldr	r1, [pc, #476]	; (801d788 <mcpwm_foc_init+0x3c8>)
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;
 801d5aa:	921d      	str	r2, [sp, #116]	; 0x74
	DMA_InitStructure.DMA_BufferSize = HW_ADC_CHANNELS;
 801d5ac:	f04f 0c0c 	mov.w	ip, #12
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 801d5b0:	f44f 6200 	mov.w	r2, #2048	; 0x800
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC->CDR;
 801d5b4:	911c      	str	r1, [sp, #112]	; 0x70
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 801d5b6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 801d5ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 801d5be:	4873      	ldr	r0, [pc, #460]	; (801d78c <mcpwm_foc_init+0x3cc>)
	DMA_InitStructure.DMA_BufferSize = HW_ADC_CHANNELS;
 801d5c0:	f8cd c07c 	str.w	ip, [sp, #124]	; 0x7c
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 801d5c4:	9222      	str	r2, [sp, #136]	; 0x88
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 801d5c6:	f44f 7c80 	mov.w	ip, #256	; 0x100
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 801d5ca:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 801d5ce:	9123      	str	r1, [sp, #140]	; 0x8c
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 801d5d0:	a91b      	add	r1, sp, #108	; 0x6c
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 801d5d2:	e9cd c224 	strd	ip, r2, [sp, #144]	; 0x90
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 801d5d6:	9321      	str	r3, [sp, #132]	; 0x84
 801d5d8:	9303      	str	r3, [sp, #12]
	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
 801d5da:	941b      	str	r4, [sp, #108]	; 0x6c
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 801d5dc:	941e      	str	r4, [sp, #120]	; 0x78
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 801d5de:	9420      	str	r4, [sp, #128]	; 0x80
	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 801d5e0:	e9cd 4426 	strd	r4, r4, [sp, #152]	; 0x98
	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 801d5e4:	e9cd 4428 	strd	r4, r4, [sp, #160]	; 0xa0
	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
 801d5e8:	f006 fc8a 	bl	8023f00 <DMA_Init>
	DMA_Cmd(DMA2_Stream4, ENABLE);
 801d5ec:	2101      	movs	r1, #1
 801d5ee:	4867      	ldr	r0, [pc, #412]	; (801d78c <mcpwm_foc_init+0x3cc>)
 801d5f0:	f006 fcb6 	bl	8023f60 <DMA_Cmd>
	DMA_ITConfig(DMA2_Stream4, DMA_IT_TC, ENABLE);
 801d5f4:	2201      	movs	r2, #1
 801d5f6:	2110      	movs	r1, #16
 801d5f8:	4864      	ldr	r0, [pc, #400]	; (801d78c <mcpwm_foc_init+0x3cc>)
 801d5fa:	f006 fcc1 	bl	8023f80 <DMA_ITConfig>
	ADC_CommonInitStructure.ADC_Mode = ADC_TripleMode_RegSimult;
 801d5fe:	2116      	movs	r1, #22
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 801d600:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	ADC_CommonInit(&ADC_CommonInitStructure);
 801d604:	a80c      	add	r0, sp, #48	; 0x30
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 801d606:	f04f 0801 	mov.w	r8, #1
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 801d60a:	940d      	str	r4, [sp, #52]	; 0x34
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 801d60c:	940f      	str	r4, [sp, #60]	; 0x3c
	ADC_CommonInitStructure.ADC_Mode = ADC_TripleMode_RegSimult;
 801d60e:	910c      	str	r1, [sp, #48]	; 0x30
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 801d610:	920e      	str	r2, [sp, #56]	; 0x38
	ADC_CommonInit(&ADC_CommonInitStructure);
 801d612:	f006 fad5 	bl	8023bc0 <ADC_CommonInit>
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T8_CC1;
 801d616:	f04f 6250 	mov.w	r2, #218103808	; 0xd000000
	ADC_Init(ADC1, &ADC_InitStructure);
 801d61a:	a915      	add	r1, sp, #84	; 0x54
 801d61c:	485c      	ldr	r0, [pc, #368]	; (801d790 <mcpwm_foc_init+0x3d0>)
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T8_CC1;
 801d61e:	9218      	str	r2, [sp, #96]	; 0x60
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 801d620:	9415      	str	r4, [sp, #84]	; 0x54
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 801d622:	f88d 4059 	strb.w	r4, [sp, #89]	; 0x59
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 801d626:	9419      	str	r4, [sp, #100]	; 0x64
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Falling;
 801d628:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
	ADC_InitStructure.ADC_NbrOfConversion = HW_ADC_NBR_CONV;
 801d62c:	f88d 9068 	strb.w	r9, [sp, #104]	; 0x68
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 801d630:	f88d 8058 	strb.w	r8, [sp, #88]	; 0x58
	ADC_Init(ADC1, &ADC_InitStructure);
 801d634:	f006 fa9c 	bl	8023b70 <ADC_Init>
	ADC_Init(ADC2, &ADC_InitStructure);
 801d638:	a915      	add	r1, sp, #84	; 0x54
 801d63a:	4856      	ldr	r0, [pc, #344]	; (801d794 <mcpwm_foc_init+0x3d4>)
	ADC_InitStructure.ADC_ExternalTrigConv = 0;
 801d63c:	e9cd 4417 	strd	r4, r4, [sp, #92]	; 0x5c
	ADC_Init(ADC2, &ADC_InitStructure);
 801d640:	f006 fa96 	bl	8023b70 <ADC_Init>
	ADC_Init(ADC3, &ADC_InitStructure);
 801d644:	a915      	add	r1, sp, #84	; 0x54
 801d646:	4854      	ldr	r0, [pc, #336]	; (801d798 <mcpwm_foc_init+0x3d8>)
 801d648:	f006 fa92 	bl	8023b70 <ADC_Init>
	ADC_TempSensorVrefintCmd(ENABLE);
 801d64c:	4640      	mov	r0, r8
 801d64e:	f006 fadf 	bl	8023c10 <ADC_TempSensorVrefintCmd>
	ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);
 801d652:	4640      	mov	r0, r8
 801d654:	f006 fb3c 	bl	8023cd0 <ADC_MultiModeDMARequestAfterLastTransferCmd>
	hw_setup_adc_channels();
 801d658:	f002 fe82 	bl	8020360 <hw_setup_adc_channels>
	ADC_Cmd(ADC1, ENABLE);
 801d65c:	4641      	mov	r1, r8
 801d65e:	484c      	ldr	r0, [pc, #304]	; (801d790 <mcpwm_foc_init+0x3d0>)
 801d660:	f006 fac6 	bl	8023bf0 <ADC_Cmd>
	ADC_Cmd(ADC2, ENABLE);
 801d664:	4641      	mov	r1, r8
 801d666:	484b      	ldr	r0, [pc, #300]	; (801d794 <mcpwm_foc_init+0x3d4>)
 801d668:	f006 fac2 	bl	8023bf0 <ADC_Cmd>
	ADC_Cmd(ADC3, ENABLE);
 801d66c:	4641      	mov	r1, r8
 801d66e:	484a      	ldr	r0, [pc, #296]	; (801d798 <mcpwm_foc_init+0x3d8>)
 801d670:	f006 fabe 	bl	8023bf0 <ADC_Cmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
 801d674:	4641      	mov	r1, r8
 801d676:	2002      	movs	r0, #2
 801d678:	f006 fdea 	bl	8024250 <RCC_APB2PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801d67c:	f64f 72ff 	movw	r2, #65535	; 0xffff
	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
 801d680:	a905      	add	r1, sp, #20
 801d682:	4630      	mov	r0, r6
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 801d684:	9405      	str	r4, [sp, #20]
	TIM_TimeBaseStructure.TIM_Period = 0xFFFF;
 801d686:	f8ad 401c 	strh.w	r4, [sp, #28]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 801d68a:	f88d 401e 	strb.w	r4, [sp, #30]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801d68e:	9206      	str	r2, [sp, #24]
	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
 801d690:	f006 ff06 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 801d694:	4b35      	ldr	r3, [pc, #212]	; (801d76c <mcpwm_foc_init+0x3ac>)
 801d696:	9310      	str	r3, [sp, #64]	; 0x40
	TIM_OCInitStructure.TIM_Pulse = 500;
 801d698:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 801d69c:	4b34      	ldr	r3, [pc, #208]	; (801d770 <mcpwm_foc_init+0x3b0>)
 801d69e:	9314      	str	r3, [sp, #80]	; 0x50
	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
 801d6a0:	a910      	add	r1, sp, #64	; 0x40
 801d6a2:	4630      	mov	r0, r6
	TIM_OCInitStructure.TIM_Pulse = 500;
 801d6a4:	9212      	str	r2, [sp, #72]	; 0x48
 801d6a6:	9413      	str	r4, [sp, #76]	; 0x4c
	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
 801d6a8:	f006 ff72 	bl	8024590 <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801d6ac:	4630      	mov	r0, r6
 801d6ae:	2108      	movs	r1, #8
 801d6b0:	f007 f896 	bl	80247e0 <TIM_OC1PreloadConfig>
	TIM_OC2Init(TIM8, &TIM_OCInitStructure);
 801d6b4:	a910      	add	r1, sp, #64	; 0x40
 801d6b6:	4630      	mov	r0, r6
 801d6b8:	f006 ffaa 	bl	8024610 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801d6bc:	4630      	mov	r0, r6
 801d6be:	2108      	movs	r1, #8
 801d6c0:	f007 f896 	bl	80247f0 <TIM_OC2PreloadConfig>
	TIM_OC3Init(TIM8, &TIM_OCInitStructure);
 801d6c4:	a910      	add	r1, sp, #64	; 0x40
 801d6c6:	4630      	mov	r0, r6
 801d6c8:	f006 ffe2 	bl	8024690 <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM8, TIM_OCPreload_Enable);
 801d6cc:	4630      	mov	r0, r6
 801d6ce:	2108      	movs	r1, #8
 801d6d0:	f007 f89e 	bl	8024810 <TIM_OC3PreloadConfig>
	TIM_ARRPreloadConfig(TIM8, ENABLE);
 801d6d4:	4641      	mov	r1, r8
 801d6d6:	4630      	mov	r0, r6
 801d6d8:	f006 ff3a 	bl	8024550 <TIM_ARRPreloadConfig>
	TIM_CCPreloadControl(TIM8, ENABLE);
 801d6dc:	4641      	mov	r1, r8
 801d6de:	4630      	mov	r0, r6
 801d6e0:	f007 f8f6 	bl	80248d0 <TIM_CCPreloadControl>
	TIM_CtrlPWMOutputs(TIM8, ENABLE);
 801d6e4:	4641      	mov	r1, r8
 801d6e6:	4630      	mov	r0, r6
 801d6e8:	f007 f8e2 	bl	80248b0 <TIM_CtrlPWMOutputs>
	TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);
 801d6ec:	4628      	mov	r0, r5
 801d6ee:	2120      	movs	r1, #32
 801d6f0:	f007 f93e 	bl	8024970 <TIM_SelectOutputTrigger>
	TIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);
 801d6f4:	4628      	mov	r0, r5
 801d6f6:	2180      	movs	r1, #128	; 0x80
 801d6f8:	f007 f95a 	bl	80249b0 <TIM_SelectMasterSlaveMode>
	TIM_SelectInputTrigger(TIM8, TIM_TS_ITR0);
 801d6fc:	4621      	mov	r1, r4
 801d6fe:	4630      	mov	r0, r6
 801d700:	f007 f92e 	bl	8024960 <TIM_SelectInputTrigger>
	TIM_SelectSlaveMode(TIM8, TIM_SlaveMode_Reset);
 801d704:	4649      	mov	r1, r9
 801d706:	4630      	mov	r0, r6
 801d708:	f007 f942 	bl	8024990 <TIM_SelectSlaveMode>
 801d70c:	e062      	b.n	801d7d4 <mcpwm_foc_init+0x414>
 801d70e:	bf00      	nop
 801d710:	2000cdd4 	.word	0x2000cdd4
 801d714:	2000cdc0 	.word	0x2000cdc0
 801d718:	00000000 	.word	0x00000000
 801d71c:	2000cdc8 	.word	0x2000cdc8
 801d720:	2000cdd0 	.word	0x2000cdd0
 801d724:	2000cdd8 	.word	0x2000cdd8
 801d728:	2000cdbc 	.word	0x2000cdbc
 801d72c:	2000cdc4 	.word	0x2000cdc4
 801d730:	2000ce5c 	.word	0x2000ce5c
 801d734:	2000ce88 	.word	0x2000ce88
 801d738:	2000ce54 	.word	0x2000ce54
 801d73c:	2000ce58 	.word	0x2000ce58
 801d740:	2000ce60 	.word	0x2000ce60
 801d744:	2000ce40 	.word	0x2000ce40
 801d748:	2000ce64 	.word	0x2000ce64
 801d74c:	2000ce68 	.word	0x2000ce68
 801d750:	2000ce90 	.word	0x2000ce90
 801d754:	2000cdcc 	.word	0x2000cdcc
 801d758:	2000cddc 	.word	0x2000cddc
 801d75c:	40010000 	.word	0x40010000
 801d760:	2000ce74 	.word	0x2000ce74
 801d764:	40010400 	.word	0x40010400
 801d768:	0a037a00 	.word	0x0a037a00
 801d76c:	00010060 	.word	0x00010060
 801d770:	02000100 	.word	0x02000100
 801d774:	04000800 	.word	0x04000800
 801d778:	00400005 	.word	0x00400005
 801d77c:	0801ee81 	.word	0x0801ee81
 801d780:	0802da40 	.word	0x0802da40
 801d784:	2000c03c 	.word	0x2000c03c
 801d788:	40012308 	.word	0x40012308
 801d78c:	40026470 	.word	0x40026470
 801d790:	40012000 	.word	0x40012000
 801d794:	40012100 	.word	0x40012100
 801d798:	40012200 	.word	0x40012200
 801d79c:	2000ce8c 	.word	0x2000ce8c
 801d7a0:	2000cdac 	.word	0x2000cdac
 801d7a4:	2000cdb4 	.word	0x2000cdb4
 801d7a8:	2000cda8 	.word	0x2000cda8
 801d7ac:	2000ce61 	.word	0x2000ce61
 801d7b0:	2000ce44 	.word	0x2000ce44
 801d7b4:	2000ce48 	.word	0x2000ce48
 801d7b8:	2000ce70 	.word	0x2000ce70
 801d7bc:	2000ce4c 	.word	0x2000ce4c
 801d7c0:	2000ce50 	.word	0x2000ce50
 801d7c4:	2000ce3c 	.word	0x2000ce3c
 801d7c8:	2000ce94 	.word	0x2000ce94
 801d7cc:	2000cda4 	.word	0x2000cda4
 801d7d0:	2000ce6c 	.word	0x2000ce6c
	TIM_Cmd(TIM1, ENABLE);
 801d7d4:	4628      	mov	r0, r5
 801d7d6:	4641      	mov	r1, r8
 801d7d8:	f006 feca 	bl	8024570 <TIM_Cmd>
	TIM_Cmd(TIM8, ENABLE);
 801d7dc:	4641      	mov	r1, r8
 801d7de:	4630      	mov	r0, r6
 801d7e0:	f006 fec6 	bl	8024570 <TIM_Cmd>
	TIM_CtrlPWMOutputs(TIM1, ENABLE);
 801d7e4:	4628      	mov	r0, r5
 801d7e6:	4641      	mov	r1, r8
 801d7e8:	f007 f862 	bl	80248b0 <TIM_CtrlPWMOutputs>
	stop_pwm_hw();
 801d7ec:	f7ff fa38 	bl	801cc60 <stop_pwm_hw>
	TIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);
 801d7f0:	2102      	movs	r1, #2
	TIM_ITConfig(TIM8, TIM_IT_CC1, ENABLE);
 801d7f2:	4642      	mov	r2, r8
	TIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);
 801d7f4:	6371      	str	r1, [r6, #52]	; 0x34
	TIM_ITConfig(TIM8, TIM_IT_CC1, ENABLE);
 801d7f6:	4630      	mov	r0, r6
 801d7f8:	f007 f8aa 	bl	8024950 <TIM_ITConfig>
	ENABLE_GATE();
 801d7fc:	f505 3584 	add.w	r5, r5, #67584	; 0x10800
	nvicEnableVector(TIM8_CC_IRQn, 6);
 801d800:	2106      	movs	r1, #6
 801d802:	202e      	movs	r0, #46	; 0x2e
 801d804:	f7f1 fc94 	bl	800f130 <nvicEnableVector>
	utils_sys_unlock_cnt();
 801d808:	f7f8 fc5a 	bl	80160c0 <utils_sys_unlock_cnt>
	ENABLE_GATE();
 801d80c:	9b03      	ldr	r3, [sp, #12]
	DCCAL_OFF();
 801d80e:	4a33      	ldr	r2, [pc, #204]	; (801d8dc <mcpwm_foc_init+0x51c>)
	ENABLE_GATE();
 801d810:	832b      	strh	r3, [r5, #24]
	DCCAL_OFF();
 801d812:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801d816:	8353      	strh	r3, [r2, #26]
	DCCAL_ON();
 801d818:	f241 3489 	movw	r4, #5001	; 0x1389
 801d81c:	8313      	strh	r3, [r2, #24]
 801d81e:	e003      	b.n	801d828 <mcpwm_foc_init+0x468>
		chThdSleepMilliseconds(1);
 801d820:	f7f0 f8de 	bl	800d9e0 <chThdSleep>
		if (cnt > 5000) {
 801d824:	3c01      	subs	r4, #1
 801d826:	d004      	beq.n	801d832 <mcpwm_foc_init+0x472>
	while(IS_DRV_FAULT()){
 801d828:	692b      	ldr	r3, [r5, #16]
 801d82a:	04db      	lsls	r3, r3, #19
		chThdSleepMilliseconds(1);
 801d82c:	f04f 000a 	mov.w	r0, #10
	while(IS_DRV_FAULT()){
 801d830:	d5f6      	bpl.n	801d820 <mcpwm_foc_init+0x460>
	chThdSleepMilliseconds(1000);
 801d832:	f242 7010 	movw	r0, #10000	; 0x2710
 801d836:	f7f0 f8d3 	bl	800d9e0 <chThdSleep>
	m_curr1_sum = 0;
 801d83a:	4a29      	ldr	r2, [pc, #164]	; (801d8e0 <mcpwm_foc_init+0x520>)
	m_curr0_sum = 0;
 801d83c:	2300      	movs	r3, #0
 801d83e:	f8cb 3000 	str.w	r3, [fp]
	m_curr1_sum = 0;
 801d842:	6013      	str	r3, [r2, #0]
	m_curr_samples = 0;
 801d844:	603b      	str	r3, [r7, #0]
	while(m_curr_samples < 4000) {};
 801d846:	683b      	ldr	r3, [r7, #0]
 801d848:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
 801d84c:	dbfb      	blt.n	801d846 <mcpwm_foc_init+0x486>
	m_curr0_offset = m_curr0_sum / m_curr_samples;
 801d84e:	4a25      	ldr	r2, [pc, #148]	; (801d8e4 <mcpwm_foc_init+0x524>)
 801d850:	f8db 3000 	ldr.w	r3, [fp]
 801d854:	6839      	ldr	r1, [r7, #0]
 801d856:	fb93 f3f1 	sdiv	r3, r3, r1
	m_curr1_offset = m_curr1_sum / m_curr_samples;
 801d85a:	4923      	ldr	r1, [pc, #140]	; (801d8e8 <mcpwm_foc_init+0x528>)
	m_curr0_offset = m_curr0_sum / m_curr_samples;
 801d85c:	6013      	str	r3, [r2, #0]
	m_curr1_offset = m_curr1_sum / m_curr_samples;
 801d85e:	4b20      	ldr	r3, [pc, #128]	; (801d8e0 <mcpwm_foc_init+0x520>)
	DCCAL_OFF();
 801d860:	4a1e      	ldr	r2, [pc, #120]	; (801d8dc <mcpwm_foc_init+0x51c>)
	m_curr1_offset = m_curr1_sum / m_curr_samples;
 801d862:	681b      	ldr	r3, [r3, #0]
 801d864:	6838      	ldr	r0, [r7, #0]
 801d866:	fb93 f3f0 	sdiv	r3, r3, r0
	m_dccal_done = true;
 801d86a:	2401      	movs	r4, #1
	m_curr1_offset = m_curr1_sum / m_curr_samples;
 801d86c:	600b      	str	r3, [r1, #0]
	DCCAL_OFF();
 801d86e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
	m_dccal_done = true;
 801d872:	4b1e      	ldr	r3, [pc, #120]	; (801d8ec <mcpwm_foc_init+0x52c>)
	DCCAL_OFF();
 801d874:	8350      	strh	r0, [r2, #26]
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12, ENABLE);
 801d876:	4621      	mov	r1, r4
 801d878:	2040      	movs	r0, #64	; 0x40
	TIM_TimeBaseStructure.TIM_Period = 0xFFFFFFFF;
 801d87a:	2500      	movs	r5, #0
	m_dccal_done = true;
 801d87c:	701c      	strb	r4, [r3, #0]
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12, ENABLE);
 801d87e:	f006 fcd7 	bl	8024230 <RCC_APB1PeriphClockCmd>
	TIM_TimeBaseStructure.TIM_Prescaler = (uint16_t)(((SYSTEM_CORE_CLOCK / 2) / 10000000) - 1);
 801d882:	2207      	movs	r2, #7
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801d884:	f04f 33ff 	mov.w	r3, #4294967295
	TIM_TimeBaseInit(TIM12, &TIM_TimeBaseStructure);
 801d888:	a905      	add	r1, sp, #20
 801d88a:	4819      	ldr	r0, [pc, #100]	; (801d8f0 <mcpwm_foc_init+0x530>)
	TIM_TimeBaseStructure.TIM_Period = 0xFFFFFFFF;
 801d88c:	f8ad 501c 	strh.w	r5, [sp, #28]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 801d890:	e9cd 2305 	strd	r2, r3, [sp, #20]
	TIM_TimeBaseInit(TIM12, &TIM_TimeBaseStructure);
 801d894:	f006 fe04 	bl	80244a0 <TIM_TimeBaseInit>
	TIM_Cmd(TIM12, ENABLE);
 801d898:	4621      	mov	r1, r4
 801d89a:	4815      	ldr	r0, [pc, #84]	; (801d8f0 <mcpwm_foc_init+0x530>)
 801d89c:	f006 fe68 	bl	8024570 <TIM_Cmd>
	timer_thd_stop = false;
 801d8a0:	4a14      	ldr	r2, [pc, #80]	; (801d8f4 <mcpwm_foc_init+0x534>)
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801d8a2:	4b15      	ldr	r3, [pc, #84]	; (801d8f8 <mcpwm_foc_init+0x538>)
 801d8a4:	9500      	str	r5, [sp, #0]
 801d8a6:	f640 1198 	movw	r1, #2456	; 0x998
	timer_thd_stop = false;
 801d8aa:	7015      	strb	r5, [r2, #0]
	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
 801d8ac:	4813      	ldr	r0, [pc, #76]	; (801d8fc <mcpwm_foc_init+0x53c>)
 801d8ae:	2240      	movs	r2, #64	; 0x40
 801d8b0:	f7f0 f85e 	bl	800d970 <chThdCreateStatic>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
 801d8b4:	4621      	mov	r1, r4
 801d8b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801d8ba:	f006 fcb9 	bl	8024230 <RCC_APB1PeriphClockCmd>
	WWDG_SetPrescaler(WWDG_Prescaler_1);
 801d8be:	4628      	mov	r0, r5
 801d8c0:	f007 f8b6 	bl	8024a30 <WWDG_SetPrescaler>
	WWDG_SetWindowValue(255);
 801d8c4:	20ff      	movs	r0, #255	; 0xff
 801d8c6:	f007 f8c3 	bl	8024a50 <WWDG_SetWindowValue>
	WWDG_Enable(100);
 801d8ca:	2064      	movs	r0, #100	; 0x64
 801d8cc:	f007 f8e0 	bl	8024a90 <WWDG_Enable>
	m_init_done = true;
 801d8d0:	4b0b      	ldr	r3, [pc, #44]	; (801d900 <mcpwm_foc_init+0x540>)
 801d8d2:	701c      	strb	r4, [r3, #0]
}
 801d8d4:	b02b      	add	sp, #172	; 0xac
 801d8d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d8da:	bf00      	nop
 801d8dc:	40020400 	.word	0x40020400
 801d8e0:	2000cdbc 	.word	0x2000cdbc
 801d8e4:	2000cdb0 	.word	0x2000cdb0
 801d8e8:	2000cdb8 	.word	0x2000cdb8
 801d8ec:	2000cdc4 	.word	0x2000cdc4
 801d8f0:	40001800 	.word	0x40001800
 801d8f4:	2000ceb4 	.word	0x2000ceb4
 801d8f8:	0801cf41 	.word	0x0801cf41
 801d8fc:	2000ceb8 	.word	0x2000ceb8
 801d900:	2000cdd4 	.word	0x2000cdd4
	...

0801d910 <mcpwm_foc_deinit>:
	m_init_done = false;
 801d910:	4b13      	ldr	r3, [pc, #76]	; (801d960 <mcpwm_foc_deinit+0x50>)
void mcpwm_foc_deinit(void) {
 801d912:	b510      	push	{r4, lr}
	m_init_done = false;
 801d914:	2200      	movs	r2, #0
	timer_thd_stop = true;
 801d916:	4c13      	ldr	r4, [pc, #76]	; (801d964 <mcpwm_foc_deinit+0x54>)
	m_init_done = false;
 801d918:	701a      	strb	r2, [r3, #0]
	WWDG_DeInit();
 801d91a:	f007 f879 	bl	8024a10 <WWDG_DeInit>
	timer_thd_stop = true;
 801d91e:	2301      	movs	r3, #1
 801d920:	7023      	strb	r3, [r4, #0]
	while (timer_thd_stop) {
 801d922:	7823      	ldrb	r3, [r4, #0]
 801d924:	b12b      	cbz	r3, 801d932 <mcpwm_foc_deinit+0x22>
		chThdSleepMilliseconds(1);
 801d926:	200a      	movs	r0, #10
 801d928:	f7f0 f85a 	bl	800d9e0 <chThdSleep>
	while (timer_thd_stop) {
 801d92c:	7823      	ldrb	r3, [r4, #0]
 801d92e:	2b00      	cmp	r3, #0
 801d930:	d1f9      	bne.n	801d926 <mcpwm_foc_deinit+0x16>
	TIM_DeInit(TIM1);
 801d932:	480d      	ldr	r0, [pc, #52]	; (801d968 <mcpwm_foc_deinit+0x58>)
 801d934:	f006 fcd4 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM8);
 801d938:	480c      	ldr	r0, [pc, #48]	; (801d96c <mcpwm_foc_deinit+0x5c>)
 801d93a:	f006 fcd1 	bl	80242e0 <TIM_DeInit>
	TIM_DeInit(TIM12);
 801d93e:	480c      	ldr	r0, [pc, #48]	; (801d970 <mcpwm_foc_deinit+0x60>)
 801d940:	f006 fcce 	bl	80242e0 <TIM_DeInit>
	ADC_DeInit();
 801d944:	f006 f904 	bl	8023b50 <ADC_DeInit>
	DMA_DeInit(DMA2_Stream4);
 801d948:	480a      	ldr	r0, [pc, #40]	; (801d974 <mcpwm_foc_deinit+0x64>)
 801d94a:	f006 fa41 	bl	8023dd0 <DMA_DeInit>
	nvicDisableVector(ADC_IRQn);
 801d94e:	2012      	movs	r0, #18
 801d950:	f7f1 fc0e 	bl	800f170 <nvicDisableVector>
	dmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));
 801d954:	4808      	ldr	r0, [pc, #32]	; (801d978 <mcpwm_foc_deinit+0x68>)
}
 801d956:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	dmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));
 801d95a:	f7f1 be21 	b.w	800f5a0 <dmaStreamRelease>
 801d95e:	bf00      	nop
 801d960:	2000cdd4 	.word	0x2000cdd4
 801d964:	2000ceb4 	.word	0x2000ceb4
 801d968:	40010000 	.word	0x40010000
 801d96c:	40010400 	.word	0x40010400
 801d970:	40001800 	.word	0x40001800
 801d974:	40026470 	.word	0x40026470
 801d978:	0802da40 	.word	0x0802da40
 801d97c:	00000000 	.word	0x00000000

0801d980 <mcpwm_foc_init_done>:
	return m_init_done;
 801d980:	4b01      	ldr	r3, [pc, #4]	; (801d988 <mcpwm_foc_init_done+0x8>)
 801d982:	7818      	ldrb	r0, [r3, #0]
}
 801d984:	4770      	bx	lr
 801d986:	bf00      	nop
 801d988:	2000cdd4 	.word	0x2000cdd4
 801d98c:	00000000 	.word	0x00000000

0801d990 <mcpwm_foc_set_configuration>:
void mcpwm_foc_set_configuration(volatile mc_configuration *configuration) {
 801d990:	b510      	push	{r4, lr}
	m_conf = configuration;
 801d992:	4c14      	ldr	r4, [pc, #80]	; (801d9e4 <mcpwm_foc_set_configuration+0x54>)
	m_control_mode = CONTROL_MODE_NONE;
 801d994:	4914      	ldr	r1, [pc, #80]	; (801d9e8 <mcpwm_foc_set_configuration+0x58>)
	m_state = MC_STATE_OFF;
 801d996:	4b15      	ldr	r3, [pc, #84]	; (801d9ec <mcpwm_foc_set_configuration+0x5c>)
	m_conf = configuration;
 801d998:	6020      	str	r0, [r4, #0]
	m_state = MC_STATE_OFF;
 801d99a:	2200      	movs	r2, #0
	m_control_mode = CONTROL_MODE_NONE;
 801d99c:	2007      	movs	r0, #7
 801d99e:	7008      	strb	r0, [r1, #0]
	m_state = MC_STATE_OFF;
 801d9a0:	701a      	strb	r2, [r3, #0]
	stop_pwm_hw();
 801d9a2:	f7ff f95d 	bl	801cc60 <stop_pwm_hw>
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d9a6:	6823      	ldr	r3, [r4, #0]
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801d9a8:	4a11      	ldr	r2, [pc, #68]	; (801d9f0 <mcpwm_foc_set_configuration+0x60>)
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d9aa:	edd3 7a2b 	vldr	s15, [r3, #172]	; 0xac
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801d9ae:	6811      	ldr	r1, [r2, #0]
 801d9b0:	4b10      	ldr	r3, [pc, #64]	; (801d9f4 <mcpwm_foc_set_configuration+0x64>)
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d9b2:	4811      	ldr	r0, [pc, #68]	; (801d9f8 <mcpwm_foc_set_configuration+0x68>)
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801d9b4:	f041 0102 	orr.w	r1, r1, #2
 801d9b8:	6011      	str	r1, [r2, #0]
 801d9ba:	6819      	ldr	r1, [r3, #0]
 801d9bc:	2402      	movs	r4, #2
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d9be:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801d9c2:	4321      	orrs	r1, r4
 801d9c4:	6019      	str	r1, [r3, #0]
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801d9c6:	ee17 1a90 	vmov	r1, s15
 801d9ca:	fb90 f1f1 	sdiv	r1, r0, r1
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801d9ce:	62d1      	str	r1, [r2, #44]	; 0x2c
 801d9d0:	635c      	str	r4, [r3, #52]	; 0x34
 801d9d2:	6811      	ldr	r1, [r2, #0]
 801d9d4:	f021 0102 	bic.w	r1, r1, #2
 801d9d8:	6011      	str	r1, [r2, #0]
 801d9da:	681a      	ldr	r2, [r3, #0]
 801d9dc:	f022 0202 	bic.w	r2, r2, #2
 801d9e0:	601a      	str	r2, [r3, #0]
}
 801d9e2:	bd10      	pop	{r4, pc}
 801d9e4:	2000cda8 	.word	0x2000cda8
 801d9e8:	2000cdac 	.word	0x2000cdac
 801d9ec:	2000ce8c 	.word	0x2000ce8c
 801d9f0:	40010000 	.word	0x40010000
 801d9f4:	40010400 	.word	0x40010400
 801d9f8:	0a037a00 	.word	0x0a037a00
 801d9fc:	00000000 	.word	0x00000000

0801da00 <mcpwm_foc_get_state>:
	return m_state;
 801da00:	4b01      	ldr	r3, [pc, #4]	; (801da08 <mcpwm_foc_get_state+0x8>)
 801da02:	7818      	ldrb	r0, [r3, #0]
}
 801da04:	4770      	bx	lr
 801da06:	bf00      	nop
 801da08:	2000ce8c 	.word	0x2000ce8c
 801da0c:	00000000 	.word	0x00000000

0801da10 <mcpwm_foc_is_dccal_done>:
	return m_dccal_done;
 801da10:	4b01      	ldr	r3, [pc, #4]	; (801da18 <mcpwm_foc_is_dccal_done+0x8>)
 801da12:	7818      	ldrb	r0, [r3, #0]
}
 801da14:	4770      	bx	lr
 801da16:	bf00      	nop
 801da18:	2000cdc4 	.word	0x2000cdc4
 801da1c:	00000000 	.word	0x00000000

0801da20 <mcpwm_foc_set_duty>:
	m_duty_cycle_set = dutyCycle;
 801da20:	4a06      	ldr	r2, [pc, #24]	; (801da3c <mcpwm_foc_set_duty+0x1c>)
	m_control_mode = CONTROL_MODE_DUTY;
 801da22:	4907      	ldr	r1, [pc, #28]	; (801da40 <mcpwm_foc_set_duty+0x20>)
	if (m_state != MC_STATE_RUNNING) {
 801da24:	4b07      	ldr	r3, [pc, #28]	; (801da44 <mcpwm_foc_set_duty+0x24>)
	m_control_mode = CONTROL_MODE_DUTY;
 801da26:	2000      	movs	r0, #0
 801da28:	7008      	strb	r0, [r1, #0]
	m_duty_cycle_set = dutyCycle;
 801da2a:	ed82 0a00 	vstr	s0, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801da2e:	781a      	ldrb	r2, [r3, #0]
 801da30:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801da32:	bf1c      	itt	ne
 801da34:	2202      	movne	r2, #2
 801da36:	701a      	strbne	r2, [r3, #0]
}
 801da38:	4770      	bx	lr
 801da3a:	bf00      	nop
 801da3c:	2000cdc8 	.word	0x2000cdc8
 801da40:	2000cdac 	.word	0x2000cdac
 801da44:	2000ce8c 	.word	0x2000ce8c
	...

0801da50 <mcpwm_foc_set_pid_speed>:
	m_speed_pid_set_rpm = rpm;
 801da50:	4a06      	ldr	r2, [pc, #24]	; (801da6c <mcpwm_foc_set_pid_speed+0x1c>)
	m_control_mode = CONTROL_MODE_SPEED;
 801da52:	4907      	ldr	r1, [pc, #28]	; (801da70 <mcpwm_foc_set_pid_speed+0x20>)
	if (m_state != MC_STATE_RUNNING) {
 801da54:	4b07      	ldr	r3, [pc, #28]	; (801da74 <mcpwm_foc_set_pid_speed+0x24>)
	m_control_mode = CONTROL_MODE_SPEED;
 801da56:	2001      	movs	r0, #1
 801da58:	7008      	strb	r0, [r1, #0]
	m_speed_pid_set_rpm = rpm;
 801da5a:	ed82 0a00 	vstr	s0, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801da5e:	781a      	ldrb	r2, [r3, #0]
 801da60:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801da62:	bf1c      	itt	ne
 801da64:	2202      	movne	r2, #2
 801da66:	701a      	strbne	r2, [r3, #0]
}
 801da68:	4770      	bx	lr
 801da6a:	bf00      	nop
 801da6c:	2000ce88 	.word	0x2000ce88
 801da70:	2000cdac 	.word	0x2000cdac
 801da74:	2000ce8c 	.word	0x2000ce8c
	...

0801da80 <mcpwm_foc_set_pid_pos>:
	m_pos_pid_set = pos;
 801da80:	4a06      	ldr	r2, [pc, #24]	; (801da9c <mcpwm_foc_set_pid_pos+0x1c>)
	m_control_mode = CONTROL_MODE_POS;
 801da82:	4907      	ldr	r1, [pc, #28]	; (801daa0 <mcpwm_foc_set_pid_pos+0x20>)
	if (m_state != MC_STATE_RUNNING) {
 801da84:	4b07      	ldr	r3, [pc, #28]	; (801daa4 <mcpwm_foc_set_pid_pos+0x24>)
	m_control_mode = CONTROL_MODE_POS;
 801da86:	2004      	movs	r0, #4
 801da88:	7008      	strb	r0, [r1, #0]
	m_pos_pid_set = pos;
 801da8a:	ed82 0a00 	vstr	s0, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801da8e:	781a      	ldrb	r2, [r3, #0]
 801da90:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801da92:	bf1c      	itt	ne
 801da94:	2202      	movne	r2, #2
 801da96:	701a      	strbne	r2, [r3, #0]
}
 801da98:	4770      	bx	lr
 801da9a:	bf00      	nop
 801da9c:	2000ce70 	.word	0x2000ce70
 801daa0:	2000cdac 	.word	0x2000cdac
 801daa4:	2000ce8c 	.word	0x2000ce8c
	...

0801dab0 <mcpwm_foc_set_current>:
	if (fabsf(current) < m_conf->cc_min_current) {
 801dab0:	4b0f      	ldr	r3, [pc, #60]	; (801daf0 <mcpwm_foc_set_current+0x40>)
 801dab2:	681b      	ldr	r3, [r3, #0]
 801dab4:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801dab8:	eeb0 7ac0 	vabs.f32	s14, s0
 801dabc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801dac0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dac4:	d40b      	bmi.n	801dade <mcpwm_foc_set_current+0x2e>
	m_iq_set = current;
 801dac6:	490b      	ldr	r1, [pc, #44]	; (801daf4 <mcpwm_foc_set_current+0x44>)
	m_control_mode = CONTROL_MODE_CURRENT;
 801dac8:	480b      	ldr	r0, [pc, #44]	; (801daf8 <mcpwm_foc_set_current+0x48>)
	if (m_state != MC_STATE_RUNNING) {
 801daca:	4b0c      	ldr	r3, [pc, #48]	; (801dafc <mcpwm_foc_set_current+0x4c>)
	m_control_mode = CONTROL_MODE_CURRENT;
 801dacc:	2202      	movs	r2, #2
 801dace:	7002      	strb	r2, [r0, #0]
	m_iq_set = current;
 801dad0:	ed81 0a00 	vstr	s0, [r1]
	if (m_state != MC_STATE_RUNNING) {
 801dad4:	7819      	ldrb	r1, [r3, #0]
 801dad6:	4291      	cmp	r1, r2
		m_state = MC_STATE_RUNNING;
 801dad8:	bf18      	it	ne
 801dada:	701a      	strbne	r2, [r3, #0]
}
 801dadc:	4770      	bx	lr
		m_control_mode = CONTROL_MODE_NONE;
 801dade:	4906      	ldr	r1, [pc, #24]	; (801daf8 <mcpwm_foc_set_current+0x48>)
		m_state = MC_STATE_OFF;
 801dae0:	4b06      	ldr	r3, [pc, #24]	; (801dafc <mcpwm_foc_set_current+0x4c>)
		m_control_mode = CONTROL_MODE_NONE;
 801dae2:	2007      	movs	r0, #7
		m_state = MC_STATE_OFF;
 801dae4:	2200      	movs	r2, #0
		m_control_mode = CONTROL_MODE_NONE;
 801dae6:	7008      	strb	r0, [r1, #0]
		m_state = MC_STATE_OFF;
 801dae8:	701a      	strb	r2, [r3, #0]
		stop_pwm_hw();
 801daea:	f7ff b8b9 	b.w	801cc60 <stop_pwm_hw>
 801daee:	bf00      	nop
 801daf0:	2000cda8 	.word	0x2000cda8
 801daf4:	2000cdd8 	.word	0x2000cdd8
 801daf8:	2000cdac 	.word	0x2000cdac
 801dafc:	2000ce8c 	.word	0x2000ce8c

0801db00 <mcpwm_foc_stop_pwm>:
	mcpwm_foc_set_current(0.0);
 801db00:	ed9f 0a01 	vldr	s0, [pc, #4]	; 801db08 <mcpwm_foc_stop_pwm+0x8>
 801db04:	f7ff bfd4 	b.w	801dab0 <mcpwm_foc_set_current>
	...

0801db10 <mcpwm_foc_set_brake_current>:
	if (fabsf(current) < m_conf->cc_min_current) {
 801db10:	4b0f      	ldr	r3, [pc, #60]	; (801db50 <mcpwm_foc_set_brake_current+0x40>)
		m_control_mode = CONTROL_MODE_NONE;
 801db12:	4910      	ldr	r1, [pc, #64]	; (801db54 <mcpwm_foc_set_brake_current+0x44>)
	if (fabsf(current) < m_conf->cc_min_current) {
 801db14:	681b      	ldr	r3, [r3, #0]
 801db16:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801db1a:	eeb0 7ac0 	vabs.f32	s14, s0
 801db1e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801db22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801db26:	d40b      	bmi.n	801db40 <mcpwm_foc_set_brake_current+0x30>
	m_iq_set = current;
 801db28:	4a0b      	ldr	r2, [pc, #44]	; (801db58 <mcpwm_foc_set_brake_current+0x48>)
	if (m_state != MC_STATE_RUNNING) {
 801db2a:	4b0c      	ldr	r3, [pc, #48]	; (801db5c <mcpwm_foc_set_brake_current+0x4c>)
	m_control_mode = CONTROL_MODE_CURRENT_BRAKE;
 801db2c:	2003      	movs	r0, #3
 801db2e:	7008      	strb	r0, [r1, #0]
	m_iq_set = current;
 801db30:	ed82 0a00 	vstr	s0, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801db34:	781a      	ldrb	r2, [r3, #0]
 801db36:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801db38:	bf1c      	itt	ne
 801db3a:	2202      	movne	r2, #2
 801db3c:	701a      	strbne	r2, [r3, #0]
}
 801db3e:	4770      	bx	lr
		m_state = MC_STATE_OFF;
 801db40:	4b06      	ldr	r3, [pc, #24]	; (801db5c <mcpwm_foc_set_brake_current+0x4c>)
		m_control_mode = CONTROL_MODE_NONE;
 801db42:	2007      	movs	r0, #7
		m_state = MC_STATE_OFF;
 801db44:	2200      	movs	r2, #0
		m_control_mode = CONTROL_MODE_NONE;
 801db46:	7008      	strb	r0, [r1, #0]
		m_state = MC_STATE_OFF;
 801db48:	701a      	strb	r2, [r3, #0]
		stop_pwm_hw();
 801db4a:	f7ff b889 	b.w	801cc60 <stop_pwm_hw>
 801db4e:	bf00      	nop
 801db50:	2000cda8 	.word	0x2000cda8
 801db54:	2000cdac 	.word	0x2000cdac
 801db58:	2000cdd8 	.word	0x2000cdd8
 801db5c:	2000ce8c 	.word	0x2000ce8c

0801db60 <mcpwm_foc_set_handbrake>:
	if (fabsf(current) < m_conf->cc_min_current) {
 801db60:	4b0f      	ldr	r3, [pc, #60]	; (801dba0 <mcpwm_foc_set_handbrake+0x40>)
		m_control_mode = CONTROL_MODE_NONE;
 801db62:	4910      	ldr	r1, [pc, #64]	; (801dba4 <mcpwm_foc_set_handbrake+0x44>)
	if (fabsf(current) < m_conf->cc_min_current) {
 801db64:	681b      	ldr	r3, [r3, #0]
 801db66:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801db6a:	eeb0 7ac0 	vabs.f32	s14, s0
 801db6e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801db72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801db76:	d40b      	bmi.n	801db90 <mcpwm_foc_set_handbrake+0x30>
	m_iq_set = current;
 801db78:	4a0b      	ldr	r2, [pc, #44]	; (801dba8 <mcpwm_foc_set_handbrake+0x48>)
	if (m_state != MC_STATE_RUNNING) {
 801db7a:	4b0c      	ldr	r3, [pc, #48]	; (801dbac <mcpwm_foc_set_handbrake+0x4c>)
	m_control_mode = CONTROL_MODE_HANDBRAKE;
 801db7c:	2005      	movs	r0, #5
 801db7e:	7008      	strb	r0, [r1, #0]
	m_iq_set = current;
 801db80:	ed82 0a00 	vstr	s0, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801db84:	781a      	ldrb	r2, [r3, #0]
 801db86:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801db88:	bf1c      	itt	ne
 801db8a:	2202      	movne	r2, #2
 801db8c:	701a      	strbne	r2, [r3, #0]
}
 801db8e:	4770      	bx	lr
		m_state = MC_STATE_OFF;
 801db90:	4b06      	ldr	r3, [pc, #24]	; (801dbac <mcpwm_foc_set_handbrake+0x4c>)
		m_control_mode = CONTROL_MODE_NONE;
 801db92:	2007      	movs	r0, #7
		m_state = MC_STATE_OFF;
 801db94:	2200      	movs	r2, #0
		m_control_mode = CONTROL_MODE_NONE;
 801db96:	7008      	strb	r0, [r1, #0]
		m_state = MC_STATE_OFF;
 801db98:	701a      	strb	r2, [r3, #0]
		stop_pwm_hw();
 801db9a:	f7ff b861 	b.w	801cc60 <stop_pwm_hw>
 801db9e:	bf00      	nop
 801dba0:	2000cda8 	.word	0x2000cda8
 801dba4:	2000cdac 	.word	0x2000cdac
 801dba8:	2000cdd8 	.word	0x2000cdd8
 801dbac:	2000ce8c 	.word	0x2000ce8c

0801dbb0 <mcpwm_foc_set_openloop>:
void mcpwm_foc_set_openloop(float current, float rpm) {
 801dbb0:	b530      	push	{r4, r5, lr}
	if (fabsf(current) < m_conf->cc_min_current) {
 801dbb2:	4b1f      	ldr	r3, [pc, #124]	; (801dc30 <mcpwm_foc_set_openloop+0x80>)
 801dbb4:	681b      	ldr	r3, [r3, #0]
void mcpwm_foc_set_openloop(float current, float rpm) {
 801dbb6:	ed2d 8b02 	vpush	{d8}
	if (fabsf(current) < m_conf->cc_min_current) {
 801dbba:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801dbbe:	eeb0 7ac0 	vabs.f32	s14, s0
 801dbc2:	eeb4 7ae7 	vcmpe.f32	s14, s15
void mcpwm_foc_set_openloop(float current, float rpm) {
 801dbc6:	b083      	sub	sp, #12
	if (fabsf(current) < m_conf->cc_min_current) {
 801dbc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
void mcpwm_foc_set_openloop(float current, float rpm) {
 801dbcc:	ed8d 0a01 	vstr	s0, [sp, #4]
	if (fabsf(current) < m_conf->cc_min_current) {
 801dbd0:	d421      	bmi.n	801dc16 <mcpwm_foc_set_openloop+0x66>
	utils_truncate_number(&current, -m_conf->l_current_max, m_conf->l_current_max);
 801dbd2:	ed93 0a01 	vldr	s0, [r3, #4]
	m_control_mode = CONTROL_MODE_OPENLOOP;
 801dbd6:	4c17      	ldr	r4, [pc, #92]	; (801dc34 <mcpwm_foc_set_openloop+0x84>)
 801dbd8:	eeb0 8a60 	vmov.f32	s16, s1
	utils_truncate_number(&current, -m_conf->l_current_max, m_conf->l_current_max);
 801dbdc:	eeb1 0a40 	vneg.f32	s0, s0
 801dbe0:	edd3 0a01 	vldr	s1, [r3, #4]
 801dbe4:	a801      	add	r0, sp, #4
 801dbe6:	f7f7 ff4b 	bl	8015a80 <utils_truncate_number>
	m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
 801dbea:	eddf 7a13 	vldr	s15, [pc, #76]	; 801dc38 <mcpwm_foc_set_openloop+0x88>
	m_iq_set = current;
 801dbee:	4913      	ldr	r1, [pc, #76]	; (801dc3c <mcpwm_foc_set_openloop+0x8c>)
	m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
 801dbf0:	4a13      	ldr	r2, [pc, #76]	; (801dc40 <mcpwm_foc_set_openloop+0x90>)
	if (m_state != MC_STATE_RUNNING) {
 801dbf2:	4b14      	ldr	r3, [pc, #80]	; (801dc44 <mcpwm_foc_set_openloop+0x94>)
	m_iq_set = current;
 801dbf4:	9801      	ldr	r0, [sp, #4]
	m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
 801dbf6:	ee28 8a27 	vmul.f32	s16, s16, s15
	m_control_mode = CONTROL_MODE_OPENLOOP;
 801dbfa:	2506      	movs	r5, #6
 801dbfc:	7025      	strb	r5, [r4, #0]
	m_iq_set = current;
 801dbfe:	6008      	str	r0, [r1, #0]
	m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
 801dc00:	ed82 8a00 	vstr	s16, [r2]
	if (m_state != MC_STATE_RUNNING) {
 801dc04:	781a      	ldrb	r2, [r3, #0]
 801dc06:	2a02      	cmp	r2, #2
		m_state = MC_STATE_RUNNING;
 801dc08:	bf1c      	itt	ne
 801dc0a:	2202      	movne	r2, #2
 801dc0c:	701a      	strbne	r2, [r3, #0]
}
 801dc0e:	b003      	add	sp, #12
 801dc10:	ecbd 8b02 	vpop	{d8}
 801dc14:	bd30      	pop	{r4, r5, pc}
		m_control_mode = CONTROL_MODE_NONE;
 801dc16:	4907      	ldr	r1, [pc, #28]	; (801dc34 <mcpwm_foc_set_openloop+0x84>)
		m_state = MC_STATE_OFF;
 801dc18:	4b0a      	ldr	r3, [pc, #40]	; (801dc44 <mcpwm_foc_set_openloop+0x94>)
		m_control_mode = CONTROL_MODE_NONE;
 801dc1a:	2007      	movs	r0, #7
		m_state = MC_STATE_OFF;
 801dc1c:	2200      	movs	r2, #0
		m_control_mode = CONTROL_MODE_NONE;
 801dc1e:	7008      	strb	r0, [r1, #0]
		m_state = MC_STATE_OFF;
 801dc20:	701a      	strb	r2, [r3, #0]
		stop_pwm_hw();
 801dc22:	f7ff f81d 	bl	801cc60 <stop_pwm_hw>
}
 801dc26:	b003      	add	sp, #12
 801dc28:	ecbd 8b02 	vpop	{d8}
 801dc2c:	bd30      	pop	{r4, r5, pc}
 801dc2e:	bf00      	nop
 801dc30:	2000cda8 	.word	0x2000cda8
 801dc34:	2000cdac 	.word	0x2000cdac
 801dc38:	3dd67750 	.word	0x3dd67750
 801dc3c:	2000cdd8 	.word	0x2000cdd8
 801dc40:	2000ce44 	.word	0x2000ce44
 801dc44:	2000ce8c 	.word	0x2000ce8c
	...

0801dc50 <mcpwm_foc_get_duty_cycle_now>:
	return m_motor_state.duty_now;
 801dc50:	4b01      	ldr	r3, [pc, #4]	; (801dc58 <mcpwm_foc_get_duty_cycle_now+0x8>)
 801dc52:	ed93 0a03 	vldr	s0, [r3, #12]
}
 801dc56:	4770      	bx	lr
 801dc58:	2000cddc 	.word	0x2000cddc
 801dc5c:	00000000 	.word	0x00000000

0801dc60 <mcpwm_foc_get_pid_pos_now>:
	return m_pos_pid_now;
 801dc60:	4b01      	ldr	r3, [pc, #4]	; (801dc68 <mcpwm_foc_get_pid_pos_now+0x8>)
 801dc62:	ed93 0a00 	vldr	s0, [r3]
}
 801dc66:	4770      	bx	lr
 801dc68:	2000ce6c 	.word	0x2000ce6c
 801dc6c:	00000000 	.word	0x00000000

0801dc70 <mcpwm_foc_get_sampling_frequency_now>:
	return m_conf->foc_f_sw / 2.0;
 801dc70:	4b04      	ldr	r3, [pc, #16]	; (801dc84 <mcpwm_foc_get_sampling_frequency_now+0x14>)
 801dc72:	681b      	ldr	r3, [r3, #0]
 801dc74:	ed93 0a2b 	vldr	s0, [r3, #172]	; 0xac
 801dc78:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
}
 801dc7c:	ee20 0a27 	vmul.f32	s0, s0, s15
 801dc80:	4770      	bx	lr
 801dc82:	bf00      	nop
 801dc84:	2000cda8 	.word	0x2000cda8
	...

0801dc90 <mcpwm_foc_get_rpm>:
	return m_pll_speed / ((2.0 * M_PI) / 60.0);
 801dc90:	4b03      	ldr	r3, [pc, #12]	; (801dca0 <mcpwm_foc_get_rpm+0x10>)
 801dc92:	eddf 7a04 	vldr	s15, [pc, #16]	; 801dca4 <mcpwm_foc_get_rpm+0x14>
 801dc96:	ed93 0a00 	vldr	s0, [r3]
}
 801dc9a:	ee80 0a27 	vdiv.f32	s0, s0, s15
 801dc9e:	4770      	bx	lr
 801dca0:	2000ce68 	.word	0x2000ce68
 801dca4:	3dd67750 	.word	0x3dd67750
	...

0801dcb0 <mcpwm_foc_get_tot_current>:
	return SIGN(m_motor_state.vq) * m_motor_state.iq;
 801dcb0:	4b09      	ldr	r3, [pc, #36]	; (801dcd8 <mcpwm_foc_get_tot_current+0x28>)
 801dcb2:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 801dcb6:	ed93 0a10 	vldr	s0, [r3, #64]	; 0x40
 801dcba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801dcbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dcc2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801dcc6:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801dcca:	bf58      	it	pl
 801dccc:	eef0 7a47 	vmovpl.f32	s15, s14
}
 801dcd0:	ee20 0a27 	vmul.f32	s0, s0, s15
 801dcd4:	4770      	bx	lr
 801dcd6:	bf00      	nop
 801dcd8:	2000cddc 	.word	0x2000cddc
 801dcdc:	00000000 	.word	0x00000000

0801dce0 <mcpwm_foc_get_tot_current_filtered>:
	return SIGN(m_motor_state.vq) * m_motor_state.iq_filter;
 801dce0:	4b09      	ldr	r3, [pc, #36]	; (801dd08 <mcpwm_foc_get_tot_current_filtered+0x28>)
 801dce2:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 801dce6:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
 801dcea:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801dcee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dcf2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801dcf6:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801dcfa:	bf58      	it	pl
 801dcfc:	eef0 7a47 	vmovpl.f32	s15, s14
}
 801dd00:	ee20 0a27 	vmul.f32	s0, s0, s15
 801dd04:	4770      	bx	lr
 801dd06:	bf00      	nop
 801dd08:	2000cddc 	.word	0x2000cddc
 801dd0c:	00000000 	.word	0x00000000

0801dd10 <mcpwm_foc_get_abs_motor_current>:
	return m_motor_state.i_abs;
 801dd10:	4b01      	ldr	r3, [pc, #4]	; (801dd18 <mcpwm_foc_get_abs_motor_current+0x8>)
 801dd12:	ed93 0a07 	vldr	s0, [r3, #28]
}
 801dd16:	4770      	bx	lr
 801dd18:	2000cddc 	.word	0x2000cddc
 801dd1c:	00000000 	.word	0x00000000

0801dd20 <mcpwm_foc_get_abs_motor_current_filtered>:
	return m_motor_state.i_abs_filter;
 801dd20:	4b01      	ldr	r3, [pc, #4]	; (801dd28 <mcpwm_foc_get_abs_motor_current_filtered+0x8>)
 801dd22:	ed93 0a08 	vldr	s0, [r3, #32]
}
 801dd26:	4770      	bx	lr
 801dd28:	2000cddc 	.word	0x2000cddc
 801dd2c:	00000000 	.word	0x00000000

0801dd30 <mcpwm_foc_get_tot_current_directional>:
	return m_motor_state.iq;
 801dd30:	4b01      	ldr	r3, [pc, #4]	; (801dd38 <mcpwm_foc_get_tot_current_directional+0x8>)
 801dd32:	ed93 0a10 	vldr	s0, [r3, #64]	; 0x40
}
 801dd36:	4770      	bx	lr
 801dd38:	2000cddc 	.word	0x2000cddc
 801dd3c:	00000000 	.word	0x00000000

0801dd40 <mcpwm_foc_get_tot_current_directional_filtered>:
	return m_motor_state.iq_filter;
 801dd40:	4b01      	ldr	r3, [pc, #4]	; (801dd48 <mcpwm_foc_get_tot_current_directional_filtered+0x8>)
 801dd42:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
}
 801dd46:	4770      	bx	lr
 801dd48:	2000cddc 	.word	0x2000cddc
 801dd4c:	00000000 	.word	0x00000000

0801dd50 <mcpwm_foc_get_id>:
	return m_motor_state.id;
 801dd50:	4b01      	ldr	r3, [pc, #4]	; (801dd58 <mcpwm_foc_get_id+0x8>)
 801dd52:	ed93 0a0f 	vldr	s0, [r3, #60]	; 0x3c
}
 801dd56:	4770      	bx	lr
 801dd58:	2000cddc 	.word	0x2000cddc
 801dd5c:	00000000 	.word	0x00000000

0801dd60 <mcpwm_foc_get_iq>:
 801dd60:	4b01      	ldr	r3, [pc, #4]	; (801dd68 <mcpwm_foc_get_iq+0x8>)
 801dd62:	ed93 0a10 	vldr	s0, [r3, #64]	; 0x40
 801dd66:	4770      	bx	lr
 801dd68:	2000cddc 	.word	0x2000cddc
 801dd6c:	00000000 	.word	0x00000000

0801dd70 <mcpwm_foc_get_tot_current_in_filtered>:
 801dd70:	4b01      	ldr	r3, [pc, #4]	; (801dd78 <mcpwm_foc_get_tot_current_in_filtered+0x8>)
 801dd72:	ed93 0a09 	vldr	s0, [r3, #36]	; 0x24
 801dd76:	4770      	bx	lr
 801dd78:	2000cddc 	.word	0x2000cddc
 801dd7c:	00000000 	.word	0x00000000

0801dd80 <mcpwm_foc_get_tachometer_value>:
	int val = m_tachometer;
 801dd80:	4b03      	ldr	r3, [pc, #12]	; (801dd90 <mcpwm_foc_get_tachometer_value+0x10>)
 801dd82:	681a      	ldr	r2, [r3, #0]
	if (reset) {
 801dd84:	b108      	cbz	r0, 801dd8a <mcpwm_foc_get_tachometer_value+0xa>
		m_tachometer = 0;
 801dd86:	2100      	movs	r1, #0
 801dd88:	6019      	str	r1, [r3, #0]
}
 801dd8a:	4610      	mov	r0, r2
 801dd8c:	4770      	bx	lr
 801dd8e:	bf00      	nop
 801dd90:	2000ce90 	.word	0x2000ce90
	...

0801dda0 <mcpwm_foc_get_tachometer_abs_value>:
	int val = m_tachometer_abs;
 801dda0:	4b03      	ldr	r3, [pc, #12]	; (801ddb0 <mcpwm_foc_get_tachometer_abs_value+0x10>)
 801dda2:	681a      	ldr	r2, [r3, #0]
	if (reset) {
 801dda4:	b108      	cbz	r0, 801ddaa <mcpwm_foc_get_tachometer_abs_value+0xa>
		m_tachometer_abs = 0;
 801dda6:	2100      	movs	r1, #0
 801dda8:	6019      	str	r1, [r3, #0]
}
 801ddaa:	4610      	mov	r0, r2
 801ddac:	4770      	bx	lr
 801ddae:	bf00      	nop
 801ddb0:	2000ce94 	.word	0x2000ce94
	...

0801ddc0 <mcpwm_foc_get_phase>:
float mcpwm_foc_get_phase(void) {
 801ddc0:	b500      	push	{lr}
	float angle = m_motor_state.phase * (180.0 / M_PI);
 801ddc2:	4b09      	ldr	r3, [pc, #36]	; (801dde8 <mcpwm_foc_get_phase+0x28>)
 801ddc4:	ed9f 7a09 	vldr	s14, [pc, #36]	; 801ddec <mcpwm_foc_get_phase+0x2c>
 801ddc8:	edd3 7a04 	vldr	s15, [r3, #16]
float mcpwm_foc_get_phase(void) {
 801ddcc:	b083      	sub	sp, #12
	float angle = m_motor_state.phase * (180.0 / M_PI);
 801ddce:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ddd2:	a802      	add	r0, sp, #8
 801ddd4:	ed60 7a01 	vstmdb	r0!, {s15}
	utils_norm_angle(&angle);
 801ddd8:	f7f7 fe02 	bl	80159e0 <utils_norm_angle>
}
 801dddc:	ed9d 0a01 	vldr	s0, [sp, #4]
 801dde0:	b003      	add	sp, #12
 801dde2:	f85d fb04 	ldr.w	pc, [sp], #4
 801dde6:	bf00      	nop
 801dde8:	2000cddc 	.word	0x2000cddc
 801ddec:	42652ee0 	.word	0x42652ee0

0801ddf0 <mcpwm_foc_get_phase_observer>:
float mcpwm_foc_get_phase_observer(void) {
 801ddf0:	b500      	push	{lr}
	float angle = m_phase_now_observer * (180.0 / M_PI);
 801ddf2:	4b09      	ldr	r3, [pc, #36]	; (801de18 <mcpwm_foc_get_phase_observer+0x28>)
 801ddf4:	ed9f 7a09 	vldr	s14, [pc, #36]	; 801de1c <mcpwm_foc_get_phase_observer+0x2c>
 801ddf8:	edd3 7a00 	vldr	s15, [r3]
float mcpwm_foc_get_phase_observer(void) {
 801ddfc:	b083      	sub	sp, #12
	float angle = m_phase_now_observer * (180.0 / M_PI);
 801ddfe:	ee67 7a87 	vmul.f32	s15, s15, s14
 801de02:	a802      	add	r0, sp, #8
 801de04:	ed60 7a01 	vstmdb	r0!, {s15}
	utils_norm_angle(&angle);
 801de08:	f7f7 fdea 	bl	80159e0 <utils_norm_angle>
}
 801de0c:	ed9d 0a01 	vldr	s0, [sp, #4]
 801de10:	b003      	add	sp, #12
 801de12:	f85d fb04 	ldr.w	pc, [sp], #4
 801de16:	bf00      	nop
 801de18:	2000ce54 	.word	0x2000ce54
 801de1c:	42652ee0 	.word	0x42652ee0

0801de20 <mcpwm_foc_get_phase_encoder>:
float mcpwm_foc_get_phase_encoder(void) {
 801de20:	b500      	push	{lr}
	float angle = m_phase_now_encoder * (180.0 / M_PI);
 801de22:	4b09      	ldr	r3, [pc, #36]	; (801de48 <mcpwm_foc_get_phase_encoder+0x28>)
 801de24:	ed9f 7a09 	vldr	s14, [pc, #36]	; 801de4c <mcpwm_foc_get_phase_encoder+0x2c>
 801de28:	edd3 7a00 	vldr	s15, [r3]
float mcpwm_foc_get_phase_encoder(void) {
 801de2c:	b083      	sub	sp, #12
	float angle = m_phase_now_encoder * (180.0 / M_PI);
 801de2e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801de32:	a802      	add	r0, sp, #8
 801de34:	ed60 7a01 	vstmdb	r0!, {s15}
	utils_norm_angle(&angle);
 801de38:	f7f7 fdd2 	bl	80159e0 <utils_norm_angle>
}
 801de3c:	ed9d 0a01 	vldr	s0, [sp, #4]
 801de40:	b003      	add	sp, #12
 801de42:	f85d fb04 	ldr.w	pc, [sp], #4
 801de46:	bf00      	nop
 801de48:	2000ce4c 	.word	0x2000ce4c
 801de4c:	42652ee0 	.word	0x42652ee0

0801de50 <mcpwm_foc_get_vq>:
	return m_motor_state.vq;
 801de50:	4b01      	ldr	r3, [pc, #4]	; (801de58 <mcpwm_foc_get_vq+0x8>)
 801de52:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
}
 801de56:	4770      	bx	lr
 801de58:	2000cddc 	.word	0x2000cddc
 801de5c:	00000000 	.word	0x00000000

0801de60 <mcpwm_foc_encoder_detect>:
void mcpwm_foc_encoder_detect(float current, bool print, float *offset, float *ratio, bool *inverted) {
 801de60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801de64:	ed2d 8b0e 	vpush	{d8-d14}
 801de68:	b087      	sub	sp, #28
 801de6a:	eeb0 9a40 	vmov.f32	s18, s0
 801de6e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801de72:	4607      	mov	r7, r0
 801de74:	4689      	mov	r9, r1
	mc_interface_lock();
 801de76:	f7fd fadb 	bl	801b430 <mc_interface_lock>
	m_phase_override = true;
 801de7a:	49c5      	ldr	r1, [pc, #788]	; (801e190 <mcpwm_foc_encoder_detect+0x330>)
	m_iq_set = 0.0;
 801de7c:	ed9f 8ac5 	vldr	s16, [pc, #788]	; 801e194 <mcpwm_foc_encoder_detect+0x334>
	float offset_old = m_conf->foc_encoder_offset;
 801de80:	f8df 8348 	ldr.w	r8, [pc, #840]	; 801e1cc <mcpwm_foc_encoder_detect+0x36c>
		for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801de84:	eddf 8ac4 	vldr	s17, [pc, #784]	; 801e198 <mcpwm_foc_encoder_detect+0x338>
 801de88:	4cc4      	ldr	r4, [pc, #784]	; (801e19c <mcpwm_foc_encoder_detect+0x33c>)
	m_phase_override = true;
 801de8a:	2201      	movs	r2, #1
 801de8c:	700a      	strb	r2, [r1, #0]
	m_id_set = current;
 801de8e:	4ac4      	ldr	r2, [pc, #784]	; (801e1a0 <mcpwm_foc_encoder_detect+0x340>)
 801de90:	ed82 9a00 	vstr	s18, [r2]
	m_iq_set = 0.0;
 801de94:	4ac3      	ldr	r2, [pc, #780]	; (801e1a4 <mcpwm_foc_encoder_detect+0x344>)
 801de96:	ed82 8a00 	vstr	s16, [r2]
	m_control_mode = CONTROL_MODE_CURRENT;
 801de9a:	4ac3      	ldr	r2, [pc, #780]	; (801e1a8 <mcpwm_foc_encoder_detect+0x348>)
 801de9c:	2302      	movs	r3, #2
 801de9e:	7013      	strb	r3, [r2, #0]
	m_state = MC_STATE_RUNNING;
 801dea0:	4ac2      	ldr	r2, [pc, #776]	; (801e1ac <mcpwm_foc_encoder_detect+0x34c>)
 801dea2:	7013      	strb	r3, [r2, #0]
	systime_t tout = timeout_get_timeout_msec();
 801dea4:	f7fc f974 	bl	801a190 <timeout_get_timeout_msec>
 801dea8:	9001      	str	r0, [sp, #4]
	float tout_c = timeout_get_brake_current();
 801deaa:	f7fc f979 	bl	801a1a0 <timeout_get_brake_current>
 801deae:	eef0 9a40 	vmov.f32	s19, s0
	timeout_reset();
 801deb2:	f7fc f955 	bl	801a160 <timeout_reset>
	timeout_configure(600000, 0.0);
 801deb6:	eeb0 0a48 	vmov.f32	s0, s16
 801deba:	48bd      	ldr	r0, [pc, #756]	; (801e1b0 <mcpwm_foc_encoder_detect+0x350>)
 801debc:	f7fc f940 	bl	801a140 <timeout_configure>
	float offset_old = m_conf->foc_encoder_offset;
 801dec0:	f8d8 3000 	ldr.w	r3, [r8]
 801dec4:	ed93 aa2d 	vldr	s20, [r3, #180]	; 0xb4
	float inverted_old = m_conf->foc_encoder_inverted;
 801dec8:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
	float ratio_old = m_conf->foc_encoder_ratio;
 801decc:	edd3 aa2f 	vldr	s21, [r3, #188]	; 0xbc
	m_conf->foc_encoder_offset = 0.0;
 801ded0:	ed83 8a2d 	vstr	s16, [r3, #180]	; 0xb4
	float inverted_old = m_conf->foc_encoder_inverted;
 801ded4:	ee09 2a10 	vmov	s18, r2
	m_conf->foc_encoder_inverted = false;
 801ded8:	2200      	movs	r2, #0
 801deda:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	float inverted_old = m_conf->foc_encoder_inverted;
 801dede:	eeb8 9a49 	vcvt.f32.u32	s18, s18
	m_conf->foc_encoder_ratio = 1.0;
 801dee2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801dee6:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	while(!encoder_index_found()) {
 801deea:	251f      	movs	r5, #31
 801deec:	f7fc ffc8 	bl	801ae80 <encoder_index_found>
 801def0:	b970      	cbnz	r0, 801df10 <mcpwm_foc_encoder_detect+0xb0>
		for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801def2:	ed9f 8aa8 	vldr	s16, [pc, #672]	; 801e194 <mcpwm_foc_encoder_detect+0x334>
 801def6:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
			chThdSleepMilliseconds(1);
 801defa:	200a      	movs	r0, #10
			m_phase_now_override = i;
 801defc:	ed84 8a00 	vstr	s16, [r4]
			chThdSleepMilliseconds(1);
 801df00:	f7ef fd6e 	bl	800d9e0 <chThdSleep>
		for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801df04:	3e01      	subs	r6, #1
 801df06:	ee38 8a28 	vadd.f32	s16, s16, s17
 801df0a:	d1f6      	bne.n	801defa <mcpwm_foc_encoder_detect+0x9a>
		if (cnt > 30) {
 801df0c:	3d01      	subs	r5, #1
 801df0e:	d1ed      	bne.n	801deec <mcpwm_foc_encoder_detect+0x8c>
	if (print) {
 801df10:	b117      	cbz	r7, 801df18 <mcpwm_foc_encoder_detect+0xb8>
		commands_printf("Index found");
 801df12:	48a8      	ldr	r0, [pc, #672]	; (801e1b4 <mcpwm_foc_encoder_detect+0x354>)
 801df14:	f7fa fb94 	bl	8018640 <commands_printf>
	while(!encoder_index_found()) {
 801df18:	ed9f 8a9e 	vldr	s16, [pc, #632]	; 801e194 <mcpwm_foc_encoder_detect+0x334>
	for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801df1c:	eddf 8a9e 	vldr	s17, [pc, #632]	; 801e198 <mcpwm_foc_encoder_detect+0x338>
	while(!encoder_index_found()) {
 801df20:	f44f 75fa 	mov.w	r5, #500	; 0x1f4
		chThdSleepMilliseconds(1);
 801df24:	200a      	movs	r0, #10
		m_phase_now_override = i;
 801df26:	ed84 8a00 	vstr	s16, [r4]
		chThdSleepMilliseconds(1);
 801df2a:	f7ef fd59 	bl	800d9e0 <chThdSleep>
	for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801df2e:	3d01      	subs	r5, #1
 801df30:	ee38 8a28 	vadd.f32	s16, s16, s17
 801df34:	d1f6      	bne.n	801df24 <mcpwm_foc_encoder_detect+0xc4>
	if (print) {
 801df36:	b117      	cbz	r7, 801df3e <mcpwm_foc_encoder_detect+0xde>
		commands_printf("Rotated for sync");
 801df38:	489f      	ldr	r0, [pc, #636]	; (801e1b8 <mcpwm_foc_encoder_detect+0x358>)
 801df3a:	f7fa fb81 	bl	8018640 <commands_printf>
	float first = m_phase_now_encoder;
 801df3e:	4d9f      	ldr	r5, [pc, #636]	; (801e1bc <mcpwm_foc_encoder_detect+0x35c>)
	float c_sum = 0.0;
 801df40:	eddf ba94 	vldr	s23, [pc, #592]	; 801e194 <mcpwm_foc_encoder_detect+0x334>
		for (float i = phase_ovr_tmp; i < phase_ovr_tmp + (2.0 / 3.0) * M_PI;
 801df44:	eddf ca9e 	vldr	s25, [pc, #632]	; 801e1c0 <mcpwm_foc_encoder_detect+0x360>
				i += (2.0 * M_PI) / 500.0) {
 801df48:	ed9f ba93 	vldr	s22, [pc, #588]	; 801e198 <mcpwm_foc_encoder_detect+0x338>
		utils_norm_angle_rad((float*)&m_phase_now_override);
 801df4c:	f8df a24c 	ldr.w	sl, [pc, #588]	; 801e19c <mcpwm_foc_encoder_detect+0x33c>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801df50:	ed9f eaa1 	vldr	s28, [pc, #644]	; 801e1d8 <mcpwm_foc_encoder_detect+0x378>
 801df54:	eddf da9f 	vldr	s27, [pc, #636]	; 801e1d4 <mcpwm_foc_encoder_detect+0x374>
 801df58:	f8df b274 	ldr.w	fp, [pc, #628]	; 801e1d0 <mcpwm_foc_encoder_detect+0x370>
	chThdSleepMilliseconds(1000);
 801df5c:	f242 7010 	movw	r0, #10000	; 0x2710
 801df60:	f7ef fd3e 	bl	800d9e0 <chThdSleep>
	float first = m_phase_now_encoder;
 801df64:	ed95 da00 	vldr	s26, [r5]
	float s_sum = 0.0;
 801df68:	eeb0 ca6b 	vmov.f32	s24, s23
	for (int i = 0; i < it_rat; i++) {
 801df6c:	2600      	movs	r6, #0
		float phase_old = m_phase_now_encoder;
 801df6e:	edd5 ea00 	vldr	s29, [r5]
		float phase_ovr_tmp = m_phase_now_override;
 801df72:	ed94 8a00 	vldr	s16, [r4]
		for (float i = phase_ovr_tmp; i < phase_ovr_tmp + (2.0 / 3.0) * M_PI;
 801df76:	ee78 8a2c 	vadd.f32	s17, s16, s25
 801df7a:	eef4 8ac8 	vcmpe.f32	s17, s16
 801df7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801df82:	dd0b      	ble.n	801df9c <mcpwm_foc_encoder_detect+0x13c>
			chThdSleepMilliseconds(1);
 801df84:	200a      	movs	r0, #10
			m_phase_now_override = i;
 801df86:	ed84 8a00 	vstr	s16, [r4]
			chThdSleepMilliseconds(1);
 801df8a:	f7ef fd29 	bl	800d9e0 <chThdSleep>
				i += (2.0 * M_PI) / 500.0) {
 801df8e:	ee38 8a0b 	vadd.f32	s16, s16, s22
		for (float i = phase_ovr_tmp; i < phase_ovr_tmp + (2.0 / 3.0) * M_PI;
 801df92:	eef4 8ac8 	vcmpe.f32	s17, s16
 801df96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801df9a:	dcf3      	bgt.n	801df84 <mcpwm_foc_encoder_detect+0x124>
		utils_norm_angle_rad((float*)&m_phase_now_override);
 801df9c:	4650      	mov	r0, sl
 801df9e:	f7f7 fd3f 	bl	8015a20 <utils_norm_angle_rad>
		chThdSleepMilliseconds(300);
 801dfa2:	f640 30b8 	movw	r0, #3000	; 0xbb8
 801dfa6:	f7ef fd1b 	bl	800d9e0 <chThdSleep>
		float diff = utils_angle_difference_rad(m_phase_now_encoder, phase_old);
 801dfaa:	eef0 0a6e 	vmov.f32	s1, s29
 801dfae:	ed95 0a00 	vldr	s0, [r5]
 801dfb2:	f7f7 fe0d 	bl	8015bd0 <utils_angle_difference_rad>
		sincosf(diff, &s, &c);
 801dfb6:	a905      	add	r1, sp, #20
 801dfb8:	a804      	add	r0, sp, #16
		float diff = utils_angle_difference_rad(m_phase_now_encoder, phase_old);
 801dfba:	eeb0 8a40 	vmov.f32	s16, s0
		sincosf(diff, &s, &c);
 801dfbe:	f007 fb97 	bl	80256f0 <sincosf>
		s_sum += s;
 801dfc2:	ed9d 7a04 	vldr	s14, [sp, #16]
		c_sum += c;
 801dfc6:	eddd 7a05 	vldr	s15, [sp, #20]
		s_sum += s;
 801dfca:	ee3c ca07 	vadd.f32	s24, s24, s14
		c_sum += c;
 801dfce:	ee7b baa7 	vadd.f32	s23, s23, s15
		if (print) {
 801dfd2:	2f00      	cmp	r7, #0
 801dfd4:	f040 81c5 	bne.w	801e362 <mcpwm_foc_encoder_detect+0x502>
		if (i > 3 && fabsf(utils_angle_difference_rad(m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {
 801dfd8:	2e03      	cmp	r6, #3
 801dfda:	dd12      	ble.n	801e002 <mcpwm_foc_encoder_detect+0x1a2>
 801dfdc:	ed95 0a00 	vldr	s0, [r5]
 801dfe0:	eef0 0a4d 	vmov.f32	s1, s26
 801dfe4:	f7f7 fdf4 	bl	8015bd0 <utils_angle_difference_rad>
 801dfe8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 801dfec:	ee28 8a27 	vmul.f32	s16, s16, s15
 801dff0:	eeb0 0ac0 	vabs.f32	s0, s0
 801dff4:	eeb0 8ac8 	vabs.f32	s16, s16
 801dff8:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801dffc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e000:	d402      	bmi.n	801e008 <mcpwm_foc_encoder_detect+0x1a8>
	for (int i = 0; i < it_rat; i++) {
 801e002:	3601      	adds	r6, #1
 801e004:	2e14      	cmp	r6, #20
 801e006:	d1b2      	bne.n	801df6e <mcpwm_foc_encoder_detect+0x10e>
	first = m_phase_now_encoder;
 801e008:	ed95 da00 	vldr	s26, [r5]
		for (float i = phase_ovr_tmp; i > phase_ovr_tmp - (2.0 / 3.0) * M_PI;
 801e00c:	eddf ca6c 	vldr	s25, [pc, #432]	; 801e1c0 <mcpwm_foc_encoder_detect+0x360>
				i -= (2.0 * M_PI) / 500.0) {
 801e010:	ed9f ba61 	vldr	s22, [pc, #388]	; 801e198 <mcpwm_foc_encoder_detect+0x338>
		utils_norm_angle_rad((float*)&m_phase_now_override);
 801e014:	f8df a184 	ldr.w	sl, [pc, #388]	; 801e19c <mcpwm_foc_encoder_detect+0x33c>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e018:	ed9f ea6f 	vldr	s28, [pc, #444]	; 801e1d8 <mcpwm_foc_encoder_detect+0x378>
 801e01c:	eddf da6d 	vldr	s27, [pc, #436]	; 801e1d4 <mcpwm_foc_encoder_detect+0x374>
 801e020:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 801e1d0 <mcpwm_foc_encoder_detect+0x370>
	for (int i = 0; i < it_rat; i++) {
 801e024:	2600      	movs	r6, #0
		float phase_old = m_phase_now_encoder;
 801e026:	edd5 ea00 	vldr	s29, [r5]
		float phase_ovr_tmp = m_phase_now_override;
 801e02a:	ed94 8a00 	vldr	s16, [r4]
		for (float i = phase_ovr_tmp; i > phase_ovr_tmp - (2.0 / 3.0) * M_PI;
 801e02e:	ee78 8a6c 	vsub.f32	s17, s16, s25
 801e032:	eef4 8ac8 	vcmpe.f32	s17, s16
 801e036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e03a:	d50b      	bpl.n	801e054 <mcpwm_foc_encoder_detect+0x1f4>
			chThdSleepMilliseconds(1);
 801e03c:	200a      	movs	r0, #10
			m_phase_now_override = i;
 801e03e:	ed84 8a00 	vstr	s16, [r4]
			chThdSleepMilliseconds(1);
 801e042:	f7ef fccd 	bl	800d9e0 <chThdSleep>
				i -= (2.0 * M_PI) / 500.0) {
 801e046:	ee38 8a4b 	vsub.f32	s16, s16, s22
		for (float i = phase_ovr_tmp; i > phase_ovr_tmp - (2.0 / 3.0) * M_PI;
 801e04a:	eef4 8ac8 	vcmpe.f32	s17, s16
 801e04e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e052:	d4f3      	bmi.n	801e03c <mcpwm_foc_encoder_detect+0x1dc>
		utils_norm_angle_rad((float*)&m_phase_now_override);
 801e054:	4650      	mov	r0, sl
 801e056:	f7f7 fce3 	bl	8015a20 <utils_norm_angle_rad>
		chThdSleepMilliseconds(300);
 801e05a:	f640 30b8 	movw	r0, #3000	; 0xbb8
 801e05e:	f7ef fcbf 	bl	800d9e0 <chThdSleep>
		float diff = utils_angle_difference_rad(phase_old, m_phase_now_encoder);
 801e062:	edd5 0a00 	vldr	s1, [r5]
 801e066:	eeb0 0a6e 	vmov.f32	s0, s29
 801e06a:	f7f7 fdb1 	bl	8015bd0 <utils_angle_difference_rad>
		sincosf(diff, &s, &c);
 801e06e:	a905      	add	r1, sp, #20
 801e070:	a804      	add	r0, sp, #16
		float diff = utils_angle_difference_rad(phase_old, m_phase_now_encoder);
 801e072:	eeb0 8a40 	vmov.f32	s16, s0
		sincosf(diff, &s, &c);
 801e076:	f007 fb3b 	bl	80256f0 <sincosf>
		s_sum += s;
 801e07a:	ed9d 7a04 	vldr	s14, [sp, #16]
		c_sum += c;
 801e07e:	eddd 7a05 	vldr	s15, [sp, #20]
		s_sum += s;
 801e082:	ee3c ca07 	vadd.f32	s24, s24, s14
		c_sum += c;
 801e086:	ee7b baa7 	vadd.f32	s23, s23, s15
		if (print) {
 801e08a:	2f00      	cmp	r7, #0
 801e08c:	f040 8177 	bne.w	801e37e <mcpwm_foc_encoder_detect+0x51e>
		if (i > 3 && fabsf(utils_angle_difference_rad(m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {
 801e090:	2e03      	cmp	r6, #3
 801e092:	dd12      	ble.n	801e0ba <mcpwm_foc_encoder_detect+0x25a>
 801e094:	ed95 0a00 	vldr	s0, [r5]
 801e098:	eef0 0a4d 	vmov.f32	s1, s26
 801e09c:	f7f7 fd98 	bl	8015bd0 <utils_angle_difference_rad>
 801e0a0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 801e0a4:	ee28 8a27 	vmul.f32	s16, s16, s15
 801e0a8:	eeb0 0ac0 	vabs.f32	s0, s0
 801e0ac:	eeb0 8ac8 	vabs.f32	s16, s16
 801e0b0:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801e0b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e0b8:	d402      	bmi.n	801e0c0 <mcpwm_foc_encoder_detect+0x260>
	for (int i = 0; i < it_rat; i++) {
 801e0ba:	3601      	adds	r6, #1
 801e0bc:	2e14      	cmp	r6, #20
 801e0be:	d1b2      	bne.n	801e026 <mcpwm_foc_encoder_detect+0x1c6>
	float diff = atan2f(s_sum, c_sum) * 180.0 / M_PI;
 801e0c0:	eef0 0a6b 	vmov.f32	s1, s23
 801e0c4:	eeb0 0a4c 	vmov.f32	s0, s24
 801e0c8:	f007 faaa 	bl	8025620 <atan2f>
 801e0cc:	eddf 7a42 	vldr	s15, [pc, #264]	; 801e1d8 <mcpwm_foc_encoder_detect+0x378>
 801e0d0:	eddf 6a40 	vldr	s13, [pc, #256]	; 801e1d4 <mcpwm_foc_encoder_detect+0x374>
	*inverted = diff < 0.0;
 801e0d4:	9b03      	ldr	r3, [sp, #12]
	*ratio = roundf(((2.0 / 3.0) * 180.0) /
 801e0d6:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 801e1c4 <mcpwm_foc_encoder_detect+0x364>
	float diff = atan2f(s_sum, c_sum) * 180.0 / M_PI;
 801e0da:	ee20 0a27 	vmul.f32	s0, s0, s15
 801e0de:	eec0 7a26 	vdiv.f32	s15, s0, s13
	*inverted = diff < 0.0;
 801e0e2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801e0e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e0ea:	bf4c      	ite	mi
 801e0ec:	2601      	movmi	r6, #1
 801e0ee:	2600      	movpl	r6, #0
			fabsf(diff));
 801e0f0:	eef0 7ae7 	vabs.f32	s15, s15
	*inverted = diff < 0.0;
 801e0f4:	701e      	strb	r6, [r3, #0]
	*ratio = roundf(((2.0 / 3.0) * 180.0) /
 801e0f6:	ee87 0a27 	vdiv.f32	s0, s14, s15
 801e0fa:	f007 f8e9 	bl	80252d0 <roundf>
	m_conf->foc_encoder_inverted = *inverted;
 801e0fe:	f8d8 3000 	ldr.w	r3, [r8]
	*ratio = roundf(((2.0 / 3.0) * 180.0) /
 801e102:	9a02      	ldr	r2, [sp, #8]
 801e104:	ed82 0a00 	vstr	s0, [r2]
	m_conf->foc_encoder_inverted = *inverted;
 801e108:	f883 60b8 	strb.w	r6, [r3, #184]	; 0xb8
	m_conf->foc_encoder_ratio = *ratio;
 801e10c:	ed83 0a2f 	vstr	s0, [r3, #188]	; 0xbc
	if (print) {
 801e110:	2f00      	cmp	r7, #0
 801e112:	f040 8142 	bne.w	801e39a <mcpwm_foc_encoder_detect+0x53a>
	for (float i = m_phase_now_override;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801e116:	ed94 8a00 	vldr	s16, [r4]
 801e11a:	eddf 7a2b 	vldr	s15, [pc, #172]	; 801e1c8 <mcpwm_foc_encoder_detect+0x368>
 801e11e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801e122:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e126:	d514      	bpl.n	801e152 <mcpwm_foc_encoder_detect+0x2f2>
 801e128:	ed9f ba1b 	vldr	s22, [pc, #108]	; 801e198 <mcpwm_foc_encoder_detect+0x338>
 801e12c:	eddf 8a26 	vldr	s17, [pc, #152]	; 801e1c8 <mcpwm_foc_encoder_detect+0x368>
		m_phase_now_override = i;
 801e130:	ed84 8a00 	vstr	s16, [r4]
		chThdSleepMilliseconds(2);
 801e134:	2014      	movs	r0, #20
 801e136:	f7ef fc53 	bl	800d9e0 <chThdSleep>
	for (float i = m_phase_now_override;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801e13a:	ee38 8a0b 	vadd.f32	s16, s16, s22
 801e13e:	eeb4 8ae8 	vcmpe.f32	s16, s17
 801e142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e146:	d4f3      	bmi.n	801e130 <mcpwm_foc_encoder_detect+0x2d0>
	if (print) {
 801e148:	2f00      	cmp	r7, #0
 801e14a:	f040 8133 	bne.w	801e3b4 <mcpwm_foc_encoder_detect+0x554>
 801e14e:	f8d8 3000 	ldr.w	r3, [r8]
	const int it_ofs = m_conf->foc_encoder_ratio * 3.0;
 801e152:	edd3 7a2f 	vldr	s15, [r3, #188]	; 0xbc
 801e156:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
 801e15a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e15e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801e162:	ee17 aa90 	vmov	sl, s15
	for (int i = 0;i < it_ofs;i++) {
 801e166:	f1ba 0f00 	cmp.w	sl, #0
 801e16a:	f340 8156 	ble.w	801e41a <mcpwm_foc_encoder_detect+0x5ba>
	c_sum = 0.0;
 801e16e:	ed9f 8a09 	vldr	s16, [pc, #36]	; 801e194 <mcpwm_foc_encoder_detect+0x334>
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e172:	ed9f ca18 	vldr	s24, [pc, #96]	; 801e1d4 <mcpwm_foc_encoder_detect+0x374>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e176:	eddf ca18 	vldr	s25, [pc, #96]	; 801e1d8 <mcpwm_foc_encoder_detect+0x378>
 801e17a:	f8df b054 	ldr.w	fp, [pc, #84]	; 801e1d0 <mcpwm_foc_encoder_detect+0x370>
 801e17e:	ee07 aa90 	vmov	s15, sl
	s_sum = 0.0;
 801e182:	eef0 8a48 	vmov.f32	s17, s16
 801e186:	eeb8 bae7 	vcvt.f32.s32	s22, s15
	for (int i = 0;i < it_ofs;i++) {
 801e18a:	2600      	movs	r6, #0
 801e18c:	e02a      	b.n	801e1e4 <mcpwm_foc_encoder_detect+0x384>
 801e18e:	bf00      	nop
 801e190:	2000ce61 	.word	0x2000ce61
 801e194:	00000000 	.word	0x00000000
 801e198:	3c4de32e 	.word	0x3c4de32e
 801e19c:	2000ce5c 	.word	0x2000ce5c
 801e1a0:	2000cdd0 	.word	0x2000cdd0
 801e1a4:	2000cdd8 	.word	0x2000cdd8
 801e1a8:	2000cdac 	.word	0x2000cdac
 801e1ac:	2000ce8c 	.word	0x2000ce8c
 801e1b0:	000927c0 	.word	0x000927c0
 801e1b4:	0802f3d0 	.word	0x0802f3d0
 801e1b8:	0802f3dc 	.word	0x0802f3dc
 801e1bc:	2000ce4c 	.word	0x2000ce4c
 801e1c0:	40060a92 	.word	0x40060a92
 801e1c4:	42f00000 	.word	0x42f00000
 801e1c8:	40c90fdb 	.word	0x40c90fdb
 801e1cc:	2000cda8 	.word	0x2000cda8
 801e1d0:	0802e5d4 	.word	0x0802e5d4
 801e1d4:	40490fdb 	.word	0x40490fdb
 801e1d8:	43340000 	.word	0x43340000
 801e1dc:	4556      	cmp	r6, sl
 801e1de:	f8d8 3000 	ldr.w	r3, [r8]
 801e1e2:	d03b      	beq.n	801e25c <mcpwm_foc_encoder_detect+0x3fc>
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e1e4:	ee07 6a90 	vmov	s15, r6
 801e1e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e1ec:	ed93 7a2f 	vldr	s14, [r3, #188]	; 0xbc
 801e1f0:	ee77 7aa7 	vadd.f32	s15, s15, s15
		chThdSleepMilliseconds(500);
 801e1f4:	f241 3088 	movw	r0, #5000	; 0x1388
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e1f8:	ee67 7a8c 	vmul.f32	s15, s15, s24
	for (int i = 0;i < it_ofs;i++) {
 801e1fc:	3601      	adds	r6, #1
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e1fe:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e202:	ee87 7a8b 	vdiv.f32	s14, s15, s22
 801e206:	ed84 7a00 	vstr	s14, [r4]
		chThdSleepMilliseconds(500);
 801e20a:	f7ef fbe9 	bl	800d9e0 <chThdSleep>
		float diff = utils_angle_difference_rad(m_phase_now_encoder, m_phase_now_override);
 801e20e:	ed95 0a00 	vldr	s0, [r5]
 801e212:	edd4 0a00 	vldr	s1, [r4]
 801e216:	f7f7 fcdb 	bl	8015bd0 <utils_angle_difference_rad>
		sincosf(diff, &s, &c);
 801e21a:	a905      	add	r1, sp, #20
 801e21c:	a804      	add	r0, sp, #16
		float diff = utils_angle_difference_rad(m_phase_now_encoder, m_phase_now_override);
 801e21e:	eef0 ba40 	vmov.f32	s23, s0
		sincosf(diff, &s, &c);
 801e222:	f007 fa65 	bl	80256f0 <sincosf>
		s_sum += s;
 801e226:	ed9d 7a04 	vldr	s14, [sp, #16]
		c_sum += c;
 801e22a:	eddd 7a05 	vldr	s15, [sp, #20]
		s_sum += s;
 801e22e:	ee78 8a87 	vadd.f32	s17, s17, s14
		c_sum += c;
 801e232:	ee38 8a27 	vadd.f32	s16, s16, s15
		if (print) {
 801e236:	2f00      	cmp	r7, #0
 801e238:	d0d0      	beq.n	801e1dc <mcpwm_foc_encoder_detect+0x37c>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e23a:	ee6b baac 	vmul.f32	s23, s23, s25
 801e23e:	eecb 7a8c 	vdiv.f32	s15, s23, s24
 801e242:	ee17 0a90 	vmov	r0, s15
 801e246:	f7ee f8df 	bl	800c408 <__aeabi_f2d>
 801e24a:	4602      	mov	r2, r0
 801e24c:	460b      	mov	r3, r1
 801e24e:	4658      	mov	r0, fp
 801e250:	f7fa f9f6 	bl	8018640 <commands_printf>
	for (int i = 0;i < it_ofs;i++) {
 801e254:	4556      	cmp	r6, sl
 801e256:	f8d8 3000 	ldr.w	r3, [r8]
 801e25a:	d1c3      	bne.n	801e1e4 <mcpwm_foc_encoder_detect+0x384>
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e25c:	ed1f ca23 	vldr	s24, [pc, #-140]	; 801e1d4 <mcpwm_foc_encoder_detect+0x374>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e260:	ed5f ca23 	vldr	s25, [pc, #-140]	; 801e1d8 <mcpwm_foc_encoder_detect+0x378>
 801e264:	f8df a1f4 	ldr.w	sl, [pc, #500]	; 801e45c <mcpwm_foc_encoder_detect+0x5fc>
 801e268:	e003      	b.n	801e272 <mcpwm_foc_encoder_detect+0x412>
	for (int i = it_ofs;i > 0;i--) {
 801e26a:	3e01      	subs	r6, #1
 801e26c:	d03a      	beq.n	801e2e4 <mcpwm_foc_encoder_detect+0x484>
 801e26e:	f8d8 3000 	ldr.w	r3, [r8]
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e272:	ed93 7a2f 	vldr	s14, [r3, #188]	; 0xbc
 801e276:	ee07 6a90 	vmov	s15, r6
 801e27a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		chThdSleepMilliseconds(500);
 801e27e:	f241 3088 	movw	r0, #5000	; 0x1388
		m_phase_now_override = ((float)i * 2.0 * M_PI * m_conf->foc_encoder_ratio) / ((float)it_ofs);
 801e282:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801e286:	ee67 7a8c 	vmul.f32	s15, s15, s24
 801e28a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e28e:	ee87 7a8b 	vdiv.f32	s14, s15, s22
 801e292:	ed84 7a00 	vstr	s14, [r4]
		chThdSleepMilliseconds(500);
 801e296:	f7ef fba3 	bl	800d9e0 <chThdSleep>
		float diff = utils_angle_difference_rad(m_phase_now_encoder, m_phase_now_override);
 801e29a:	ed95 0a00 	vldr	s0, [r5]
 801e29e:	edd4 0a00 	vldr	s1, [r4]
 801e2a2:	f7f7 fc95 	bl	8015bd0 <utils_angle_difference_rad>
		sincosf(diff, &s, &c);
 801e2a6:	a905      	add	r1, sp, #20
 801e2a8:	a804      	add	r0, sp, #16
		float diff = utils_angle_difference_rad(m_phase_now_encoder, m_phase_now_override);
 801e2aa:	eef0 ba40 	vmov.f32	s23, s0
		sincosf(diff, &s, &c);
 801e2ae:	f007 fa1f 	bl	80256f0 <sincosf>
		s_sum += s;
 801e2b2:	ed9d 7a04 	vldr	s14, [sp, #16]
		c_sum += c;
 801e2b6:	eddd 7a05 	vldr	s15, [sp, #20]
		s_sum += s;
 801e2ba:	ee78 8a87 	vadd.f32	s17, s17, s14
		c_sum += c;
 801e2be:	ee38 8a27 	vadd.f32	s16, s16, s15
		if (print) {
 801e2c2:	2f00      	cmp	r7, #0
 801e2c4:	d0d1      	beq.n	801e26a <mcpwm_foc_encoder_detect+0x40a>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e2c6:	ee6b baac 	vmul.f32	s23, s23, s25
 801e2ca:	eecb 7a8c 	vdiv.f32	s15, s23, s24
 801e2ce:	ee17 0a90 	vmov	r0, s15
 801e2d2:	f7ee f899 	bl	800c408 <__aeabi_f2d>
 801e2d6:	4602      	mov	r2, r0
 801e2d8:	460b      	mov	r3, r1
 801e2da:	4650      	mov	r0, sl
 801e2dc:	f7fa f9b0 	bl	8018640 <commands_printf>
	for (int i = it_ofs;i > 0;i--) {
 801e2e0:	3e01      	subs	r6, #1
 801e2e2:	d1c4      	bne.n	801e26e <mcpwm_foc_encoder_detect+0x40e>
	*offset = atan2f(s_sum, c_sum) * 180.0 / M_PI;
 801e2e4:	eef0 0a48 	vmov.f32	s1, s16
 801e2e8:	eeb0 0a68 	vmov.f32	s0, s17
 801e2ec:	f007 f998 	bl	8025620 <atan2f>
 801e2f0:	eddf 7a4c 	vldr	s15, [pc, #304]	; 801e424 <mcpwm_foc_encoder_detect+0x5c4>
 801e2f4:	eddf 6a4c 	vldr	s13, [pc, #304]	; 801e428 <mcpwm_foc_encoder_detect+0x5c8>
 801e2f8:	ee60 7a27 	vmul.f32	s15, s0, s15
 801e2fc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e300:	ed89 7a00 	vstr	s14, [r9]
	if (print) {
 801e304:	2f00      	cmp	r7, #0
 801e306:	d178      	bne.n	801e3fa <mcpwm_foc_encoder_detect+0x59a>
	utils_norm_angle(offset);
 801e308:	4648      	mov	r0, r9
 801e30a:	f7f7 fb69 	bl	80159e0 <utils_norm_angle>
	m_iq_set = 0.0;
 801e30e:	4847      	ldr	r0, [pc, #284]	; (801e42c <mcpwm_foc_encoder_detect+0x5cc>)
	m_id_set = 0.0;
 801e310:	4947      	ldr	r1, [pc, #284]	; (801e430 <mcpwm_foc_encoder_detect+0x5d0>)
 801e312:	2200      	movs	r2, #0
 801e314:	600a      	str	r2, [r1, #0]
	m_iq_set = 0.0;
 801e316:	6002      	str	r2, [r0, #0]
	m_phase_override = false;
 801e318:	4a46      	ldr	r2, [pc, #280]	; (801e434 <mcpwm_foc_encoder_detect+0x5d4>)
 801e31a:	2300      	movs	r3, #0
 801e31c:	7013      	strb	r3, [r2, #0]
	m_control_mode = CONTROL_MODE_NONE;
 801e31e:	4a46      	ldr	r2, [pc, #280]	; (801e438 <mcpwm_foc_encoder_detect+0x5d8>)
 801e320:	2107      	movs	r1, #7
 801e322:	7011      	strb	r1, [r2, #0]
	m_state = MC_STATE_OFF;
 801e324:	4a45      	ldr	r2, [pc, #276]	; (801e43c <mcpwm_foc_encoder_detect+0x5dc>)
 801e326:	7013      	strb	r3, [r2, #0]
	stop_pwm_hw();
 801e328:	f7fe fc9a 	bl	801cc60 <stop_pwm_hw>
	m_conf->foc_encoder_inverted = inverted_old;
 801e32c:	eeb5 9a40 	vcmp.f32	s18, #0.0
 801e330:	f8d8 3000 	ldr.w	r3, [r8]
	timeout_configure(tout, tout_c);
 801e334:	9801      	ldr	r0, [sp, #4]
	m_conf->foc_encoder_inverted = inverted_old;
 801e336:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e33a:	bf14      	ite	ne
 801e33c:	2201      	movne	r2, #1
 801e33e:	2200      	moveq	r2, #0
 801e340:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	timeout_configure(tout, tout_c);
 801e344:	eeb0 0a69 	vmov.f32	s0, s19
	m_conf->foc_encoder_offset = offset_old;
 801e348:	ed83 aa2d 	vstr	s20, [r3, #180]	; 0xb4
	m_conf->foc_encoder_ratio = ratio_old;
 801e34c:	edc3 aa2f 	vstr	s21, [r3, #188]	; 0xbc
	timeout_configure(tout, tout_c);
 801e350:	f7fb fef6 	bl	801a140 <timeout_configure>
}
 801e354:	b007      	add	sp, #28
 801e356:	ecbd 8b0e 	vpop	{d8-d14}
 801e35a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mc_interface_unlock();
 801e35e:	f7fd b86f 	b.w	801b440 <mc_interface_unlock>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e362:	ee68 7a0e 	vmul.f32	s15, s16, s28
 801e366:	eec7 7aad 	vdiv.f32	s15, s15, s27
 801e36a:	ee17 0a90 	vmov	r0, s15
 801e36e:	f7ee f84b 	bl	800c408 <__aeabi_f2d>
 801e372:	4602      	mov	r2, r0
 801e374:	460b      	mov	r3, r1
 801e376:	4658      	mov	r0, fp
 801e378:	f7fa f962 	bl	8018640 <commands_printf>
 801e37c:	e62c      	b.n	801dfd8 <mcpwm_foc_encoder_detect+0x178>
			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 801e37e:	ee68 7a0e 	vmul.f32	s15, s16, s28
 801e382:	eec7 7aad 	vdiv.f32	s15, s15, s27
 801e386:	ee17 0a90 	vmov	r0, s15
 801e38a:	f7ee f83d 	bl	800c408 <__aeabi_f2d>
 801e38e:	4602      	mov	r2, r0
 801e390:	460b      	mov	r3, r1
 801e392:	4658      	mov	r0, fp
 801e394:	f7fa f954 	bl	8018640 <commands_printf>
 801e398:	e67a      	b.n	801e090 <mcpwm_foc_encoder_detect+0x230>
		commands_printf("Inversion and ratio detected");
 801e39a:	4829      	ldr	r0, [pc, #164]	; (801e440 <mcpwm_foc_encoder_detect+0x5e0>)
 801e39c:	f7fa f950 	bl	8018640 <commands_printf>
	for (float i = m_phase_now_override;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
 801e3a0:	ed94 8a00 	vldr	s16, [r4]
 801e3a4:	eddf 7a27 	vldr	s15, [pc, #156]	; 801e444 <mcpwm_foc_encoder_detect+0x5e4>
 801e3a8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801e3ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e3b0:	f53f aeba 	bmi.w	801e128 <mcpwm_foc_encoder_detect+0x2c8>
		commands_printf("Rotated for sync");
 801e3b4:	4824      	ldr	r0, [pc, #144]	; (801e448 <mcpwm_foc_encoder_detect+0x5e8>)
 801e3b6:	f7fa f943 	bl	8018640 <commands_printf>
		commands_printf("Enc: %.2f", (double)encoder_read_deg());
 801e3ba:	f7fc fc81 	bl	801acc0 <encoder_read_deg>
 801e3be:	ee10 0a10 	vmov	r0, s0
 801e3c2:	f7ee f821 	bl	800c408 <__aeabi_f2d>
 801e3c6:	4602      	mov	r2, r0
 801e3c8:	460b      	mov	r3, r1
 801e3ca:	4820      	ldr	r0, [pc, #128]	; (801e44c <mcpwm_foc_encoder_detect+0x5ec>)
 801e3cc:	f7fa f938 	bl	8018640 <commands_printf>
 801e3d0:	f8d8 3000 	ldr.w	r3, [r8]
	const int it_ofs = m_conf->foc_encoder_ratio * 3.0;
 801e3d4:	edd3 7a2f 	vldr	s15, [r3, #188]	; 0xbc
 801e3d8:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
 801e3dc:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e3e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801e3e4:	ee17 aa90 	vmov	sl, s15
	for (int i = 0;i < it_ofs;i++) {
 801e3e8:	f1ba 0f00 	cmp.w	sl, #0
 801e3ec:	f73f aebf 	bgt.w	801e16e <mcpwm_foc_encoder_detect+0x30e>
	c_sum = 0.0;
 801e3f0:	ed9f 8a17 	vldr	s16, [pc, #92]	; 801e450 <mcpwm_foc_encoder_detect+0x5f0>
	s_sum = 0.0;
 801e3f4:	eef0 8a48 	vmov.f32	s17, s16
 801e3f8:	e774      	b.n	801e2e4 <mcpwm_foc_encoder_detect+0x484>
		commands_printf("Avg: %.2f", (double)*offset);
 801e3fa:	ee17 0a10 	vmov	r0, s14
 801e3fe:	f7ee f803 	bl	800c408 <__aeabi_f2d>
 801e402:	4602      	mov	r2, r0
 801e404:	460b      	mov	r3, r1
 801e406:	4813      	ldr	r0, [pc, #76]	; (801e454 <mcpwm_foc_encoder_detect+0x5f4>)
 801e408:	f7fa f91a 	bl	8018640 <commands_printf>
	utils_norm_angle(offset);
 801e40c:	4648      	mov	r0, r9
 801e40e:	f7f7 fae7 	bl	80159e0 <utils_norm_angle>
		commands_printf("Offset detected");
 801e412:	4811      	ldr	r0, [pc, #68]	; (801e458 <mcpwm_foc_encoder_detect+0x5f8>)
 801e414:	f7fa f914 	bl	8018640 <commands_printf>
 801e418:	e779      	b.n	801e30e <mcpwm_foc_encoder_detect+0x4ae>
	*offset = atan2f(s_sum, c_sum) * 180.0 / M_PI;
 801e41a:	2300      	movs	r3, #0
 801e41c:	f8c9 3000 	str.w	r3, [r9]
 801e420:	e772      	b.n	801e308 <mcpwm_foc_encoder_detect+0x4a8>
 801e422:	bf00      	nop
 801e424:	43340000 	.word	0x43340000
 801e428:	40490fdb 	.word	0x40490fdb
 801e42c:	2000cdd8 	.word	0x2000cdd8
 801e430:	2000cdd0 	.word	0x2000cdd0
 801e434:	2000ce61 	.word	0x2000ce61
 801e438:	2000cdac 	.word	0x2000cdac
 801e43c:	2000ce8c 	.word	0x2000ce8c
 801e440:	0802f3f0 	.word	0x0802f3f0
 801e444:	40c90fdb 	.word	0x40c90fdb
 801e448:	0802f3dc 	.word	0x0802f3dc
 801e44c:	0802f410 	.word	0x0802f410
 801e450:	00000000 	.word	0x00000000
 801e454:	0802f41c 	.word	0x0802f41c
 801e458:	0802f428 	.word	0x0802f428
 801e45c:	0802e5d4 	.word	0x0802e5d4

0801e460 <mcpwm_foc_measure_resistance>:
float mcpwm_foc_measure_resistance(float current, int samples) {
 801e460:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e464:	ed2d 8b04 	vpush	{d8-d9}
 801e468:	b083      	sub	sp, #12
 801e46a:	eef0 8a40 	vmov.f32	s17, s0
	m_phase_now_override = 0.0;
 801e46e:	ed9f 8a38 	vldr	s16, [pc, #224]	; 801e550 <mcpwm_foc_measure_resistance+0xf0>
	m_phase_override = true;
 801e472:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 801e568 <mcpwm_foc_measure_resistance+0x108>
	m_id_set = 0.0;
 801e476:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 801e56c <mcpwm_foc_measure_resistance+0x10c>
	m_iq_set = current;
 801e47a:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 801e570 <mcpwm_foc_measure_resistance+0x110>
	m_control_mode = CONTROL_MODE_CURRENT;
 801e47e:	4e35      	ldr	r6, [pc, #212]	; (801e554 <mcpwm_foc_measure_resistance+0xf4>)
	m_state = MC_STATE_RUNNING;
 801e480:	4f35      	ldr	r7, [pc, #212]	; (801e558 <mcpwm_foc_measure_resistance+0xf8>)
	m_samples.avg_current_tot = 0.0;
 801e482:	4c36      	ldr	r4, [pc, #216]	; (801e55c <mcpwm_foc_measure_resistance+0xfc>)
float mcpwm_foc_measure_resistance(float current, int samples) {
 801e484:	4605      	mov	r5, r0
	mc_interface_lock();
 801e486:	f7fc ffd3 	bl	801b430 <mc_interface_lock>
	m_phase_now_override = 0.0;
 801e48a:	4a35      	ldr	r2, [pc, #212]	; (801e560 <mcpwm_foc_measure_resistance+0x100>)
	m_control_mode = CONTROL_MODE_CURRENT;
 801e48c:	2302      	movs	r3, #2
	m_phase_override = true;
 801e48e:	2101      	movs	r1, #1
 801e490:	f889 1000 	strb.w	r1, [r9]
	m_phase_now_override = 0.0;
 801e494:	ed82 8a00 	vstr	s16, [r2]
	m_id_set = 0.0;
 801e498:	ed8a 8a00 	vstr	s16, [sl]
	m_iq_set = current;
 801e49c:	edc8 8a00 	vstr	s17, [r8]
	m_control_mode = CONTROL_MODE_CURRENT;
 801e4a0:	7033      	strb	r3, [r6, #0]
	m_state = MC_STATE_RUNNING;
 801e4a2:	703b      	strb	r3, [r7, #0]
	systime_t tout = timeout_get_timeout_msec();
 801e4a4:	f7fb fe74 	bl	801a190 <timeout_get_timeout_msec>
 801e4a8:	9001      	str	r0, [sp, #4]
	float tout_c = timeout_get_brake_current();
 801e4aa:	f7fb fe79 	bl	801a1a0 <timeout_get_brake_current>
 801e4ae:	eef0 8a40 	vmov.f32	s17, s0
	timeout_reset();
 801e4b2:	f7fb fe55 	bl	801a160 <timeout_reset>
	timeout_configure(60000, 0.0);
 801e4b6:	eeb0 0a48 	vmov.f32	s0, s16
 801e4ba:	f64e 2060 	movw	r0, #60000	; 0xea60
 801e4be:	f7fb fe3f 	bl	801a140 <timeout_configure>
	chThdSleepMilliseconds(500);
 801e4c2:	f241 3088 	movw	r0, #5000	; 0x1388
 801e4c6:	f7ef fa8b 	bl	800d9e0 <chThdSleep>
	m_samples.sample_num = 0;
 801e4ca:	2300      	movs	r3, #0
	m_samples.avg_current_tot = 0.0;
 801e4cc:	ed84 8a01 	vstr	s16, [r4, #4]
	while (m_samples.sample_num < samples) {
 801e4d0:	f242 7b11 	movw	fp, #10001	; 0x2711
	m_samples.avg_voltage_tot = 0.0;
 801e4d4:	ed84 8a02 	vstr	s16, [r4, #8]
	m_samples.sample_num = 0;
 801e4d8:	6023      	str	r3, [r4, #0]
	while (m_samples.sample_num < samples) {
 801e4da:	e004      	b.n	801e4e6 <mcpwm_foc_measure_resistance+0x86>
		chThdSleepMilliseconds(1);
 801e4dc:	f7ef fa80 	bl	800d9e0 <chThdSleep>
		if (cnt > 10000) {
 801e4e0:	f1bb 0b01 	subs.w	fp, fp, #1
 801e4e4:	d004      	beq.n	801e4f0 <mcpwm_foc_measure_resistance+0x90>
	while (m_samples.sample_num < samples) {
 801e4e6:	6822      	ldr	r2, [r4, #0]
 801e4e8:	42aa      	cmp	r2, r5
		chThdSleepMilliseconds(1);
 801e4ea:	f04f 000a 	mov.w	r0, #10
	while (m_samples.sample_num < samples) {
 801e4ee:	dbf5      	blt.n	801e4dc <mcpwm_foc_measure_resistance+0x7c>
	const float current_avg = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e4f0:	ed94 6a01 	vldr	s12, [r4, #4]
 801e4f4:	ed94 7a00 	vldr	s14, [r4]
	const float voltage_avg = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e4f8:	edd4 6a02 	vldr	s13, [r4, #8]
 801e4fc:	edd4 7a00 	vldr	s15, [r4]
	const float current_avg = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e500:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	const float voltage_avg = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e504:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	const float current_avg = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e508:	ee86 8a07 	vdiv.f32	s16, s12, s14
	m_id_set = 0.0;
 801e50c:	2200      	movs	r2, #0
	m_phase_override = false;
 801e50e:	2300      	movs	r3, #0
	m_control_mode = CONTROL_MODE_NONE;
 801e510:	2107      	movs	r1, #7
	m_id_set = 0.0;
 801e512:	f8ca 2000 	str.w	r2, [sl]
	m_iq_set = 0.0;
 801e516:	f8c8 2000 	str.w	r2, [r8]
	m_phase_override = false;
 801e51a:	f889 3000 	strb.w	r3, [r9]
	m_control_mode = CONTROL_MODE_NONE;
 801e51e:	7031      	strb	r1, [r6, #0]
	m_state = MC_STATE_OFF;
 801e520:	703b      	strb	r3, [r7, #0]
	const float voltage_avg = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e522:	ee86 9aa7 	vdiv.f32	s18, s13, s15
	stop_pwm_hw();
 801e526:	f7fe fb9b 	bl	801cc60 <stop_pwm_hw>
	timeout_configure(tout, tout_c);
 801e52a:	9801      	ldr	r0, [sp, #4]
 801e52c:	eeb0 0a68 	vmov.f32	s0, s17
 801e530:	f7fb fe06 	bl	801a140 <timeout_configure>
	mc_interface_unlock();
 801e534:	f7fc ff84 	bl	801b440 <mc_interface_unlock>
	return (voltage_avg / current_avg) * (2.0 / 3.0);
 801e538:	ee89 0a08 	vdiv.f32	s0, s18, s16
 801e53c:	eddf 7a09 	vldr	s15, [pc, #36]	; 801e564 <mcpwm_foc_measure_resistance+0x104>
 801e540:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 801e544:	b003      	add	sp, #12
 801e546:	ecbd 8b04 	vpop	{d8-d9}
 801e54a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e54e:	bf00      	nop
 801e550:	00000000 	.word	0x00000000
 801e554:	2000cdac 	.word	0x2000cdac
 801e558:	2000ce8c 	.word	0x2000ce8c
 801e55c:	2000ce74 	.word	0x2000ce74
 801e560:	2000ce5c 	.word	0x2000ce5c
 801e564:	3f2aaaab 	.word	0x3f2aaaab
 801e568:	2000ce61 	.word	0x2000ce61
 801e56c:	2000cdd0 	.word	0x2000cdd0
 801e570:	2000cdd8 	.word	0x2000cdd8
	...

0801e580 <mcpwm_foc_measure_inductance>:
float mcpwm_foc_measure_inductance(float duty, int samples, float *curr) {
 801e580:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	m_samples.avg_current_tot = 0.0;
 801e584:	4d39      	ldr	r5, [pc, #228]	; (801e66c <mcpwm_foc_measure_inductance+0xec>)
float mcpwm_foc_measure_inductance(float duty, int samples, float *curr) {
 801e586:	ed2d 8b02 	vpush	{d8}
	m_samples.avg_current_tot = 0.0;
 801e58a:	eddf 8a39 	vldr	s17, [pc, #228]	; 801e670 <mcpwm_foc_measure_inductance+0xf0>
	m_samples.sample_num = 0;
 801e58e:	2700      	movs	r7, #0
float mcpwm_foc_measure_inductance(float duty, int samples, float *curr) {
 801e590:	468a      	mov	sl, r1
	m_samples.avg_current_tot = 0.0;
 801e592:	edc5 8a01 	vstr	s17, [r5, #4]
float mcpwm_foc_measure_inductance(float duty, int samples, float *curr) {
 801e596:	4680      	mov	r8, r0
	m_samples.avg_voltage_tot = 0.0;
 801e598:	edc5 8a02 	vstr	s17, [r5, #8]
	m_samples.sample_num = 0;
 801e59c:	602f      	str	r7, [r5, #0]
	m_samples.measure_inductance_duty = duty;
 801e59e:	ed85 0a04 	vstr	s0, [r5, #16]
	systime_t tout = timeout_get_timeout_msec();
 801e5a2:	f7fb fdf5 	bl	801a190 <timeout_get_timeout_msec>
 801e5a6:	4683      	mov	fp, r0
	float tout_c = timeout_get_brake_current();
 801e5a8:	f7fb fdfa 	bl	801a1a0 <timeout_get_brake_current>
 801e5ac:	eeb0 8a40 	vmov.f32	s16, s0
	timeout_reset();
 801e5b0:	f7fb fdd6 	bl	801a160 <timeout_reset>
	timeout_configure(60000, 0.0);
 801e5b4:	eeb0 0a68 	vmov.f32	s0, s17
 801e5b8:	f64e 2060 	movw	r0, #60000	; 0xea60
 801e5bc:	f7fb fdc0 	bl	801a140 <timeout_configure>
	mc_interface_lock();
 801e5c0:	f7fc ff36 	bl	801b430 <mc_interface_lock>
	for (int i = 0;i < samples;i++) {
 801e5c4:	45b8      	cmp	r8, r7
 801e5c6:	dd10      	ble.n	801e5ea <mcpwm_foc_measure_inductance+0x6a>
	int to_cnt = 0;
 801e5c8:	463c      	mov	r4, r7
		m_samples.measure_inductance_now = true;
 801e5ca:	f04f 0901 	mov.w	r9, #1
			if (to_cnt > 50000) {
 801e5ce:	f24c 3650 	movw	r6, #50000	; 0xc350
		m_samples.measure_inductance_now = true;
 801e5d2:	f885 900c 	strb.w	r9, [r5, #12]
 801e5d6:	e002      	b.n	801e5de <mcpwm_foc_measure_inductance+0x5e>
		} while (m_samples.measure_inductance_now);
 801e5d8:	7b2b      	ldrb	r3, [r5, #12]
 801e5da:	2b00      	cmp	r3, #0
 801e5dc:	d042      	beq.n	801e664 <mcpwm_foc_measure_inductance+0xe4>
			to_cnt++;
 801e5de:	3401      	adds	r4, #1
			chThdSleepMicroseconds(100);
 801e5e0:	2001      	movs	r0, #1
 801e5e2:	f7ef f9fd 	bl	800d9e0 <chThdSleep>
			if (to_cnt > 50000) {
 801e5e6:	42b4      	cmp	r4, r6
 801e5e8:	ddf6      	ble.n	801e5d8 <mcpwm_foc_measure_inductance+0x58>
	timeout_configure(tout, tout_c);
 801e5ea:	eeb0 0a48 	vmov.f32	s0, s16
 801e5ee:	4658      	mov	r0, fp
 801e5f0:	f7fb fda6 	bl	801a140 <timeout_configure>
	mc_interface_unlock();
 801e5f4:	f7fc ff24 	bl	801b440 <mc_interface_unlock>
	float t = (float)TIM1->ARR * m_samples.measure_inductance_duty / (float)SYSTEM_CORE_CLOCK -
 801e5f8:	4b1e      	ldr	r3, [pc, #120]	; (801e674 <mcpwm_foc_measure_inductance+0xf4>)
	float avg_current = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e5fa:	edd5 4a01 	vldr	s9, [r5, #4]
 801e5fe:	edd5 6a00 	vldr	s13, [r5]
	float avg_voltage = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e602:	ed95 5a02 	vldr	s10, [r5, #8]
 801e606:	ed95 7a00 	vldr	s14, [r5]
	float t = (float)TIM1->ARR * m_samples.measure_inductance_duty / (float)SYSTEM_CORE_CLOCK -
 801e60a:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 801e60e:	ed95 6a04 	vldr	s12, [r5, #16]
 801e612:	ed9f 4a19 	vldr	s8, [pc, #100]	; 801e678 <mcpwm_foc_measure_inductance+0xf8>
 801e616:	eddf 5a19 	vldr	s11, [pc, #100]	; 801e67c <mcpwm_foc_measure_inductance+0xfc>
 801e61a:	eef8 7a67 	vcvt.f32.u32	s15, s15
	float avg_current = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e61e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
	float t = (float)TIM1->ARR * m_samples.measure_inductance_duty / (float)SYSTEM_CORE_CLOCK -
 801e622:	ee67 7a86 	vmul.f32	s15, s15, s12
	float avg_voltage = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e626:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	float t = (float)TIM1->ARR * m_samples.measure_inductance_duty / (float)SYSTEM_CORE_CLOCK -
 801e62a:	ee87 6a84 	vdiv.f32	s12, s15, s8
	float avg_current = m_samples.avg_current_tot / (float)m_samples.sample_num;
 801e62e:	ee84 4aa6 	vdiv.f32	s8, s9, s13
	float avg_voltage = m_samples.avg_voltage_tot / (float)m_samples.sample_num;
 801e632:	eec5 7a07 	vdiv.f32	s15, s10, s14
	float t = (float)TIM1->ARR * m_samples.measure_inductance_duty / (float)SYSTEM_CORE_CLOCK -
 801e636:	ee36 6a65 	vsub.f32	s12, s12, s11
	if (curr) {
 801e63a:	f1ba 0f00 	cmp.w	sl, #0
 801e63e:	d001      	beq.n	801e644 <mcpwm_foc_measure_inductance+0xc4>
		*curr = avg_current;
 801e640:	ed8a 4a00 	vstr	s8, [sl]
	return ((avg_voltage * t) / avg_current) * 1e6 * (2.0 /  3.0);
 801e644:	ee27 6a86 	vmul.f32	s12, s15, s12
}
 801e648:	ecbd 8b02 	vpop	{d8}
	return ((avg_voltage * t) / avg_current) * 1e6 * (2.0 /  3.0);
 801e64c:	ee86 0a04 	vdiv.f32	s0, s12, s8
 801e650:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 801e680 <mcpwm_foc_measure_inductance+0x100>
 801e654:	eddf 7a0b 	vldr	s15, [pc, #44]	; 801e684 <mcpwm_foc_measure_inductance+0x104>
 801e658:	ee20 0a07 	vmul.f32	s0, s0, s14
 801e65c:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 801e660:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (int i = 0;i < samples;i++) {
 801e664:	3701      	adds	r7, #1
 801e666:	45b8      	cmp	r8, r7
 801e668:	d1b3      	bne.n	801e5d2 <mcpwm_foc_measure_inductance+0x52>
 801e66a:	e7be      	b.n	801e5ea <mcpwm_foc_measure_inductance+0x6a>
 801e66c:	2000ce74 	.word	0x2000ce74
 801e670:	00000000 	.word	0x00000000
 801e674:	40010000 	.word	0x40010000
 801e678:	4d2037a0 	.word	0x4d2037a0
 801e67c:	34bfbd57 	.word	0x34bfbd57
 801e680:	49742400 	.word	0x49742400
 801e684:	3f2aaaab 	.word	0x3f2aaaab
	...

0801e690 <mcpwm_foc_measure_res_ind>:
bool mcpwm_foc_measure_res_ind(float *res, float *ind) {
 801e690:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const float f_sw_old = m_conf->foc_f_sw;
 801e694:	4d73      	ldr	r5, [pc, #460]	; (801e864 <mcpwm_foc_measure_res_ind+0x1d4>)
	m_conf->foc_f_sw = 10000.0;
 801e696:	4a74      	ldr	r2, [pc, #464]	; (801e868 <mcpwm_foc_measure_res_ind+0x1d8>)
	const float f_sw_old = m_conf->foc_f_sw;
 801e698:	682b      	ldr	r3, [r5, #0]
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e69a:	4c74      	ldr	r4, [pc, #464]	; (801e86c <mcpwm_foc_measure_res_ind+0x1dc>)
	const float f_sw_old = m_conf->foc_f_sw;
 801e69c:	f8d3 90ac 	ldr.w	r9, [r3, #172]	; 0xac
	m_conf->foc_current_kp = 0.01;
 801e6a0:	4e73      	ldr	r6, [pc, #460]	; (801e870 <mcpwm_foc_measure_res_ind+0x1e0>)
	const float kp_old = m_conf->foc_current_kp;
 801e6a2:	f8d3 80a4 	ldr.w	r8, [r3, #164]	; 0xa4
	const float ki_old = m_conf->foc_current_ki;
 801e6a6:	f8d3 70a8 	ldr.w	r7, [r3, #168]	; 0xa8
bool mcpwm_foc_measure_res_ind(float *res, float *ind) {
 801e6aa:	ed2d 8b04 	vpush	{d8-d9}
	m_conf->foc_f_sw = 10000.0;
 801e6ae:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	m_conf->foc_current_ki = 10.0;
 801e6b2:	4a70      	ldr	r2, [pc, #448]	; (801e874 <mcpwm_foc_measure_res_ind+0x1e4>)
	m_conf->foc_current_kp = 0.01;
 801e6b4:	f8c3 60a4 	str.w	r6, [r3, #164]	; 0xa4
	m_conf->foc_current_ki = 10.0;
 801e6b8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e6bc:	edd3 7a2b 	vldr	s15, [r3, #172]	; 0xac
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e6c0:	f8d4 c000 	ldr.w	ip, [r4]
 801e6c4:	4a6c      	ldr	r2, [pc, #432]	; (801e878 <mcpwm_foc_measure_res_ind+0x1e8>)
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e6c6:	4e6d      	ldr	r6, [pc, #436]	; (801e87c <mcpwm_foc_measure_res_ind+0x1ec>)
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e6c8:	f04c 0c02 	orr.w	ip, ip, #2
 801e6cc:	f8c4 c000 	str.w	ip, [r4]
 801e6d0:	f8d2 c000 	ldr.w	ip, [r2]
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e6d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e6d8:	f04c 0c02 	orr.w	ip, ip, #2
 801e6dc:	f8c2 c000 	str.w	ip, [r2]
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e6e0:	ee17 ca90 	vmov	ip, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e6e4:	f04f 0e02 	mov.w	lr, #2
	uint32_t top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e6e8:	fb96 f6fc 	sdiv	r6, r6, ip
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e6ec:	62e6      	str	r6, [r4, #44]	; 0x2c
 801e6ee:	f8c2 e034 	str.w	lr, [r2, #52]	; 0x34
 801e6f2:	6826      	ldr	r6, [r4, #0]
 801e6f4:	f026 0602 	bic.w	r6, r6, #2
 801e6f8:	6026      	str	r6, [r4, #0]
 801e6fa:	6814      	ldr	r4, [r2, #0]
 801e6fc:	f024 0402 	bic.w	r4, r4, #2
 801e700:	6014      	str	r4, [r2, #0]
	for (float i = 2.0;i < (m_conf->l_current_max / 2.0);i *= 1.5) {
 801e702:	edd3 7a01 	vldr	s15, [r3, #4]
 801e706:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801e70a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e70e:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
 801e712:	eef4 7ac8 	vcmpe.f32	s15, s16
 801e716:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
bool mcpwm_foc_measure_res_ind(float *res, float *ind) {
 801e71a:	b083      	sub	sp, #12
 801e71c:	4604      	mov	r4, r0
 801e71e:	460e      	mov	r6, r1
	for (float i = 2.0;i < (m_conf->l_current_max / 2.0);i *= 1.5) {
 801e720:	dd26      	ble.n	801e770 <mcpwm_foc_measure_res_ind+0xe0>
		if (i > (1.0 / res_tmp)) {
 801e722:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	for (float i = 2.0;i < (m_conf->l_current_max / 2.0);i *= 1.5) {
 801e726:	eeb7 9a08 	vmov.f32	s18, #120	; 0x3fc00000  1.5
 801e72a:	e00b      	b.n	801e744 <mcpwm_foc_measure_res_ind+0xb4>
 801e72c:	682b      	ldr	r3, [r5, #0]
 801e72e:	edd3 7a01 	vldr	s15, [r3, #4]
 801e732:	ee28 8a09 	vmul.f32	s16, s16, s18
 801e736:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e73a:	eef4 7ac8 	vcmpe.f32	s15, s16
 801e73e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e742:	dd15      	ble.n	801e770 <mcpwm_foc_measure_res_ind+0xe0>
		res_tmp = mcpwm_foc_measure_resistance(i, 20);
 801e744:	2014      	movs	r0, #20
 801e746:	eeb0 0a48 	vmov.f32	s0, s16
 801e74a:	f7ff fe89 	bl	801e460 <mcpwm_foc_measure_resistance>
		if (i > (1.0 / res_tmp)) {
 801e74e:	ee88 0a80 	vdiv.f32	s0, s17, s0
	for (float i = 2.0;i < (m_conf->l_current_max / 2.0);i *= 1.5) {
 801e752:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
		if (i > (1.0 / res_tmp)) {
 801e756:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801e75a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e75e:	d5e5      	bpl.n	801e72c <mcpwm_foc_measure_res_ind+0x9c>
	if (i_last < 0.01) {
 801e760:	eddf 7a47 	vldr	s15, [pc, #284]	; 801e880 <mcpwm_foc_measure_res_ind+0x1f0>
 801e764:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801e768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e76c:	d506      	bpl.n	801e77c <mcpwm_foc_measure_res_ind+0xec>
 801e76e:	682b      	ldr	r3, [r5, #0]
		i_last = (m_conf->l_current_max / 2.0);
 801e770:	ed93 8a01 	vldr	s16, [r3, #4]
 801e774:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 801e778:	ee28 8a27 	vmul.f32	s16, s16, s15
	*res = mcpwm_foc_measure_resistance(i_last, 200);
 801e77c:	20c8      	movs	r0, #200	; 0xc8
 801e77e:	eeb0 0a48 	vmov.f32	s0, s16
 801e782:	f7ff fe6d 	bl	801e460 <mcpwm_foc_measure_resistance>
	m_conf->foc_f_sw = 3000.0;
 801e786:	682b      	ldr	r3, [r5, #0]
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e788:	4a38      	ldr	r2, [pc, #224]	; (801e86c <mcpwm_foc_measure_res_ind+0x1dc>)
	m_conf->foc_f_sw = 3000.0;
 801e78a:	493e      	ldr	r1, [pc, #248]	; (801e884 <mcpwm_foc_measure_res_ind+0x1f4>)
	*res = mcpwm_foc_measure_resistance(i_last, 200);
 801e78c:	ed84 0a00 	vstr	s0, [r4]
	m_conf->foc_f_sw = 3000.0;
 801e790:	f8c3 10ac 	str.w	r1, [r3, #172]	; 0xac
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e794:	edd3 7a2b 	vldr	s15, [r3, #172]	; 0xac
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e798:	6811      	ldr	r1, [r2, #0]
 801e79a:	4b37      	ldr	r3, [pc, #220]	; (801e878 <mcpwm_foc_measure_res_ind+0x1e8>)
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e79c:	4837      	ldr	r0, [pc, #220]	; (801e87c <mcpwm_foc_measure_res_ind+0x1ec>)
	for (float i = 0.02;i < 0.5;i *= 1.5) {
 801e79e:	eddf 8a3a 	vldr	s17, [pc, #232]	; 801e888 <mcpwm_foc_measure_res_ind+0x1f8>
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e7a2:	f041 0102 	orr.w	r1, r1, #2
 801e7a6:	6011      	str	r1, [r2, #0]
 801e7a8:	6819      	ldr	r1, [r3, #0]
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e7aa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e7ae:	f041 0102 	orr.w	r1, r1, #2
 801e7b2:	6019      	str	r1, [r3, #0]
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e7b4:	ee17 1a90 	vmov	r1, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e7b8:	2402      	movs	r4, #2
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e7ba:	fb90 f1f1 	sdiv	r1, r0, r1
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e7be:	62d1      	str	r1, [r2, #44]	; 0x2c
 801e7c0:	635c      	str	r4, [r3, #52]	; 0x34
 801e7c2:	6811      	ldr	r1, [r2, #0]
 801e7c4:	f021 0102 	bic.w	r1, r1, #2
 801e7c8:	6011      	str	r1, [r2, #0]
 801e7ca:	681a      	ldr	r2, [r3, #0]
 801e7cc:	f022 0202 	bic.w	r2, r2, #2
 801e7d0:	601a      	str	r2, [r3, #0]
 801e7d2:	2408      	movs	r4, #8
	for (float i = 0.02;i < 0.5;i *= 1.5) {
 801e7d4:	eeb7 9a08 	vmov.f32	s18, #120	; 0x3fc00000  1.5
 801e7d8:	e001      	b.n	801e7de <mcpwm_foc_measure_res_ind+0x14e>
 801e7da:	eef0 8a67 	vmov.f32	s17, s15
		mcpwm_foc_measure_inductance(i, 20, &i_tmp);
 801e7de:	a901      	add	r1, sp, #4
 801e7e0:	2014      	movs	r0, #20
 801e7e2:	eeb0 0a68 	vmov.f32	s0, s17
 801e7e6:	f7ff fecb 	bl	801e580 <mcpwm_foc_measure_inductance>
		if (i_tmp >= i_last) {
 801e7ea:	eddd 7a01 	vldr	s15, [sp, #4]
 801e7ee:	eef4 7ac8 	vcmpe.f32	s15, s16
 801e7f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e7f6:	da03      	bge.n	801e800 <mcpwm_foc_measure_res_ind+0x170>
	for (float i = 0.02;i < 0.5;i *= 1.5) {
 801e7f8:	3c01      	subs	r4, #1
 801e7fa:	ee68 7a89 	vmul.f32	s15, s17, s18
 801e7fe:	d1ec      	bne.n	801e7da <mcpwm_foc_measure_res_ind+0x14a>
	*ind = mcpwm_foc_measure_inductance(duty_last, 200, 0);
 801e800:	eeb0 0a68 	vmov.f32	s0, s17
 801e804:	2100      	movs	r1, #0
 801e806:	20c8      	movs	r0, #200	; 0xc8
 801e808:	f7ff feba 	bl	801e580 <mcpwm_foc_measure_inductance>
	m_conf->foc_f_sw = f_sw_old;
 801e80c:	682b      	ldr	r3, [r5, #0]
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e80e:	4a17      	ldr	r2, [pc, #92]	; (801e86c <mcpwm_foc_measure_res_ind+0x1dc>)
	*ind = mcpwm_foc_measure_inductance(duty_last, 200, 0);
 801e810:	ed86 0a00 	vstr	s0, [r6]
	m_conf->foc_f_sw = f_sw_old;
 801e814:	f8c3 90ac 	str.w	r9, [r3, #172]	; 0xac
	m_conf->foc_current_kp = kp_old;
 801e818:	f8c3 80a4 	str.w	r8, [r3, #164]	; 0xa4
	m_conf->foc_current_ki = ki_old;
 801e81c:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e820:	edd3 7a2b 	vldr	s15, [r3, #172]	; 0xac
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e824:	6811      	ldr	r1, [r2, #0]
 801e826:	4b14      	ldr	r3, [pc, #80]	; (801e878 <mcpwm_foc_measure_res_ind+0x1e8>)
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e828:	4814      	ldr	r0, [pc, #80]	; (801e87c <mcpwm_foc_measure_res_ind+0x1ec>)
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e82a:	f041 0102 	orr.w	r1, r1, #2
 801e82e:	6011      	str	r1, [r2, #0]
 801e830:	6819      	ldr	r1, [r3, #0]
 801e832:	2402      	movs	r4, #2
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e834:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e838:	4321      	orrs	r1, r4
 801e83a:	6019      	str	r1, [r3, #0]
	top = SYSTEM_CORE_CLOCK / (int)m_conf->foc_f_sw;
 801e83c:	ee17 1a90 	vmov	r1, s15
 801e840:	fb90 f1f1 	sdiv	r1, r0, r1
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e844:	62d1      	str	r1, [r2, #44]	; 0x2c
 801e846:	635c      	str	r4, [r3, #52]	; 0x34
 801e848:	6811      	ldr	r1, [r2, #0]
 801e84a:	f021 0102 	bic.w	r1, r1, #2
 801e84e:	6011      	str	r1, [r2, #0]
 801e850:	681a      	ldr	r2, [r3, #0]
}
 801e852:	2001      	movs	r0, #1
	TIMER_UPDATE_SAMP_TOP(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);
 801e854:	f022 0202 	bic.w	r2, r2, #2
 801e858:	601a      	str	r2, [r3, #0]
}
 801e85a:	b003      	add	sp, #12
 801e85c:	ecbd 8b04 	vpop	{d8-d9}
 801e860:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801e864:	2000cda8 	.word	0x2000cda8
 801e868:	461c4000 	.word	0x461c4000
 801e86c:	40010000 	.word	0x40010000
 801e870:	3c23d70a 	.word	0x3c23d70a
 801e874:	41200000 	.word	0x41200000
 801e878:	40010400 	.word	0x40010400
 801e87c:	0a037a00 	.word	0x0a037a00
 801e880:	3c23d70a 	.word	0x3c23d70a
 801e884:	453b8000 	.word	0x453b8000
 801e888:	3ca3d70a 	.word	0x3ca3d70a
 801e88c:	00000000 	.word	0x00000000

0801e890 <mcpwm_foc_hall_detect>:
bool mcpwm_foc_hall_detect(float current, uint8_t *hall_table) {
 801e890:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e894:	ed2d 8b04 	vpush	{d8-d9}
 801e898:	b09d      	sub	sp, #116	; 0x74
 801e89a:	eeb0 8a40 	vmov.f32	s16, s0
 801e89e:	4606      	mov	r6, r0
	mc_interface_lock();
 801e8a0:	f7fc fdc6 	bl	801b430 <mc_interface_lock>
	m_phase_override = true;
 801e8a4:	4983      	ldr	r1, [pc, #524]	; (801eab4 <mcpwm_foc_hall_detect+0x224>)
	m_iq_set = 0.0;
 801e8a6:	eddf 9a84 	vldr	s19, [pc, #528]	; 801eab8 <mcpwm_foc_hall_detect+0x228>
	m_id_set = current;
 801e8aa:	f8df b22c 	ldr.w	fp, [pc, #556]	; 801ead8 <mcpwm_foc_hall_detect+0x248>
	m_iq_set = 0.0;
 801e8ae:	f8df a22c 	ldr.w	sl, [pc, #556]	; 801eadc <mcpwm_foc_hall_detect+0x24c>
	m_state = MC_STATE_RUNNING;
 801e8b2:	4f82      	ldr	r7, [pc, #520]	; (801eabc <mcpwm_foc_hall_detect+0x22c>)
	m_phase_now_override = 0;
 801e8b4:	4c82      	ldr	r4, [pc, #520]	; (801eac0 <mcpwm_foc_hall_detect+0x230>)
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e8b6:	ed9f 9a83 	vldr	s18, [pc, #524]	; 801eac4 <mcpwm_foc_hall_detect+0x234>
 801e8ba:	eddf 8a83 	vldr	s17, [pc, #524]	; 801eac8 <mcpwm_foc_hall_detect+0x238>
	m_phase_override = true;
 801e8be:	2201      	movs	r2, #1
 801e8c0:	700a      	strb	r2, [r1, #0]
	m_control_mode = CONTROL_MODE_CURRENT;
 801e8c2:	4a82      	ldr	r2, [pc, #520]	; (801eacc <mcpwm_foc_hall_detect+0x23c>)
	m_id_set = current;
 801e8c4:	ed8b 8a00 	vstr	s16, [fp]
	m_control_mode = CONTROL_MODE_CURRENT;
 801e8c8:	2302      	movs	r3, #2
	m_iq_set = 0.0;
 801e8ca:	edca 9a00 	vstr	s19, [sl]
	m_control_mode = CONTROL_MODE_CURRENT;
 801e8ce:	7013      	strb	r3, [r2, #0]
	m_state = MC_STATE_RUNNING;
 801e8d0:	703b      	strb	r3, [r7, #0]
	systime_t tout = timeout_get_timeout_msec();
 801e8d2:	f7fb fc5d 	bl	801a190 <timeout_get_timeout_msec>
 801e8d6:	9001      	str	r0, [sp, #4]
	float tout_c = timeout_get_brake_current();
 801e8d8:	f7fb fc62 	bl	801a1a0 <timeout_get_brake_current>
 801e8dc:	eeb0 8a40 	vmov.f32	s16, s0
	timeout_reset();
 801e8e0:	f7fb fc3e 	bl	801a160 <timeout_reset>
	timeout_configure(60000, 0.0);
 801e8e4:	eeb0 0a69 	vmov.f32	s0, s19
 801e8e8:	f64e 2060 	movw	r0, #60000	; 0xea60
 801e8ec:	f7fb fc28 	bl	801a140 <timeout_configure>
	chThdSleepMilliseconds(1000);
 801e8f0:	f242 7010 	movw	r0, #10000	; 0x2710
	m_phase_now_override = 0;
 801e8f4:	edc4 9a00 	vstr	s19, [r4]
	chThdSleepMilliseconds(1000);
 801e8f8:	f7ef f872 	bl	800d9e0 <chThdSleep>
	memset(sin_hall, 0, sizeof(sin_hall));
 801e8fc:	2220      	movs	r2, #32
 801e8fe:	2100      	movs	r1, #0
 801e900:	a804      	add	r0, sp, #16
 801e902:	f008 f98d 	bl	8026c20 <memset>
	memset(cos_hall, 0, sizeof(cos_hall));
 801e906:	2220      	movs	r2, #32
 801e908:	2100      	movs	r1, #0
 801e90a:	a80c      	add	r0, sp, #48	; 0x30
 801e90c:	f008 f988 	bl	8026c20 <memset>
	memset(hall_iterations, 0, sizeof(hall_iterations));
 801e910:	2220      	movs	r2, #32
 801e912:	2100      	movs	r1, #0
 801e914:	a814      	add	r0, sp, #80	; 0x50
 801e916:	f008 f983 	bl	8026c20 <memset>
 801e91a:	2503      	movs	r5, #3
		for (int i = 0;i < 360;i++) {
 801e91c:	f04f 0900 	mov.w	r9, #0
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e920:	ee07 9a90 	vmov	s15, r9
 801e924:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			chThdSleepMilliseconds(5);
 801e928:	2032      	movs	r0, #50	; 0x32
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e92a:	ee67 7a89 	vmul.f32	s15, s15, s18
		for (int i = 0;i < 360;i++) {
 801e92e:	f109 0901 	add.w	r9, r9, #1
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e932:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 801e936:	ed84 7a00 	vstr	s14, [r4]
			chThdSleepMilliseconds(5);
 801e93a:	f7ef f851 	bl	800d9e0 <chThdSleep>
			int hall = read_hall();
 801e93e:	f7fe f9cf 	bl	801cce0 <read_hall>
			sincosf(m_phase_now_override, &s, &c);
 801e942:	ed94 0a00 	vldr	s0, [r4]
			int hall = read_hall();
 801e946:	4680      	mov	r8, r0
			sincosf(m_phase_now_override, &s, &c);
 801e948:	a903      	add	r1, sp, #12
 801e94a:	a802      	add	r0, sp, #8
 801e94c:	f006 fed0 	bl	80256f0 <sincosf>
			sin_hall[hall] += s;
 801e950:	ab1c      	add	r3, sp, #112	; 0x70
 801e952:	eb03 0088 	add.w	r0, r3, r8, lsl #2
 801e956:	ed10 6a18 	vldr	s12, [r0, #-96]	; 0xffffffa0
			cos_hall[hall] += c;
 801e95a:	ed10 7a10 	vldr	s14, [r0, #-64]	; 0xffffffc0
			sin_hall[hall] += s;
 801e95e:	eddd 6a02 	vldr	s13, [sp, #8]
			cos_hall[hall] += c;
 801e962:	eddd 7a03 	vldr	s15, [sp, #12]
			hall_iterations[hall]++;
 801e966:	f850 3c20 	ldr.w	r3, [r0, #-32]
			sin_hall[hall] += s;
 801e96a:	ee76 6a26 	vadd.f32	s13, s12, s13
			cos_hall[hall] += c;
 801e96e:	ee77 7a27 	vadd.f32	s15, s14, s15
			hall_iterations[hall]++;
 801e972:	3301      	adds	r3, #1
		for (int i = 0;i < 360;i++) {
 801e974:	f5b9 7fb4 	cmp.w	r9, #360	; 0x168
			sin_hall[hall] += s;
 801e978:	ed40 6a18 	vstr	s13, [r0, #-96]	; 0xffffffa0
			cos_hall[hall] += c;
 801e97c:	ed40 7a10 	vstr	s15, [r0, #-64]	; 0xffffffc0
			hall_iterations[hall]++;
 801e980:	f840 3c20 	str.w	r3, [r0, #-32]
		for (int i = 0;i < 360;i++) {
 801e984:	d1cc      	bne.n	801e920 <mcpwm_foc_hall_detect+0x90>
	for (int i = 0;i < 3;i++) {
 801e986:	3d01      	subs	r5, #1
 801e988:	d1c8      	bne.n	801e91c <mcpwm_foc_hall_detect+0x8c>
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e98a:	ed9f 9a4e 	vldr	s18, [pc, #312]	; 801eac4 <mcpwm_foc_hall_detect+0x234>
 801e98e:	eddf 8a4e 	vldr	s17, [pc, #312]	; 801eac8 <mcpwm_foc_hall_detect+0x238>
 801e992:	2503      	movs	r5, #3
		for (int i = 360;i >= 0;i--) {
 801e994:	f44f 79b4 	mov.w	r9, #360	; 0x168
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e998:	ee07 9a90 	vmov	s15, r9
 801e99c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			chThdSleepMilliseconds(5);
 801e9a0:	2032      	movs	r0, #50	; 0x32
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e9a2:	ee67 7a89 	vmul.f32	s15, s15, s18
		for (int i = 360;i >= 0;i--) {
 801e9a6:	f109 39ff 	add.w	r9, r9, #4294967295
			m_phase_now_override = (float)i * M_PI / 180.0;
 801e9aa:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 801e9ae:	ed84 7a00 	vstr	s14, [r4]
			chThdSleepMilliseconds(5);
 801e9b2:	f7ef f815 	bl	800d9e0 <chThdSleep>
			int hall = read_hall();
 801e9b6:	f7fe f993 	bl	801cce0 <read_hall>
			sincosf(m_phase_now_override, &s, &c);
 801e9ba:	ed94 0a00 	vldr	s0, [r4]
			int hall = read_hall();
 801e9be:	4680      	mov	r8, r0
			sincosf(m_phase_now_override, &s, &c);
 801e9c0:	a903      	add	r1, sp, #12
 801e9c2:	a802      	add	r0, sp, #8
 801e9c4:	f006 fe94 	bl	80256f0 <sincosf>
			sin_hall[hall] += s;
 801e9c8:	ab1c      	add	r3, sp, #112	; 0x70
 801e9ca:	eb03 0088 	add.w	r0, r3, r8, lsl #2
 801e9ce:	ed10 6a18 	vldr	s12, [r0, #-96]	; 0xffffffa0
			cos_hall[hall] += c;
 801e9d2:	ed10 7a10 	vldr	s14, [r0, #-64]	; 0xffffffc0
			sin_hall[hall] += s;
 801e9d6:	eddd 6a02 	vldr	s13, [sp, #8]
			cos_hall[hall] += c;
 801e9da:	eddd 7a03 	vldr	s15, [sp, #12]
			hall_iterations[hall]++;
 801e9de:	f850 3c20 	ldr.w	r3, [r0, #-32]
			sin_hall[hall] += s;
 801e9e2:	ee76 6a26 	vadd.f32	s13, s12, s13
			cos_hall[hall] += c;
 801e9e6:	ee77 7a27 	vadd.f32	s15, s14, s15
			hall_iterations[hall]++;
 801e9ea:	3301      	adds	r3, #1
		for (int i = 360;i >= 0;i--) {
 801e9ec:	f1b9 3fff 	cmp.w	r9, #4294967295
			sin_hall[hall] += s;
 801e9f0:	ed40 6a18 	vstr	s13, [r0, #-96]	; 0xffffffa0
			cos_hall[hall] += c;
 801e9f4:	ed40 7a10 	vstr	s15, [r0, #-64]	; 0xffffffc0
			hall_iterations[hall]++;
 801e9f8:	f840 3c20 	str.w	r3, [r0, #-32]
		for (int i = 360;i >= 0;i--) {
 801e9fc:	d1cc      	bne.n	801e998 <mcpwm_foc_hall_detect+0x108>
	for (int i = 0;i < 3;i++) {
 801e9fe:	3d01      	subs	r5, #1
 801ea00:	d1c8      	bne.n	801e994 <mcpwm_foc_hall_detect+0x104>
	m_id_set = 0.0;
 801ea02:	2300      	movs	r3, #0
 801ea04:	f8cb 3000 	str.w	r3, [fp]
	m_iq_set = 0.0;
 801ea08:	f8ca 3000 	str.w	r3, [sl]
	m_phase_override = false;
 801ea0c:	4b29      	ldr	r3, [pc, #164]	; (801eab4 <mcpwm_foc_hall_detect+0x224>)
			float ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;
 801ea0e:	eddf 9a2e 	vldr	s19, [pc, #184]	; 801eac8 <mcpwm_foc_hall_detect+0x238>
	m_phase_override = false;
 801ea12:	701d      	strb	r5, [r3, #0]
	m_control_mode = CONTROL_MODE_NONE;
 801ea14:	4b2d      	ldr	r3, [pc, #180]	; (801eacc <mcpwm_foc_hall_detect+0x23c>)
			float ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;
 801ea16:	ed9f 9a2b 	vldr	s18, [pc, #172]	; 801eac4 <mcpwm_foc_hall_detect+0x234>
			hall_table[i] = (uint8_t)(ang * 200.0 / 360.0);
 801ea1a:	eddf 8a2d 	vldr	s17, [pc, #180]	; 801ead0 <mcpwm_foc_hall_detect+0x240>
	m_control_mode = CONTROL_MODE_NONE;
 801ea1e:	2207      	movs	r2, #7
 801ea20:	701a      	strb	r2, [r3, #0]
	m_state = MC_STATE_OFF;
 801ea22:	703d      	strb	r5, [r7, #0]
	stop_pwm_hw();
 801ea24:	f7fe f91c 	bl	801cc60 <stop_pwm_hw>
	timeout_configure(tout, tout_c);
 801ea28:	eeb0 0a48 	vmov.f32	s0, s16
 801ea2c:	9801      	ldr	r0, [sp, #4]
			hall_table[i] = (uint8_t)(ang * 200.0 / 360.0);
 801ea2e:	ed9f 8a29 	vldr	s16, [pc, #164]	; 801ead4 <mcpwm_foc_hall_detect+0x244>
	timeout_configure(tout, tout_c);
 801ea32:	f7fb fb85 	bl	801a140 <timeout_configure>
	int fails = 0;
 801ea36:	462f      	mov	r7, r5
 801ea38:	ac13      	add	r4, sp, #76	; 0x4c
			hall_table[i] = 255;
 801ea3a:	f04f 08ff 	mov.w	r8, #255	; 0xff
 801ea3e:	e006      	b.n	801ea4e <mcpwm_foc_hall_detect+0x1be>
 801ea40:	f806 8005 	strb.w	r8, [r6, r5]
	for(int i = 0;i < 8;i++) {
 801ea44:	3501      	adds	r5, #1
 801ea46:	2d08      	cmp	r5, #8
			fails++;
 801ea48:	f107 0701 	add.w	r7, r7, #1
	for(int i = 0;i < 8;i++) {
 801ea4c:	d025      	beq.n	801ea9a <mcpwm_foc_hall_detect+0x20a>
		if (hall_iterations[i] > 30) {
 801ea4e:	f854 3f04 	ldr.w	r3, [r4, #4]!
 801ea52:	2b1e      	cmp	r3, #30
 801ea54:	ddf4      	ble.n	801ea40 <mcpwm_foc_hall_detect+0x1b0>
 801ea56:	00ab      	lsls	r3, r5, #2
			float ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;
 801ea58:	a904      	add	r1, sp, #16
 801ea5a:	aa0c      	add	r2, sp, #48	; 0x30
 801ea5c:	441a      	add	r2, r3
 801ea5e:	440b      	add	r3, r1
 801ea60:	ed93 0a00 	vldr	s0, [r3]
 801ea64:	edd2 0a00 	vldr	s1, [r2]
 801ea68:	f006 fdda 	bl	8025620 <atan2f>
 801ea6c:	ee20 0a29 	vmul.f32	s0, s0, s19
			utils_norm_angle(&ang);
 801ea70:	a803      	add	r0, sp, #12
			float ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;
 801ea72:	eec0 7a09 	vdiv.f32	s15, s0, s18
 801ea76:	edcd 7a03 	vstr	s15, [sp, #12]
			utils_norm_angle(&ang);
 801ea7a:	f7f6 ffb1 	bl	80159e0 <utils_norm_angle>
			hall_table[i] = (uint8_t)(ang * 200.0 / 360.0);
 801ea7e:	ed9d 7a03 	vldr	s14, [sp, #12]
 801ea82:	ee27 7a28 	vmul.f32	s14, s14, s17
 801ea86:	eec7 7a08 	vdiv.f32	s15, s14, s16
 801ea8a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ea8e:	ee17 3a90 	vmov	r3, s15
 801ea92:	5573      	strb	r3, [r6, r5]
	for(int i = 0;i < 8;i++) {
 801ea94:	3501      	adds	r5, #1
 801ea96:	2d08      	cmp	r5, #8
 801ea98:	d1d9      	bne.n	801ea4e <mcpwm_foc_hall_detect+0x1be>
	mc_interface_unlock();
 801ea9a:	f7fc fcd1 	bl	801b440 <mc_interface_unlock>
}
 801ea9e:	f1a7 0002 	sub.w	r0, r7, #2
 801eaa2:	fab0 f080 	clz	r0, r0
 801eaa6:	0940      	lsrs	r0, r0, #5
 801eaa8:	b01d      	add	sp, #116	; 0x74
 801eaaa:	ecbd 8b04 	vpop	{d8-d9}
 801eaae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801eab2:	bf00      	nop
 801eab4:	2000ce61 	.word	0x2000ce61
 801eab8:	00000000 	.word	0x00000000
 801eabc:	2000ce8c 	.word	0x2000ce8c
 801eac0:	2000ce5c 	.word	0x2000ce5c
 801eac4:	40490fdb 	.word	0x40490fdb
 801eac8:	43340000 	.word	0x43340000
 801eacc:	2000cdac 	.word	0x2000cdac
 801ead0:	43480000 	.word	0x43480000
 801ead4:	43b40000 	.word	0x43b40000
 801ead8:	2000cdd0 	.word	0x2000cdd0
 801eadc:	2000cdd8 	.word	0x2000cdd8

0801eae0 <mcpwm_foc_print_state>:
void mcpwm_foc_print_state(void) {
 801eae0:	b510      	push	{r4, lr}
	commands_printf("Mod d:        %.2f", (double)m_motor_state.mod_d);
 801eae2:	4c4a      	ldr	r4, [pc, #296]	; (801ec0c <mcpwm_foc_print_state+0x12c>)
 801eae4:	6b60      	ldr	r0, [r4, #52]	; 0x34
 801eae6:	f7ed fc8f 	bl	800c408 <__aeabi_f2d>
 801eaea:	4602      	mov	r2, r0
 801eaec:	460b      	mov	r3, r1
 801eaee:	4848      	ldr	r0, [pc, #288]	; (801ec10 <mcpwm_foc_print_state+0x130>)
 801eaf0:	f7f9 fda6 	bl	8018640 <commands_printf>
	commands_printf("Mod q:        %.2f", (double)m_motor_state.mod_q);
 801eaf4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801eaf6:	f7ed fc87 	bl	800c408 <__aeabi_f2d>
 801eafa:	4602      	mov	r2, r0
 801eafc:	460b      	mov	r3, r1
 801eafe:	4845      	ldr	r0, [pc, #276]	; (801ec14 <mcpwm_foc_print_state+0x134>)
 801eb00:	f7f9 fd9e 	bl	8018640 <commands_printf>
	commands_printf("Duty:         %.2f", (double)m_motor_state.duty_now);
 801eb04:	68e0      	ldr	r0, [r4, #12]
 801eb06:	f7ed fc7f 	bl	800c408 <__aeabi_f2d>
 801eb0a:	4602      	mov	r2, r0
 801eb0c:	460b      	mov	r3, r1
 801eb0e:	4842      	ldr	r0, [pc, #264]	; (801ec18 <mcpwm_foc_print_state+0x138>)
 801eb10:	f7f9 fd96 	bl	8018640 <commands_printf>
	commands_printf("Vd:           %.2f", (double)m_motor_state.vd);
 801eb14:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 801eb16:	f7ed fc77 	bl	800c408 <__aeabi_f2d>
 801eb1a:	4602      	mov	r2, r0
 801eb1c:	460b      	mov	r3, r1
 801eb1e:	483f      	ldr	r0, [pc, #252]	; (801ec1c <mcpwm_foc_print_state+0x13c>)
 801eb20:	f7f9 fd8e 	bl	8018640 <commands_printf>
	commands_printf("Vq:           %.2f", (double)m_motor_state.vq);
 801eb24:	6d20      	ldr	r0, [r4, #80]	; 0x50
 801eb26:	f7ed fc6f 	bl	800c408 <__aeabi_f2d>
 801eb2a:	4602      	mov	r2, r0
 801eb2c:	460b      	mov	r3, r1
 801eb2e:	483c      	ldr	r0, [pc, #240]	; (801ec20 <mcpwm_foc_print_state+0x140>)
 801eb30:	f7f9 fd86 	bl	8018640 <commands_printf>
	commands_printf("Phase:        %.2f", (double)m_motor_state.phase);
 801eb34:	6920      	ldr	r0, [r4, #16]
 801eb36:	f7ed fc67 	bl	800c408 <__aeabi_f2d>
 801eb3a:	4602      	mov	r2, r0
 801eb3c:	460b      	mov	r3, r1
 801eb3e:	4839      	ldr	r0, [pc, #228]	; (801ec24 <mcpwm_foc_print_state+0x144>)
 801eb40:	f7f9 fd7e 	bl	8018640 <commands_printf>
	commands_printf("V_alpha:      %.2f", (double)m_motor_state.v_alpha);
 801eb44:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 801eb46:	f7ed fc5f 	bl	800c408 <__aeabi_f2d>
 801eb4a:	4602      	mov	r2, r0
 801eb4c:	460b      	mov	r3, r1
 801eb4e:	4836      	ldr	r0, [pc, #216]	; (801ec28 <mcpwm_foc_print_state+0x148>)
 801eb50:	f7f9 fd76 	bl	8018640 <commands_printf>
	commands_printf("V_beta:       %.2f", (double)m_motor_state.v_beta);
 801eb54:	6b20      	ldr	r0, [r4, #48]	; 0x30
 801eb56:	f7ed fc57 	bl	800c408 <__aeabi_f2d>
 801eb5a:	4602      	mov	r2, r0
 801eb5c:	460b      	mov	r3, r1
 801eb5e:	4833      	ldr	r0, [pc, #204]	; (801ec2c <mcpwm_foc_print_state+0x14c>)
 801eb60:	f7f9 fd6e 	bl	8018640 <commands_printf>
	commands_printf("id:           %.2f", (double)m_motor_state.id);
 801eb64:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 801eb66:	f7ed fc4f 	bl	800c408 <__aeabi_f2d>
 801eb6a:	4602      	mov	r2, r0
 801eb6c:	460b      	mov	r3, r1
 801eb6e:	4830      	ldr	r0, [pc, #192]	; (801ec30 <mcpwm_foc_print_state+0x150>)
 801eb70:	f7f9 fd66 	bl	8018640 <commands_printf>
	commands_printf("iq:           %.2f", (double)m_motor_state.iq);
 801eb74:	6c20      	ldr	r0, [r4, #64]	; 0x40
 801eb76:	f7ed fc47 	bl	800c408 <__aeabi_f2d>
 801eb7a:	4602      	mov	r2, r0
 801eb7c:	460b      	mov	r3, r1
 801eb7e:	482d      	ldr	r0, [pc, #180]	; (801ec34 <mcpwm_foc_print_state+0x154>)
 801eb80:	f7f9 fd5e 	bl	8018640 <commands_printf>
	commands_printf("id_filter:    %.2f", (double)m_motor_state.id_filter);
 801eb84:	6c60      	ldr	r0, [r4, #68]	; 0x44
 801eb86:	f7ed fc3f 	bl	800c408 <__aeabi_f2d>
 801eb8a:	4602      	mov	r2, r0
 801eb8c:	460b      	mov	r3, r1
 801eb8e:	482a      	ldr	r0, [pc, #168]	; (801ec38 <mcpwm_foc_print_state+0x158>)
 801eb90:	f7f9 fd56 	bl	8018640 <commands_printf>
	commands_printf("iq_filter:    %.2f", (double)m_motor_state.iq_filter);
 801eb94:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 801eb96:	f7ed fc37 	bl	800c408 <__aeabi_f2d>
 801eb9a:	4602      	mov	r2, r0
 801eb9c:	460b      	mov	r3, r1
 801eb9e:	4827      	ldr	r0, [pc, #156]	; (801ec3c <mcpwm_foc_print_state+0x15c>)
 801eba0:	f7f9 fd4e 	bl	8018640 <commands_printf>
	commands_printf("id_target:    %.2f", (double)m_motor_state.id_target);
 801eba4:	6820      	ldr	r0, [r4, #0]
 801eba6:	f7ed fc2f 	bl	800c408 <__aeabi_f2d>
 801ebaa:	4602      	mov	r2, r0
 801ebac:	460b      	mov	r3, r1
 801ebae:	4824      	ldr	r0, [pc, #144]	; (801ec40 <mcpwm_foc_print_state+0x160>)
 801ebb0:	f7f9 fd46 	bl	8018640 <commands_printf>
	commands_printf("iq_target:    %.2f", (double)m_motor_state.iq_target);
 801ebb4:	6860      	ldr	r0, [r4, #4]
 801ebb6:	f7ed fc27 	bl	800c408 <__aeabi_f2d>
 801ebba:	4602      	mov	r2, r0
 801ebbc:	460b      	mov	r3, r1
 801ebbe:	4821      	ldr	r0, [pc, #132]	; (801ec44 <mcpwm_foc_print_state+0x164>)
 801ebc0:	f7f9 fd3e 	bl	8018640 <commands_printf>
	commands_printf("i_abs:        %.2f", (double)m_motor_state.i_abs);
 801ebc4:	69e0      	ldr	r0, [r4, #28]
 801ebc6:	f7ed fc1f 	bl	800c408 <__aeabi_f2d>
 801ebca:	4602      	mov	r2, r0
 801ebcc:	460b      	mov	r3, r1
 801ebce:	481e      	ldr	r0, [pc, #120]	; (801ec48 <mcpwm_foc_print_state+0x168>)
 801ebd0:	f7f9 fd36 	bl	8018640 <commands_printf>
	commands_printf("i_abs_filter: %.2f", (double)m_motor_state.i_abs_filter);
 801ebd4:	6a20      	ldr	r0, [r4, #32]
 801ebd6:	f7ed fc17 	bl	800c408 <__aeabi_f2d>
 801ebda:	4602      	mov	r2, r0
 801ebdc:	460b      	mov	r3, r1
 801ebde:	481b      	ldr	r0, [pc, #108]	; (801ec4c <mcpwm_foc_print_state+0x16c>)
 801ebe0:	f7f9 fd2e 	bl	8018640 <commands_printf>
	commands_printf("Obs_x1:       %.2f", (double)m_observer_x1);
 801ebe4:	4b1a      	ldr	r3, [pc, #104]	; (801ec50 <mcpwm_foc_print_state+0x170>)
 801ebe6:	6818      	ldr	r0, [r3, #0]
 801ebe8:	f7ed fc0e 	bl	800c408 <__aeabi_f2d>
 801ebec:	4602      	mov	r2, r0
 801ebee:	460b      	mov	r3, r1
 801ebf0:	4818      	ldr	r0, [pc, #96]	; (801ec54 <mcpwm_foc_print_state+0x174>)
 801ebf2:	f7f9 fd25 	bl	8018640 <commands_printf>
	commands_printf("Obs_x2:       %.2f", (double)m_observer_x2);
 801ebf6:	4b18      	ldr	r3, [pc, #96]	; (801ec58 <mcpwm_foc_print_state+0x178>)
 801ebf8:	6818      	ldr	r0, [r3, #0]
 801ebfa:	f7ed fc05 	bl	800c408 <__aeabi_f2d>
}
 801ebfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	commands_printf("Obs_x2:       %.2f", (double)m_observer_x2);
 801ec02:	4602      	mov	r2, r0
 801ec04:	460b      	mov	r3, r1
 801ec06:	4815      	ldr	r0, [pc, #84]	; (801ec5c <mcpwm_foc_print_state+0x17c>)
 801ec08:	f7f9 bd1a 	b.w	8018640 <commands_printf>
 801ec0c:	2000cddc 	.word	0x2000cddc
 801ec10:	0802f440 	.word	0x0802f440
 801ec14:	0802f454 	.word	0x0802f454
 801ec18:	0802f468 	.word	0x0802f468
 801ec1c:	0802f47c 	.word	0x0802f47c
 801ec20:	0802f490 	.word	0x0802f490
 801ec24:	0802f4a4 	.word	0x0802f4a4
 801ec28:	0802f4b8 	.word	0x0802f4b8
 801ec2c:	0802f4cc 	.word	0x0802f4cc
 801ec30:	0802f4e0 	.word	0x0802f4e0
 801ec34:	0802f4f4 	.word	0x0802f4f4
 801ec38:	0802f508 	.word	0x0802f508
 801ec3c:	0802f51c 	.word	0x0802f51c
 801ec40:	0802f530 	.word	0x0802f530
 801ec44:	0802f544 	.word	0x0802f544
 801ec48:	0802f558 	.word	0x0802f558
 801ec4c:	0802f56c 	.word	0x0802f56c
 801ec50:	2000ce3c 	.word	0x2000ce3c
 801ec54:	0802f580 	.word	0x0802f580
 801ec58:	2000ce40 	.word	0x2000ce40
 801ec5c:	0802f594 	.word	0x0802f594

0801ec60 <mcpwm_foc_get_last_inj_adc_isr_duration>:
	return last_inj_adc_isr_duration;
 801ec60:	4b01      	ldr	r3, [pc, #4]	; (801ec68 <mcpwm_foc_get_last_inj_adc_isr_duration+0x8>)
 801ec62:	ed93 0a00 	vldr	s0, [r3]
}
 801ec66:	4770      	bx	lr
 801ec68:	2000cda4 	.word	0x2000cda4
 801ec6c:	00000000 	.word	0x00000000

0801ec70 <mcpwm_foc_tim_sample_int_handler>:
	if (m_init_done) {
 801ec70:	4b03      	ldr	r3, [pc, #12]	; (801ec80 <mcpwm_foc_tim_sample_int_handler+0x10>)
 801ec72:	781b      	ldrb	r3, [r3, #0]
 801ec74:	b903      	cbnz	r3, 801ec78 <mcpwm_foc_tim_sample_int_handler+0x8>
}
 801ec76:	4770      	bx	lr
		TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 801ec78:	2120      	movs	r1, #32
 801ec7a:	4802      	ldr	r0, [pc, #8]	; (801ec84 <mcpwm_foc_tim_sample_int_handler+0x14>)
 801ec7c:	f005 be38 	b.w	80248f0 <TIM_GenerateEvent>
 801ec80:	2000cdd4 	.word	0x2000cdd4
 801ec84:	40010000 	.word	0x40010000
	...

0801ec90 <observer_update>:
		float dt, volatile float *x1, volatile float *x2, volatile float *phase) {
 801ec90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const float L = (3.0 / 2.0) * m_conf->foc_motor_l;
 801ec94:	4f73      	ldr	r7, [pc, #460]	; (801ee64 <observer_update+0x1d4>)
	const float sign = (m_motor_state.iq * m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;
 801ec96:	4e74      	ldr	r6, [pc, #464]	; (801ee68 <observer_update+0x1d8>)
	const float L = (3.0 / 2.0) * m_conf->foc_motor_l;
 801ec98:	683b      	ldr	r3, [r7, #0]
		float dt, volatile float *x1, volatile float *x2, volatile float *phase) {
 801ec9a:	ed2d 8b0a 	vpush	{d8-d12}
	const float L = (3.0 / 2.0) * m_conf->foc_motor_l;
 801ec9e:	ed93 ba30 	vldr	s22, [r3, #192]	; 0xc0
	const float lambda = m_conf->foc_motor_flux_linkage;
 801eca2:	ed93 8a32 	vldr	s16, [r3, #200]	; 0xc8
	float R = (3.0 / 2.0) * m_conf->foc_motor_r;
 801eca6:	edd3 aa31 	vldr	s21, [r3, #196]	; 0xc4
	const float sign = (m_motor_state.iq * m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;
 801ecaa:	edd6 7a10 	vldr	s15, [r6, #64]	; 0x40
 801ecae:	ed96 7a14 	vldr	s14, [r6, #80]	; 0x50
	R -= R * sign * m_conf->foc_sat_comp * (m_motor_state.i_abs_filter / m_conf->l_current_max);
 801ecb2:	edd3 6a43 	vldr	s13, [r3, #268]	; 0x10c
 801ecb6:	edd6 5a08 	vldr	s11, [r6, #32]
 801ecba:	ed93 6a01 	vldr	s12, [r3, #4]
	const float sign = (m_motor_state.iq * m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;
 801ecbe:	ee67 7a87 	vmul.f32	s15, s15, s14
	const float L = (3.0 / 2.0) * m_conf->foc_motor_l;
 801ecc2:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
	float R = (3.0 / 2.0) * m_conf->foc_motor_r;
 801ecc6:	ee6a aa87 	vmul.f32	s21, s21, s14
	const float L = (3.0 / 2.0) * m_conf->foc_motor_l;
 801ecca:	ee2b ba07 	vmul.f32	s22, s22, s14
	R -= R * sign * m_conf->foc_sat_comp * (m_motor_state.i_abs_filter / m_conf->l_current_max);
 801ecce:	ee85 7a86 	vdiv.f32	s14, s11, s12
		float dt, volatile float *x1, volatile float *x2, volatile float *phase) {
 801ecd2:	b082      	sub	sp, #8
 801ecd4:	4690      	mov	r8, r2
 801ecd6:	4605      	mov	r5, r0
 801ecd8:	460c      	mov	r4, r1
	const float sign = (m_motor_state.iq * m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;
 801ecda:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801ecde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ece2:	bfb4      	ite	lt
 801ece4:	eef1 7a6a 	vneglt.f32	s15, s21
 801ece8:	eef0 7a6a 	vmovge.f32	s15, s21
	R -= R * sign * m_conf->foc_sat_comp * (m_motor_state.i_abs_filter / m_conf->l_current_max);
 801ecec:	ee67 7ae6 	vnmul.f32	s15, s15, s13
		float dt, volatile float *x1, volatile float *x2, volatile float *phase) {
 801ecf0:	eeb0 9a40 	vmov.f32	s18, s0
 801ecf4:	eef0 8a60 	vmov.f32	s17, s1
 801ecf8:	eef0 ba41 	vmov.f32	s23, s2
 801ecfc:	eef0 ca61 	vmov.f32	s25, s3
 801ed00:	eef0 9a42 	vmov.f32	s19, s4
	R -= R * sign * m_conf->foc_sat_comp * (m_motor_state.i_abs_filter / m_conf->l_current_max);
 801ed04:	eee7 aa87 	vfma.f32	s21, s15, s14
	const float t = mc_interface_temp_motor_filtered();
 801ed08:	f7fd f9fa 	bl	801c100 <mc_interface_temp_motor_filtered>
	if (m_conf->foc_temp_comp && t > -5.0) {
 801ed0c:	683b      	ldr	r3, [r7, #0]
 801ed0e:	f893 2110 	ldrb.w	r2, [r3, #272]	; 0x110
 801ed12:	b13a      	cbz	r2, 801ed24 <observer_update+0x94>
 801ed14:	eef9 7a04 	vmov.f32	s15, #148	; 0xc0a00000 -5.0
 801ed18:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801ed1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ed20:	f300 8094 	bgt.w	801ee4c <observer_update+0x1bc>
	const float gamma_half = m_gamma_now * 0.5;
 801ed24:	4b51      	ldr	r3, [pc, #324]	; (801ee6c <observer_update+0x1dc>)
	const float dt_iteration = dt / (float)iterations;
 801ed26:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 801ed2a:	ee89 caa7 	vdiv.f32	s24, s19, s15
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801ed2e:	2606      	movs	r6, #6
	const float R_ia = R * i_alpha;
 801ed30:	ee6a 7aab 	vmul.f32	s15, s21, s23
	const float lambda_2 = SQ(lambda);
 801ed34:	ee28 8a08 	vmul.f32	s16, s16, s16
	const float R_ib = R * i_beta;
 801ed38:	ee6a aaac 	vmul.f32	s21, s21, s25
	const float gamma_half = m_gamma_now * 0.5;
 801ed3c:	ed93 aa00 	vldr	s20, [r3]
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801ed40:	eddf 9a4b 	vldr	s19, [pc, #300]	; 801ee70 <observer_update+0x1e0>
	const float gamma_half = m_gamma_now * 0.5;
 801ed44:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801ed48:	ee78 8aea 	vsub.f32	s17, s17, s21
	const float L_ia = L * i_alpha;
 801ed4c:	ee6b ba2b 	vmul.f32	s23, s22, s23
	const float gamma_half = m_gamma_now * 0.5;
 801ed50:	ee2a aa07 	vmul.f32	s20, s20, s14
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801ed54:	ee68 9a29 	vmul.f32	s19, s16, s19
 801ed58:	ee39 9a67 	vsub.f32	s18, s18, s15
	const float L_ib = L * i_beta;
 801ed5c:	ee2b ba2c 	vmul.f32	s22, s22, s25
			gamma_tmp *= 10.0;
 801ed60:	eef2 aa04 	vmov.f32	s21, #36	; 0x41200000  10.0
 801ed64:	e027      	b.n	801edb6 <observer_update+0x126>
 801ed66:	ee6a 5a2a 	vmul.f32	s11, s20, s21
		float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 801ed6a:	ed95 7a00 	vldr	s14, [r5]
		float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
 801ed6e:	edd4 7a00 	vldr	s15, [r4]
		float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 801ed72:	ed9d 6a01 	vldr	s12, [sp, #4]
		*x1 += x1_dot * dt_iteration;
 801ed76:	edd5 6a00 	vldr	s13, [r5]
		float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 801ed7a:	ee37 7a6b 	vsub.f32	s14, s14, s23
		float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
 801ed7e:	ee77 7acb 	vsub.f32	s15, s15, s22
		float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 801ed82:	ee27 7a25 	vmul.f32	s14, s14, s11
		float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
 801ed86:	ee67 7aa5 	vmul.f32	s15, s15, s11
		float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 801ed8a:	eef0 5a49 	vmov.f32	s11, s18
 801ed8e:	eee7 5a06 	vfma.f32	s11, s14, s12
	for (int i = 0;i < iterations;i++) {
 801ed92:	3e01      	subs	r6, #1
		float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
 801ed94:	eeb0 7a68 	vmov.f32	s14, s17
 801ed98:	eea6 7a27 	vfma.f32	s14, s12, s15
		*x1 += x1_dot * dt_iteration;
 801ed9c:	eef0 7a66 	vmov.f32	s15, s13
 801eda0:	eeec 7a25 	vfma.f32	s15, s24, s11
 801eda4:	edc5 7a00 	vstr	s15, [r5]
		*x2 += x2_dot * dt_iteration;
 801eda8:	edd4 7a00 	vldr	s15, [r4]
 801edac:	eeec 7a07 	vfma.f32	s15, s24, s14
 801edb0:	edc4 7a00 	vstr	s15, [r4]
	for (int i = 0;i < iterations;i++) {
 801edb4:	d021      	beq.n	801edfa <observer_update+0x16a>
		float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 801edb6:	edd5 6a00 	vldr	s13, [r5]
 801edba:	ed95 7a00 	vldr	s14, [r5]
 801edbe:	edd4 7a00 	vldr	s15, [r4]
 801edc2:	ed94 6a00 	vldr	s12, [r4]
 801edc6:	ee77 7acb 	vsub.f32	s15, s15, s22
 801edca:	ee36 6a4b 	vsub.f32	s12, s12, s22
 801edce:	ee76 6aeb 	vsub.f32	s13, s13, s23
 801edd2:	ee37 7a6b 	vsub.f32	s14, s14, s23
 801edd6:	ee67 7a86 	vmul.f32	s15, s15, s12
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801edda:	eeb0 0a69 	vmov.f32	s0, s19
		float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 801edde:	eee6 7a87 	vfma.f32	s15, s13, s14
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801ede2:	a801      	add	r0, sp, #4
		float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 801ede4:	ee78 7a67 	vsub.f32	s15, s16, s15
 801ede8:	edcd 7a01 	vstr	s15, [sp, #4]
		if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
 801edec:	f7f6 fe70 	bl	8015ad0 <utils_truncate_number_abs>
 801edf0:	2800      	cmp	r0, #0
 801edf2:	d1b8      	bne.n	801ed66 <observer_update+0xd6>
		float gamma_tmp = gamma_half;
 801edf4:	eef0 5a4a 	vmov.f32	s11, s20
 801edf8:	e7b7      	b.n	801ed6a <observer_update+0xda>
	UTILS_NAN_ZERO(*x1);
 801edfa:	ed95 7a00 	vldr	s14, [r5]
 801edfe:	edd5 7a00 	vldr	s15, [r5]
 801ee02:	eeb4 7a67 	vcmp.f32	s14, s15
 801ee06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ee0a:	bf0c      	ite	eq
 801ee0c:	682b      	ldreq	r3, [r5, #0]
 801ee0e:	2300      	movne	r3, #0
 801ee10:	602b      	str	r3, [r5, #0]
	UTILS_NAN_ZERO(*x2);
 801ee12:	ed94 7a00 	vldr	s14, [r4]
 801ee16:	edd4 7a00 	vldr	s15, [r4]
 801ee1a:	eeb4 7a67 	vcmp.f32	s14, s15
 801ee1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ee22:	bf0c      	ite	eq
 801ee24:	6823      	ldreq	r3, [r4, #0]
 801ee26:	2300      	movne	r3, #0
 801ee28:	6023      	str	r3, [r4, #0]
	*phase = utils_fast_atan2(*x2 - L_ib, *x1 - L_ia);
 801ee2a:	ed94 0a00 	vldr	s0, [r4]
 801ee2e:	edd5 0a00 	vldr	s1, [r5]
 801ee32:	ee30 0a4b 	vsub.f32	s0, s0, s22
 801ee36:	ee70 0aeb 	vsub.f32	s1, s1, s23
 801ee3a:	f7f6 ff51 	bl	8015ce0 <utils_fast_atan2>
 801ee3e:	ed88 0a00 	vstr	s0, [r8]
}
 801ee42:	b002      	add	sp, #8
 801ee44:	ecbd 8b0a 	vpop	{d8-d12}
 801ee48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		R += R * 0.00386 * (t - m_conf->foc_temp_comp_base_temp);
 801ee4c:	eddf 7a09 	vldr	s15, [pc, #36]	; 801ee74 <observer_update+0x1e4>
 801ee50:	ed93 7a45 	vldr	s14, [r3, #276]	; 0x114
 801ee54:	ee6a 7aa7 	vmul.f32	s15, s21, s15
 801ee58:	ee30 0a47 	vsub.f32	s0, s0, s14
 801ee5c:	eee7 aa80 	vfma.f32	s21, s15, s0
 801ee60:	e760      	b.n	801ed24 <observer_update+0x94>
 801ee62:	bf00      	nop
 801ee64:	2000cda8 	.word	0x2000cda8
 801ee68:	2000cddc 	.word	0x2000cddc
 801ee6c:	2000cdcc 	.word	0x2000cdcc
 801ee70:	3e4ccccd 	.word	0x3e4ccccd
 801ee74:	3b7cf80e 	.word	0x3b7cf80e
	...

0801ee80 <mcpwm_foc_adc_int_handler>:
void mcpwm_foc_adc_int_handler(void *p, uint32_t flags) {
 801ee80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	TIM12->CNT = 0;
 801ee84:	4a38      	ldr	r2, [pc, #224]	; (801ef68 <mcpwm_foc_adc_int_handler+0xe8>)
	bool is_v7 = !(TIM1->CR1 & TIM_CR1_DIR);
 801ee86:	4b39      	ldr	r3, [pc, #228]	; (801ef6c <mcpwm_foc_adc_int_handler+0xec>)
	if (!m_samples.measure_inductance_now) {
 801ee88:	4d39      	ldr	r5, [pc, #228]	; (801ef70 <mcpwm_foc_adc_int_handler+0xf0>)
	TIM12->CNT = 0;
 801ee8a:	2100      	movs	r1, #0
void mcpwm_foc_adc_int_handler(void *p, uint32_t flags) {
 801ee8c:	ed2d 8b06 	vpush	{d8-d10}
	TIM12->CNT = 0;
 801ee90:	6251      	str	r1, [r2, #36]	; 0x24
	bool is_v7 = !(TIM1->CR1 & TIM_CR1_DIR);
 801ee92:	681c      	ldr	r4, [r3, #0]
	if (!m_samples.measure_inductance_now) {
 801ee94:	7b2b      	ldrb	r3, [r5, #12]
void mcpwm_foc_adc_int_handler(void *p, uint32_t flags) {
 801ee96:	b089      	sub	sp, #36	; 0x24
	bool is_v7 = !(TIM1->CR1 & TIM_CR1_DIR);
 801ee98:	f004 0410 	and.w	r4, r4, #16
	if (!m_samples.measure_inductance_now) {
 801ee9c:	b92b      	cbnz	r3, 801eeaa <mcpwm_foc_adc_int_handler+0x2a>
		if (is_v7) {
 801ee9e:	b924      	cbnz	r4, 801eeaa <mcpwm_foc_adc_int_handler+0x2a>
}
 801eea0:	b009      	add	sp, #36	; 0x24
 801eea2:	ecbd 8b06 	vpop	{d8-d10}
 801eea6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int curr0 = ADC_Value[ADC_IND_CURR1];
 801eeaa:	4e32      	ldr	r6, [pc, #200]	; (801ef74 <mcpwm_foc_adc_int_handler+0xf4>)
	m_curr0_sum += curr0;
 801eeac:	4f32      	ldr	r7, [pc, #200]	; (801ef78 <mcpwm_foc_adc_int_handler+0xf8>)
	WWDG_SetCounter(100);
 801eeae:	2064      	movs	r0, #100	; 0x64
 801eeb0:	f005 fde6 	bl	8024a80 <WWDG_SetCounter>
	int curr0 = ADC_Value[ADC_IND_CURR1];
 801eeb4:	8930      	ldrh	r0, [r6, #8]
	int curr1 = ADC_Value[ADC_IND_CURR2];
 801eeb6:	88f2      	ldrh	r2, [r6, #6]
	m_curr0_sum += curr0;
 801eeb8:	683b      	ldr	r3, [r7, #0]
	m_curr1_sum += curr1;
 801eeba:	4930      	ldr	r1, [pc, #192]	; (801ef7c <mcpwm_foc_adc_int_handler+0xfc>)
	m_curr_samples++;
 801eebc:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 801ef88 <mcpwm_foc_adc_int_handler+0x108>
	curr0 -= m_curr0_offset;
 801eec0:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 801ef8c <mcpwm_foc_adc_int_handler+0x10c>
	int curr0 = ADC_Value[ADC_IND_CURR1];
 801eec4:	b280      	uxth	r0, r0
	m_curr0_sum += curr0;
 801eec6:	4403      	add	r3, r0
 801eec8:	603b      	str	r3, [r7, #0]
	m_curr1_sum += curr1;
 801eeca:	680b      	ldr	r3, [r1, #0]
	curr1 -= m_curr1_offset;
 801eecc:	4f2c      	ldr	r7, [pc, #176]	; (801ef80 <mcpwm_foc_adc_int_handler+0x100>)
	int curr1 = ADC_Value[ADC_IND_CURR2];
 801eece:	b292      	uxth	r2, r2
	m_curr1_sum += curr1;
 801eed0:	4413      	add	r3, r2
 801eed2:	600b      	str	r3, [r1, #0]
	curr0 -= m_curr0_offset;
 801eed4:	f8de e000 	ldr.w	lr, [lr]
	curr1 -= m_curr1_offset;
 801eed8:	6839      	ldr	r1, [r7, #0]
	m_curr_samples++;
 801eeda:	f8dc 7000 	ldr.w	r7, [ip]
	ADC_curr_norm_value[0] = curr0;
 801eede:	4b29      	ldr	r3, [pc, #164]	; (801ef84 <mcpwm_foc_adc_int_handler+0x104>)
	curr1 -= m_curr1_offset;
 801eee0:	1a51      	subs	r1, r2, r1
	m_curr_samples++;
 801eee2:	3701      	adds	r7, #1
	curr0 -= m_curr0_offset;
 801eee4:	eba0 000e 	sub.w	r0, r0, lr
	m_curr_samples++;
 801eee8:	f8cc 7000 	str.w	r7, [ip]
	ADC_curr_norm_value[0] = curr0;
 801eeec:	6018      	str	r0, [r3, #0]
	ADC_curr_norm_value[1] = curr1;
 801eeee:	6059      	str	r1, [r3, #4]
	ADC_curr_norm_value[2] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);
 801eef0:	681a      	ldr	r2, [r3, #0]
 801eef2:	685f      	ldr	r7, [r3, #4]
 801eef4:	443a      	add	r2, r7
 801eef6:	4252      	negs	r2, r2
 801eef8:	609a      	str	r2, [r3, #8]
	float ia = ADC_curr_norm_value[0] * FAC_CURRENT;
 801eefa:	f8d3 9000 	ldr.w	r9, [r3]
	float ib = ADC_curr_norm_value[1] * FAC_CURRENT;
 801eefe:	f8d3 a004 	ldr.w	sl, [r3, #4]
	if (m_samples.measure_inductance_now) {
 801ef02:	7b2b      	ldrb	r3, [r5, #12]
 801ef04:	2b00      	cmp	r3, #0
 801ef06:	d045      	beq.n	801ef94 <mcpwm_foc_adc_int_handler+0x114>
		if (!is_v7) {
 801ef08:	2c00      	cmp	r4, #0
 801ef0a:	d1c9      	bne.n	801eea0 <mcpwm_foc_adc_int_handler+0x20>
		const uint32_t duty_cnt = (uint32_t)((float)TIM1->ARR * m_samples.measure_inductance_duty);
 801ef0c:	4a17      	ldr	r2, [pc, #92]	; (801ef6c <mcpwm_foc_adc_int_handler+0xec>)
		if (inductance_state == 0) {
 801ef0e:	f8df 8080 	ldr.w	r8, [pc, #128]	; 801ef90 <mcpwm_foc_adc_int_handler+0x110>
		const uint32_t duty_cnt = (uint32_t)((float)TIM1->ARR * m_samples.measure_inductance_duty);
 801ef12:	edd2 7a0b 	vldr	s15, [r2, #44]	; 0x2c
 801ef16:	ed95 7a04 	vldr	s14, [r5, #16]
		if (inductance_state == 0) {
 801ef1a:	f8d8 7000 	ldr.w	r7, [r8]
		const uint32_t duty_cnt = (uint32_t)((float)TIM1->ARR * m_samples.measure_inductance_duty);
 801ef1e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801ef22:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ef26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ef2a:	ee17 3a90 	vmov	r3, s15
		if (inductance_state == 0) {
 801ef2e:	2f00      	cmp	r7, #0
 801ef30:	f000 824d 	beq.w	801f3ce <mcpwm_foc_adc_int_handler+0x54e>
		} else if (inductance_state == 2) {
 801ef34:	2f02      	cmp	r7, #2
 801ef36:	f000 8584 	beq.w	801fa42 <mcpwm_foc_adc_int_handler+0xbc2>
		} else if (inductance_state == 3) {
 801ef3a:	2f03      	cmp	r7, #3
 801ef3c:	f000 86de 	beq.w	801fcfc <mcpwm_foc_adc_int_handler+0xe7c>
		} else if (inductance_state == 5) {
 801ef40:	2f05      	cmp	r7, #5
 801ef42:	f000 85f9 	beq.w	801fb38 <mcpwm_foc_adc_int_handler+0xcb8>
		} else if (inductance_state == 6) {
 801ef46:	2f06      	cmp	r7, #6
 801ef48:	f001 8022 	beq.w	801ff90 <mcpwm_foc_adc_int_handler+0x1110>
		} else if (inductance_state == 8) {
 801ef4c:	2f08      	cmp	r7, #8
 801ef4e:	f001 807b 	beq.w	8020048 <mcpwm_foc_adc_int_handler+0x11c8>
		} else if (inductance_state == 9) {
 801ef52:	2f09      	cmp	r7, #9
 801ef54:	f001 80fa 	beq.w	802014c <mcpwm_foc_adc_int_handler+0x12cc>
		} else if (inductance_state == 10) {
 801ef58:	2f0a      	cmp	r7, #10
 801ef5a:	f040 8252 	bne.w	801f402 <mcpwm_foc_adc_int_handler+0x582>
			inductance_state = 0;
 801ef5e:	2300      	movs	r3, #0
 801ef60:	f8c8 3000 	str.w	r3, [r8]
			m_samples.measure_inductance_now = false;
 801ef64:	732b      	strb	r3, [r5, #12]
			return;
 801ef66:	e79b      	b.n	801eea0 <mcpwm_foc_adc_int_handler+0x20>
 801ef68:	40001800 	.word	0x40001800
 801ef6c:	40010000 	.word	0x40010000
 801ef70:	2000ce74 	.word	0x2000ce74
 801ef74:	2000c03c 	.word	0x2000c03c
 801ef78:	2000cdb4 	.word	0x2000cdb4
 801ef7c:	2000cdbc 	.word	0x2000cdbc
 801ef80:	2000cdb8 	.word	0x2000cdb8
 801ef84:	2000c054 	.word	0x2000c054
 801ef88:	2000cdc0 	.word	0x2000cdc0
 801ef8c:	2000cdb0 	.word	0x2000cdb0
 801ef90:	2000cda0 	.word	0x2000cda0
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801ef94:	4ddd      	ldr	r5, [pc, #884]	; (801f30c <mcpwm_foc_adc_int_handler+0x48c>)
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801ef96:	4cde      	ldr	r4, [pc, #888]	; (801f310 <mcpwm_foc_adc_int_handler+0x490>)
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801ef98:	682b      	ldr	r3, [r5, #0]
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801ef9a:	eddf 5ade 	vldr	s11, [pc, #888]	; 801f314 <mcpwm_foc_adc_int_handler+0x494>
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801ef9e:	ed93 7a2b 	vldr	s14, [r3, #172]	; 0xac
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801efa2:	edd4 6a0a 	vldr	s13, [r4, #40]	; 0x28
 801efa6:	8a33      	ldrh	r3, [r6, #16]
 801efa8:	eddf 4adb 	vldr	s9, [pc, #876]	; 801f318 <mcpwm_foc_adc_int_handler+0x498>
 801efac:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 801efb0:	ed9f 5ada 	vldr	s10, [pc, #872]	; 801f31c <mcpwm_foc_adc_int_handler+0x49c>
 801efb4:	ee06 3a10 	vmov	s12, r3
 801efb8:	eeb8 6a46 	vcvt.f32.u32	s12, s12
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801efbc:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801efc0:	ee25 6ac6 	vnmul.f32	s12, s11, s12
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801efc4:	ee27 7a04 	vmul.f32	s14, s14, s8
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801efc8:	eee6 6a24 	vfma.f32	s13, s12, s9
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801efcc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801efd0:	eee6 7ac5 	vfms.f32	s15, s13, s10
	const float dt = 1.0 / (m_conf->foc_f_sw / 2.0);
 801efd4:	ee86 8a07 	vdiv.f32	s16, s12, s14
	UTILS_LP_FAST(m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
 801efd8:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
	if (encoder_is_configured()) {
 801efdc:	f7fb fe68 	bl	801acb0 <encoder_is_configured>
 801efe0:	2800      	cmp	r0, #0
 801efe2:	f040 8216 	bne.w	801f412 <mcpwm_foc_adc_int_handler+0x592>
	float enc_ang = 0;
 801efe6:	eddf 8ace 	vldr	s17, [pc, #824]	; 801f320 <mcpwm_foc_adc_int_handler+0x4a0>
 801efea:	af07      	add	r7, sp, #28
	const float phase_diff = utils_angle_difference_rad(m_motor_state.phase, phase_before);
 801efec:	f8df b37c 	ldr.w	fp, [pc, #892]	; 801f36c <mcpwm_foc_adc_int_handler+0x4ec>
	if (m_state == MC_STATE_RUNNING) {
 801eff0:	f8df 837c 	ldr.w	r8, [pc, #892]	; 801f370 <mcpwm_foc_adc_int_handler+0x4f0>
	const float phase_diff = utils_angle_difference_rad(m_motor_state.phase, phase_before);
 801eff4:	ed94 0a04 	vldr	s0, [r4, #16]
 801eff8:	eddb 0a00 	vldr	s1, [fp]
 801effc:	f7f6 fde8 	bl	8015bd0 <utils_angle_difference_rad>
	phase_before = m_motor_state.phase;
 801f000:	6922      	ldr	r2, [r4, #16]
	if (m_state == MC_STATE_RUNNING) {
 801f002:	f898 3000 	ldrb.w	r3, [r8]
	phase_before = m_motor_state.phase;
 801f006:	f8cb 2000 	str.w	r2, [fp]
	if (m_state == MC_STATE_RUNNING) {
 801f00a:	2b02      	cmp	r3, #2
	const float phase_diff = utils_angle_difference_rad(m_motor_state.phase, phase_before);
 801f00c:	eef0 9a40 	vmov.f32	s19, s0
	if (m_state == MC_STATE_RUNNING) {
 801f010:	f000 8256 	beq.w	801f4c0 <mcpwm_foc_adc_int_handler+0x640>
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f014:	88b3      	ldrh	r3, [r6, #4]
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f016:	eddf 6ac3 	vldr	s13, [pc, #780]	; 801f324 <mcpwm_foc_adc_int_handler+0x4a4>
 801f01a:	ed9f 5ac3 	vldr	s10, [pc, #780]	; 801f328 <mcpwm_foc_adc_int_handler+0x4a8>
 801f01e:	eddf 5abe 	vldr	s11, [pc, #760]	; 801f318 <mcpwm_foc_adc_int_handler+0x498>
		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 801f022:	eddf 3ac2 	vldr	s7, [pc, #776]	; 801f32c <mcpwm_foc_adc_int_handler+0x4ac>
 801f026:	ed9f 3ac2 	vldr	s6, [pc, #776]	; 801f330 <mcpwm_foc_adc_int_handler+0x4b0>
		m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;
 801f02a:	ed9f 4ac2 	vldr	s8, [pc, #776]	; 801f334 <mcpwm_foc_adc_int_handler+0x4b4>
		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801f02e:	f8df 9344 	ldr.w	r9, [pc, #836]	; 801f374 <mcpwm_foc_adc_int_handler+0x4f4>
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f032:	ee07 3a10 	vmov	s14, r3
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f036:	8833      	ldrh	r3, [r6, #0]
 801f038:	ee06 3a10 	vmov	s12, r3
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f03c:	8873      	ldrh	r3, [r6, #2]
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f03e:	eeb8 6a46 	vcvt.f32.u32	s12, s12
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f042:	ee04 3a90 	vmov	s9, r3
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f046:	eec6 7a26 	vdiv.f32	s15, s12, s13
		utils_fast_sincos_better(m_motor_state.phase, &s, &c);
 801f04a:	f10d 0b18 	add.w	fp, sp, #24
 801f04e:	4659      	mov	r1, fp
 801f050:	4638      	mov	r0, r7
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f052:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f056:	eef8 4a64 	vcvt.f32.u32	s9, s9
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f05a:	ee87 6a26 	vdiv.f32	s12, s14, s13
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f05e:	ee84 7aa6 	vdiv.f32	s14, s9, s13
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f062:	ee67 7a85 	vmul.f32	s15, s15, s10
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f066:	ee26 6a05 	vmul.f32	s12, s12, s10
		float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f06a:	ee67 7aa5 	vmul.f32	s15, s15, s11
		float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f06e:	ee26 6a25 	vmul.f32	s12, s12, s11
		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 801f072:	ee63 6ae7 	vnmul.f32	s13, s7, s15
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f076:	ee27 7a05 	vmul.f32	s14, s14, s10
		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 801f07a:	eee6 6a03 	vfma.f32	s13, s12, s6
		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 801f07e:	ee27 7a25 	vmul.f32	s14, s14, s11
		m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;
 801f082:	ee24 6a47 	vnmul.f32	s12, s8, s14
		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 801f086:	eee7 6a63 	vfms.f32	s13, s14, s7
		m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;
 801f08a:	eea7 6a84 	vfma.f32	s12, s15, s8
		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 801f08e:	edc4 6a0b 	vstr	s13, [r4, #44]	; 0x2c
		m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;
 801f092:	ed84 6a0c 	vstr	s12, [r4, #48]	; 0x30
		utils_fast_sincos_better(m_motor_state.phase, &s, &c);
 801f096:	ed94 0a04 	vldr	s0, [r4, #16]
 801f09a:	f7f6 fea9 	bl	8015df0 <utils_fast_sincos_better>
		float vd_tmp = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
 801f09e:	ed94 4a0b 	vldr	s8, [r4, #44]	; 0x2c
 801f0a2:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
		float vq_tmp = c * m_motor_state.v_beta  - s * m_motor_state.v_alpha;
 801f0a6:	edd4 4a0c 	vldr	s9, [r4, #48]	; 0x30
 801f0aa:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
		UTILS_NAN_ZERO(m_motor_state.vd);
 801f0ae:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
 801f0b2:	edd4 5a13 	vldr	s11, [r4, #76]	; 0x4c
		float vd_tmp = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
 801f0b6:	ed9d 6a07 	vldr	s12, [sp, #28]
 801f0ba:	eddd 6a06 	vldr	s13, [sp, #24]
		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801f0be:	499e      	ldr	r1, [pc, #632]	; (801f338 <mcpwm_foc_adc_int_handler+0x4b8>)
 801f0c0:	489e      	ldr	r0, [pc, #632]	; (801f33c <mcpwm_foc_adc_int_handler+0x4bc>)
		UTILS_NAN_ZERO(m_motor_state.vd);
 801f0c2:	eeb4 5a65 	vcmp.f32	s10, s11
 801f0c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f0ca:	bf08      	it	eq
 801f0cc:	6ce3      	ldreq	r3, [r4, #76]	; 0x4c
		UTILS_LP_FAST(m_motor_state.vd, vd_tmp, 0.2);
 801f0ce:	ed9f 5a9c 	vldr	s10, [pc, #624]	; 801f340 <mcpwm_foc_adc_int_handler+0x4c0>
		m_motor_state.mod_d = m_motor_state.vd / ((2.0 / 3.0) * m_motor_state.v_bus);
 801f0d2:	eddf 5a97 	vldr	s11, [pc, #604]	; 801f330 <mcpwm_foc_adc_int_handler+0x4b0>
		UTILS_NAN_ZERO(m_motor_state.vd);
 801f0d6:	bf18      	it	ne
 801f0d8:	2300      	movne	r3, #0
		float vd_tmp = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
 801f0da:	ee27 7a06 	vmul.f32	s14, s14, s12
		float vq_tmp = c * m_motor_state.v_beta  - s * m_motor_state.v_alpha;
 801f0de:	ee67 7ac6 	vnmul.f32	s15, s15, s12
		UTILS_NAN_ZERO(m_motor_state.vd);
 801f0e2:	64e3      	str	r3, [r4, #76]	; 0x4c
		UTILS_NAN_ZERO(m_motor_state.vq);
 801f0e4:	ed94 6a14 	vldr	s12, [r4, #80]	; 0x50
		float vd_tmp = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
 801f0e8:	eea4 7a26 	vfma.f32	s14, s8, s13
		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801f0ec:	464a      	mov	r2, r9
		float vq_tmp = c * m_motor_state.v_beta  - s * m_motor_state.v_alpha;
 801f0ee:	eee6 7aa4 	vfma.f32	s15, s13, s9
		UTILS_NAN_ZERO(m_motor_state.vq);
 801f0f2:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 801f0f6:	eeb4 6a66 	vcmp.f32	s12, s13
 801f0fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f0fe:	bf0c      	ite	eq
 801f100:	6d23      	ldreq	r3, [r4, #80]	; 0x50
 801f102:	2300      	movne	r3, #0
 801f104:	6523      	str	r3, [r4, #80]	; 0x50
		UTILS_LP_FAST(m_motor_state.vd, vd_tmp, 0.2);
 801f106:	ed94 6a13 	vldr	s12, [r4, #76]	; 0x4c
 801f10a:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
 801f10e:	ee36 7a47 	vsub.f32	s14, s12, s14
		m_motor_state.i_alpha = 0.0;
 801f112:	2300      	movs	r3, #0
		UTILS_LP_FAST(m_motor_state.vd, vd_tmp, 0.2);
 801f114:	eee7 6a45 	vfms.f32	s13, s14, s10
		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801f118:	eeb0 2a48 	vmov.f32	s4, s16
		UTILS_LP_FAST(m_motor_state.vd, vd_tmp, 0.2);
 801f11c:	edc4 6a13 	vstr	s13, [r4, #76]	; 0x4c
		UTILS_LP_FAST(m_motor_state.vq, vq_tmp, 0.2);
 801f120:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 801f124:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
 801f128:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801f12c:	eea7 7ac5 	vfms.f32	s14, s15, s10
 801f130:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
		m_motor_state.vd_int = m_motor_state.vd;
 801f134:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
 801f136:	6566      	str	r6, [r4, #84]	; 0x54
		m_motor_state.vq_int = m_motor_state.vq;
 801f138:	6d26      	ldr	r6, [r4, #80]	; 0x50
 801f13a:	65a6      	str	r6, [r4, #88]	; 0x58
		m_motor_state.mod_d = m_motor_state.vd / ((2.0 / 3.0) * m_motor_state.v_bus);
 801f13c:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
 801f140:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
 801f144:	ee27 7a25 	vmul.f32	s14, s14, s11
 801f148:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801f14c:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
		m_motor_state.mod_q = m_motor_state.vq / ((2.0 / 3.0) * m_motor_state.v_bus);
 801f150:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 801f154:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 801f158:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801f15c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801f160:	ed84 7a0e 	vstr	s14, [r4, #56]	; 0x38
		m_motor_state.i_alpha = 0.0;
 801f164:	6163      	str	r3, [r4, #20]
		m_motor_state.i_beta = 0.0;
 801f166:	61a3      	str	r3, [r4, #24]
		m_motor_state.id = 0.0;
 801f168:	63e3      	str	r3, [r4, #60]	; 0x3c
		m_motor_state.iq = 0.0;
 801f16a:	6423      	str	r3, [r4, #64]	; 0x40
		m_motor_state.id_filter = 0.0;
 801f16c:	6463      	str	r3, [r4, #68]	; 0x44
		m_motor_state.iq_filter = 0.0;
 801f16e:	64a3      	str	r3, [r4, #72]	; 0x48
		m_motor_state.i_bus = 0.0;
 801f170:	6263      	str	r3, [r4, #36]	; 0x24
		m_motor_state.i_abs = 0.0;
 801f172:	61e3      	str	r3, [r4, #28]
		m_motor_state.i_abs_filter = 0.0;
 801f174:	6223      	str	r3, [r4, #32]
		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801f176:	ed94 0a0b 	vldr	s0, [r4, #44]	; 0x2c
 801f17a:	edd4 0a0c 	vldr	s1, [r4, #48]	; 0x30
 801f17e:	ed94 1a05 	vldr	s2, [r4, #20]
 801f182:	edd4 1a06 	vldr	s3, [r4, #24]
 801f186:	f7ff fd83 	bl	801ec90 <observer_update>
		switch (m_conf->foc_sensor_mode) {
 801f18a:	682b      	ldr	r3, [r5, #0]
 801f18c:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
 801f190:	b2db      	uxtb	r3, r3
 801f192:	2b01      	cmp	r3, #1
 801f194:	f000 8575 	beq.w	801fc82 <mcpwm_foc_adc_int_handler+0xe02>
 801f198:	f0c0 856d 	bcc.w	801fc76 <mcpwm_foc_adc_int_handler+0xdf6>
 801f19c:	2b02      	cmp	r3, #2
			m_phase_now_observer = correct_hall(m_phase_now_observer, m_pll_speed, dt);
 801f19e:	4e69      	ldr	r6, [pc, #420]	; (801f344 <mcpwm_foc_adc_int_handler+0x4c4>)
		switch (m_conf->foc_sensor_mode) {
 801f1a0:	f000 8471 	beq.w	801fa86 <mcpwm_foc_adc_int_handler+0xc06>
 801f1a4:	f10d 0910 	add.w	r9, sp, #16
 801f1a8:	f10d 0a14 	add.w	sl, sp, #20
	m_motor_state.duty_now = SIGN(m_motor_state.vq) *
 801f1ac:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
			sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
 801f1b0:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
 801f1b4:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
					m_motor_state.mod_q * m_motor_state.mod_q) / SQRT3_BY_2;
 801f1b8:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 801f1bc:	ed94 6a0e 	vldr	s12, [r4, #56]	; 0x38
 801f1c0:	ee20 0a06 	vmul.f32	s0, s0, s12
	m_motor_state.duty_now = SIGN(m_motor_state.vq) *
 801f1c4:	eef5 6ac0 	vcmpe.f32	s13, #0.0
			sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
 801f1c8:	eea7 0a27 	vfma.f32	s0, s14, s15
	m_motor_state.duty_now = SIGN(m_motor_state.vq) *
 801f1cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f1d0:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
 801f1d4:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 801f1d8:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801f1dc:	bf48      	it	mi
 801f1de:	eef0 9a49 	vmovmi.f32	s19, s18
 801f1e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
 801f1e6:	eeb1 9ac0 	vsqrt.f32	s18, s0
 801f1ea:	f100 87f7 	bmi.w	80201dc <mcpwm_foc_adc_int_handler+0x135c>
	UTILS_NAN_ZERO(*phase_var);
 801f1ee:	4b56      	ldr	r3, [pc, #344]	; (801f348 <mcpwm_foc_adc_int_handler+0x4c8>)
	float delta_theta = phase - *phase_var;
 801f1f0:	9301      	str	r3, [sp, #4]
	utils_norm_angle_rad(&delta_theta);
 801f1f2:	4638      	mov	r0, r7
					m_motor_state.mod_q * m_motor_state.mod_q) / SQRT3_BY_2;
 801f1f4:	ed9f 7a55 	vldr	s14, [pc, #340]	; 801f34c <mcpwm_foc_adc_int_handler+0x4cc>
	m_motor_state.duty_now = SIGN(m_motor_state.vq) *
 801f1f8:	ee29 9a29 	vmul.f32	s18, s18, s19
					m_motor_state.mod_q * m_motor_state.mod_q) / SQRT3_BY_2;
 801f1fc:	eec9 7a07 	vdiv.f32	s15, s18, s14
	m_motor_state.duty_now = SIGN(m_motor_state.vq) *
 801f200:	edc4 7a03 	vstr	s15, [r4, #12]
	pll_run(m_motor_state.phase, dt, &m_pll_phase, &m_pll_speed);
 801f204:	edd4 7a04 	vldr	s15, [r4, #16]
	UTILS_NAN_ZERO(*phase_var);
 801f208:	edd3 6a00 	vldr	s13, [r3]
 801f20c:	ed93 7a00 	vldr	s14, [r3]
 801f210:	eef4 6a47 	vcmp.f32	s13, s14
 801f214:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f218:	bf0c      	ite	eq
 801f21a:	681a      	ldreq	r2, [r3, #0]
 801f21c:	2200      	movne	r2, #0
 801f21e:	601a      	str	r2, [r3, #0]
	float delta_theta = phase - *phase_var;
 801f220:	ed93 7a00 	vldr	s14, [r3]
 801f224:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801f228:	edcd 7a07 	vstr	s15, [sp, #28]
	utils_norm_angle_rad(&delta_theta);
 801f22c:	f7f6 fbf8 	bl	8015a20 <utils_norm_angle_rad>
	UTILS_NAN_ZERO(*speed_var);
 801f230:	ed96 7a00 	vldr	s14, [r6]
 801f234:	edd6 7a00 	vldr	s15, [r6]
	*phase_var += (*speed_var + m_conf->foc_pll_kp * delta_theta) * dt;
 801f238:	682a      	ldr	r2, [r5, #0]
 801f23a:	eddd 6a07 	vldr	s13, [sp, #28]
	UTILS_NAN_ZERO(*speed_var);
 801f23e:	9b01      	ldr	r3, [sp, #4]
	utils_norm_angle_rad((float*)phase_var);
 801f240:	4841      	ldr	r0, [pc, #260]	; (801f348 <mcpwm_foc_adc_int_handler+0x4c8>)
	UTILS_NAN_ZERO(*speed_var);
 801f242:	eeb4 7a67 	vcmp.f32	s14, s15
 801f246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f24a:	bf0c      	ite	eq
 801f24c:	6831      	ldreq	r1, [r6, #0]
 801f24e:	2100      	movne	r1, #0
 801f250:	6031      	str	r1, [r6, #0]
	*phase_var += (*speed_var + m_conf->foc_pll_kp * delta_theta) * dt;
 801f252:	ed96 7a00 	vldr	s14, [r6]
 801f256:	ed92 6a35 	vldr	s12, [r2, #212]	; 0xd4
 801f25a:	edd3 7a00 	vldr	s15, [r3]
 801f25e:	eea6 7a26 	vfma.f32	s14, s12, s13
 801f262:	eee8 7a07 	vfma.f32	s15, s16, s14
 801f266:	edc3 7a00 	vstr	s15, [r3]
	utils_norm_angle_rad((float*)phase_var);
 801f26a:	f7f6 fbd9 	bl	8015a20 <utils_norm_angle_rad>
	*speed_var += m_conf->foc_pll_ki * delta_theta * dt;
 801f26e:	682b      	ldr	r3, [r5, #0]
 801f270:	eddd 6a07 	vldr	s13, [sp, #28]
 801f274:	ed93 7a36 	vldr	s14, [r3, #216]	; 0xd8
 801f278:	edd6 7a00 	vldr	s15, [r6]
 801f27c:	ee27 7a26 	vmul.f32	s14, s14, s13
	utils_norm_angle_rad(&ph_tmp);
 801f280:	4648      	mov	r0, r9
	*speed_var += m_conf->foc_pll_ki * delta_theta * dt;
 801f282:	eee8 7a07 	vfma.f32	s15, s16, s14
 801f286:	edc6 7a00 	vstr	s15, [r6]
	float ph_tmp = m_motor_state.phase;
 801f28a:	6923      	ldr	r3, [r4, #16]
 801f28c:	9304      	str	r3, [sp, #16]
	utils_norm_angle_rad(&ph_tmp);
 801f28e:	f7f6 fbc7 	bl	8015a20 <utils_norm_angle_rad>
	int step = (int)floorf((ph_tmp + M_PI) / (2.0 * M_PI) * 6.0);
 801f292:	eddd 7a04 	vldr	s15, [sp, #16]
 801f296:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 801f350 <mcpwm_foc_adc_int_handler+0x4d0>
 801f29a:	eddf 6a2e 	vldr	s13, [pc, #184]	; 801f354 <mcpwm_foc_adc_int_handler+0x4d4>
 801f29e:	ee77 7a87 	vadd.f32	s15, s15, s14
 801f2a2:	eeb1 7a08 	vmov.f32	s14, #24	; 0x40c00000  6.0
 801f2a6:	ee87 0aa6 	vdiv.f32	s0, s15, s13
 801f2aa:	ee20 0a07 	vmul.f32	s0, s0, s14
 801f2ae:	f005 fcf7 	bl	8024ca0 <floorf>
 801f2b2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
	utils_truncate_number_int(&step, 0, 5);
 801f2b6:	2205      	movs	r2, #5
 801f2b8:	2100      	movs	r1, #0
 801f2ba:	4650      	mov	r0, sl
	int step = (int)floorf((ph_tmp + M_PI) / (2.0 * M_PI) * 6.0);
 801f2bc:	ed8d 0a05 	vstr	s0, [sp, #20]
	utils_truncate_number_int(&step, 0, 5);
 801f2c0:	f7f6 fbf6 	bl	8015ab0 <utils_truncate_number_int>
	int diff = step - step_last;
 801f2c4:	4a24      	ldr	r2, [pc, #144]	; (801f358 <mcpwm_foc_adc_int_handler+0x4d8>)
 801f2c6:	9b05      	ldr	r3, [sp, #20]
 801f2c8:	6811      	ldr	r1, [r2, #0]
	step_last = step;
 801f2ca:	6013      	str	r3, [r2, #0]
	int diff = step - step_last;
 801f2cc:	1a5b      	subs	r3, r3, r1
	if (diff > 3) {
 801f2ce:	2b03      	cmp	r3, #3
 801f2d0:	f340 80dc 	ble.w	801f48c <mcpwm_foc_adc_int_handler+0x60c>
		diff -= 6;
 801f2d4:	3b06      	subs	r3, #6
	m_tachometer += diff;
 801f2d6:	4821      	ldr	r0, [pc, #132]	; (801f35c <mcpwm_foc_adc_int_handler+0x4dc>)
	m_tachometer_abs += abs(diff);
 801f2d8:	4921      	ldr	r1, [pc, #132]	; (801f360 <mcpwm_foc_adc_int_handler+0x4e0>)
	m_tachometer += diff;
 801f2da:	6802      	ldr	r2, [r0, #0]
 801f2dc:	441a      	add	r2, r3
 801f2de:	6002      	str	r2, [r0, #0]
	m_tachometer_abs += abs(diff);
 801f2e0:	2b00      	cmp	r3, #0
 801f2e2:	680a      	ldr	r2, [r1, #0]
 801f2e4:	bfb8      	it	lt
 801f2e6:	425b      	neglt	r3, r3
 801f2e8:	4413      	add	r3, r2
 801f2ea:	600b      	str	r3, [r1, #0]
	if (encoder_is_configured()) {
 801f2ec:	f7fb fce0 	bl	801acb0 <encoder_is_configured>
 801f2f0:	b928      	cbnz	r0, 801f2fe <mcpwm_foc_adc_int_handler+0x47e>
		angle_now = m_motor_state.phase * (180.0 / M_PI);
 801f2f2:	edd4 8a04 	vldr	s17, [r4, #16]
 801f2f6:	eddf 7a1b 	vldr	s15, [pc, #108]	; 801f364 <mcpwm_foc_adc_int_handler+0x4e4>
 801f2fa:	ee68 8aa7 	vmul.f32	s17, s17, s15
	if (m_conf->p_pid_ang_div > 0.98 && m_conf->p_pid_ang_div < 1.02) {
 801f2fe:	682b      	ldr	r3, [r5, #0]
 801f300:	eddf 7a19 	vldr	s15, [pc, #100]	; 801f368 <mcpwm_foc_adc_int_handler+0x4e8>
 801f304:	ed93 7a4e 	vldr	s14, [r3, #312]	; 0x138
 801f308:	e038      	b.n	801f37c <mcpwm_foc_adc_int_handler+0x4fc>
 801f30a:	bf00      	nop
 801f30c:	2000cda8 	.word	0x2000cda8
 801f310:	2000cddc 	.word	0x2000cddc
 801f314:	3a534067 	.word	0x3a534067
 801f318:	4195d174 	.word	0x4195d174
 801f31c:	3dcccccd 	.word	0x3dcccccd
 801f320:	00000000 	.word	0x00000000
 801f324:	457ff000 	.word	0x457ff000
 801f328:	40533333 	.word	0x40533333
 801f32c:	3eaaaaab 	.word	0x3eaaaaab
 801f330:	3f2aaaab 	.word	0x3f2aaaab
 801f334:	3f13cd3a 	.word	0x3f13cd3a
 801f338:	2000ce40 	.word	0x2000ce40
 801f33c:	2000ce3c 	.word	0x2000ce3c
 801f340:	3e4ccccd 	.word	0x3e4ccccd
 801f344:	2000ce68 	.word	0x2000ce68
 801f348:	2000ce64 	.word	0x2000ce64
 801f34c:	3f5db3d7 	.word	0x3f5db3d7
 801f350:	40490fdb 	.word	0x40490fdb
 801f354:	40c90fdb 	.word	0x40c90fdb
 801f358:	2000ceb0 	.word	0x2000ceb0
 801f35c:	2000ce90 	.word	0x2000ce90
 801f360:	2000ce94 	.word	0x2000ce94
 801f364:	42652ee0 	.word	0x42652ee0
 801f368:	3f7ae148 	.word	0x3f7ae148
 801f36c:	2000cea4 	.word	0x2000cea4
 801f370:	2000ce8c 	.word	0x2000ce8c
 801f374:	2000ce54 	.word	0x2000ce54
 801f378:	3f828f5c 	.word	0x3f828f5c
 801f37c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801f380:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f384:	dd69      	ble.n	801f45a <mcpwm_foc_adc_int_handler+0x5da>
 801f386:	ed93 7a4e 	vldr	s14, [r3, #312]	; 0x138
 801f38a:	ed5f 7a05 	vldr	s15, [pc, #-20]	; 801f378 <mcpwm_foc_adc_int_handler+0x4f8>
 801f38e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801f392:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f396:	d560      	bpl.n	801f45a <mcpwm_foc_adc_int_handler+0x5da>
		m_pos_pid_now = angle_now;
 801f398:	4c3e      	ldr	r4, [pc, #248]	; (801f494 <mcpwm_foc_adc_int_handler+0x614>)
 801f39a:	edc4 8a00 	vstr	s17, [r4]
	if (m_state == MC_STATE_RUNNING) {
 801f39e:	f898 3000 	ldrb.w	r3, [r8]
 801f3a2:	2b02      	cmp	r3, #2
 801f3a4:	f000 835a 	beq.w	801fa5c <mcpwm_foc_adc_int_handler+0xbdc>
	mc_interface_mc_timer_isr();
 801f3a8:	f7fd f852 	bl	801c450 <mc_interface_mc_timer_isr>
	last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0;
 801f3ac:	4b3a      	ldr	r3, [pc, #232]	; (801f498 <mcpwm_foc_adc_int_handler+0x618>)
 801f3ae:	eddf 6a3b 	vldr	s13, [pc, #236]	; 801f49c <mcpwm_foc_adc_int_handler+0x61c>
 801f3b2:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 801f3b6:	4b3a      	ldr	r3, [pc, #232]	; (801f4a0 <mcpwm_foc_adc_int_handler+0x620>)
 801f3b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f3bc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801f3c0:	ed83 7a00 	vstr	s14, [r3]
}
 801f3c4:	b009      	add	sp, #36	; 0x24
 801f3c6:	ecbd 8b06 	vpop	{d8-d10}
 801f3ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			TIMER_UPDATE_DUTY_SAMP(0, 0, 0, samp_time);
 801f3ce:	6810      	ldr	r0, [r2, #0]
 801f3d0:	4934      	ldr	r1, [pc, #208]	; (801f4a4 <mcpwm_foc_adc_int_handler+0x624>)
 801f3d2:	f040 0002 	orr.w	r0, r0, #2
 801f3d6:	6010      	str	r0, [r2, #0]
 801f3d8:	6808      	ldr	r0, [r1, #0]
		const uint32_t samp_time = duty_cnt - MCPWM_FOC_INDUCTANCE_SAMPLE_CNT_OFFSET;
 801f3da:	3b0a      	subs	r3, #10
			TIMER_UPDATE_DUTY_SAMP(0, 0, 0, samp_time);
 801f3dc:	f040 0002 	orr.w	r0, r0, #2
 801f3e0:	6008      	str	r0, [r1, #0]
 801f3e2:	6354      	str	r4, [r2, #52]	; 0x34
 801f3e4:	6394      	str	r4, [r2, #56]	; 0x38
 801f3e6:	63d4      	str	r4, [r2, #60]	; 0x3c
 801f3e8:	634b      	str	r3, [r1, #52]	; 0x34
 801f3ea:	6813      	ldr	r3, [r2, #0]
 801f3ec:	f023 0302 	bic.w	r3, r3, #2
 801f3f0:	6013      	str	r3, [r2, #0]
 801f3f2:	680b      	ldr	r3, [r1, #0]
 801f3f4:	f023 0302 	bic.w	r3, r3, #2
 801f3f8:	600b      	str	r3, [r1, #0]
			start_pwm_hw();
 801f3fa:	f7fd fbf9 	bl	801cbf0 <start_pwm_hw>
 801f3fe:	f8d8 7000 	ldr.w	r7, [r8]
		inductance_state++;
 801f402:	3701      	adds	r7, #1
 801f404:	f8c8 7000 	str.w	r7, [r8]
}
 801f408:	b009      	add	sp, #36	; 0x24
 801f40a:	ecbd 8b06 	vpop	{d8-d10}
 801f40e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		enc_ang = encoder_read_deg();
 801f412:	f7fb fc55 	bl	801acc0 <encoder_read_deg>
		if (m_conf->foc_encoder_inverted) {
 801f416:	682b      	ldr	r3, [r5, #0]
		float phase_tmp = enc_ang;
 801f418:	ed8d 0a07 	vstr	s0, [sp, #28]
		if (m_conf->foc_encoder_inverted) {
 801f41c:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
		enc_ang = encoder_read_deg();
 801f420:	eef0 8a40 	vmov.f32	s17, s0
		if (m_conf->foc_encoder_inverted) {
 801f424:	2a00      	cmp	r2, #0
 801f426:	f040 8329 	bne.w	801fa7c <mcpwm_foc_adc_int_handler+0xbfc>
 801f42a:	eeb0 7a40 	vmov.f32	s14, s0
		phase_tmp *= m_conf->foc_encoder_ratio;
 801f42e:	edd3 6a2f 	vldr	s13, [r3, #188]	; 0xbc
		phase_tmp -= m_conf->foc_encoder_offset;
 801f432:	edd3 7a2d 	vldr	s15, [r3, #180]	; 0xb4
 801f436:	eed6 7a87 	vfnms.f32	s15, s13, s14
 801f43a:	af08      	add	r7, sp, #32
 801f43c:	ed67 7a01 	vstmdb	r7!, {s15}
		utils_norm_angle((float*)&phase_tmp);
 801f440:	4638      	mov	r0, r7
 801f442:	f7f6 facd 	bl	80159e0 <utils_norm_angle>
		m_phase_now_encoder = phase_tmp * (M_PI / 180.0);
 801f446:	eddd 7a07 	vldr	s15, [sp, #28]
 801f44a:	ed9f 7a17 	vldr	s14, [pc, #92]	; 801f4a8 <mcpwm_foc_adc_int_handler+0x628>
 801f44e:	4b17      	ldr	r3, [pc, #92]	; (801f4ac <mcpwm_foc_adc_int_handler+0x62c>)
 801f450:	ee67 7a87 	vmul.f32	s15, s15, s14
 801f454:	edc3 7a00 	vstr	s15, [r3]
 801f458:	e5c8      	b.n	801efec <mcpwm_foc_adc_int_handler+0x16c>
		float diff_f = utils_angle_difference(angle_now, angle_last);
 801f45a:	4e15      	ldr	r6, [pc, #84]	; (801f4b0 <mcpwm_foc_adc_int_handler+0x630>)
		m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
 801f45c:	4c0d      	ldr	r4, [pc, #52]	; (801f494 <mcpwm_foc_adc_int_handler+0x614>)
		float diff_f = utils_angle_difference(angle_now, angle_last);
 801f45e:	edd6 0a00 	vldr	s1, [r6]
 801f462:	eeb0 0a68 	vmov.f32	s0, s17
 801f466:	f7f6 fb83 	bl	8015b70 <utils_angle_difference>
		m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
 801f46a:	682b      	ldr	r3, [r5, #0]
		angle_last = angle_now;
 801f46c:	edc6 8a00 	vstr	s17, [r6]
		m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
 801f470:	ed93 7a4e 	vldr	s14, [r3, #312]	; 0x138
 801f474:	edd4 7a00 	vldr	s15, [r4]
 801f478:	ee80 0a07 	vdiv.f32	s0, s0, s14
		utils_norm_angle((float*)&m_pos_pid_now);
 801f47c:	4620      	mov	r0, r4
		m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
 801f47e:	ee30 0a27 	vadd.f32	s0, s0, s15
 801f482:	ed84 0a00 	vstr	s0, [r4]
		utils_norm_angle((float*)&m_pos_pid_now);
 801f486:	f7f6 faab 	bl	80159e0 <utils_norm_angle>
 801f48a:	e788      	b.n	801f39e <mcpwm_foc_adc_int_handler+0x51e>
	} else if (diff < -2) {
 801f48c:	1c9a      	adds	r2, r3, #2
		diff += 6;
 801f48e:	bfb8      	it	lt
 801f490:	3306      	addlt	r3, #6
 801f492:	e720      	b.n	801f2d6 <mcpwm_foc_adc_int_handler+0x456>
 801f494:	2000ce6c 	.word	0x2000ce6c
 801f498:	40001800 	.word	0x40001800
 801f49c:	4b189680 	.word	0x4b189680
 801f4a0:	2000cda4 	.word	0x2000cda4
 801f4a4:	40010400 	.word	0x40010400
 801f4a8:	3c8efa35 	.word	0x3c8efa35
 801f4ac:	2000ce4c 	.word	0x2000ce4c
 801f4b0:	2000cd88 	.word	0x2000cd88
 801f4b4:	3da50a50 	.word	0x3da50a50
 801f4b8:	3f93cd3a 	.word	0x3f93cd3a
 801f4bc:	3f13cd3a 	.word	0x3f13cd3a
	float ib = ADC_curr_norm_value[1] * FAC_CURRENT;
 801f4c0:	ee07 aa90 	vmov	s15, sl
	float ia = ADC_curr_norm_value[0] * FAC_CURRENT;
 801f4c4:	ed5f 6a05 	vldr	s13, [pc, #-20]	; 801f4b4 <mcpwm_foc_adc_int_handler+0x634>
		m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;
 801f4c8:	ed1f 5a05 	vldr	s10, [pc, #-20]	; 801f4b8 <mcpwm_foc_adc_int_handler+0x638>
 801f4cc:	ed5f 5a05 	vldr	s11, [pc, #-20]	; 801f4bc <mcpwm_foc_adc_int_handler+0x63c>
		float id_set_tmp = m_id_set;
 801f4d0:	49ea      	ldr	r1, [pc, #936]	; (801f87c <mcpwm_foc_adc_int_handler+0x9fc>)
		float iq_set_tmp = m_iq_set;
 801f4d2:	4aeb      	ldr	r2, [pc, #940]	; (801f880 <mcpwm_foc_adc_int_handler+0xa00>)
		m_motor_state.max_duty = m_conf->l_max_duty;
 801f4d4:	682b      	ldr	r3, [r5, #0]
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f4d6:	f8df a3dc 	ldr.w	sl, [pc, #988]	; 801f8b4 <mcpwm_foc_adc_int_handler+0xa34>
 801f4da:	ed9f 6aea 	vldr	s12, [pc, #936]	; 801f884 <mcpwm_foc_adc_int_handler+0xa04>
	float ia = ADC_curr_norm_value[0] * FAC_CURRENT;
 801f4de:	ee07 9a10 	vmov	s14, r9
	float ib = ADC_curr_norm_value[1] * FAC_CURRENT;
 801f4e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float ia = ADC_curr_norm_value[0] * FAC_CURRENT;
 801f4e6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	float ib = ADC_curr_norm_value[1] * FAC_CURRENT;
 801f4ea:	ee67 7aa6 	vmul.f32	s15, s15, s13
	float ia = ADC_curr_norm_value[0] * FAC_CURRENT;
 801f4ee:	ee27 7a26 	vmul.f32	s14, s14, s13
		m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;
 801f4f2:	ee67 7a85 	vmul.f32	s15, s15, s10
		m_motor_state.i_alpha = ia;
 801f4f6:	ed84 7a05 	vstr	s14, [r4, #20]
		m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;
 801f4fa:	eee7 7a25 	vfma.f32	s15, s14, s11
		utils_truncate_number(&duty_filtered, -1.0, 1.0);
 801f4fe:	4650      	mov	r0, sl
		bool control_duty = m_control_mode == CONTROL_MODE_DUTY;
 801f500:	f8df 93b4 	ldr.w	r9, [pc, #948]	; 801f8b8 <mcpwm_foc_adc_int_handler+0xa38>
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f504:	ed9a 7a00 	vldr	s14, [sl]
		m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;
 801f508:	edc4 7a06 	vstr	s15, [r4, #24]
		const float duty_abs = fabsf(m_motor_state.duty_now);
 801f50c:	edd4 6a03 	vldr	s13, [r4, #12]
		float id_set_tmp = m_id_set;
 801f510:	6809      	ldr	r1, [r1, #0]
		float iq_set_tmp = m_iq_set;
 801f512:	6812      	ldr	r2, [r2, #0]
 801f514:	9204      	str	r2, [sp, #16]
		m_motor_state.max_duty = m_conf->l_max_duty;
 801f516:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801f518:	60a3      	str	r3, [r4, #8]
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f51a:	edd4 7a03 	vldr	s15, [r4, #12]
		float id_set_tmp = m_id_set;
 801f51e:	9103      	str	r1, [sp, #12]
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f520:	ee77 7a67 	vsub.f32	s15, s14, s15
		utils_truncate_number(&duty_filtered, -1.0, 1.0);
 801f524:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f528:	eea7 7ac6 	vfms.f32	s14, s15, s12
		utils_truncate_number(&duty_filtered, -1.0, 1.0);
 801f52c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
		const float duty_abs = fabsf(m_motor_state.duty_now);
 801f530:	eeb0 9ae6 	vabs.f32	s18, s13
		UTILS_LP_FAST(duty_filtered, m_motor_state.duty_now, 0.1);
 801f534:	ed8a 7a00 	vstr	s14, [sl]
		utils_truncate_number(&duty_filtered, -1.0, 1.0);
 801f538:	f7f6 faa2 	bl	8015a80 <utils_truncate_number>
		float duty_set = m_duty_cycle_set;
 801f53c:	4bd2      	ldr	r3, [pc, #840]	; (801f888 <mcpwm_foc_adc_int_handler+0xa08>)
 801f53e:	edd3 7a00 	vldr	s15, [r3]
		bool control_duty = m_control_mode == CONTROL_MODE_DUTY;
 801f542:	f899 3000 	ldrb.w	r3, [r9]
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE
 801f546:	f899 2000 	ldrb.w	r2, [r9]
 801f54a:	2a03      	cmp	r2, #3
		bool control_duty = m_control_mode == CONTROL_MODE_DUTY;
 801f54c:	b2db      	uxtb	r3, r3
		if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE
 801f54e:	f000 82ad 	beq.w	801faac <mcpwm_foc_adc_int_handler+0xc2c>
		if (m_control_mode == CONTROL_MODE_SPEED &&
 801f552:	f899 2000 	ldrb.w	r2, [r9]
 801f556:	2a01      	cmp	r2, #1
 801f558:	f000 82fc 	beq.w	801fb54 <mcpwm_foc_adc_int_handler+0xcd4>
		if (control_duty) {
 801f55c:	2b00      	cmp	r3, #0
 801f55e:	f000 831a 	beq.w	801fb96 <mcpwm_foc_adc_int_handler+0xd16>
		} else if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE) {
 801f562:	f899 3000 	ldrb.w	r3, [r9]
 801f566:	2b03      	cmp	r3, #3
 801f568:	f000 8523 	beq.w	801ffb2 <mcpwm_foc_adc_int_handler+0x1132>
		if (!m_phase_override) {
 801f56c:	f8df a34c 	ldr.w	sl, [pc, #844]	; 801f8bc <mcpwm_foc_adc_int_handler+0xa3c>
 801f570:	f89a 3000 	ldrb.w	r3, [sl]
 801f574:	2b00      	cmp	r3, #0
 801f576:	f000 8479 	beq.w	801fe6c <mcpwm_foc_adc_int_handler+0xfec>
		switch (m_conf->foc_sensor_mode) {
 801f57a:	682a      	ldr	r2, [r5, #0]
 801f57c:	f892 30f8 	ldrb.w	r3, [r2, #248]	; 0xf8
 801f580:	b2db      	uxtb	r3, r3
 801f582:	2b01      	cmp	r3, #1
 801f584:	f000 84cd 	beq.w	801ff22 <mcpwm_foc_adc_int_handler+0x10a2>
 801f588:	f0c0 84b3 	bcc.w	801fef2 <mcpwm_foc_adc_int_handler+0x1072>
 801f58c:	2b02      	cmp	r3, #2
 801f58e:	f040 8427 	bne.w	801fde0 <mcpwm_foc_adc_int_handler+0xf60>
			m_phase_now_observer = correct_hall(m_phase_now_observer, m_pll_speed, dt);
 801f592:	f8df b32c 	ldr.w	fp, [pc, #812]	; 801f8c0 <mcpwm_foc_adc_int_handler+0xa40>
 801f596:	4ebd      	ldr	r6, [pc, #756]	; (801f88c <mcpwm_foc_adc_int_handler+0xa0c>)
 801f598:	ed9b 0a00 	vldr	s0, [fp]
 801f59c:	edd6 0a00 	vldr	s1, [r6]
 801f5a0:	eeb0 1a48 	vmov.f32	s2, s16
 801f5a4:	f7fd fbd4 	bl	801cd50 <correct_hall>
 801f5a8:	ed8b 0a00 	vstr	s0, [fp]
			m_motor_state.phase = m_phase_now_observer;
 801f5ac:	f8db 3000 	ldr.w	r3, [fp]
 801f5b0:	6123      	str	r3, [r4, #16]
			if (!m_phase_override) {
 801f5b2:	f89a 3000 	ldrb.w	r3, [sl]
 801f5b6:	b90b      	cbnz	r3, 801f5bc <mcpwm_foc_adc_int_handler+0x73c>
				id_set_tmp = 0.0;
 801f5b8:	2300      	movs	r3, #0
 801f5ba:	9303      	str	r3, [sp, #12]
		if (m_control_mode == CONTROL_MODE_HANDBRAKE) {
 801f5bc:	f899 3000 	ldrb.w	r3, [r9]
 801f5c0:	2b05      	cmp	r3, #5
 801f5c2:	f000 844f 	beq.w	801fe64 <mcpwm_foc_adc_int_handler+0xfe4>
		} else if (m_control_mode == CONTROL_MODE_OPENLOOP) {
 801f5c6:	f899 3000 	ldrb.w	r3, [r9]
 801f5ca:	2b06      	cmp	r3, #6
 801f5cc:	f000 8503 	beq.w	801ffd6 <mcpwm_foc_adc_int_handler+0x1156>
		if (m_phase_override) {
 801f5d0:	f89a 3000 	ldrb.w	r3, [sl]
 801f5d4:	b113      	cbz	r3, 801f5dc <mcpwm_foc_adc_int_handler+0x75c>
			m_motor_state.phase = m_phase_now_override;
 801f5d6:	4bae      	ldr	r3, [pc, #696]	; (801f890 <mcpwm_foc_adc_int_handler+0xa10>)
 801f5d8:	681b      	ldr	r3, [r3, #0]
 801f5da:	6123      	str	r3, [r4, #16]
		const float mod_q = m_motor_state.mod_q;
 801f5dc:	ed94 9a0e 	vldr	s18, [r4, #56]	; 0x38
		if (mod_q > 0.001) {
 801f5e0:	eddf 7aac 	vldr	s15, [pc, #688]	; 801f894 <mcpwm_foc_adc_int_handler+0xa14>
 801f5e4:	682b      	ldr	r3, [r5, #0]
 801f5e6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 801f5ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f5ee:	f300 844e 	bgt.w	801fe8e <mcpwm_foc_adc_int_handler+0x100e>
		} else if (mod_q < -0.001) {
 801f5f2:	eddf 7aa9 	vldr	s15, [pc, #676]	; 801f898 <mcpwm_foc_adc_int_handler+0xa18>
 801f5f6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 801f5fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f5fe:	f100 84c2 	bmi.w	801ff86 <mcpwm_foc_adc_int_handler+0x1106>
 801f602:	f10d 0910 	add.w	r9, sp, #16
		if (mod_q > 0.0) {
 801f606:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 801f60a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f60e:	f340 841c 	ble.w	801fe4a <mcpwm_foc_adc_int_handler+0xfca>
			utils_truncate_number(&iq_set_tmp, m_conf->lo_current_min, m_conf->lo_current_max);
 801f612:	ed93 0a1a 	vldr	s0, [r3, #104]	; 0x68
 801f616:	edd3 0a19 	vldr	s1, [r3, #100]	; 0x64
 801f61a:	4648      	mov	r0, r9
 801f61c:	f7f6 fa30 	bl	8015a80 <utils_truncate_number>
				utils_max_abs(m_conf->lo_current_max, m_conf->lo_current_min));
 801f620:	682b      	ldr	r3, [r5, #0]
			(2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f622:	eddf 9aac 	vldr	s19, [pc, #688]	; 801f8d4 <mcpwm_foc_adc_int_handler+0xa54>
		utils_saturate_vector_2d(&id_set_tmp, &iq_set_tmp,
 801f626:	ed93 0a19 	vldr	s0, [r3, #100]	; 0x64
 801f62a:	edd3 0a1a 	vldr	s1, [r3, #104]	; 0x68
			(2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f62e:	ed9f 9a9b 	vldr	s18, [pc, #620]	; 801f89c <mcpwm_foc_adc_int_handler+0xa1c>
		utils_saturate_vector_2d(&id_set_tmp, &iq_set_tmp,
 801f632:	f7f6 fc7d 	bl	8015f30 <utils_max_abs>
 801f636:	4649      	mov	r1, r9
 801f638:	a803      	add	r0, sp, #12
 801f63a:	f7f6 fb91 	bl	8015d60 <utils_saturate_vector_2d>
		m_motor_state.id_target = id_set_tmp;
 801f63e:	9a03      	ldr	r2, [sp, #12]
		m_motor_state.iq_target = iq_set_tmp;
 801f640:	9b04      	ldr	r3, [sp, #16]
		m_motor_state.id_target = id_set_tmp;
 801f642:	6022      	str	r2, [r4, #0]
	utils_fast_sincos_better(state_m->phase, &s, &c);
 801f644:	f10d 0a14 	add.w	sl, sp, #20
		m_motor_state.iq_target = iq_set_tmp;
 801f648:	6063      	str	r3, [r4, #4]
	utils_fast_sincos_better(state_m->phase, &s, &c);
 801f64a:	f10d 0b18 	add.w	fp, sp, #24
 801f64e:	4651      	mov	r1, sl
 801f650:	ed94 0a04 	vldr	s0, [r4, #16]
 801f654:	4658      	mov	r0, fp
 801f656:	f7f6 fbcb 	bl	8015df0 <utils_fast_sincos_better>
	float max_duty = fabsf(state_m->max_duty);
 801f65a:	edd4 7a02 	vldr	s15, [r4, #8]
	utils_truncate_number(&max_duty, 0.0, m_conf->l_max_duty);
 801f65e:	682b      	ldr	r3, [r5, #0]
 801f660:	ed9f 0a8f 	vldr	s0, [pc, #572]	; 801f8a0 <mcpwm_foc_adc_int_handler+0xa20>
	float max_duty = fabsf(state_m->max_duty);
 801f664:	eef0 7ae7 	vabs.f32	s15, s15
 801f668:	edcd 7a07 	vstr	s15, [sp, #28]
	utils_truncate_number(&max_duty, 0.0, m_conf->l_max_duty);
 801f66c:	edd3 0a16 	vldr	s1, [r3, #88]	; 0x58
 801f670:	4638      	mov	r0, r7
 801f672:	f7f6 fa05 	bl	8015a80 <utils_truncate_number>
	state_m->id = c * state_m->i_alpha + s * state_m->i_beta;
 801f676:	ed94 7a05 	vldr	s14, [r4, #20]
 801f67a:	eddd 5a06 	vldr	s11, [sp, #24]
 801f67e:	edd4 6a06 	vldr	s13, [r4, #24]
 801f682:	eddd 7a05 	vldr	s15, [sp, #20]
	UTILS_LP_FAST(state_m->id_filter, state_m->id, MCPWM_FOC_I_FILTER_CONST);
 801f686:	ed9f 6a7f 	vldr	s12, [pc, #508]	; 801f884 <mcpwm_foc_adc_int_handler+0xa04>
	state_m->vd = state_m->vd_int + Ierr_d * m_conf->foc_current_kp;
 801f68a:	682b      	ldr	r3, [r5, #0]
	utils_saturate_vector_2d((float*)&state_m->vd, (float*)&state_m->vq,
 801f68c:	4985      	ldr	r1, [pc, #532]	; (801f8a4 <mcpwm_foc_adc_int_handler+0xa24>)
	state_m->id = c * state_m->i_alpha + s * state_m->i_beta;
 801f68e:	ee66 6aa5 	vmul.f32	s13, s13, s11
	utils_saturate_vector_2d((float*)&state_m->vd, (float*)&state_m->vq,
 801f692:	1f08      	subs	r0, r1, #4
	state_m->id = c * state_m->i_alpha + s * state_m->i_beta;
 801f694:	eee7 6a27 	vfma.f32	s13, s14, s15
 801f698:	edc4 6a0f 	vstr	s13, [r4, #60]	; 0x3c
	state_m->iq = c * state_m->i_beta  - s * state_m->i_alpha;
 801f69c:	edd4 6a06 	vldr	s13, [r4, #24]
 801f6a0:	ed94 7a05 	vldr	s14, [r4, #20]
 801f6a4:	ee27 7a65 	vnmul.f32	s14, s14, s11
 801f6a8:	eea7 7aa6 	vfma.f32	s14, s15, s13
 801f6ac:	ed84 7a10 	vstr	s14, [r4, #64]	; 0x40
	UTILS_LP_FAST(state_m->id_filter, state_m->id, MCPWM_FOC_I_FILTER_CONST);
 801f6b0:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
 801f6b4:	edd4 6a0f 	vldr	s13, [r4, #60]	; 0x3c
 801f6b8:	edd4 7a11 	vldr	s15, [r4, #68]	; 0x44
 801f6bc:	ee37 7a66 	vsub.f32	s14, s14, s13
 801f6c0:	eee7 7a46 	vfms.f32	s15, s14, s12
 801f6c4:	edc4 7a11 	vstr	s15, [r4, #68]	; 0x44
	UTILS_LP_FAST(state_m->iq_filter, state_m->iq, MCPWM_FOC_I_FILTER_CONST);
 801f6c8:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
 801f6cc:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
 801f6d0:	edd4 7a12 	vldr	s15, [r4, #72]	; 0x48
 801f6d4:	ee37 7a66 	vsub.f32	s14, s14, s13
 801f6d8:	eee7 7a46 	vfms.f32	s15, s14, s12
 801f6dc:	edc4 7a12 	vstr	s15, [r4, #72]	; 0x48
	float Ierr_d = state_m->id_target - state_m->id;
 801f6e0:	edd4 6a00 	vldr	s13, [r4]
 801f6e4:	ed94 5a0f 	vldr	s10, [r4, #60]	; 0x3c
	float Ierr_q = state_m->iq_target - state_m->iq;
 801f6e8:	ed94 7a01 	vldr	s14, [r4, #4]
 801f6ec:	edd4 5a10 	vldr	s11, [r4, #64]	; 0x40
	state_m->vd = state_m->vd_int + Ierr_d * m_conf->foc_current_kp;
 801f6f0:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
 801f6f4:	ed93 6a29 	vldr	s12, [r3, #164]	; 0xa4
	float Ierr_d = state_m->id_target - state_m->id;
 801f6f8:	ee76 6ac5 	vsub.f32	s13, s13, s10
	float Ierr_q = state_m->iq_target - state_m->iq;
 801f6fc:	ee37 7a65 	vsub.f32	s14, s14, s11
	state_m->vd = state_m->vd_int + Ierr_d * m_conf->foc_current_kp;
 801f700:	eee6 7a86 	vfma.f32	s15, s13, s12
 801f704:	edc4 7a13 	vstr	s15, [r4, #76]	; 0x4c
	state_m->vq = state_m->vq_int + Ierr_q * m_conf->foc_current_kp;
 801f708:	edd4 7a16 	vldr	s15, [r4, #88]	; 0x58
 801f70c:	ed93 6a29 	vldr	s12, [r3, #164]	; 0xa4
 801f710:	eee7 7a06 	vfma.f32	s15, s14, s12
 801f714:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
	state_m->vd_int += Ierr_d * (m_conf->foc_current_ki * dt);
 801f718:	ed93 6a2a 	vldr	s12, [r3, #168]	; 0xa8
 801f71c:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
 801f720:	ee28 6a06 	vmul.f32	s12, s16, s12
 801f724:	eee6 7a86 	vfma.f32	s15, s13, s12
 801f728:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
	state_m->vq_int += Ierr_q * (m_conf->foc_current_ki * dt);
 801f72c:	edd3 6a2a 	vldr	s13, [r3, #168]	; 0xa8
 801f730:	edd4 7a16 	vldr	s15, [r4, #88]	; 0x58
 801f734:	ee68 6a26 	vmul.f32	s13, s16, s13
 801f738:	eee7 7a26 	vfma.f32	s15, s14, s13
 801f73c:	edc4 7a16 	vstr	s15, [r4, #88]	; 0x58
			(2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f740:	ed9d 7a07 	vldr	s14, [sp, #28]
 801f744:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 801f748:	ee27 7a29 	vmul.f32	s14, s14, s19
 801f74c:	ee27 7a09 	vmul.f32	s14, s14, s18
	utils_saturate_vector_2d((float*)&state_m->vd, (float*)&state_m->vq,
 801f750:	ee27 0a00 	vmul.f32	s0, s14, s0
 801f754:	f7f6 fb04 	bl	8015d60 <utils_saturate_vector_2d>
	state_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);
 801f758:	ed94 6a13 	vldr	s12, [r4, #76]	; 0x4c
 801f75c:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
	utils_truncate_number_abs((float*)&state_m->vd_int, (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f760:	ed9d 7a07 	vldr	s14, [sp, #28]
 801f764:	4850      	ldr	r0, [pc, #320]	; (801f8a8 <mcpwm_foc_adc_int_handler+0xa28>)
	state_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);
 801f766:	ee67 7aa9 	vmul.f32	s15, s15, s19
	utils_truncate_number_abs((float*)&state_m->vd_int, (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f76a:	ee27 7a29 	vmul.f32	s14, s14, s19
	state_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);
 801f76e:	eec6 6a27 	vdiv.f32	s13, s12, s15
	utils_truncate_number_abs((float*)&state_m->vd_int, (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f772:	ee27 7a09 	vmul.f32	s14, s14, s18
	state_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);
 801f776:	edc4 6a0d 	vstr	s13, [r4, #52]	; 0x34
	state_m->mod_q = state_m->vq / ((2.0 / 3.0) * state_m->v_bus);
 801f77a:	ed94 6a14 	vldr	s12, [r4, #80]	; 0x50
 801f77e:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 801f782:	ee67 7aa9 	vmul.f32	s15, s15, s19
 801f786:	eec6 6a27 	vdiv.f32	s13, s12, s15
 801f78a:	edc4 6a0e 	vstr	s13, [r4, #56]	; 0x38
	utils_truncate_number_abs((float*)&state_m->vd_int, (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f78e:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 801f792:	ee27 0a00 	vmul.f32	s0, s14, s0
 801f796:	f7f6 f99b 	bl	8015ad0 <utils_truncate_number_abs>
	utils_truncate_number_abs((float*)&state_m->vq_int, (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus);
 801f79a:	eddd 7a07 	vldr	s15, [sp, #28]
 801f79e:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 801f7a2:	4842      	ldr	r0, [pc, #264]	; (801f8ac <mcpwm_foc_adc_int_handler+0xa2c>)
 801f7a4:	ee67 7aa9 	vmul.f32	s15, s15, s19
 801f7a8:	ee67 7a89 	vmul.f32	s15, s15, s18
 801f7ac:	ee27 0a80 	vmul.f32	s0, s15, s0
 801f7b0:	f7f6 f98e 	bl	8015ad0 <utils_truncate_number_abs>
	state_m->i_bus = state_m->mod_d * state_m->id + state_m->mod_q * state_m->iq;
 801f7b4:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
 801f7b8:	ed94 7a0f 	vldr	s14, [r4, #60]	; 0x3c
 801f7bc:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
 801f7c0:	ed94 6a10 	vldr	s12, [r4, #64]	; 0x40
 801f7c4:	ee67 7a86 	vmul.f32	s15, s15, s12
 801f7c8:	eee6 7a87 	vfma.f32	s15, s13, s14
 801f7cc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
	state_m->i_abs = sqrtf(SQ(state_m->id) + SQ(state_m->iq));
 801f7d0:	ed94 7a0f 	vldr	s14, [r4, #60]	; 0x3c
 801f7d4:	edd4 7a0f 	vldr	s15, [r4, #60]	; 0x3c
 801f7d8:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
 801f7dc:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
 801f7e0:	ee20 0a26 	vmul.f32	s0, s0, s13
 801f7e4:	eea7 0a27 	vfma.f32	s0, s14, s15
 801f7e8:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801f7ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f7f0:	eeb1 9ac0 	vsqrt.f32	s18, s0
 801f7f4:	f100 84fa 	bmi.w	80201ec <mcpwm_foc_adc_int_handler+0x136c>
 801f7f8:	ed84 9a07 	vstr	s18, [r4, #28]
	state_m->i_abs_filter = sqrtf(SQ(state_m->id_filter) + SQ(state_m->iq_filter));
 801f7fc:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
 801f800:	edd4 7a11 	vldr	s15, [r4, #68]	; 0x44
 801f804:	ed94 0a12 	vldr	s0, [r4, #72]	; 0x48
 801f808:	edd4 6a12 	vldr	s13, [r4, #72]	; 0x48
 801f80c:	ee20 0a26 	vmul.f32	s0, s0, s13
 801f810:	eea7 0a27 	vfma.f32	s0, s14, s15
 801f814:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801f818:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f81c:	eeb1 9ac0 	vsqrt.f32	s18, s0
 801f820:	f100 84e0 	bmi.w	80201e4 <mcpwm_foc_adc_int_handler+0x1364>
 801f824:	ed84 9a08 	vstr	s18, [r4, #32]
	float mod_alpha = c * state_m->mod_d - s * state_m->mod_q;
 801f828:	edd4 2a0d 	vldr	s5, [r4, #52]	; 0x34
 801f82c:	ed9d 6a06 	vldr	s12, [sp, #24]
 801f830:	edd4 5a0e 	vldr	s11, [r4, #56]	; 0x38
	float mod_beta  = c * state_m->mod_q + s * state_m->mod_d;
 801f834:	ed94 3a0e 	vldr	s6, [r4, #56]	; 0x38
 801f838:	ed94 2a0d 	vldr	s4, [r4, #52]	; 0x34
	const float i_alpha_filter = c * state_m->id_target - s * state_m->iq_target;
 801f83c:	ed94 4a00 	vldr	s8, [r4]
 801f840:	ed94 7a01 	vldr	s14, [r4, #4]
	const float i_beta_filter = c * state_m->iq_target + s * state_m->id_target;
 801f844:	edd4 1a01 	vldr	s3, [r4, #4]
 801f848:	edd4 7a00 	vldr	s15, [r4]
	float mod_alpha = c * state_m->mod_d - s * state_m->mod_q;
 801f84c:	ed9d 5a05 	vldr	s10, [sp, #20]
	const float ib_filter = -0.5 * i_alpha_filter + SQRT3_BY_2 * i_beta_filter;
 801f850:	eddf 4a12 	vldr	s9, [pc, #72]	; 801f89c <mcpwm_foc_adc_int_handler+0xa1c>
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f854:	eddf 6a16 	vldr	s13, [pc, #88]	; 801f8b0 <mcpwm_foc_adc_int_handler+0xa30>
 801f858:	eddf 3a1e 	vldr	s7, [pc, #120]	; 801f8d4 <mcpwm_foc_adc_int_handler+0xa54>
	const float i_beta_filter = c * state_m->iq_target + s * state_m->id_target;
 801f85c:	ee66 7a27 	vmul.f32	s15, s12, s15
	const float i_alpha_filter = c * state_m->id_target - s * state_m->iq_target;
 801f860:	ee27 7a46 	vnmul.f32	s14, s14, s12
	const float i_beta_filter = c * state_m->iq_target + s * state_m->id_target;
 801f864:	eee5 7a21 	vfma.f32	s15, s10, s3
	const float i_alpha_filter = c * state_m->id_target - s * state_m->iq_target;
 801f868:	eea5 7a04 	vfma.f32	s14, s10, s8
	const float ib_filter = -0.5 * i_alpha_filter + SQRT3_BY_2 * i_beta_filter;
 801f86c:	ee67 7aa4 	vmul.f32	s15, s15, s9
 801f870:	eefe 4a00 	vmov.f32	s9, #224	; 0xbf000000 -0.5
 801f874:	eeb0 4a67 	vmov.f32	s8, s15
 801f878:	e02e      	b.n	801f8d8 <mcpwm_foc_adc_int_handler+0xa58>
 801f87a:	bf00      	nop
 801f87c:	2000cdd0 	.word	0x2000cdd0
 801f880:	2000cdd8 	.word	0x2000cdd8
 801f884:	3dcccccd 	.word	0x3dcccccd
 801f888:	2000cdc8 	.word	0x2000cdc8
 801f88c:	2000ce68 	.word	0x2000ce68
 801f890:	2000ce5c 	.word	0x2000ce5c
 801f894:	3a83126f 	.word	0x3a83126f
 801f898:	ba83126f 	.word	0xba83126f
 801f89c:	3f5db3d7 	.word	0x3f5db3d7
 801f8a0:	00000000 	.word	0x00000000
 801f8a4:	2000ce2c 	.word	0x2000ce2c
 801f8a8:	2000ce30 	.word	0x2000ce30
 801f8ac:	2000ce34 	.word	0x2000ce34
 801f8b0:	bf2aaaab 	.word	0xbf2aaaab
 801f8b4:	2000cd90 	.word	0x2000cd90
 801f8b8:	2000cdac 	.word	0x2000cdac
 801f8bc:	2000ce61 	.word	0x2000ce61
 801f8c0:	2000ce54 	.word	0x2000ce54
 801f8c4:	3eaaaaab 	.word	0x3eaaaaab
 801f8c8:	bf13cd3a 	.word	0xbf13cd3a
 801f8cc:	3f13cd3a 	.word	0x3f13cd3a
 801f8d0:	358637bd 	.word	0x358637bd
 801f8d4:	3f2aaaab 	.word	0x3f2aaaab
 801f8d8:	eea7 4a24 	vfma.f32	s8, s14, s9
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f8dc:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 801f8e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	float mod_alpha = c * state_m->mod_d - s * state_m->mod_q;
 801f8e4:	ee66 5a65 	vnmul.f32	s11, s12, s11
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f8e8:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
	float mod_beta  = c * state_m->mod_q + s * state_m->mod_d;
 801f8ec:	ee26 6a02 	vmul.f32	s12, s12, s4
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f8f0:	bf58      	it	pl
 801f8f2:	eef0 6a63 	vmovpl.f32	s13, s7
 801f8f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	const float ic_filter = -0.5 * i_alpha_filter - SQRT3_BY_2 * i_beta_filter;
 801f8fa:	eed7 7a24 	vfnms.f32	s15, s14, s9
	float mod_alpha = c * state_m->mod_d - s * state_m->mod_q;
 801f8fe:	eee2 5a85 	vfma.f32	s11, s5, s10
	float mod_beta  = c * state_m->mod_q + s * state_m->mod_d;
 801f902:	eea5 6a03 	vfma.f32	s12, s10, s6
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f906:	ed1f 7a11 	vldr	s14, [pc, #-68]	; 801f8c4 <mcpwm_foc_adc_int_handler+0xa44>
 801f90a:	f100 8291 	bmi.w	801fe30 <mcpwm_foc_adc_int_handler+0xfb0>
 801f90e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f912:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f916:	ee76 6ac7 	vsub.f32	s13, s13, s14
 801f91a:	f100 82c8 	bmi.w	801feae <mcpwm_foc_adc_int_handler+0x102e>
	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 801f91e:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
 801f922:	ed5f 4a17 	vldr	s9, [pc, #-92]	; 801f8c8 <mcpwm_foc_adc_int_handler+0xa48>
 801f926:	ed1f 5a17 	vldr	s10, [pc, #-92]	; 801f8cc <mcpwm_foc_adc_int_handler+0xa4c>
 801f92a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801f92e:	ee36 7ac7 	vsub.f32	s14, s13, s14
	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 801f932:	bf58      	it	pl
 801f934:	eef0 4a45 	vmovpl.f32	s9, s10
 801f938:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f93c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f940:	f100 82b9 	bmi.w	801feb6 <mcpwm_foc_adc_int_handler+0x1036>
 801f944:	ed5f 7a1f 	vldr	s15, [pc, #-124]	; 801f8cc <mcpwm_foc_adc_int_handler+0xa4c>
 801f948:	ee74 4ae7 	vsub.f32	s9, s9, s15
	const float mod_comp_fact = m_conf->foc_dt_us * 1e-6 * m_conf->foc_f_sw;
 801f94c:	682b      	ldr	r3, [r5, #0]
 801f94e:	ed5f 6a20 	vldr	s13, [pc, #-128]	; 801f8d0 <mcpwm_foc_adc_int_handler+0xa50>
 801f952:	edd3 7a2c 	vldr	s15, [r3, #176]	; 0xb0
 801f956:	ed93 5a2b 	vldr	s10, [r3, #172]	; 0xac
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f95a:	ed1f 3a22 	vldr	s6, [pc, #-136]	; 801f8d4 <mcpwm_foc_adc_int_handler+0xa54>
 801f95e:	edd4 2a0a 	vldr	s5, [r4, #40]	; 0x28
	top = TIM1->ARR;
 801f962:	4bd1      	ldr	r3, [pc, #836]	; (801fca8 <mcpwm_foc_adc_int_handler+0xe28>)
 801f964:	eddf 3ad1 	vldr	s7, [pc, #836]	; 801fcac <mcpwm_foc_adc_int_handler+0xe2c>
	const float mod_comp_fact = m_conf->foc_dt_us * 1e-6 * m_conf->foc_f_sw;
 801f968:	ee67 7aa6 	vmul.f32	s15, s15, s13
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f96c:	eef0 6a65 	vmov.f32	s13, s11
 801f970:	ee25 5a67 	vnmul.f32	s10, s10, s15
	if (beta >= 0.0f) {
 801f974:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f978:	eee5 6a07 	vfma.f32	s13, s10, s14
	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f97c:	eeb0 7a46 	vmov.f32	s14, s12
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f980:	ee66 6a83 	vmul.f32	s13, s13, s6
	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f984:	eea5 7a24 	vfma.f32	s14, s10, s9
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f988:	ee66 6aa2 	vmul.f32	s13, s13, s5
	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f98c:	ee27 7a03 	vmul.f32	s14, s14, s6
	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f990:	edc4 6a0b 	vstr	s13, [r4, #44]	; 0x2c
	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f994:	edd4 6a0a 	vldr	s13, [r4, #40]	; 0x28
 801f998:	ee27 7a26 	vmul.f32	s14, s14, s13
	svm(-mod_alpha, -mod_beta, top, &duty1, &duty2, &duty3, (uint32_t*)&state_m->svm_sector);
 801f99c:	eeb1 4a46 	vneg.f32	s8, s12
	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 801f9a0:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
	top = TIM1->ARR;
 801f9a4:	f8d3 c02c 	ldr.w	ip, [r3, #44]	; 0x2c
 801f9a8:	ee07 ca10 	vmov	s14, ip
	if (beta >= 0.0f) {
 801f9ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f9b0:	ee64 7a23 	vmul.f32	s15, s8, s7
	svm(-mod_alpha, -mod_beta, top, &duty1, &duty2, &duty3, (uint32_t*)&state_m->svm_sector);
 801f9b4:	eeb1 5a65 	vneg.f32	s10, s11
 801f9b8:	eef8 6a47 	vcvt.f32.u32	s13, s14
		if (alpha >= 0.0f) {
 801f9bc:	eef5 5ac0 	vcmpe.f32	s11, #0.0
	if (beta >= 0.0f) {
 801f9c0:	f200 8211 	bhi.w	801fde6 <mcpwm_foc_adc_int_handler+0xf66>
		if (alpha >= 0.0f) {
 801f9c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f9c8:	f200 82bb 	bhi.w	801ff42 <mcpwm_foc_adc_int_handler+0x10c2>
			if (ONE_BY_SQRT3 * beta > alpha) {
 801f9cc:	eeb4 5ae7 	vcmpe.f32	s10, s15
 801f9d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f9d4:	f100 8274 	bmi.w	801fec0 <mcpwm_foc_adc_int_handler+0x1040>
		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9d8:	ed9f 7ab5 	vldr	s14, [pc, #724]	; 801fcb0 <mcpwm_foc_adc_int_handler+0xe30>
		uint32_t t1 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9dc:	ee75 7a67 	vsub.f32	s15, s10, s15
		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9e0:	ee24 7a07 	vmul.f32	s14, s8, s14
		uint32_t t1 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9e4:	ee67 7aa6 	vmul.f32	s15, s15, s13
		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9e8:	ee27 7a26 	vmul.f32	s14, s14, s13
		uint32_t t1 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9ec:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801f9f0:	ee17 2a90 	vmov	r2, s15
		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9f4:	eefc 7ac7 	vcvt.u32.f32	s15, s14
		tA = (PWMHalfPeriod - t1 - t2) / 2;
 801f9f8:	ebac 0302 	sub.w	r3, ip, r2
		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801f9fc:	ee17 1a90 	vmov	r1, s15
		tA = (PWMHalfPeriod - t1 - t2) / 2;
 801fa00:	1a5b      	subs	r3, r3, r1
 801fa02:	085b      	lsrs	r3, r3, #1
		tB = tA + t1;
 801fa04:	441a      	add	r2, r3
		tC = tB + t2;
 801fa06:	4411      	add	r1, r2
 801fa08:	9101      	str	r1, [sp, #4]
				sector = 1;
 801fa0a:	2101      	movs	r1, #1
	TIMER_UPDATE_DUTY(duty1, duty2, duty3);
 801fa0c:	48a6      	ldr	r0, [pc, #664]	; (801fca8 <mcpwm_foc_adc_int_handler+0xe28>)
	if (!m_output_on) {
 801fa0e:	f8df e2dc 	ldr.w	lr, [pc, #732]	; 801fcec <mcpwm_foc_adc_int_handler+0xe6c>
	TIMER_UPDATE_DUTY(duty1, duty2, duty3);
 801fa12:	f8d0 c000 	ldr.w	ip, [r0]
	*svm_sector = sector;
 801fa16:	65e1      	str	r1, [r4, #92]	; 0x5c
	TIMER_UPDATE_DUTY(duty1, duty2, duty3);
 801fa18:	f04c 0c02 	orr.w	ip, ip, #2
 801fa1c:	f8c0 c000 	str.w	ip, [r0]
 801fa20:	6343      	str	r3, [r0, #52]	; 0x34
 801fa22:	9b01      	ldr	r3, [sp, #4]
 801fa24:	6383      	str	r3, [r0, #56]	; 0x38
 801fa26:	63c2      	str	r2, [r0, #60]	; 0x3c
 801fa28:	6803      	ldr	r3, [r0, #0]
 801fa2a:	f023 0302 	bic.w	r3, r3, #2
 801fa2e:	6003      	str	r3, [r0, #0]
	if (!m_output_on) {
 801fa30:	f89e 3000 	ldrb.w	r3, [lr]
 801fa34:	2b00      	cmp	r3, #0
 801fa36:	f47f abb9 	bne.w	801f1ac <mcpwm_foc_adc_int_handler+0x32c>
		start_pwm_hw();
 801fa3a:	f7fd f8d9 	bl	801cbf0 <start_pwm_hw>
 801fa3e:	f7ff bbb5 	b.w	801f1ac <mcpwm_foc_adc_int_handler+0x32c>
			TIMER_UPDATE_DUTY(duty_cnt,	0, duty_cnt);
 801fa42:	6811      	ldr	r1, [r2, #0]
 801fa44:	f041 0102 	orr.w	r1, r1, #2
 801fa48:	6011      	str	r1, [r2, #0]
 801fa4a:	edc2 7a0d 	vstr	s15, [r2, #52]	; 0x34
			TIMER_UPDATE_DUTY(0, 0, duty_cnt);
 801fa4e:	6393      	str	r3, [r2, #56]	; 0x38
 801fa50:	63d4      	str	r4, [r2, #60]	; 0x3c
 801fa52:	6813      	ldr	r3, [r2, #0]
 801fa54:	f023 0302 	bic.w	r3, r3, #2
 801fa58:	6013      	str	r3, [r2, #0]
 801fa5a:	e4d2      	b.n	801f402 <mcpwm_foc_adc_int_handler+0x582>
		run_pid_control_pos(m_pos_pid_now, m_pos_pid_set, dt);
 801fa5c:	4a95      	ldr	r2, [pc, #596]	; (801fcb4 <mcpwm_foc_adc_int_handler+0xe34>)
	if (m_control_mode != CONTROL_MODE_POS) {
 801fa5e:	4b96      	ldr	r3, [pc, #600]	; (801fcb8 <mcpwm_foc_adc_int_handler+0xe38>)
		run_pid_control_pos(m_pos_pid_now, m_pos_pid_set, dt);
 801fa60:	edd4 0a00 	vldr	s1, [r4]
 801fa64:	ed92 0a00 	vldr	s0, [r2]
	if (m_control_mode != CONTROL_MODE_POS) {
 801fa68:	781b      	ldrb	r3, [r3, #0]
 801fa6a:	2b04      	cmp	r3, #4
 801fa6c:	f000 8097 	beq.w	801fb9e <mcpwm_foc_adc_int_handler+0xd1e>
		i_term = 0;
 801fa70:	4992      	ldr	r1, [pc, #584]	; (801fcbc <mcpwm_foc_adc_int_handler+0xe3c>)
		prev_error = 0;
 801fa72:	4a93      	ldr	r2, [pc, #588]	; (801fcc0 <mcpwm_foc_adc_int_handler+0xe40>)
		i_term = 0;
 801fa74:	2300      	movs	r3, #0
 801fa76:	600b      	str	r3, [r1, #0]
		prev_error = 0;
 801fa78:	6013      	str	r3, [r2, #0]
 801fa7a:	e495      	b.n	801f3a8 <mcpwm_foc_adc_int_handler+0x528>
			phase_tmp = 360.0 - phase_tmp;
 801fa7c:	ed9f 7a91 	vldr	s14, [pc, #580]	; 801fcc4 <mcpwm_foc_adc_int_handler+0xe44>
 801fa80:	ee37 7a40 	vsub.f32	s14, s14, s0
 801fa84:	e4d3      	b.n	801f42e <mcpwm_foc_adc_int_handler+0x5ae>
			m_phase_now_observer = correct_hall(m_phase_now_observer, m_pll_speed, dt);
 801fa86:	ed99 0a00 	vldr	s0, [r9]
 801fa8a:	edd6 0a00 	vldr	s1, [r6]
 801fa8e:	eeb0 1a48 	vmov.f32	s2, s16
 801fa92:	f7fd f95d 	bl	801cd50 <correct_hall>
 801fa96:	ed89 0a00 	vstr	s0, [r9]
			m_motor_state.phase = m_phase_now_observer;
 801fa9a:	f8d9 3000 	ldr.w	r3, [r9]
 801fa9e:	6123      	str	r3, [r4, #16]
 801faa0:	f10d 0910 	add.w	r9, sp, #16
 801faa4:	f10d 0a14 	add.w	sl, sp, #20
			break;
 801faa8:	f7ff bb80 	b.w	801f1ac <mcpwm_foc_adc_int_handler+0x32c>
				&& fabsf(duty_filtered) < 0.03) {
 801faac:	ed9a 7a00 	vldr	s14, [sl]
 801fab0:	eddf 6a85 	vldr	s13, [pc, #532]	; 801fcc8 <mcpwm_foc_adc_int_handler+0xe48>
 801fab4:	eeb0 7ac7 	vabs.f32	s14, s14
 801fab8:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801fabc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fac0:	f57f ad47 	bpl.w	801f552 <mcpwm_foc_adc_int_handler+0x6d2>
		if (m_control_mode == CONTROL_MODE_SPEED &&
 801fac4:	f899 3000 	ldrb.w	r3, [r9]
 801fac8:	682a      	ldr	r2, [r5, #0]
 801faca:	2b01      	cmp	r3, #1
 801facc:	d055      	beq.n	801fb7a <mcpwm_foc_adc_int_handler+0xcfa>
 801face:	eddf 6a7f 	vldr	s13, [pc, #508]	; 801fccc <mcpwm_foc_adc_int_handler+0xe4c>
			duty_set = 0.0;
 801fad2:	eef0 7a66 	vmov.f32	s15, s13
			if (fabsf(duty_set) < (duty_abs - 0.05) ||
 801fad6:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 801fcd0 <mcpwm_foc_adc_int_handler+0xe50>
 801fada:	ee39 7a47 	vsub.f32	s14, s18, s14
 801fade:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801fae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fae6:	f300 8136 	bgt.w	801fd56 <mcpwm_foc_adc_int_handler+0xed6>
					(SIGN(m_motor_state.vq) * m_motor_state.iq) < m_conf->lo_current_min) {
 801faea:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 801faee:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 801faf2:	ed92 6a1a 	vldr	s12, [r2, #104]	; 0x68
 801faf6:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 801fafa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fafe:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 801fb02:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801fb06:	bf58      	it	pl
 801fb08:	eef0 6a65 	vmovpl.f32	s13, s11
 801fb0c:	ee27 7a26 	vmul.f32	s14, s14, s13
			if (fabsf(duty_set) < (duty_abs - 0.05) ||
 801fb10:	eeb4 7ac6 	vcmpe.f32	s14, s12
 801fb14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fb18:	f100 811d 	bmi.w	801fd56 <mcpwm_foc_adc_int_handler+0xed6>
				duty_i_term = 0.0;
 801fb1c:	4b6d      	ldr	r3, [pc, #436]	; (801fcd4 <mcpwm_foc_adc_int_handler+0xe54>)
				m_motor_state.max_duty = duty_set;
 801fb1e:	edc4 7a02 	vstr	s15, [r4, #8]
				if (duty_set > 0.0) {
 801fb22:	eef5 7ac0 	vcmpe.f32	s15, #0.0
				duty_i_term = 0.0;
 801fb26:	2100      	movs	r1, #0
				if (duty_set > 0.0) {
 801fb28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				duty_i_term = 0.0;
 801fb2c:	6019      	str	r1, [r3, #0]
				if (duty_set > 0.0) {
 801fb2e:	f340 82c1 	ble.w	80200b4 <mcpwm_foc_adc_int_handler+0x1234>
					iq_set_tmp = m_conf->lo_current_max;
 801fb32:	6e53      	ldr	r3, [r2, #100]	; 0x64
 801fb34:	9304      	str	r3, [sp, #16]
 801fb36:	e519      	b.n	801f56c <mcpwm_foc_adc_int_handler+0x6ec>
			TIMER_UPDATE_DUTY(0, duty_cnt, duty_cnt);
 801fb38:	6811      	ldr	r1, [r2, #0]
 801fb3a:	f041 0102 	orr.w	r1, r1, #2
 801fb3e:	6011      	str	r1, [r2, #0]
 801fb40:	6354      	str	r4, [r2, #52]	; 0x34
 801fb42:	edc2 7a0e 	vstr	s15, [r2, #56]	; 0x38
 801fb46:	edc2 7a0f 	vstr	s15, [r2, #60]	; 0x3c
 801fb4a:	6813      	ldr	r3, [r2, #0]
 801fb4c:	f023 0302 	bic.w	r3, r3, #2
 801fb50:	6013      	str	r3, [r2, #0]
 801fb52:	e456      	b.n	801f402 <mcpwm_foc_adc_int_handler+0x582>
				fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801fb54:	4960      	ldr	r1, [pc, #384]	; (801fcd8 <mcpwm_foc_adc_int_handler+0xe58>)
 801fb56:	682a      	ldr	r2, [r5, #0]
 801fb58:	ed91 7a00 	vldr	s14, [r1]
 801fb5c:	edd2 6a49 	vldr	s13, [r2, #292]	; 0x124
 801fb60:	eeb0 7ac7 	vabs.f32	s14, s14
		if (m_control_mode == CONTROL_MODE_SPEED &&
 801fb64:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801fb68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fb6c:	f57f acf6 	bpl.w	801f55c <mcpwm_foc_adc_int_handler+0x6dc>
 801fb70:	eddf 7a56 	vldr	s15, [pc, #344]	; 801fccc <mcpwm_foc_adc_int_handler+0xe4c>
			duty_set = 0.0;
 801fb74:	eef0 6a67 	vmov.f32	s13, s15
 801fb78:	e7ad      	b.n	801fad6 <mcpwm_foc_adc_int_handler+0xc56>
				fabsf(m_speed_pid_set_rpm) < m_conf->s_pid_min_erpm) {
 801fb7a:	4b57      	ldr	r3, [pc, #348]	; (801fcd8 <mcpwm_foc_adc_int_handler+0xe58>)
 801fb7c:	edd3 7a00 	vldr	s15, [r3]
 801fb80:	ed92 7a49 	vldr	s14, [r2, #292]	; 0x124
 801fb84:	eef0 7ae7 	vabs.f32	s15, s15
		if (m_control_mode == CONTROL_MODE_SPEED &&
 801fb88:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801fb8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fb90:	dc9d      	bgt.n	801face <mcpwm_foc_adc_int_handler+0xc4e>
			duty_set = 0.0;
 801fb92:	eddf 7a4e 	vldr	s15, [pc, #312]	; 801fccc <mcpwm_foc_adc_int_handler+0xe4c>
 801fb96:	682a      	ldr	r2, [r5, #0]
 801fb98:	eef0 6ae7 	vabs.f32	s13, s15
 801fb9c:	e79b      	b.n	801fad6 <mcpwm_foc_adc_int_handler+0xc56>
	float error = utils_angle_difference(angle_set, angle_now);
 801fb9e:	f7f5 ffe7 	bl	8015b70 <utils_angle_difference>
 801fba2:	eef0 8a40 	vmov.f32	s17, s0
	if (encoder_is_configured()) {
 801fba6:	f7fb f883 	bl	801acb0 <encoder_is_configured>
		if (m_conf->foc_encoder_inverted) {
 801fbaa:	682b      	ldr	r3, [r5, #0]
	if (encoder_is_configured()) {
 801fbac:	b120      	cbz	r0, 801fbb8 <mcpwm_foc_adc_int_handler+0xd38>
		if (m_conf->foc_encoder_inverted) {
 801fbae:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
 801fbb2:	b10a      	cbz	r2, 801fbb8 <mcpwm_foc_adc_int_handler+0xd38>
			error = -error;
 801fbb4:	eef1 8a68 	vneg.f32	s17, s17
	p_term = error * m_conf->p_pid_kp;
 801fbb8:	edd3 7a4b 	vldr	s15, [r3, #300]	; 0x12c
	dt_int += dt;
 801fbbc:	4a47      	ldr	r2, [pc, #284]	; (801fcdc <mcpwm_foc_adc_int_handler+0xe5c>)
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbbe:	4c3f      	ldr	r4, [pc, #252]	; (801fcbc <mcpwm_foc_adc_int_handler+0xe3c>)
	dt_int += dt;
 801fbc0:	ed92 7a00 	vldr	s14, [r2]
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbc4:	edd4 6a00 	vldr	s13, [r4]
	if (error == prev_error) {
 801fbc8:	4e3d      	ldr	r6, [pc, #244]	; (801fcc0 <mcpwm_foc_adc_int_handler+0xe40>)
	p_term = error * m_conf->p_pid_kp;
 801fbca:	ee67 7aa8 	vmul.f32	s15, s15, s17
	dt_int += dt;
 801fbce:	ee38 7a07 	vadd.f32	s14, s16, s14
	p_term = error * m_conf->p_pid_kp;
 801fbd2:	edcd 7a06 	vstr	s15, [sp, #24]
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbd6:	ed93 6a4c 	vldr	s12, [r3, #304]	; 0x130
	if (error == prev_error) {
 801fbda:	edd6 7a00 	vldr	s15, [r6]
	dt_int += dt;
 801fbde:	ed82 7a00 	vstr	s14, [r2]
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbe2:	ee28 8a06 	vmul.f32	s16, s16, s12
	if (error == prev_error) {
 801fbe6:	eef4 8a67 	vcmp.f32	s17, s15
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbea:	eee8 6a88 	vfma.f32	s13, s17, s16
	if (error == prev_error) {
 801fbee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	i_term += error * (m_conf->p_pid_ki * dt);
 801fbf2:	edc4 6a00 	vstr	s13, [r4]
	if (error == prev_error) {
 801fbf6:	f000 825a 	beq.w	80200ae <mcpwm_foc_adc_int_handler+0x122e>
		d_term = (error - prev_error) * (m_conf->p_pid_kd / dt_int);
 801fbfa:	edd3 6a4d 	vldr	s13, [r3, #308]	; 0x134
 801fbfe:	ee86 8a87 	vdiv.f32	s16, s13, s14
		dt_int = 0.0;
 801fc02:	2300      	movs	r3, #0
 801fc04:	6013      	str	r3, [r2, #0]
		d_term = (error - prev_error) * (m_conf->p_pid_kd / dt_int);
 801fc06:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801fc0a:	ee27 8a88 	vmul.f32	s16, s15, s16
	utils_truncate_number_abs(&p_term, 1.0);
 801fc0e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801fc12:	4658      	mov	r0, fp
 801fc14:	f7f5 ff5c 	bl	8015ad0 <utils_truncate_number_abs>
	utils_truncate_number_abs(&i_term, 1.0 - fabsf(p_term));
 801fc18:	ed9d 0a06 	vldr	s0, [sp, #24]
 801fc1c:	4827      	ldr	r0, [pc, #156]	; (801fcbc <mcpwm_foc_adc_int_handler+0xe3c>)
 801fc1e:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 801fc22:	eeb0 0ac0 	vabs.f32	s0, s0
 801fc26:	ee39 0a40 	vsub.f32	s0, s18, s0
 801fc2a:	f7f5 ff51 	bl	8015ad0 <utils_truncate_number_abs>
	float output = p_term + i_term + d_term;
 801fc2e:	ed94 7a00 	vldr	s14, [r4]
 801fc32:	eddd 7a06 	vldr	s15, [sp, #24]
	prev_error = error;
 801fc36:	edc6 8a00 	vstr	s17, [r6]
	float output = p_term + i_term + d_term;
 801fc3a:	ee77 7a87 	vadd.f32	s15, s15, s14
	utils_truncate_number(&output, -1.0, 1.0);
 801fc3e:	eef0 0a49 	vmov.f32	s1, s18
	float output = p_term + i_term + d_term;
 801fc42:	ee77 7a88 	vadd.f32	s15, s15, s16
	utils_truncate_number(&output, -1.0, 1.0);
 801fc46:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 801fc4a:	4638      	mov	r0, r7
	float output = p_term + i_term + d_term;
 801fc4c:	edcd 7a07 	vstr	s15, [sp, #28]
	utils_truncate_number(&output, -1.0, 1.0);
 801fc50:	f7f5 ff16 	bl	8015a80 <utils_truncate_number>
	if (encoder_is_configured()) {
 801fc54:	f7fb f82c 	bl	801acb0 <encoder_is_configured>
 801fc58:	2800      	cmp	r0, #0
 801fc5a:	f040 8233 	bne.w	80200c4 <mcpwm_foc_adc_int_handler+0x1244>
		m_iq_set = output * m_conf->lo_current_max;
 801fc5e:	682b      	ldr	r3, [r5, #0]
 801fc60:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 801fc64:	ed9d 7a07 	vldr	s14, [sp, #28]
 801fc68:	4b1d      	ldr	r3, [pc, #116]	; (801fce0 <mcpwm_foc_adc_int_handler+0xe60>)
 801fc6a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801fc6e:	edc3 7a00 	vstr	s15, [r3]
 801fc72:	f7ff bb99 	b.w	801f3a8 <mcpwm_foc_adc_int_handler+0x528>
			m_motor_state.phase = m_phase_now_observer;
 801fc76:	f8d9 3000 	ldr.w	r3, [r9]
 801fc7a:	4e1a      	ldr	r6, [pc, #104]	; (801fce4 <mcpwm_foc_adc_int_handler+0xe64>)
 801fc7c:	6123      	str	r3, [r4, #16]
 801fc7e:	f7ff ba91 	b.w	801f1a4 <mcpwm_foc_adc_int_handler+0x324>
			m_motor_state.phase = correct_encoder(m_phase_now_observer, m_phase_now_encoder, m_pll_speed);
 801fc82:	4b19      	ldr	r3, [pc, #100]	; (801fce8 <mcpwm_foc_adc_int_handler+0xe68>)
 801fc84:	4e17      	ldr	r6, [pc, #92]	; (801fce4 <mcpwm_foc_adc_int_handler+0xe64>)
 801fc86:	ed99 0a00 	vldr	s0, [r9]
 801fc8a:	edd3 0a00 	vldr	s1, [r3]
 801fc8e:	ed96 1a00 	vldr	s2, [r6]
 801fc92:	f7fc ff75 	bl	801cb80 <correct_encoder>
 801fc96:	f10d 0910 	add.w	r9, sp, #16
 801fc9a:	ed84 0a04 	vstr	s0, [r4, #16]
 801fc9e:	f10d 0a14 	add.w	sl, sp, #20
			break;
 801fca2:	f7ff ba83 	b.w	801f1ac <mcpwm_foc_adc_int_handler+0x32c>
 801fca6:	bf00      	nop
 801fca8:	40010000 	.word	0x40010000
 801fcac:	3f13cd3a 	.word	0x3f13cd3a
 801fcb0:	3f93cd3a 	.word	0x3f93cd3a
 801fcb4:	2000ce70 	.word	0x2000ce70
 801fcb8:	2000cdac 	.word	0x2000cdac
 801fcbc:	2000cd98 	.word	0x2000cd98
 801fcc0:	2000cea8 	.word	0x2000cea8
 801fcc4:	43b40000 	.word	0x43b40000
 801fcc8:	3cf5c28f 	.word	0x3cf5c28f
 801fccc:	00000000 	.word	0x00000000
 801fcd0:	3d4ccccd 	.word	0x3d4ccccd
 801fcd4:	2000cd94 	.word	0x2000cd94
 801fcd8:	2000ce88 	.word	0x2000ce88
 801fcdc:	2000cd8c 	.word	0x2000cd8c
 801fce0:	2000cdd8 	.word	0x2000cdd8
 801fce4:	2000ce68 	.word	0x2000ce68
 801fce8:	2000ce4c 	.word	0x2000ce4c
 801fcec:	2000ce48 	.word	0x2000ce48
 801fcf0:	3da50a50 	.word	0x3da50a50
 801fcf4:	3a534067 	.word	0x3a534067
 801fcf8:	4195d174 	.word	0x4195d174
			m_samples.avg_current_tot += -((float)curr1 * FAC_CURRENT);
 801fcfc:	ee05 1a90 	vmov	s11, r1
 801fd00:	ed95 7a01 	vldr	s14, [r5, #4]
 801fd04:	ed5f 7a06 	vldr	s15, [pc, #-24]	; 801fcf0 <mcpwm_foc_adc_int_handler+0xe70>
			m_samples.avg_voltage_tot += GET_INPUT_VOLTAGE();
 801fd08:	ed1f 6a06 	vldr	s12, [pc, #-24]	; 801fcf4 <mcpwm_foc_adc_int_handler+0xe74>
 801fd0c:	ed5f 6a06 	vldr	s13, [pc, #-24]	; 801fcf8 <mcpwm_foc_adc_int_handler+0xe78>
			m_samples.avg_current_tot += -((float)curr1 * FAC_CURRENT);
 801fd10:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 801fd14:	eea5 7ae7 	vfms.f32	s14, s11, s15
 801fd18:	ed85 7a01 	vstr	s14, [r5, #4]
			m_samples.avg_voltage_tot += GET_INPUT_VOLTAGE();
 801fd1c:	8a33      	ldrh	r3, [r6, #16]
 801fd1e:	ed95 7a02 	vldr	s14, [r5, #8]
 801fd22:	ee07 3a90 	vmov	s15, r3
 801fd26:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801fd2a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801fd2e:	eea7 7aa6 	vfma.f32	s14, s15, s13
 801fd32:	ed85 7a02 	vstr	s14, [r5, #8]
			m_samples.sample_num++;
 801fd36:	682b      	ldr	r3, [r5, #0]
 801fd38:	3301      	adds	r3, #1
 801fd3a:	602b      	str	r3, [r5, #0]
			TIMER_UPDATE_DUTY(0, 0, 0);
 801fd3c:	6813      	ldr	r3, [r2, #0]
 801fd3e:	f043 0302 	orr.w	r3, r3, #2
 801fd42:	6013      	str	r3, [r2, #0]
 801fd44:	6354      	str	r4, [r2, #52]	; 0x34
 801fd46:	6394      	str	r4, [r2, #56]	; 0x38
 801fd48:	63d4      	str	r4, [r2, #60]	; 0x3c
 801fd4a:	6813      	ldr	r3, [r2, #0]
 801fd4c:	f023 0302 	bic.w	r3, r3, #2
 801fd50:	6013      	str	r3, [r2, #0]
 801fd52:	f7ff bb56 	b.w	801f402 <mcpwm_foc_adc_int_handler+0x582>
				float scale = 1.0 / GET_INPUT_VOLTAGE();
 801fd56:	8a33      	ldrh	r3, [r6, #16]
 801fd58:	ed1f 5a1a 	vldr	s10, [pc, #-104]	; 801fcf4 <mcpwm_foc_adc_int_handler+0xe74>
 801fd5c:	ed1f 6a1a 	vldr	s12, [pc, #-104]	; 801fcf8 <mcpwm_foc_adc_int_handler+0xe78>
				float error = duty_set - m_motor_state.duty_now;
 801fd60:	edd4 5a03 	vldr	s11, [r4, #12]
				float p_term = error * m_conf->foc_duty_dowmramp_kp * scale;
 801fd64:	ed92 aa37 	vldr	s20, [r2, #220]	; 0xdc
				duty_i_term += error * (m_conf->foc_duty_dowmramp_ki * dt) * scale;
 801fd68:	edd2 6a38 	vldr	s13, [r2, #224]	; 0xe0
 801fd6c:	4ede      	ldr	r6, [pc, #888]	; (80200e8 <mcpwm_foc_adc_int_handler+0x1268>)
				float scale = 1.0 / GET_INPUT_VOLTAGE();
 801fd6e:	ee07 3a10 	vmov	s14, r3
 801fd72:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801fd76:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 801fd7a:	ee27 7a05 	vmul.f32	s14, s14, s10
				float error = duty_set - m_motor_state.duty_now;
 801fd7e:	ee77 7ae5 	vsub.f32	s15, s15, s11
				float scale = 1.0 / GET_INPUT_VOLTAGE();
 801fd82:	ee27 7a06 	vmul.f32	s14, s14, s12
				duty_i_term += error * (m_conf->foc_duty_dowmramp_ki * dt) * scale;
 801fd86:	ee66 6a88 	vmul.f32	s13, s13, s16
				float scale = 1.0 / GET_INPUT_VOLTAGE();
 801fd8a:	eec9 aa87 	vdiv.f32	s21, s19, s14
				utils_truncate_number(&duty_i_term, -1.0, 1.0);
 801fd8e:	4630      	mov	r0, r6
				duty_i_term += error * (m_conf->foc_duty_dowmramp_ki * dt) * scale;
 801fd90:	ee26 7aa7 	vmul.f32	s14, s13, s15
 801fd94:	edd6 6a00 	vldr	s13, [r6]
 801fd98:	eee7 6a2a 	vfma.f32	s13, s14, s21
				utils_truncate_number(&duty_i_term, -1.0, 1.0);
 801fd9c:	eef0 0a69 	vmov.f32	s1, s19
 801fda0:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
				float p_term = error * m_conf->foc_duty_dowmramp_kp * scale;
 801fda4:	ee2a aa27 	vmul.f32	s20, s20, s15
				duty_i_term += error * (m_conf->foc_duty_dowmramp_ki * dt) * scale;
 801fda8:	edc6 6a00 	vstr	s13, [r6]
				utils_truncate_number(&duty_i_term, -1.0, 1.0);
 801fdac:	f7f5 fe68 	bl	8015a80 <utils_truncate_number>
				float output = p_term + duty_i_term;
 801fdb0:	edd6 7a00 	vldr	s15, [r6]
 801fdb4:	eeea 7a2a 	vfma.f32	s15, s20, s21
				utils_truncate_number(&output, -1.0, 1.0);
 801fdb8:	4638      	mov	r0, r7
 801fdba:	eef0 0a69 	vmov.f32	s1, s19
 801fdbe:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
				float output = p_term + duty_i_term;
 801fdc2:	edcd 7a07 	vstr	s15, [sp, #28]
				utils_truncate_number(&output, -1.0, 1.0);
 801fdc6:	f7f5 fe5b 	bl	8015a80 <utils_truncate_number>
				iq_set_tmp = output * m_conf->lo_current_max;
 801fdca:	682b      	ldr	r3, [r5, #0]
 801fdcc:	eddd 7a07 	vldr	s15, [sp, #28]
 801fdd0:	ed93 7a19 	vldr	s14, [r3, #100]	; 0x64
 801fdd4:	ee67 7a87 	vmul.f32	s15, s15, s14
 801fdd8:	edcd 7a04 	vstr	s15, [sp, #16]
					(SIGN(m_motor_state.vq) * m_motor_state.iq) < m_conf->lo_current_min) {
 801fddc:	f7ff bbc6 	b.w	801f56c <mcpwm_foc_adc_int_handler+0x6ec>
 801fde0:	4ec2      	ldr	r6, [pc, #776]	; (80200ec <mcpwm_foc_adc_int_handler+0x126c>)
 801fde2:	f7ff bbeb 	b.w	801f5bc <mcpwm_foc_adc_int_handler+0x73c>
		if (alpha >= 0.0f) {
 801fde6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fdea:	f200 810c 	bhi.w	8020006 <mcpwm_foc_adc_int_handler+0x1186>
			if (-ONE_BY_SQRT3 * beta > alpha) {
 801fdee:	ee66 3a23 	vmul.f32	s7, s12, s7
 801fdf2:	eeb4 5ae3 	vcmpe.f32	s10, s7
 801fdf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fdfa:	f140 812f 	bpl.w	802005c <mcpwm_foc_adc_int_handler+0x11dc>
		uint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fdfe:	ee35 7ae7 	vsub.f32	s14, s11, s15
		uint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe02:	ee75 7a67 	vsub.f32	s15, s10, s15
		uint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe06:	ee27 7a26 	vmul.f32	s14, s14, s13
		uint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe0a:	ee67 7aa6 	vmul.f32	s15, s15, s13
		uint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe0e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
		uint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe12:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		uint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe16:	ee17 3a10 	vmov	r3, s14
		uint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fe1a:	ee17 2a90 	vmov	r2, s15
		tC = (PWMHalfPeriod - t5 - t6) / 2;
 801fe1e:	ebac 0103 	sub.w	r1, ip, r3
 801fe22:	1a89      	subs	r1, r1, r2
 801fe24:	0849      	lsrs	r1, r1, #1
		tA = tC + t5;
 801fe26:	440b      	add	r3, r1
		tC = (PWMHalfPeriod - t5 - t6) / 2;
 801fe28:	9101      	str	r1, [sp, #4]
		tB = tA + t6;
 801fe2a:	441a      	add	r2, r3
 801fe2c:	2105      	movs	r1, #5
 801fe2e:	e5ed      	b.n	801fa0c <mcpwm_foc_adc_int_handler+0xb8c>
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801fe30:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801fe34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fe38:	ee76 6a87 	vadd.f32	s13, s13, s14
 801fe3c:	f100 80de 	bmi.w	801fffc <mcpwm_foc_adc_int_handler+0x117c>
 801fe40:	ee36 7ac7 	vsub.f32	s14, s13, s14
	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 801fe44:	eddf 4aaa 	vldr	s9, [pc, #680]	; 80200f0 <mcpwm_foc_adc_int_handler+0x1270>
 801fe48:	e576      	b.n	801f938 <mcpwm_foc_adc_int_handler+0xab8>
			utils_truncate_number(&iq_set_tmp, -m_conf->lo_current_max, -m_conf->lo_current_min);
 801fe4a:	ed93 0a19 	vldr	s0, [r3, #100]	; 0x64
 801fe4e:	edd3 0a1a 	vldr	s1, [r3, #104]	; 0x68
 801fe52:	eeb1 0a40 	vneg.f32	s0, s0
 801fe56:	eef1 0a60 	vneg.f32	s1, s1
 801fe5a:	4648      	mov	r0, r9
 801fe5c:	f7f5 fe10 	bl	8015a80 <utils_truncate_number>
 801fe60:	f7ff bbde 	b.w	801f620 <mcpwm_foc_adc_int_handler+0x7a0>
			m_motor_state.phase = 0.0;
 801fe64:	2300      	movs	r3, #0
 801fe66:	6123      	str	r3, [r4, #16]
 801fe68:	f7ff bbb2 	b.w	801f5d0 <mcpwm_foc_adc_int_handler+0x750>
			observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
 801fe6c:	ed94 0a0b 	vldr	s0, [r4, #44]	; 0x2c
 801fe70:	4aa0      	ldr	r2, [pc, #640]	; (80200f4 <mcpwm_foc_adc_int_handler+0x1274>)
 801fe72:	edd4 0a0c 	vldr	s1, [r4, #48]	; 0x30
 801fe76:	49a0      	ldr	r1, [pc, #640]	; (80200f8 <mcpwm_foc_adc_int_handler+0x1278>)
 801fe78:	ed94 1a05 	vldr	s2, [r4, #20]
 801fe7c:	489f      	ldr	r0, [pc, #636]	; (80200fc <mcpwm_foc_adc_int_handler+0x127c>)
 801fe7e:	edd4 1a06 	vldr	s3, [r4, #24]
 801fe82:	eeb0 2a48 	vmov.f32	s4, s16
 801fe86:	f7fe ff03 	bl	801ec90 <observer_update>
 801fe8a:	f7ff bb76 	b.w	801f57a <mcpwm_foc_adc_int_handler+0x6fa>
			utils_truncate_number(&iq_set_tmp, m_conf->lo_in_current_min / mod_q, m_conf->lo_in_current_max / mod_q);
 801fe8e:	ed93 0a1c 	vldr	s0, [r3, #112]	; 0x70
 801fe92:	edd3 0a1b 	vldr	s1, [r3, #108]	; 0x6c
			utils_truncate_number(&iq_set_tmp, m_conf->lo_in_current_max / mod_q, m_conf->lo_in_current_min / mod_q);
 801fe96:	f10d 0910 	add.w	r9, sp, #16
 801fe9a:	ee80 0a09 	vdiv.f32	s0, s0, s18
 801fe9e:	4648      	mov	r0, r9
 801fea0:	eec0 0a89 	vdiv.f32	s1, s1, s18
 801fea4:	f7f5 fdec 	bl	8015a80 <utils_truncate_number>
 801fea8:	682b      	ldr	r3, [r5, #0]
 801feaa:	f7ff bbac 	b.w	801f606 <mcpwm_foc_adc_int_handler+0x786>
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801feae:	ee36 7a87 	vadd.f32	s14, s13, s14
	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 801feb2:	eddf 4a93 	vldr	s9, [pc, #588]	; 8020100 <mcpwm_foc_adc_int_handler+0x1280>
 801feb6:	eddf 7a92 	vldr	s15, [pc, #584]	; 8020100 <mcpwm_foc_adc_int_handler+0x1280>
 801feba:	ee74 4aa7 	vadd.f32	s9, s9, s15
 801febe:	e545      	b.n	801f94c <mcpwm_foc_adc_int_handler+0xacc>
		uint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fec0:	ee37 7ae5 	vsub.f32	s14, s15, s11
		uint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fec4:	ee75 7aa7 	vadd.f32	s15, s11, s15
		uint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fec8:	ee27 7a26 	vmul.f32	s14, s14, s13
		uint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fecc:	ee67 7aa6 	vmul.f32	s15, s15, s13
		uint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fed0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
		uint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fed4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		uint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fed8:	ee17 1a10 	vmov	r1, s14
		uint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801fedc:	ee17 3a90 	vmov	r3, s15
		tB = (PWMHalfPeriod - t2 - t3) / 2;
 801fee0:	ebac 0201 	sub.w	r2, ip, r1
 801fee4:	1ad2      	subs	r2, r2, r3
 801fee6:	0852      	lsrs	r2, r2, #1
		tA = tB + t3;
 801fee8:	4413      	add	r3, r2
		tC = tA + t2;
 801feea:	4419      	add	r1, r3
 801feec:	9101      	str	r1, [sp, #4]
 801feee:	2102      	movs	r1, #2
 801fef0:	e58c      	b.n	801fa0c <mcpwm_foc_adc_int_handler+0xb8c>
			if (m_phase_observer_override) {
 801fef2:	4b84      	ldr	r3, [pc, #528]	; (8020104 <mcpwm_foc_adc_int_handler+0x1284>)
 801fef4:	781b      	ldrb	r3, [r3, #0]
 801fef6:	2b00      	cmp	r3, #0
 801fef8:	f000 80ac 	beq.w	8020054 <mcpwm_foc_adc_int_handler+0x11d4>
				m_motor_state.phase = m_phase_now_observer_override;
 801fefc:	4b82      	ldr	r3, [pc, #520]	; (8020108 <mcpwm_foc_adc_int_handler+0x1288>)
 801fefe:	681b      	ldr	r3, [r3, #0]
 801ff00:	6123      	str	r3, [r4, #16]
			if (!m_phase_override) {
 801ff02:	f89a 3000 	ldrb.w	r3, [sl]
 801ff06:	2b00      	cmp	r3, #0
 801ff08:	f47f af6a 	bne.w	801fde0 <mcpwm_foc_adc_int_handler+0xf60>
				if (duty_abs < m_conf->foc_sl_d_current_duty) {
 801ff0c:	edd2 7a3c 	vldr	s15, [r2, #240]	; 0xf0
 801ff10:	eef4 7ac9 	vcmpe.f32	s15, s18
 801ff14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ff18:	f300 8149 	bgt.w	80201ae <mcpwm_foc_adc_int_handler+0x132e>
 801ff1c:	4e73      	ldr	r6, [pc, #460]	; (80200ec <mcpwm_foc_adc_int_handler+0x126c>)
 801ff1e:	f7ff bb4b 	b.w	801f5b8 <mcpwm_foc_adc_int_handler+0x738>
			if (encoder_index_found()) {
 801ff22:	f7fa ffad 	bl	801ae80 <encoder_index_found>
 801ff26:	2800      	cmp	r0, #0
 801ff28:	f040 80b3 	bne.w	8020092 <mcpwm_foc_adc_int_handler+0x1212>
				m_motor_state.phase = m_phase_now_encoder_no_index;
 801ff2c:	4b77      	ldr	r3, [pc, #476]	; (802010c <mcpwm_foc_adc_int_handler+0x128c>)
 801ff2e:	4e6f      	ldr	r6, [pc, #444]	; (80200ec <mcpwm_foc_adc_int_handler+0x126c>)
 801ff30:	681b      	ldr	r3, [r3, #0]
 801ff32:	6123      	str	r3, [r4, #16]
			if (!m_phase_override) {
 801ff34:	f89a 3000 	ldrb.w	r3, [sl]
 801ff38:	2b00      	cmp	r3, #0
 801ff3a:	f47f ab3f 	bne.w	801f5bc <mcpwm_foc_adc_int_handler+0x73c>
 801ff3e:	f7ff bb3b 	b.w	801f5b8 <mcpwm_foc_adc_int_handler+0x738>
			if (-ONE_BY_SQRT3 * beta > alpha) {
 801ff42:	ee26 6a23 	vmul.f32	s12, s12, s7
 801ff46:	eeb4 5ac6 	vcmpe.f32	s10, s12
 801ff4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ff4e:	d5b7      	bpl.n	801fec0 <mcpwm_foc_adc_int_handler+0x1040>
		uint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff50:	ed9f 7a6f 	vldr	s14, [pc, #444]	; 8020110 <mcpwm_foc_adc_int_handler+0x1290>
 801ff54:	ee24 7a07 	vmul.f32	s14, s8, s14
		uint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff58:	ee75 7ae7 	vsub.f32	s15, s11, s15
		uint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff5c:	ee27 7a26 	vmul.f32	s14, s14, s13
		uint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff60:	ee67 7aa6 	vmul.f32	s15, s15, s13
		uint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff64:	eebc 7ac7 	vcvt.u32.f32	s14, s14
		uint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff68:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		uint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff6c:	ee17 1a10 	vmov	r1, s14
		uint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 801ff70:	ee17 3a90 	vmov	r3, s15
		tB = (PWMHalfPeriod - t3 - t4) / 2;
 801ff74:	ebac 0201 	sub.w	r2, ip, r1
 801ff78:	1ad2      	subs	r2, r2, r3
 801ff7a:	0852      	lsrs	r2, r2, #1
		tC = tB + t3;
 801ff7c:	4411      	add	r1, r2
 801ff7e:	9101      	str	r1, [sp, #4]
		tA = tC + t4;
 801ff80:	440b      	add	r3, r1
				sector = 3;
 801ff82:	2103      	movs	r1, #3
 801ff84:	e542      	b.n	801fa0c <mcpwm_foc_adc_int_handler+0xb8c>
			utils_truncate_number(&iq_set_tmp, m_conf->lo_in_current_max / mod_q, m_conf->lo_in_current_min / mod_q);
 801ff86:	ed93 0a1b 	vldr	s0, [r3, #108]	; 0x6c
 801ff8a:	edd3 0a1c 	vldr	s1, [r3, #112]	; 0x70
 801ff8e:	e782      	b.n	801fe96 <mcpwm_foc_adc_int_handler+0x1016>
			m_samples.avg_current_tot += -((float)curr0 * FAC_CURRENT);
 801ff90:	ee05 0a90 	vmov	s11, r0
 801ff94:	edd5 7a01 	vldr	s15, [r5, #4]
 801ff98:	ed9f 7a64 	vldr	s14, [pc, #400]	; 802012c <mcpwm_foc_adc_int_handler+0x12ac>
			m_samples.avg_voltage_tot += GET_INPUT_VOLTAGE();
 801ff9c:	ed9f 6a64 	vldr	s12, [pc, #400]	; 8020130 <mcpwm_foc_adc_int_handler+0x12b0>
 801ffa0:	eddf 6a64 	vldr	s13, [pc, #400]	; 8020134 <mcpwm_foc_adc_int_handler+0x12b4>
			m_samples.avg_current_tot += -((float)curr0 * FAC_CURRENT);
 801ffa4:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 801ffa8:	eee5 7ac7 	vfms.f32	s15, s11, s14
 801ffac:	edc5 7a01 	vstr	s15, [r5, #4]
 801ffb0:	e6b4      	b.n	801fd1c <mcpwm_foc_adc_int_handler+0xe9c>
			iq_set_tmp = fabsf(iq_set_tmp);
 801ffb2:	eddd 7a04 	vldr	s15, [sp, #16]
			if (phase_diff > 0.0) {
 801ffb6:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 801ffba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ffbe:	f04f 0300 	mov.w	r3, #0
			iq_set_tmp = fabsf(iq_set_tmp);
 801ffc2:	eef0 7ae7 	vabs.f32	s15, s15
			if (phase_diff > 0.0) {
 801ffc6:	f340 80b7 	ble.w	8020138 <mcpwm_foc_adc_int_handler+0x12b8>
				iq_set_tmp = -iq_set_tmp;
 801ffca:	eef1 7a67 	vneg.f32	s15, s15
 801ffce:	edcd 7a04 	vstr	s15, [sp, #16]
 801ffd2:	f7ff bacb 	b.w	801f56c <mcpwm_foc_adc_int_handler+0x6ec>
			openloop_angle += dt * m_openloop_speed;
 801ffd6:	f8df 9150 	ldr.w	r9, [pc, #336]	; 8020128 <mcpwm_foc_adc_int_handler+0x12a8>
 801ffda:	4b4e      	ldr	r3, [pc, #312]	; (8020114 <mcpwm_foc_adc_int_handler+0x1294>)
 801ffdc:	edd9 7a00 	vldr	s15, [r9]
 801ffe0:	ed93 7a00 	vldr	s14, [r3]
 801ffe4:	eee7 7a08 	vfma.f32	s15, s14, s16
			utils_norm_angle_rad(&openloop_angle);
 801ffe8:	4648      	mov	r0, r9
			openloop_angle += dt * m_openloop_speed;
 801ffea:	edc9 7a00 	vstr	s15, [r9]
			utils_norm_angle_rad(&openloop_angle);
 801ffee:	f7f5 fd17 	bl	8015a20 <utils_norm_angle_rad>
			m_motor_state.phase = openloop_angle;
 801fff2:	f8d9 3000 	ldr.w	r3, [r9]
 801fff6:	6123      	str	r3, [r4, #16]
 801fff8:	f7ff baea 	b.w	801f5d0 <mcpwm_foc_adc_int_handler+0x750>
	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 801fffc:	ee36 7a87 	vadd.f32	s14, s13, s14
	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 8020000:	eddf 4a3b 	vldr	s9, [pc, #236]	; 80200f0 <mcpwm_foc_adc_int_handler+0x1270>
 8020004:	e498      	b.n	801f938 <mcpwm_foc_adc_int_handler+0xab8>
			if (ONE_BY_SQRT3 * beta > alpha) {
 8020006:	eeb4 5ae7 	vcmpe.f32	s10, s15
 802000a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802000e:	f57f aef6 	bpl.w	801fdfe <mcpwm_foc_adc_int_handler+0xf7e>
		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020012:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 8020110 <mcpwm_foc_adc_int_handler+0x1290>
		uint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020016:	ee75 7aa7 	vadd.f32	s15, s11, s15
		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 802001a:	ee26 6a07 	vmul.f32	s12, s12, s14
		uint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 802001e:	ee27 7aa6 	vmul.f32	s14, s15, s13
		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020022:	ee66 7a26 	vmul.f32	s15, s12, s13
		uint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020026:	eebc 7ac7 	vcvt.u32.f32	s14, s14
		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 802002a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		uint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 802002e:	ee17 3a10 	vmov	r3, s14
		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020032:	ee17 2a90 	vmov	r2, s15
		tC = (PWMHalfPeriod - t4 - t5) / 2;
 8020036:	ebac 0103 	sub.w	r1, ip, r3
 802003a:	1a89      	subs	r1, r1, r2
 802003c:	0849      	lsrs	r1, r1, #1
		tB = tC + t5;
 802003e:	440a      	add	r2, r1
		tC = (PWMHalfPeriod - t4 - t5) / 2;
 8020040:	9101      	str	r1, [sp, #4]
		tA = tB + t4;
 8020042:	4413      	add	r3, r2
				sector = 4;
 8020044:	2104      	movs	r1, #4
 8020046:	e4e1      	b.n	801fa0c <mcpwm_foc_adc_int_handler+0xb8c>
			TIMER_UPDATE_DUTY(0, 0, duty_cnt);
 8020048:	6811      	ldr	r1, [r2, #0]
 802004a:	f041 0102 	orr.w	r1, r1, #2
 802004e:	6011      	str	r1, [r2, #0]
 8020050:	6354      	str	r4, [r2, #52]	; 0x34
 8020052:	e4fc      	b.n	801fa4e <mcpwm_foc_adc_int_handler+0xbce>
				m_motor_state.phase = m_phase_now_observer;
 8020054:	4b27      	ldr	r3, [pc, #156]	; (80200f4 <mcpwm_foc_adc_int_handler+0x1274>)
 8020056:	681b      	ldr	r3, [r3, #0]
 8020058:	6123      	str	r3, [r4, #16]
 802005a:	e752      	b.n	801ff02 <mcpwm_foc_adc_int_handler+0x1082>
		uint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 802005c:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8020110 <mcpwm_foc_adc_int_handler+0x1290>
 8020060:	ee26 7a07 	vmul.f32	s14, s12, s14
		uint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020064:	ee77 7ae5 	vsub.f32	s15, s15, s11
		uint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020068:	ee27 7a26 	vmul.f32	s14, s14, s13
		uint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 802006c:	ee67 7aa6 	vmul.f32	s15, s15, s13
		uint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020070:	eebc 7ac7 	vcvt.u32.f32	s14, s14
		uint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020074:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		uint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 8020078:	ee17 2a10 	vmov	r2, s14
		uint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 802007c:	ee17 1a90 	vmov	r1, s15
		tA = (PWMHalfPeriod - t6 - t1) / 2;
 8020080:	ebac 0302 	sub.w	r3, ip, r2
 8020084:	1a5b      	subs	r3, r3, r1
 8020086:	085b      	lsrs	r3, r3, #1
		tC = tA + t1;
 8020088:	4419      	add	r1, r3
 802008a:	9101      	str	r1, [sp, #4]
		tB = tC + t6;
 802008c:	440a      	add	r2, r1
				sector = 6;
 802008e:	2106      	movs	r1, #6
 8020090:	e4bc      	b.n	801fa0c <mcpwm_foc_adc_int_handler+0xb8c>
				m_motor_state.phase = correct_encoder(m_phase_now_observer, m_phase_now_encoder, m_pll_speed);
 8020092:	4a18      	ldr	r2, [pc, #96]	; (80200f4 <mcpwm_foc_adc_int_handler+0x1274>)
 8020094:	4b20      	ldr	r3, [pc, #128]	; (8020118 <mcpwm_foc_adc_int_handler+0x1298>)
 8020096:	4e15      	ldr	r6, [pc, #84]	; (80200ec <mcpwm_foc_adc_int_handler+0x126c>)
 8020098:	ed92 0a00 	vldr	s0, [r2]
 802009c:	edd3 0a00 	vldr	s1, [r3]
 80200a0:	ed96 1a00 	vldr	s2, [r6]
 80200a4:	f7fc fd6c 	bl	801cb80 <correct_encoder>
 80200a8:	ed84 0a04 	vstr	s0, [r4, #16]
 80200ac:	e742      	b.n	801ff34 <mcpwm_foc_adc_int_handler+0x10b4>
		d_term = 0.0;
 80200ae:	ed9f 8a1b 	vldr	s16, [pc, #108]	; 802011c <mcpwm_foc_adc_int_handler+0x129c>
 80200b2:	e5ac      	b.n	801fc0e <mcpwm_foc_adc_int_handler+0xd8e>
					iq_set_tmp = -m_conf->lo_current_max;
 80200b4:	edd2 7a19 	vldr	s15, [r2, #100]	; 0x64
 80200b8:	eef1 7a67 	vneg.f32	s15, s15
 80200bc:	edcd 7a04 	vstr	s15, [sp, #16]
 80200c0:	f7ff ba54 	b.w	801f56c <mcpwm_foc_adc_int_handler+0x6ec>
		if (encoder_index_found()) {
 80200c4:	f7fa fedc 	bl	801ae80 <encoder_index_found>
			m_iq_set = output * m_conf->lo_current_max;
 80200c8:	682b      	ldr	r3, [r5, #0]
		if (encoder_index_found()) {
 80200ca:	2800      	cmp	r0, #0
 80200cc:	f47f adc8 	bne.w	801fc60 <mcpwm_foc_adc_int_handler+0xde0>
			m_iq_set = 0.4 * m_conf->lo_current_max;
 80200d0:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 80200d4:	ed9f 7a12 	vldr	s14, [pc, #72]	; 8020120 <mcpwm_foc_adc_int_handler+0x12a0>
 80200d8:	4b12      	ldr	r3, [pc, #72]	; (8020124 <mcpwm_foc_adc_int_handler+0x12a4>)
 80200da:	ee67 7a87 	vmul.f32	s15, s15, s14
 80200de:	edc3 7a00 	vstr	s15, [r3]
 80200e2:	f7ff b961 	b.w	801f3a8 <mcpwm_foc_adc_int_handler+0x528>
 80200e6:	bf00      	nop
 80200e8:	2000cd94 	.word	0x2000cd94
 80200ec:	2000ce68 	.word	0x2000ce68
 80200f0:	bf13cd3a 	.word	0xbf13cd3a
 80200f4:	2000ce54 	.word	0x2000ce54
 80200f8:	2000ce40 	.word	0x2000ce40
 80200fc:	2000ce3c 	.word	0x2000ce3c
 8020100:	3f13cd3a 	.word	0x3f13cd3a
 8020104:	2000ce60 	.word	0x2000ce60
 8020108:	2000ce58 	.word	0x2000ce58
 802010c:	2000ce50 	.word	0x2000ce50
 8020110:	3f93cd3a 	.word	0x3f93cd3a
 8020114:	2000ce44 	.word	0x2000ce44
 8020118:	2000ce4c 	.word	0x2000ce4c
 802011c:	00000000 	.word	0x00000000
 8020120:	3ecccccd 	.word	0x3ecccccd
 8020124:	2000cdd8 	.word	0x2000cdd8
 8020128:	2000cea0 	.word	0x2000cea0
 802012c:	3da50a50 	.word	0x3da50a50
 8020130:	3a534067 	.word	0x3a534067
 8020134:	4195d174 	.word	0x4195d174
			} else if (phase_diff == 0.0) {
 8020138:	eef5 9a40 	vcmp.f32	s19, #0.0
 802013c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			iq_set_tmp = fabsf(iq_set_tmp);
 8020140:	bf14      	ite	ne
 8020142:	edcd 7a04 	vstrne	s15, [sp, #16]
				iq_set_tmp = 0.0;
 8020146:	9304      	streq	r3, [sp, #16]
 8020148:	f7ff ba10 	b.w	801f56c <mcpwm_foc_adc_int_handler+0x6ec>
			m_samples.avg_current_tot += -((float)curr0 * FAC_CURRENT + (float)curr1 * FAC_CURRENT);
 802014c:	ee07 1a90 	vmov	s15, r1
 8020150:	ed1f 6a0a 	vldr	s12, [pc, #-40]	; 802012c <mcpwm_foc_adc_int_handler+0x12ac>
 8020154:	edd5 6a01 	vldr	s13, [r5, #4]
			m_samples.avg_voltage_tot += GET_INPUT_VOLTAGE();
 8020158:	ed1f 5a0b 	vldr	s10, [pc, #-44]	; 8020130 <mcpwm_foc_adc_int_handler+0x12b0>
 802015c:	ed5f 5a0b 	vldr	s11, [pc, #-44]	; 8020134 <mcpwm_foc_adc_int_handler+0x12b4>
			m_samples.avg_current_tot += -((float)curr0 * FAC_CURRENT + (float)curr1 * FAC_CURRENT);
 8020160:	ee07 0a10 	vmov	s14, r0
 8020164:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8020168:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802016c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8020170:	eee7 7a06 	vfma.f32	s15, s14, s12
 8020174:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8020178:	edc5 7a01 	vstr	s15, [r5, #4]
			m_samples.avg_voltage_tot += GET_INPUT_VOLTAGE();
 802017c:	8a33      	ldrh	r3, [r6, #16]
 802017e:	ed95 7a02 	vldr	s14, [r5, #8]
 8020182:	ee07 3a90 	vmov	s15, r3
 8020186:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802018a:	ee67 7a85 	vmul.f32	s15, s15, s10
 802018e:	eea7 7aa5 	vfma.f32	s14, s15, s11
 8020192:	ed85 7a02 	vstr	s14, [r5, #8]
			m_samples.sample_num++;
 8020196:	682b      	ldr	r3, [r5, #0]
 8020198:	3301      	adds	r3, #1
 802019a:	602b      	str	r3, [r5, #0]
			stop_pwm_hw();
 802019c:	f7fc fd60 	bl	801cc60 <stop_pwm_hw>
			TIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);
 80201a0:	4b14      	ldr	r3, [pc, #80]	; (80201f4 <mcpwm_foc_adc_int_handler+0x1374>)
 80201a2:	f8d8 7000 	ldr.w	r7, [r8]
 80201a6:	2202      	movs	r2, #2
 80201a8:	635a      	str	r2, [r3, #52]	; 0x34
 80201aa:	f7ff b92a 	b.w	801f402 <mcpwm_foc_adc_int_handler+0x582>
					id_set_tmp = utils_map(duty_abs, 0.0, m_conf->foc_sl_d_current_duty,
 80201ae:	ed92 1a3c 	vldr	s2, [r2, #240]	; 0xf0
							fabsf(m_motor_state.iq_target) * m_conf->foc_sl_d_current_factor, 0.0);
 80201b2:	edd4 7a01 	vldr	s15, [r4, #4]
					id_set_tmp = utils_map(duty_abs, 0.0, m_conf->foc_sl_d_current_duty,
 80201b6:	ed9f 2a10 	vldr	s4, [pc, #64]	; 80201f8 <mcpwm_foc_adc_int_handler+0x1378>
							fabsf(m_motor_state.iq_target) * m_conf->foc_sl_d_current_factor, 0.0);
 80201ba:	edd2 1a3d 	vldr	s3, [r2, #244]	; 0xf4
 80201be:	4e0f      	ldr	r6, [pc, #60]	; (80201fc <mcpwm_foc_adc_int_handler+0x137c>)
 80201c0:	eef0 7ae7 	vabs.f32	s15, s15
					id_set_tmp = utils_map(duty_abs, 0.0, m_conf->foc_sl_d_current_duty,
 80201c4:	eeb0 0a49 	vmov.f32	s0, s18
 80201c8:	ee67 1aa1 	vmul.f32	s3, s15, s3
 80201cc:	eef0 0a42 	vmov.f32	s1, s4
 80201d0:	f7f5 fc96 	bl	8015b00 <utils_map>
 80201d4:	ed8d 0a03 	vstr	s0, [sp, #12]
 80201d8:	f7ff b9f0 	b.w	801f5bc <mcpwm_foc_adc_int_handler+0x73c>
			sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
 80201dc:	f005 faa0 	bl	8025720 <sqrtf>
 80201e0:	f7ff b805 	b.w	801f1ee <mcpwm_foc_adc_int_handler+0x36e>
	state_m->i_abs_filter = sqrtf(SQ(state_m->id_filter) + SQ(state_m->iq_filter));
 80201e4:	f005 fa9c 	bl	8025720 <sqrtf>
 80201e8:	f7ff bb1c 	b.w	801f824 <mcpwm_foc_adc_int_handler+0x9a4>
	state_m->i_abs = sqrtf(SQ(state_m->id) + SQ(state_m->iq));
 80201ec:	f005 fa98 	bl	8025720 <sqrtf>
 80201f0:	f7ff bb02 	b.w	801f7f8 <mcpwm_foc_adc_int_handler+0x978>
 80201f4:	40010400 	.word	0x40010400
 80201f8:	00000000 	.word	0x00000000
 80201fc:	2000ce68 	.word	0x2000ce68

08020200 <hw_init_gpio>:
		STD_DUTY_CYCLE
};

void hw_init_gpio(void) {
	// GPIO clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8020200:	2101      	movs	r1, #1
void hw_init_gpio(void) {
 8020202:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8020204:	4608      	mov	r0, r1
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

	// LEDs
	palSetPadMode(GPIOC, 4,
 8020206:	4c50      	ldr	r4, [pc, #320]	; (8020348 <hw_init_gpio+0x148>)
			PAL_MODE_OUTPUT_PUSHPULL |
			PAL_STM32_OSPEED_HIGHEST);
	DISABLE_GATE();

	// GPIOB (DCCAL)
	palSetPadMode(GPIOB, 12,
 8020208:	4e50      	ldr	r6, [pc, #320]	; (802034c <hw_init_gpio+0x14c>)
			PAL_MODE_OUTPUT_PUSHPULL |
			PAL_STM32_OSPEED_HIGHEST);

	// GPIOA Configuration: Channel 1 to 3 as alternate function push-pull
	palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 802020a:	4d51      	ldr	r5, [pc, #324]	; (8020350 <hw_init_gpio+0x150>)
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 802020c:	f004 f800 	bl	8024210 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8020210:	2101      	movs	r1, #1
 8020212:	2002      	movs	r0, #2
 8020214:	f003 fffc 	bl	8024210 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8020218:	2101      	movs	r1, #1
 802021a:	2004      	movs	r0, #4
 802021c:	f003 fff8 	bl	8024210 <RCC_AHB1PeriphClockCmd>
	palSetPadMode(GPIOC, 4,
 8020220:	4620      	mov	r0, r4
 8020222:	2219      	movs	r2, #25
 8020224:	2110      	movs	r1, #16
 8020226:	f7ef fe1b 	bl	800fe60 <_pal_lld_setgroupmode>
	DISABLE_GATE();
 802022a:	f44f 6780 	mov.w	r7, #1024	; 0x400
	palSetPadMode(GPIOC, 5,
 802022e:	4620      	mov	r0, r4
 8020230:	2219      	movs	r2, #25
 8020232:	2120      	movs	r1, #32
 8020234:	f7ef fe14 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 10,
 8020238:	4620      	mov	r0, r4
 802023a:	4639      	mov	r1, r7
 802023c:	2219      	movs	r2, #25
 802023e:	f7ef fe0f 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 12,
 8020242:	4630      	mov	r0, r6
	DISABLE_GATE();
 8020244:	8367      	strh	r7, [r4, #26]
	palSetPadMode(GPIOB, 12,
 8020246:	2219      	movs	r2, #25
 8020248:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 802024c:	f7ef fe08 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 8020250:	4628      	mov	r0, r5
 8020252:	229a      	movs	r2, #154	; 0x9a
 8020254:	f44f 7180 	mov.w	r1, #256	; 0x100
 8020258:	f7ef fe02 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);
	palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 802025c:	4628      	mov	r0, r5
 802025e:	229a      	movs	r2, #154	; 0x9a
 8020260:	f44f 7100 	mov.w	r1, #512	; 0x200
 8020264:	f7ef fdfc 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);
	palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 8020268:	4639      	mov	r1, r7
 802026a:	4628      	mov	r0, r5
 802026c:	229a      	movs	r2, #154	; 0x9a
 802026e:	f7ef fdf7 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);

	palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 8020272:	4630      	mov	r0, r6
 8020274:	229a      	movs	r2, #154	; 0x9a
 8020276:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 802027a:	f7ef fdf1 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);
	palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 802027e:	4630      	mov	r0, r6
 8020280:	229a      	movs	r2, #154	; 0x9a
 8020282:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8020286:	f7ef fdeb 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);
	palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(GPIO_AF_TIM1) |
 802028a:	4630      	mov	r0, r6
 802028c:	229a      	movs	r2, #154	; 0x9a
 802028e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8020292:	f7ef fde5 	bl	800fe60 <_pal_lld_setgroupmode>
			PAL_STM32_OSPEED_HIGHEST |
			PAL_STM32_PUDR_FLOATING);

	// Hall sensors
	palSetPadMode(HW_HALL_ENC_GPIO1, HW_HALL_ENC_PIN1, PAL_MODE_INPUT_PULLUP);
 8020296:	4630      	mov	r0, r6
 8020298:	2220      	movs	r2, #32
 802029a:	2140      	movs	r1, #64	; 0x40
 802029c:	f7ef fde0 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_HALL_ENC_GPIO2, HW_HALL_ENC_PIN2, PAL_MODE_INPUT_PULLUP);
 80202a0:	4630      	mov	r0, r6
 80202a2:	2220      	movs	r2, #32
 80202a4:	2180      	movs	r1, #128	; 0x80
 80202a6:	f7ef fddb 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_HALL_ENC_GPIO3, HW_HALL_ENC_PIN3, PAL_MODE_INPUT_PULLUP);
 80202aa:	4620      	mov	r0, r4
 80202ac:	2220      	movs	r2, #32
 80202ae:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80202b2:	f7ef fdd5 	bl	800fe60 <_pal_lld_setgroupmode>

	// Fault pin
	palSetPadMode(GPIOC, 12, PAL_MODE_INPUT_PULLUP);
 80202b6:	4620      	mov	r0, r4
 80202b8:	2220      	movs	r2, #32
 80202ba:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80202be:	f7ef fdcf 	bl	800fe60 <_pal_lld_setgroupmode>

	// ADC Pins
	palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG);
 80202c2:	4628      	mov	r0, r5
 80202c4:	2203      	movs	r2, #3
 80202c6:	2101      	movs	r1, #1
 80202c8:	f7ef fdca 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 1, PAL_MODE_INPUT_ANALOG);
 80202cc:	4628      	mov	r0, r5
 80202ce:	2203      	movs	r2, #3
 80202d0:	2102      	movs	r1, #2
 80202d2:	f7ef fdc5 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 2, PAL_MODE_INPUT_ANALOG);
 80202d6:	4628      	mov	r0, r5
 80202d8:	2203      	movs	r2, #3
 80202da:	2104      	movs	r1, #4
 80202dc:	f7ef fdc0 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 3, PAL_MODE_INPUT_ANALOG);
 80202e0:	4628      	mov	r0, r5
 80202e2:	2203      	movs	r2, #3
 80202e4:	2108      	movs	r1, #8
 80202e6:	f7ef fdbb 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 4, PAL_MODE_INPUT_ANALOG);
 80202ea:	4628      	mov	r0, r5
 80202ec:	2203      	movs	r2, #3
 80202ee:	2110      	movs	r1, #16
 80202f0:	f7ef fdb6 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 5, PAL_MODE_INPUT_ANALOG);
 80202f4:	4628      	mov	r0, r5
 80202f6:	2203      	movs	r2, #3
 80202f8:	2120      	movs	r1, #32
 80202fa:	f7ef fdb1 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 6, PAL_MODE_INPUT_ANALOG);
 80202fe:	4628      	mov	r0, r5
 8020300:	2203      	movs	r2, #3
 8020302:	2140      	movs	r1, #64	; 0x40
 8020304:	f7ef fdac 	bl	800fe60 <_pal_lld_setgroupmode>

	palSetPadMode(GPIOB, 0, PAL_MODE_INPUT_ANALOG);
 8020308:	4630      	mov	r0, r6
 802030a:	2203      	movs	r2, #3
 802030c:	2101      	movs	r1, #1
 802030e:	f7ef fda7 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_ANALOG);
 8020312:	4630      	mov	r0, r6
 8020314:	2203      	movs	r2, #3
 8020316:	2102      	movs	r1, #2
 8020318:	f7ef fda2 	bl	800fe60 <_pal_lld_setgroupmode>

	palSetPadMode(GPIOC, 0, PAL_MODE_INPUT_ANALOG);
 802031c:	4620      	mov	r0, r4
 802031e:	2203      	movs	r2, #3
 8020320:	2101      	movs	r1, #1
 8020322:	f7ef fd9d 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 1, PAL_MODE_INPUT_ANALOG);
 8020326:	4620      	mov	r0, r4
 8020328:	2203      	movs	r2, #3
 802032a:	2102      	movs	r1, #2
 802032c:	f7ef fd98 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 2, PAL_MODE_INPUT_ANALOG);
 8020330:	4620      	mov	r0, r4
 8020332:	2203      	movs	r2, #3
 8020334:	2104      	movs	r1, #4
 8020336:	f7ef fd93 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOC, 3, PAL_MODE_INPUT_ANALOG);
 802033a:	4620      	mov	r0, r4
 802033c:	2203      	movs	r2, #3
 802033e:	2108      	movs	r1, #8
}
 8020340:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	palSetPadMode(GPIOC, 3, PAL_MODE_INPUT_ANALOG);
 8020344:	f7ef bd8c 	b.w	800fe60 <_pal_lld_setgroupmode>
 8020348:	40020800 	.word	0x40020800
 802034c:	40020400 	.word	0x40020400
 8020350:	40020000 	.word	0x40020000
	...

08020360 <hw_setup_adc_channels>:

void hw_setup_adc_channels(void) {
 8020360:	b570      	push	{r4, r5, r6, lr}
	// ADC1 regular channels
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_15Cycles);
 8020362:	4d32      	ldr	r5, [pc, #200]	; (802042c <hw_setup_adc_channels+0xcc>)
	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 2, ADC_SampleTime_15Cycles);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_Vrefint, 3, ADC_SampleTime_15Cycles);
	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 4, ADC_SampleTime_15Cycles);

	// ADC2 regular channels
	ADC_RegularChannelConfig(ADC2, ADC_Channel_1, 1, ADC_SampleTime_15Cycles);
 8020364:	4c32      	ldr	r4, [pc, #200]	; (8020430 <hw_setup_adc_channels+0xd0>)
	ADC_RegularChannelConfig(ADC2, ADC_Channel_9, 2, ADC_SampleTime_15Cycles);
	ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 3, ADC_SampleTime_15Cycles);
	ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 4, ADC_SampleTime_15Cycles);

	// ADC3 regular channels
	ADC_RegularChannelConfig(ADC3, ADC_Channel_2, 1, ADC_SampleTime_15Cycles);
 8020366:	4e33      	ldr	r6, [pc, #204]	; (8020434 <hw_setup_adc_channels+0xd4>)
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_15Cycles);
 8020368:	2301      	movs	r3, #1
 802036a:	4628      	mov	r0, r5
 802036c:	461a      	mov	r2, r3
 802036e:	2100      	movs	r1, #0
 8020370:	f003 fc5e 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 2, ADC_SampleTime_15Cycles);
 8020374:	4628      	mov	r0, r5
 8020376:	2301      	movs	r3, #1
 8020378:	2202      	movs	r2, #2
 802037a:	2108      	movs	r1, #8
 802037c:	f003 fc58 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC1, ADC_Channel_Vrefint, 3, ADC_SampleTime_15Cycles);
 8020380:	4628      	mov	r0, r5
 8020382:	2301      	movs	r3, #1
 8020384:	2203      	movs	r2, #3
 8020386:	2111      	movs	r1, #17
 8020388:	f003 fc52 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 4, ADC_SampleTime_15Cycles);
 802038c:	2204      	movs	r2, #4
 802038e:	4628      	mov	r0, r5
 8020390:	4611      	mov	r1, r2
 8020392:	2301      	movs	r3, #1
 8020394:	f003 fc4c 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC2, ADC_Channel_1, 1, ADC_SampleTime_15Cycles);
 8020398:	2301      	movs	r3, #1
 802039a:	4620      	mov	r0, r4
 802039c:	461a      	mov	r2, r3
 802039e:	4619      	mov	r1, r3
 80203a0:	f003 fc46 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC2, ADC_Channel_9, 2, ADC_SampleTime_15Cycles);
 80203a4:	4620      	mov	r0, r4
 80203a6:	2301      	movs	r3, #1
 80203a8:	2202      	movs	r2, #2
 80203aa:	2109      	movs	r1, #9
 80203ac:	f003 fc40 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC2, ADC_Channel_6, 3, ADC_SampleTime_15Cycles);
 80203b0:	4620      	mov	r0, r4
 80203b2:	2301      	movs	r3, #1
 80203b4:	2203      	movs	r2, #3
 80203b6:	2106      	movs	r1, #6
 80203b8:	f003 fc3a 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 4, ADC_SampleTime_15Cycles);
 80203bc:	4620      	mov	r0, r4
 80203be:	2301      	movs	r3, #1
 80203c0:	2204      	movs	r2, #4
 80203c2:	2105      	movs	r1, #5
 80203c4:	f003 fc34 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC3, ADC_Channel_2, 1, ADC_SampleTime_15Cycles);
 80203c8:	2301      	movs	r3, #1
 80203ca:	4630      	mov	r0, r6
 80203cc:	461a      	mov	r2, r3
 80203ce:	2102      	movs	r1, #2
 80203d0:	f003 fc2e 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC3, ADC_Channel_3, 2, ADC_SampleTime_15Cycles);
 80203d4:	4630      	mov	r0, r6
 80203d6:	2301      	movs	r3, #1
 80203d8:	2202      	movs	r2, #2
 80203da:	2103      	movs	r1, #3
 80203dc:	f003 fc28 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 3, ADC_SampleTime_15Cycles);
 80203e0:	4630      	mov	r0, r6
 80203e2:	2301      	movs	r3, #1
 80203e4:	2203      	movs	r2, #3
 80203e6:	210c      	movs	r1, #12
 80203e8:	f003 fc22 	bl	8023c30 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC3, ADC_Channel_10, 4, ADC_SampleTime_15Cycles);
 80203ec:	4630      	mov	r0, r6
 80203ee:	2301      	movs	r3, #1
 80203f0:	2204      	movs	r2, #4
 80203f2:	210a      	movs	r1, #10
 80203f4:	f003 fc1c 	bl	8023c30 <ADC_RegularChannelConfig>

	// Injected channels
	ADC_InjectedChannelConfig(ADC1, ADC_Channel_9, 1, ADC_SampleTime_15Cycles);
 80203f8:	2301      	movs	r3, #1
 80203fa:	4628      	mov	r0, r5
 80203fc:	461a      	mov	r2, r3
 80203fe:	2109      	movs	r1, #9
 8020400:	f003 fc76 	bl	8023cf0 <ADC_InjectedChannelConfig>
	ADC_InjectedChannelConfig(ADC1, ADC_Channel_8, 2, ADC_SampleTime_15Cycles);
 8020404:	4628      	mov	r0, r5
 8020406:	2301      	movs	r3, #1
 8020408:	2202      	movs	r2, #2
 802040a:	2108      	movs	r1, #8
 802040c:	f003 fc70 	bl	8023cf0 <ADC_InjectedChannelConfig>
	ADC_InjectedChannelConfig(ADC2, ADC_Channel_8, 1, ADC_SampleTime_15Cycles);
 8020410:	2301      	movs	r3, #1
 8020412:	4620      	mov	r0, r4
 8020414:	461a      	mov	r2, r3
 8020416:	2108      	movs	r1, #8
 8020418:	f003 fc6a 	bl	8023cf0 <ADC_InjectedChannelConfig>
	ADC_InjectedChannelConfig(ADC2, ADC_Channel_9, 2, ADC_SampleTime_15Cycles);
 802041c:	4620      	mov	r0, r4
 802041e:	2301      	movs	r3, #1
 8020420:	2202      	movs	r2, #2
 8020422:	2109      	movs	r1, #9
}
 8020424:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ADC_InjectedChannelConfig(ADC2, ADC_Channel_9, 2, ADC_SampleTime_15Cycles);
 8020428:	f003 bc62 	b.w	8023cf0 <ADC_InjectedChannelConfig>
 802042c:	40012000 	.word	0x40012000
 8020430:	40012100 	.word	0x40012100
 8020434:	40012200 	.word	0x40012200
	...

08020440 <hw_start_i2c>:
	servos[1].pin = 4;
	servos[1].offset = 0;
	servos[1].pos = 0;
}

void hw_start_i2c(void) {
 8020440:	b510      	push	{r4, lr}
	i2cAcquireBus(&HW_I2C_DEV);

	if (!i2c_running) {
 8020442:	4c0f      	ldr	r4, [pc, #60]	; (8020480 <hw_start_i2c+0x40>)
	i2cAcquireBus(&HW_I2C_DEV);
 8020444:	480f      	ldr	r0, [pc, #60]	; (8020484 <hw_start_i2c+0x44>)
 8020446:	f7ee f8eb 	bl	800e620 <i2cAcquireBus>
	if (!i2c_running) {
 802044a:	7823      	ldrb	r3, [r4, #0]
 802044c:	b99b      	cbnz	r3, 8020476 <hw_start_i2c+0x36>
		palSetPadMode(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN,
 802044e:	f240 222e 	movw	r2, #558	; 0x22e
 8020452:	f44f 7180 	mov.w	r1, #256	; 0x100
 8020456:	480c      	ldr	r0, [pc, #48]	; (8020488 <hw_start_i2c+0x48>)
 8020458:	f7ef fd02 	bl	800fe60 <_pal_lld_setgroupmode>
				PAL_MODE_ALTERNATE(HW_I2C_GPIO_AF) |
				PAL_STM32_OTYPE_OPENDRAIN |
				PAL_STM32_OSPEED_MID1 |
				PAL_STM32_PUDR_PULLUP);
		palSetPadMode(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN,
 802045c:	f240 222e 	movw	r2, #558	; 0x22e
 8020460:	f44f 7100 	mov.w	r1, #512	; 0x200
 8020464:	4808      	ldr	r0, [pc, #32]	; (8020488 <hw_start_i2c+0x48>)
 8020466:	f7ef fcfb 	bl	800fe60 <_pal_lld_setgroupmode>
				PAL_MODE_ALTERNATE(HW_I2C_GPIO_AF) |
				PAL_STM32_OTYPE_OPENDRAIN |
				PAL_STM32_OSPEED_MID1 |
				PAL_STM32_PUDR_PULLUP);

		i2cStart(&HW_I2C_DEV, &i2cfg);
 802046a:	4908      	ldr	r1, [pc, #32]	; (802048c <hw_start_i2c+0x4c>)
 802046c:	4805      	ldr	r0, [pc, #20]	; (8020484 <hw_start_i2c+0x44>)
 802046e:	f7ee f87f 	bl	800e570 <i2cStart>
		i2c_running = true;
 8020472:	2301      	movs	r3, #1
 8020474:	7023      	strb	r3, [r4, #0]
	}

	i2cReleaseBus(&HW_I2C_DEV);
 8020476:	4803      	ldr	r0, [pc, #12]	; (8020484 <hw_start_i2c+0x44>)
}
 8020478:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	i2cReleaseBus(&HW_I2C_DEV);
 802047c:	f7ee b8d8 	b.w	800e630 <i2cReleaseBus>
 8020480:	2000d850 	.word	0x2000d850
 8020484:	20001d7c 	.word	0x20001d7c
 8020488:	40020400 	.word	0x40020400
 802048c:	0802f5c0 	.word	0x0802f5c0

08020490 <hw_stop_i2c>:

void hw_stop_i2c(void) {
 8020490:	b510      	push	{r4, lr}
	i2cAcquireBus(&HW_I2C_DEV);

	if (i2c_running) {
 8020492:	4c0e      	ldr	r4, [pc, #56]	; (80204cc <hw_stop_i2c+0x3c>)
	i2cAcquireBus(&HW_I2C_DEV);
 8020494:	480e      	ldr	r0, [pc, #56]	; (80204d0 <hw_stop_i2c+0x40>)
 8020496:	f7ee f8c3 	bl	800e620 <i2cAcquireBus>
	if (i2c_running) {
 802049a:	7823      	ldrb	r3, [r4, #0]
 802049c:	b183      	cbz	r3, 80204c0 <hw_stop_i2c+0x30>
		palSetPadMode(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN, PAL_MODE_INPUT);
 802049e:	2200      	movs	r2, #0
 80204a0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80204a4:	480b      	ldr	r0, [pc, #44]	; (80204d4 <hw_stop_i2c+0x44>)
 80204a6:	f7ef fcdb 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN, PAL_MODE_INPUT);
 80204aa:	2200      	movs	r2, #0
 80204ac:	f44f 7100 	mov.w	r1, #512	; 0x200
 80204b0:	4808      	ldr	r0, [pc, #32]	; (80204d4 <hw_stop_i2c+0x44>)
 80204b2:	f7ef fcd5 	bl	800fe60 <_pal_lld_setgroupmode>

		i2cStop(&HW_I2C_DEV);
 80204b6:	4806      	ldr	r0, [pc, #24]	; (80204d0 <hw_stop_i2c+0x40>)
 80204b8:	f7ee f86a 	bl	800e590 <i2cStop>
		i2c_running = false;
 80204bc:	2300      	movs	r3, #0
 80204be:	7023      	strb	r3, [r4, #0]

	}

	i2cReleaseBus(&HW_I2C_DEV);
 80204c0:	4803      	ldr	r0, [pc, #12]	; (80204d0 <hw_stop_i2c+0x40>)
}
 80204c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	i2cReleaseBus(&HW_I2C_DEV);
 80204c6:	f7ee b8b3 	b.w	800e630 <i2cReleaseBus>
 80204ca:	bf00      	nop
 80204cc:	2000d850 	.word	0x2000d850
 80204d0:	20001d7c 	.word	0x20001d7c
 80204d4:	40020400 	.word	0x40020400
	...

080204e0 <hw_try_restore_i2c>:

/**
 * Try to restore the i2c bus
 */
void hw_try_restore_i2c(void) {
 80204e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (i2c_running) {
 80204e2:	4b28      	ldr	r3, [pc, #160]	; (8020584 <hw_try_restore_i2c+0xa4>)
 80204e4:	781b      	ldrb	r3, [r3, #0]
 80204e6:	b903      	cbnz	r3, 80204ea <hw_try_restore_i2c+0xa>
		HW_I2C_DEV.state = I2C_STOP;
		i2cStart(&HW_I2C_DEV, &i2cfg);

		i2cReleaseBus(&HW_I2C_DEV);
	}
}
 80204e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		palSetPadMode(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN,
 80204ea:	4d27      	ldr	r5, [pc, #156]	; (8020588 <hw_try_restore_i2c+0xa8>)
		i2cAcquireBus(&HW_I2C_DEV);
 80204ec:	4827      	ldr	r0, [pc, #156]	; (802058c <hw_try_restore_i2c+0xac>)
 80204ee:	f7ee f897 	bl	800e620 <i2cAcquireBus>
		palSetPadMode(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN,
 80204f2:	4628      	mov	r0, r5
 80204f4:	222c      	movs	r2, #44	; 0x2c
 80204f6:	f44f 7180 	mov.w	r1, #256	; 0x100
 80204fa:	f7ef fcb1 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN,
 80204fe:	4628      	mov	r0, r5
 8020500:	222c      	movs	r2, #44	; 0x2c
 8020502:	f44f 7100 	mov.w	r1, #512	; 0x200
 8020506:	f7ef fcab 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 802050a:	f44f 7680 	mov.w	r6, #256	; 0x100
		palSetPad(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN);
 802050e:	f44f 7300 	mov.w	r3, #512	; 0x200
		palSetPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 8020512:	832e      	strh	r6, [r5, #24]
		chThdSleep(1);
 8020514:	2001      	movs	r0, #1
		palSetPad(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN);
 8020516:	832b      	strh	r3, [r5, #24]
		chThdSleep(1);
 8020518:	f7ed fa62 	bl	800d9e0 <chThdSleep>
			palClearPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 802051c:	4637      	mov	r7, r6
		chThdSleep(1);
 802051e:	2410      	movs	r4, #16
			chThdSleep(1);
 8020520:	2001      	movs	r0, #1
			palClearPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 8020522:	836f      	strh	r7, [r5, #26]
			chThdSleep(1);
 8020524:	f7ed fa5c 	bl	800d9e0 <chThdSleep>
			palSetPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 8020528:	832e      	strh	r6, [r5, #24]
			chThdSleep(1);
 802052a:	2001      	movs	r0, #1
 802052c:	f7ed fa58 	bl	800d9e0 <chThdSleep>
		for(int i = 0;i < 16;i++) {
 8020530:	3c01      	subs	r4, #1
 8020532:	d1f5      	bne.n	8020520 <hw_try_restore_i2c+0x40>
		palClearPad(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN);
 8020534:	f44f 7700 	mov.w	r7, #512	; 0x200
 8020538:	836f      	strh	r7, [r5, #26]
		chThdSleep(1);
 802053a:	2001      	movs	r0, #1
 802053c:	f7ed fa50 	bl	800d9e0 <chThdSleep>
		palClearPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 8020540:	836e      	strh	r6, [r5, #26]
		chThdSleep(1);
 8020542:	2001      	movs	r0, #1
 8020544:	f7ed fa4c 	bl	800d9e0 <chThdSleep>
		palSetPad(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN);
 8020548:	832e      	strh	r6, [r5, #24]
		chThdSleep(1);
 802054a:	2001      	movs	r0, #1
 802054c:	f7ed fa48 	bl	800d9e0 <chThdSleep>
		HW_I2C_DEV.state = I2C_STOP;
 8020550:	4c0e      	ldr	r4, [pc, #56]	; (802058c <hw_try_restore_i2c+0xac>)
		palSetPad(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN);
 8020552:	832f      	strh	r7, [r5, #24]
		palSetPadMode(HW_I2C_SCL_PORT, HW_I2C_SCL_PIN,
 8020554:	f240 222e 	movw	r2, #558	; 0x22e
 8020558:	f44f 7180 	mov.w	r1, #256	; 0x100
 802055c:	480a      	ldr	r0, [pc, #40]	; (8020588 <hw_try_restore_i2c+0xa8>)
 802055e:	f7ef fc7f 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(HW_I2C_SDA_PORT, HW_I2C_SDA_PIN,
 8020562:	4639      	mov	r1, r7
 8020564:	f240 222e 	movw	r2, #558	; 0x22e
 8020568:	4807      	ldr	r0, [pc, #28]	; (8020588 <hw_try_restore_i2c+0xa8>)
 802056a:	f7ef fc79 	bl	800fe60 <_pal_lld_setgroupmode>
		HW_I2C_DEV.state = I2C_STOP;
 802056e:	2301      	movs	r3, #1
		i2cStart(&HW_I2C_DEV, &i2cfg);
 8020570:	4620      	mov	r0, r4
 8020572:	4907      	ldr	r1, [pc, #28]	; (8020590 <hw_try_restore_i2c+0xb0>)
		HW_I2C_DEV.state = I2C_STOP;
 8020574:	7023      	strb	r3, [r4, #0]
		i2cStart(&HW_I2C_DEV, &i2cfg);
 8020576:	f7ed fffb 	bl	800e570 <i2cStart>
		i2cReleaseBus(&HW_I2C_DEV);
 802057a:	4620      	mov	r0, r4
}
 802057c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		i2cReleaseBus(&HW_I2C_DEV);
 8020580:	f7ee b856 	b.w	800e630 <i2cReleaseBus>
 8020584:	2000d850 	.word	0x2000d850
 8020588:	40020400 	.word	0x40020400
 802058c:	20001d7c 	.word	0x20001d7c
 8020590:	0802f5c0 	.word	0x0802f5c0
	...

080205a0 <app_get_configuration>:
// Private variables
static app_configuration appconf;

const app_configuration* app_get_configuration(void) {
	return &appconf;
}
 80205a0:	4800      	ldr	r0, [pc, #0]	; (80205a4 <app_get_configuration+0x4>)
 80205a2:	4770      	bx	lr
 80205a4:	2000d854 	.word	0x2000d854
	...

080205b0 <app_set_configuration>:
 * Reconfigure and restart all apps. Some apps don't have any configuration options.
 *
 * @param conf
 * The new configuration to use.
 */
void app_set_configuration(app_configuration *conf) {
 80205b0:	b570      	push	{r4, r5, r6, lr}
 80205b2:	4605      	mov	r5, r0
	app_ppm_stop();
	app_adc_stop();
	app_uartcomm_stop();
	app_nunchuk_stop();

	if (!conf_general_permanent_nrf_found) {
 80205b4:	4e2b      	ldr	r6, [pc, #172]	; (8020664 <app_set_configuration+0xb4>)
	appconf = *conf;
 80205b6:	482c      	ldr	r0, [pc, #176]	; (8020668 <app_set_configuration+0xb8>)
 80205b8:	4629      	mov	r1, r5
 80205ba:	22c8      	movs	r2, #200	; 0xc8
 80205bc:	f7ec fab0 	bl	800cb20 <memcpy>
	app_ppm_stop();
 80205c0:	f000 fc26 	bl	8020e10 <app_ppm_stop>
	app_adc_stop();
 80205c4:	f001 fa3c 	bl	8021a40 <app_adc_stop>
	app_uartcomm_stop();
 80205c8:	f001 fb62 	bl	8021c90 <app_uartcomm_stop>
	app_nunchuk_stop();
 80205cc:	f001 ff58 	bl	8022480 <app_nunchuk_stop>
	if (!conf_general_permanent_nrf_found) {
 80205d0:	7833      	ldrb	r3, [r6, #0]
 80205d2:	b30b      	cbz	r3, 8020618 <app_set_configuration+0x68>

#ifdef APP_CUSTOM_TO_USE
	app_custom_stop();
#endif

	switch (appconf.app_to_use) {
 80205d4:	4c24      	ldr	r4, [pc, #144]	; (8020668 <app_set_configuration+0xb8>)
	comm_can_set_baud(conf->can_baud_rate);
 80205d6:	7d28      	ldrb	r0, [r5, #20]
 80205d8:	f7fa f88a 	bl	801a6f0 <comm_can_set_baud>
	switch (appconf.app_to_use) {
 80205dc:	7d63      	ldrb	r3, [r4, #21]
 80205de:	3b01      	subs	r3, #1
 80205e0:	2b06      	cmp	r3, #6
 80205e2:	d807      	bhi.n	80205f4 <app_set_configuration+0x44>
 80205e4:	e8df f003 	tbb	[pc, r3]
 80205e8:	2c272304 	.word	0x2c272304
 80205ec:	3b33      	.short	0x3b33
 80205ee:	1b          	.byte	0x1b
 80205ef:	00          	.byte	0x00
	case APP_PPM:
		app_ppm_start();
 80205f0:	f000 fbde 	bl	8020db0 <app_ppm_start>

	default:
		break;
	}

	app_ppm_configure(&appconf.app_ppm_conf);
 80205f4:	481d      	ldr	r0, [pc, #116]	; (802066c <app_set_configuration+0xbc>)
 80205f6:	f000 fbb3 	bl	8020d60 <app_ppm_configure>
	app_adc_configure(&appconf.app_adc_conf);
 80205fa:	481d      	ldr	r0, [pc, #116]	; (8020670 <app_set_configuration+0xc0>)
 80205fc:	f001 f9f0 	bl	80219e0 <app_adc_configure>
	app_uartcomm_configure(appconf.app_uart_baudrate);
 8020600:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 8020604:	f001 fb5c 	bl	8021cc0 <app_uartcomm_configure>
	app_nunchuk_configure(&appconf.app_chuk_conf);
 8020608:	481a      	ldr	r0, [pc, #104]	; (8020674 <app_set_configuration+0xc4>)
 802060a:	f001 ff01 	bl	8022410 <app_nunchuk_configure>

#ifdef APP_CUSTOM_TO_USE
	app_custom_configure(&appconf);
#endif

	rfhelp_update_conf(&appconf.app_nrf_conf);
 802060e:	481a      	ldr	r0, [pc, #104]	; (8020678 <app_set_configuration+0xc8>)
}
 8020610:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	rfhelp_update_conf(&appconf.app_nrf_conf);
 8020614:	f002 be1c 	b.w	8023250 <rfhelp_update_conf>
		nrf_driver_stop();
 8020618:	f003 fa4a 	bl	8023ab0 <nrf_driver_stop>
 802061c:	e7da      	b.n	80205d4 <app_set_configuration+0x24>
		if (!conf_general_permanent_nrf_found) {
 802061e:	7833      	ldrb	r3, [r6, #0]
 8020620:	2b00      	cmp	r3, #0
 8020622:	d1e7      	bne.n	80205f4 <app_set_configuration+0x44>
			nrf_driver_init();
 8020624:	f003 f9e4 	bl	80239f0 <nrf_driver_init>
			rfhelp_restart();
 8020628:	f002 fdaa 	bl	8023180 <rfhelp_restart>
 802062c:	e7e2      	b.n	80205f4 <app_set_configuration+0x44>
		app_adc_start(true);
 802062e:	2001      	movs	r0, #1
 8020630:	f001 f9e6 	bl	8021a00 <app_adc_start>
		break;
 8020634:	e7de      	b.n	80205f4 <app_set_configuration+0x44>
		hw_stop_i2c();
 8020636:	f7ff ff2b 	bl	8020490 <hw_stop_i2c>
		app_uartcomm_start();
 802063a:	f001 fae1 	bl	8021c00 <app_uartcomm_start>
		break;
 802063e:	e7d9      	b.n	80205f4 <app_set_configuration+0x44>
		hw_stop_i2c();
 8020640:	f7ff ff26 	bl	8020490 <hw_stop_i2c>
		app_ppm_start();
 8020644:	f000 fbb4 	bl	8020db0 <app_ppm_start>
		app_uartcomm_start();
 8020648:	f001 fada 	bl	8021c00 <app_uartcomm_start>
		break;
 802064c:	e7d2      	b.n	80205f4 <app_set_configuration+0x44>
		hw_stop_i2c();
 802064e:	f7ff ff1f 	bl	8020490 <hw_stop_i2c>
		app_adc_start(false);
 8020652:	2000      	movs	r0, #0
 8020654:	f001 f9d4 	bl	8021a00 <app_adc_start>
		app_uartcomm_start();
 8020658:	f001 fad2 	bl	8021c00 <app_uartcomm_start>
		break;
 802065c:	e7ca      	b.n	80205f4 <app_set_configuration+0x44>
		app_nunchuk_start();
 802065e:	f001 feef 	bl	8022440 <app_nunchuk_start>
		break;
 8020662:	e7c7      	b.n	80205f4 <app_set_configuration+0x44>
 8020664:	20008050 	.word	0x20008050
 8020668:	2000d854 	.word	0x2000d854
 802066c:	2000d86c 	.word	0x2000d86c
 8020670:	2000d8a4 	.word	0x2000d8a4
 8020674:	2000d8ec 	.word	0x2000d8ec
 8020678:	2000d910 	.word	0x2000d910
 802067c:	00000000 	.word	0x00000000

08020680 <ppm_thread>:
	chVTSetI(&vt, MS2ST(2), update, p);
	chEvtSignalI(ppm_tp, (eventmask_t) 1);
	chSysUnlockFromISR();
}

static THD_FUNCTION(ppm_thread, arg) {
 8020680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020684:	4fc4      	ldr	r7, [pc, #784]	; (8020998 <ppm_thread+0x318>)
	(void)arg;

	chRegSetThreadName("APP_PPM");
	ppm_tp = chThdGetSelfX();

	servodec_set_pulse_options(config.pulse_start, config.pulse_end, config.median_filter);
 8020686:	4cc5      	ldr	r4, [pc, #788]	; (802099c <ppm_thread+0x31c>)
 8020688:	69bb      	ldr	r3, [r7, #24]
 802068a:	49c5      	ldr	r1, [pc, #788]	; (80209a0 <ppm_thread+0x320>)
	ppm_tp = chThdGetSelfX();
 802068c:	4ac5      	ldr	r2, [pc, #788]	; (80209a4 <ppm_thread+0x324>)
	servodec_set_pulse_options(config.pulse_start, config.pulse_end, config.median_filter);
 802068e:	ed94 0a03 	vldr	s0, [r4, #12]
 8020692:	edd4 0a04 	vldr	s1, [r4, #16]
 8020696:	7e20      	ldrb	r0, [r4, #24]
	servodec_init(servodec_func);
	is_running = true;
 8020698:	f8df 8338 	ldr.w	r8, [pc, #824]	; 80209d4 <ppm_thread+0x354>
 802069c:	4ec2      	ldr	r6, [pc, #776]	; (80209a8 <ppm_thread+0x328>)
static THD_FUNCTION(ppm_thread, arg) {
 802069e:	ed2d 8b08 	vpush	{d8-d11}
 80206a2:	6199      	str	r1, [r3, #24]
 80206a4:	b085      	sub	sp, #20
	ppm_tp = chThdGetSelfX();
 80206a6:	6013      	str	r3, [r2, #0]
	servodec_set_pulse_options(config.pulse_start, config.pulse_end, config.median_filter);
 80206a8:	f7f5 f93a 	bl	8015920 <servodec_set_pulse_options>
	servodec_init(servodec_func);
 80206ac:	48bf      	ldr	r0, [pc, #764]	; (80209ac <ppm_thread+0x32c>)
			// Mapping with respect to center pulsewidth
			if (servo_ms < config.pulse_center) {
				servo_val = utils_map(servo_ms, config.pulse_start,
						config.pulse_center, -1.0, 0.0);
			} else {
				servo_val = utils_map(servo_ms, config.pulse_center,
 80206ae:	eddf 8ac0 	vldr	s17, [pc, #768]	; 80209b0 <ppm_thread+0x330>
		// Apply ramping
		static systime_t last_time = 0;
		static float servo_val_ramp = 0.0;
		const float ramp_time = fabsf(servo_val) > fabsf(servo_val_ramp) ? config.ramp_time_pos : config.ramp_time_neg;

		if (ramp_time > 0.01) {
 80206b2:	ed9f aac0 	vldr	s20, [pc, #768]	; 80209b4 <ppm_thread+0x334>
				// Traction control
				if (config.multi_esc) {
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
						can_status_msg *msg = comm_can_get_status_msg_index(i);

						if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 80206b6:	eddf 9ac0 	vldr	s19, [pc, #768]	; 80209b8 <ppm_thread+0x338>
 80206ba:	ed9f 9ac0 	vldr	s18, [pc, #768]	; 80209bc <ppm_thread+0x33c>
	servodec_init(servodec_func);
 80206be:	f7f5 f8cf 	bl	8015860 <servodec_init>
	is_running = true;
 80206c2:	2301      	movs	r3, #1
 80206c4:	f888 3000 	strb.w	r3, [r8]
		chEvtWaitAny((eventmask_t) 1);
 80206c8:	2001      	movs	r0, #1
 80206ca:	f7ed fbe9 	bl	800dea0 <chEvtWaitAny>
		if (stop_now) {
 80206ce:	7833      	ldrb	r3, [r6, #0]
 80206d0:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80206d4:	2b00      	cmp	r3, #0
 80206d6:	f040 809c 	bne.w	8020812 <ppm_thread+0x192>
		const volatile mc_configuration *mcconf = mc_interface_get_configuration();
 80206da:	f7fa fe91 	bl	801b400 <mc_interface_get_configuration>
 80206de:	4681      	mov	r9, r0
		const float rpm_now = mc_interface_get_rpm();
 80206e0:	f7fa ff1e 	bl	801b520 <mc_interface_get_rpm>
		float servo_val = servodec_get_servo(0);
 80206e4:	4628      	mov	r0, r5
		const float rpm_now = mc_interface_get_rpm();
 80206e6:	eeb0 8a40 	vmov.f32	s16, s0
		float servo_val = servodec_get_servo(0);
 80206ea:	f7f5 f929 	bl	8015940 <servodec_get_servo>
		float servo_ms = utils_map(servo_val, -1.0, 1.0, config.pulse_start, config.pulse_end);
 80206ee:	edd4 1a03 	vldr	s3, [r4, #12]
 80206f2:	ed94 2a04 	vldr	s4, [r4, #16]
		float servo_val = servodec_get_servo(0);
 80206f6:	ed8d 0a03 	vstr	s0, [sp, #12]
		float servo_ms = utils_map(servo_val, -1.0, 1.0, config.pulse_start, config.pulse_end);
 80206fa:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80206fe:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8020702:	f7f5 f9fd 	bl	8015b00 <utils_map>
		switch (config.ctrl_type) {
 8020706:	7823      	ldrb	r3, [r4, #0]
 8020708:	b2db      	uxtb	r3, r3
 802070a:	2b07      	cmp	r3, #7
 802070c:	d85d      	bhi.n	80207ca <ppm_thread+0x14a>
 802070e:	2201      	movs	r2, #1
 8020710:	fa02 f303 	lsl.w	r3, r2, r3
 8020714:	f013 0fa4 	tst.w	r3, #164	; 0xa4
 8020718:	d057      	beq.n	80207ca <ppm_thread+0x14a>
			input_val = servo_val;
 802071a:	ed9d 7a03 	vldr	s14, [sp, #12]
 802071e:	4ba8      	ldr	r3, [pc, #672]	; (80209c0 <ppm_thread+0x340>)
			servo_val += 1.0;
 8020720:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8020724:	ee77 7a27 	vadd.f32	s15, s14, s15
			servo_val /= 2.0;
 8020728:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802072c:	ee67 7aa6 	vmul.f32	s15, s15, s13
			input_val = servo_val;
 8020730:	ed83 7a00 	vstr	s14, [r3]
			servo_val /= 2.0;
 8020734:	edcd 7a03 	vstr	s15, [sp, #12]
		if (timeout_has_timeout() || servodec_get_time_since_update() > timeout_get_timeout_msec() ||
 8020738:	f7f9 fd22 	bl	801a180 <timeout_has_timeout>
 802073c:	4605      	mov	r5, r0
 802073e:	2800      	cmp	r0, #0
 8020740:	d13f      	bne.n	80207c2 <ppm_thread+0x142>
 8020742:	f7f5 f90d 	bl	8015960 <servodec_get_time_since_update>
 8020746:	4682      	mov	sl, r0
 8020748:	f7f9 fd22 	bl	801a190 <timeout_get_timeout_msec>
 802074c:	4582      	cmp	sl, r0
 802074e:	d838      	bhi.n	80207c2 <ppm_thread+0x142>
				mc_interface_get_fault() != FAULT_CODE_NONE) {
 8020750:	f7fa fe86 	bl	801b460 <mc_interface_get_fault>
		if (timeout_has_timeout() || servodec_get_time_since_update() > timeout_get_timeout_msec() ||
 8020754:	bba8      	cbnz	r0, 80207c2 <ppm_thread+0x142>
		utils_deadband(&servo_val, config.hyst, 1.0);
 8020756:	ed94 0a02 	vldr	s0, [r4, #8]
		const float ramp_time = fabsf(servo_val) > fabsf(servo_val_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 802075a:	f8df a274 	ldr.w	sl, [pc, #628]	; 80209d0 <ppm_thread+0x350>
		utils_deadband(&servo_val, config.hyst, 1.0);
 802075e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8020762:	a803      	add	r0, sp, #12
 8020764:	f7f5 f9dc 	bl	8015b20 <utils_deadband>
		servo_val = utils_throttle_curve(servo_val, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 8020768:	edd4 0a07 	vldr	s1, [r4, #28]
 802076c:	ed9d 0a03 	vldr	s0, [sp, #12]
 8020770:	ed94 1a08 	vldr	s2, [r4, #32]
 8020774:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 8020778:	f7f5 fbea 	bl	8015f50 <utils_throttle_curve>
		const float ramp_time = fabsf(servo_val) > fabsf(servo_val_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 802077c:	edda 7a00 	vldr	s15, [sl]
		servo_val = utils_throttle_curve(servo_val, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 8020780:	ed8d 0a03 	vstr	s0, [sp, #12]
		const float ramp_time = fabsf(servo_val) > fabsf(servo_val_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 8020784:	eef0 7ae7 	vabs.f32	s15, s15
 8020788:	eeb0 7ac0 	vabs.f32	s14, s0
 802078c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8020790:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020794:	bfcc      	ite	gt
 8020796:	edd4 0a0a 	vldrgt	s1, [r4, #40]	; 0x28
 802079a:	edd4 0a0b 	vldrle	s1, [r4, #44]	; 0x2c
		if (ramp_time > 0.01) {
 802079e:	eef4 0aca 	vcmpe.f32	s1, s20
 80207a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80207a6:	dc3c      	bgt.n	8020822 <ppm_thread+0x1a2>
		switch (config.ctrl_type) {
 80207a8:	7823      	ldrb	r3, [r4, #0]
 80207aa:	3b01      	subs	r3, #1
 80207ac:	2b06      	cmp	r3, #6
 80207ae:	d88b      	bhi.n	80206c8 <ppm_thread+0x48>
 80207b0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80207b4:	00810081 	.word	0x00810081
 80207b8:	011600d5 	.word	0x011600d5
 80207bc:	005b0116 	.word	0x005b0116
 80207c0:	005b      	.short	0x005b
			pulses_without_power = 0;
 80207c2:	4b80      	ldr	r3, [pc, #512]	; (80209c4 <ppm_thread+0x344>)
 80207c4:	2200      	movs	r2, #0
 80207c6:	601a      	str	r2, [r3, #0]
			continue;
 80207c8:	e77e      	b.n	80206c8 <ppm_thread+0x48>
			if (servo_ms < config.pulse_center) {
 80207ca:	edd4 7a05 	vldr	s15, [r4, #20]
 80207ce:	eef4 7ac0 	vcmpe.f32	s15, s0
 80207d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80207d6:	dd0f      	ble.n	80207f8 <ppm_thread+0x178>
				servo_val = utils_map(servo_ms, config.pulse_start,
 80207d8:	edd4 0a03 	vldr	s1, [r4, #12]
 80207dc:	ed94 1a05 	vldr	s2, [r4, #20]
 80207e0:	eeb0 2a68 	vmov.f32	s4, s17
 80207e4:	eeff 1a00 	vmov.f32	s3, #240	; 0xbf800000 -1.0
 80207e8:	f7f5 f98a 	bl	8015b00 <utils_map>
 80207ec:	ed8d 0a03 	vstr	s0, [sp, #12]
			input_val = servo_val;
 80207f0:	4b73      	ldr	r3, [pc, #460]	; (80209c0 <ppm_thread+0x340>)
 80207f2:	ed83 0a00 	vstr	s0, [r3]
			break;
 80207f6:	e79f      	b.n	8020738 <ppm_thread+0xb8>
				servo_val = utils_map(servo_ms, config.pulse_center,
 80207f8:	edd4 0a05 	vldr	s1, [r4, #20]
 80207fc:	ed94 1a04 	vldr	s2, [r4, #16]
 8020800:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 8020804:	eef0 1a68 	vmov.f32	s3, s17
 8020808:	f7f5 f97a 	bl	8015b00 <utils_map>
 802080c:	ed8d 0a03 	vstr	s0, [sp, #12]
 8020810:	e7ee      	b.n	80207f0 <ppm_thread+0x170>
			is_running = false;
 8020812:	2300      	movs	r3, #0
 8020814:	f888 3000 	strb.w	r3, [r8]
				}
			}
		}

	}
}
 8020818:	b005      	add	sp, #20
 802081a:	ecbd 8b08 	vpop	{d8-d11}
 802081e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			const float ramp_step = (float)ST2MS(chVTTimeElapsedSinceX(last_time)) / (ramp_time * 1000.0);
 8020822:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 80209d8 <ppm_thread+0x358>
 8020826:	6abb      	ldr	r3, [r7, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8020828:	f8db 2000 	ldr.w	r2, [fp]
 802082c:	4966      	ldr	r1, [pc, #408]	; (80209c8 <ppm_thread+0x348>)
 802082e:	ed9f 7a67 	vldr	s14, [pc, #412]	; 80209cc <ppm_thread+0x34c>
 8020832:	1a9b      	subs	r3, r3, r2
 8020834:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8020838:	f242 720f 	movw	r2, #9999	; 0x270f
 802083c:	fb00 2303 	mla	r3, r0, r3, r2
 8020840:	fba1 2303 	umull	r2, r3, r1, r3
 8020844:	0b5b      	lsrs	r3, r3, #13
 8020846:	ee07 3a90 	vmov	s15, r3
 802084a:	ee60 0a87 	vmul.f32	s1, s1, s14
 802084e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			utils_step_towards(&servo_val_ramp, servo_val, ramp_step);
 8020852:	485f      	ldr	r0, [pc, #380]	; (80209d0 <ppm_thread+0x350>)
 8020854:	eec7 0aa0 	vdiv.f32	s1, s15, s1
 8020858:	f7f5 f8a2 	bl	80159a0 <utils_step_towards>
  return ch.vtlist.vt_systime;
 802085c:	6abb      	ldr	r3, [r7, #40]	; 0x28
			last_time = chVTGetSystemTimeX();
 802085e:	f8cb 3000 	str.w	r3, [fp]
			servo_val = servo_val_ramp;
 8020862:	f8da 3000 	ldr.w	r3, [sl]
 8020866:	9303      	str	r3, [sp, #12]
 8020868:	e79e      	b.n	80207a8 <ppm_thread+0x128>
			if (fabsf(servo_val) < 0.001) {
 802086a:	eddd 7a03 	vldr	s15, [sp, #12]
 802086e:	ed9f 7a5b 	vldr	s14, [pc, #364]	; 80209dc <ppm_thread+0x35c>
				pulses_without_power++;
 8020872:	4b54      	ldr	r3, [pc, #336]	; (80209c4 <ppm_thread+0x344>)
			if (fabsf(servo_val) < 0.001) {
 8020874:	eef0 6ae7 	vabs.f32	s13, s15
 8020878:	eef4 6ac7 	vcmpe.f32	s13, s14
 802087c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				pulses_without_power++;
 8020880:	bf42      	ittt	mi
 8020882:	681a      	ldrmi	r2, [r3, #0]
 8020884:	3201      	addmi	r2, #1
 8020886:	601a      	strmi	r2, [r3, #0]
			if (!(pulses_without_power < MIN_PULSES_WITHOUT_POWER && config.safe_start)) {
 8020888:	681a      	ldr	r2, [r3, #0]
 802088a:	2a31      	cmp	r2, #49	; 0x31
 802088c:	dc03      	bgt.n	8020896 <ppm_thread+0x216>
 802088e:	7e62      	ldrb	r2, [r4, #25]
 8020890:	2a00      	cmp	r2, #0
 8020892:	f040 80fb 	bne.w	8020a8c <ppm_thread+0x40c>
				mc_interface_set_pid_speed(servo_val * config.pid_max_erpm);
 8020896:	ed94 0a01 	vldr	s0, [r4, #4]
 802089a:	9301      	str	r3, [sp, #4]
 802089c:	ee27 0a80 	vmul.f32	s0, s15, s0
		bool current_mode_brake = false;
 80208a0:	f04f 0a00 	mov.w	sl, #0
				mc_interface_set_pid_speed(servo_val * config.pid_max_erpm);
 80208a4:	f7fb fca4 	bl	801c1f0 <mc_interface_set_pid_speed>
		float current = 0;
 80208a8:	eddf aa41 	vldr	s21, [pc, #260]	; 80209b0 <ppm_thread+0x330>
		bool current_mode = false;
 80208ac:	f8cd a000 	str.w	sl, [sp]
				send_current = true;
 80208b0:	2501      	movs	r5, #1
 80208b2:	9b01      	ldr	r3, [sp, #4]
 80208b4:	e023      	b.n	80208fe <ppm_thread+0x27e>
			if ((servo_val >= 0.0 && rpm_now > 0.0) || (servo_val < 0.0 && rpm_now < 0.0)) {
 80208b6:	eddd 7a03 	vldr	s15, [sp, #12]
 80208ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80208be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80208c2:	f2c0 80f8 	blt.w	8020ab6 <ppm_thread+0x436>
 80208c6:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80208ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80208ce:	f340 80f2 	ble.w	8020ab6 <ppm_thread+0x436>
				current = servo_val * mcconf->lo_current_motor_max_now;
 80208d2:	edd9 aa1d 	vldr	s21, [r9, #116]	; 0x74
 80208d6:	ee67 aaaa 	vmul.f32	s21, s15, s21
			if (fabsf(servo_val) < 0.001) {
 80208da:	ed9f 7a40 	vldr	s14, [pc, #256]	; 80209dc <ppm_thread+0x35c>
 80208de:	eef0 7ae7 	vabs.f32	s15, s15
 80208e2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80208e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80208ea:	f140 80f4 	bpl.w	8020ad6 <ppm_thread+0x456>
				pulses_without_power++;
 80208ee:	4b35      	ldr	r3, [pc, #212]	; (80209c4 <ppm_thread+0x344>)
 80208f0:	681a      	ldr	r2, [r3, #0]
 80208f2:	3201      	adds	r2, #1
 80208f4:	601a      	str	r2, [r3, #0]
			current_mode = true;
 80208f6:	2201      	movs	r2, #1
		bool current_mode_brake = false;
 80208f8:	f04f 0a00 	mov.w	sl, #0
			current_mode = true;
 80208fc:	9200      	str	r2, [sp, #0]
		if (pulses_without_power < MIN_PULSES_WITHOUT_POWER && config.safe_start) {
 80208fe:	681a      	ldr	r2, [r3, #0]
 8020900:	2a31      	cmp	r2, #49	; 0x31
 8020902:	dc03      	bgt.n	802090c <ppm_thread+0x28c>
 8020904:	7e62      	ldrb	r2, [r4, #25]
 8020906:	2a00      	cmp	r2, #0
 8020908:	f040 80c7 	bne.w	8020a9a <ppm_thread+0x41a>
		float rpm_local = mc_interface_get_rpm();
 802090c:	f7fa fe08 	bl	801b520 <mc_interface_get_rpm>
		if (config.multi_esc) {
 8020910:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
		float rpm_local = mc_interface_get_rpm();
 8020914:	eeb0 ba40 	vmov.f32	s22, s0
		float rpm_lowest = rpm_local;
 8020918:	eeb0 8a40 	vmov.f32	s16, s0
		if (config.multi_esc) {
 802091c:	2b00      	cmp	r3, #0
 802091e:	f040 808c 	bne.w	8020a3a <ppm_thread+0x3ba>
		if (send_current && config.multi_esc) {
 8020922:	b125      	cbz	r5, 802092e <ppm_thread+0x2ae>
 8020924:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8020928:	2b00      	cmp	r3, #0
 802092a:	f040 819d 	bne.w	8020c68 <ppm_thread+0x5e8>
		if (current_mode) {
 802092e:	9b00      	ldr	r3, [sp, #0]
 8020930:	2b00      	cmp	r3, #0
 8020932:	f43f aec9 	beq.w	80206c8 <ppm_thread+0x48>
			if (current_mode_brake) {
 8020936:	f1ba 0f00 	cmp.w	sl, #0
 802093a:	f040 8170 	bne.w	8020c1e <ppm_thread+0x59e>
				if (current_out < 0.0) {
 802093e:	eef5 aac0 	vcmpe.f32	s21, #0.0
 8020942:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				if (config.multi_esc) {
 8020946:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
				if (current_out < 0.0) {
 802094a:	f100 80ca 	bmi.w	8020ae2 <ppm_thread+0x462>
				if (config.multi_esc) {
 802094e:	2b00      	cmp	r3, #0
 8020950:	f040 81af 	bne.w	8020cb2 <ppm_thread+0x632>
					mc_interface_set_current(current_out);
 8020954:	eeb0 0a6a 	vmov.f32	s0, s21
 8020958:	f7fb fcc2 	bl	801c2e0 <mc_interface_set_current>
 802095c:	e6b4      	b.n	80206c8 <ppm_thread+0x48>
			if (servo_val >= 0.0) {
 802095e:	eddd 7a03 	vldr	s15, [sp, #12]
 8020962:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802096a:	f2c0 80c4 	blt.w	8020af6 <ppm_thread+0x476>
				current = servo_val * mcconf->lo_current_motor_max_now;
 802096e:	edd9 aa1d 	vldr	s21, [r9, #116]	; 0x74
 8020972:	ee67 aaaa 	vmul.f32	s21, s15, s21
		bool current_mode_brake = false;
 8020976:	f04f 0a00 	mov.w	sl, #0
			if (servo_val < 0.001) {
 802097a:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80209dc <ppm_thread+0x35c>
				pulses_without_power++;
 802097e:	4b11      	ldr	r3, [pc, #68]	; (80209c4 <ppm_thread+0x344>)
			if (servo_val < 0.001) {
 8020980:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020984:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020988:	f140 80a2 	bpl.w	8020ad0 <ppm_thread+0x450>
				pulses_without_power++;
 802098c:	681a      	ldr	r2, [r3, #0]
 802098e:	3201      	adds	r2, #1
 8020990:	601a      	str	r2, [r3, #0]
			current_mode = true;
 8020992:	2201      	movs	r2, #1
 8020994:	9200      	str	r2, [sp, #0]
 8020996:	e7b2      	b.n	80208fe <ppm_thread+0x27e>
 8020998:	20001a48 	.word	0x20001a48
 802099c:	2000d91c 	.word	0x2000d91c
 80209a0:	0802f5d0 	.word	0x0802f5d0
 80209a4:	2000def8 	.word	0x2000def8
 80209a8:	2000104e 	.word	0x2000104e
 80209ac:	08020ce1 	.word	0x08020ce1
 80209b0:	00000000 	.word	0x00000000
 80209b4:	3c23d70a 	.word	0x3c23d70a
 80209b8:	461c4000 	.word	0x461c4000
 80209bc:	3dcccccd 	.word	0x3dcccccd
 80209c0:	2000d954 	.word	0x2000d954
 80209c4:	2000defc 	.word	0x2000defc
 80209c8:	d1b71759 	.word	0xd1b71759
 80209cc:	447a0000 	.word	0x447a0000
 80209d0:	2000df04 	.word	0x2000df04
 80209d4:	2000d958 	.word	0x2000d958
 80209d8:	2000d95c 	.word	0x2000d95c
 80209dc:	3a83126f 	.word	0x3a83126f
			if (fabsf(servo_val) < 0.001) {
 80209e0:	ed9d 0a03 	vldr	s0, [sp, #12]
 80209e4:	ed5f 7a03 	vldr	s15, [pc, #-12]	; 80209dc <ppm_thread+0x35c>
				pulses_without_power++;
 80209e8:	4bb8      	ldr	r3, [pc, #736]	; (8020ccc <ppm_thread+0x64c>)
			if (fabsf(servo_val) < 0.001) {
 80209ea:	eeb0 7ac0 	vabs.f32	s14, s0
 80209ee:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80209f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				pulses_without_power++;
 80209f6:	bf42      	ittt	mi
 80209f8:	681a      	ldrmi	r2, [r3, #0]
 80209fa:	3201      	addmi	r2, #1
 80209fc:	601a      	strmi	r2, [r3, #0]
			if (!(pulses_without_power < MIN_PULSES_WITHOUT_POWER && config.safe_start)) {
 80209fe:	681a      	ldr	r2, [r3, #0]
 8020a00:	2a31      	cmp	r2, #49	; 0x31
 8020a02:	dc02      	bgt.n	8020a0a <ppm_thread+0x38a>
 8020a04:	7e62      	ldrb	r2, [r4, #25]
 8020a06:	2a00      	cmp	r2, #0
 8020a08:	d140      	bne.n	8020a8c <ppm_thread+0x40c>
				mc_interface_set_duty(utils_map(servo_val, -1.0, 1.0, -mcconf->l_max_duty, mcconf->l_max_duty));
 8020a0a:	edd9 1a16 	vldr	s3, [r9, #88]	; 0x58
 8020a0e:	ed99 2a16 	vldr	s4, [r9, #88]	; 0x58
 8020a12:	9301      	str	r3, [sp, #4]
 8020a14:	eef1 1a61 	vneg.f32	s3, s3
 8020a18:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8020a1c:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8020a20:	f7f5 f86e 	bl	8015b00 <utils_map>
		bool current_mode_brake = false;
 8020a24:	f04f 0a00 	mov.w	sl, #0
				mc_interface_set_duty(utils_map(servo_val, -1.0, 1.0, -mcconf->l_max_duty, mcconf->l_max_duty));
 8020a28:	f7fb fbb2 	bl	801c190 <mc_interface_set_duty>
		float current = 0;
 8020a2c:	eddf aaa8 	vldr	s21, [pc, #672]	; 8020cd0 <ppm_thread+0x650>
		bool current_mode = false;
 8020a30:	f8cd a000 	str.w	sl, [sp]
				send_current = true;
 8020a34:	2501      	movs	r5, #1
 8020a36:	9b01      	ldr	r3, [sp, #4]
 8020a38:	e761      	b.n	80208fe <ppm_thread+0x27e>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020a3a:	f04f 0b00 	mov.w	fp, #0
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 8020a3e:	4658      	mov	r0, fp
 8020a40:	f7fa f82e 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020a44:	6802      	ldr	r2, [r0, #0]
 8020a46:	2a00      	cmp	r2, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020a48:	f10b 0b01 	add.w	fp, fp, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020a4c:	db1a      	blt.n	8020a84 <ppm_thread+0x404>
 8020a4e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8020a50:	6841      	ldr	r1, [r0, #4]
 8020a52:	1a52      	subs	r2, r2, r1
 8020a54:	ee07 2a90 	vmov	s15, r2
 8020a58:	eef8 7a67 	vcvt.f32.u32	s15, s15
					if (fabsf(rpm_tmp) < fabsf(rpm_lowest)) {
 8020a5c:	eef0 6ac8 	vabs.f32	s13, s16
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020a60:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8020a64:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8020a68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a6c:	d50a      	bpl.n	8020a84 <ppm_thread+0x404>
					float rpm_tmp = msg->rpm;
 8020a6e:	edd0 7a02 	vldr	s15, [r0, #8]
					if (fabsf(rpm_tmp) < fabsf(rpm_lowest)) {
 8020a72:	eeb0 7ae7 	vabs.f32	s14, s15
						rpm_lowest = rpm_tmp;
 8020a76:	eeb4 7a66 	vcmp.f32	s14, s13
 8020a7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020a7e:	bf48      	it	mi
 8020a80:	eeb0 8a67 	vmovmi.f32	s16, s15
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020a84:	f1bb 0f0a 	cmp.w	fp, #10
 8020a88:	d1d9      	bne.n	8020a3e <ppm_thread+0x3be>
 8020a8a:	e74a      	b.n	8020922 <ppm_thread+0x2a2>
		bool current_mode_brake = false;
 8020a8c:	f04f 0a00 	mov.w	sl, #0
		bool current_mode = false;
 8020a90:	f8cd a000 	str.w	sl, [sp]
		float current = 0;
 8020a94:	eddf aa8e 	vldr	s21, [pc, #568]	; 8020cd0 <ppm_thread+0x650>
 8020a98:	e731      	b.n	80208fe <ppm_thread+0x27e>
			if (pulses_without_power == pulses_without_power_before) {
 8020a9a:	4a8e      	ldr	r2, [pc, #568]	; (8020cd4 <ppm_thread+0x654>)
 8020a9c:	6818      	ldr	r0, [r3, #0]
 8020a9e:	6811      	ldr	r1, [r2, #0]
 8020aa0:	4288      	cmp	r0, r1
				pulses_without_power = 0;
 8020aa2:	bf04      	itt	eq
 8020aa4:	2100      	moveq	r1, #0
 8020aa6:	6019      	streq	r1, [r3, #0]
			pulses_without_power_before = pulses_without_power;
 8020aa8:	681b      	ldr	r3, [r3, #0]
 8020aaa:	6013      	str	r3, [r2, #0]
			mc_interface_set_brake_current(timeout_get_brake_current());
 8020aac:	f7f9 fb78 	bl	801a1a0 <timeout_get_brake_current>
 8020ab0:	f7fb fc66 	bl	801c380 <mc_interface_set_brake_current>
			continue;
 8020ab4:	e608      	b.n	80206c8 <ppm_thread+0x48>
			if ((servo_val >= 0.0 && rpm_now > 0.0) || (servo_val < 0.0 && rpm_now < 0.0)) {
 8020ab6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020aba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020abe:	f100 80fb 	bmi.w	8020cb8 <ppm_thread+0x638>
				current = servo_val * fabsf(mcconf->lo_current_motor_min_now);
 8020ac2:	edd9 aa1e 	vldr	s21, [r9, #120]	; 0x78
 8020ac6:	eef0 aaea 	vabs.f32	s21, s21
 8020aca:	ee6a aaa7 	vmul.f32	s21, s21, s15
 8020ace:	e704      	b.n	80208da <ppm_thread+0x25a>
			current_mode = true;
 8020ad0:	2201      	movs	r2, #1
 8020ad2:	9200      	str	r2, [sp, #0]
 8020ad4:	e713      	b.n	80208fe <ppm_thread+0x27e>
			current_mode = true;
 8020ad6:	2301      	movs	r3, #1
 8020ad8:	9300      	str	r3, [sp, #0]
		bool current_mode_brake = false;
 8020ada:	f04f 0a00 	mov.w	sl, #0
 8020ade:	4b7b      	ldr	r3, [pc, #492]	; (8020ccc <ppm_thread+0x64c>)
 8020ae0:	e70d      	b.n	80208fe <ppm_thread+0x27e>
					current_out = -current_out;
 8020ae2:	eef1 aa6a 	vneg.f32	s21, s21
				if (config.multi_esc) {
 8020ae6:	f003 0aff 	and.w	sl, r3, #255	; 0xff
 8020aea:	b96b      	cbnz	r3, 8020b08 <ppm_thread+0x488>
					mc_interface_set_current(-current_out);
 8020aec:	eeb1 0a6a 	vneg.f32	s0, s21
 8020af0:	f7fb fbf6 	bl	801c2e0 <mc_interface_set_current>
 8020af4:	e5e8      	b.n	80206c8 <ppm_thread+0x48>
				current = fabsf(servo_val * mcconf->lo_current_motor_min_now);
 8020af6:	edd9 aa1e 	vldr	s21, [r9, #120]	; 0x78
 8020afa:	ee67 aaaa 	vmul.f32	s21, s15, s21
				current_mode_brake = true;
 8020afe:	f04f 0a01 	mov.w	sl, #1
				current = fabsf(servo_val * mcconf->lo_current_motor_min_now);
 8020b02:	eef0 aaea 	vabs.f32	s21, s21
 8020b06:	e738      	b.n	802097a <ppm_thread+0x2fa>
					rpm_local = -rpm_local;
 8020b08:	eeb1 ba4b 	vneg.f32	s22, s22
					rpm_lowest = -rpm_lowest;
 8020b0c:	eeb1 8a48 	vneg.f32	s16, s16
					current = -current;
 8020b10:	eef0 ba6a 	vmov.f32	s23, s21
 8020b14:	2500      	movs	r5, #0
 8020b16:	e027      	b.n	8020b68 <ppm_thread+0x4e8>
								float rpm_tmp = msg->rpm;
 8020b18:	ed90 0a02 	vldr	s0, [r0, #8]
 8020b1c:	9000      	str	r0, [sp, #0]
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020b1e:	ed94 1a0d 	vldr	s2, [r4, #52]	; 0x34
 8020b22:	eddf 0a6b 	vldr	s1, [pc, #428]	; 8020cd0 <ppm_thread+0x650>
								if (is_reverse) {
 8020b26:	f1ba 0f00 	cmp.w	sl, #0
 8020b2a:	d062      	beq.n	8020bf2 <ppm_thread+0x572>
									rpm_tmp = -rpm_tmp;
 8020b2c:	eeb1 0a40 	vneg.f32	s0, s0
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020b30:	ee30 0a48 	vsub.f32	s0, s0, s16
 8020b34:	eeb0 2a68 	vmov.f32	s4, s17
 8020b38:	eef0 1a6b 	vmov.f32	s3, s23
 8020b3c:	f7f4 ffe0 	bl	8015b00 <utils_map>
								if (current_out < mcconf->cc_min_current) {
 8020b40:	edd9 7a50 	vldr	s15, [r9, #320]	; 0x140
 8020b44:	9800      	ldr	r0, [sp, #0]
 8020b46:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8020b4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020b4e:	eef0 aa40 	vmov.f32	s21, s0
 8020b52:	6801      	ldr	r1, [r0, #0]
								if (current_out < mcconf->cc_min_current) {
 8020b54:	f100 80b7 	bmi.w	8020cc6 <ppm_thread+0x646>
								comm_can_set_current(msg->id, -current_out);
 8020b58:	b2c8      	uxtb	r0, r1
 8020b5a:	eeb1 0a6a 	vneg.f32	s0, s21
 8020b5e:	f7f9 ff5f 	bl	801aa20 <comm_can_set_current>
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020b62:	3501      	adds	r5, #1
 8020b64:	2d0a      	cmp	r5, #10
 8020b66:	d020      	beq.n	8020baa <ppm_thread+0x52a>
						can_status_msg *msg = comm_can_get_status_msg_index(i);
 8020b68:	4628      	mov	r0, r5
 8020b6a:	f7f9 ff99 	bl	801aaa0 <comm_can_get_status_msg_index>
						if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020b6e:	6801      	ldr	r1, [r0, #0]
 8020b70:	2900      	cmp	r1, #0
 8020b72:	dbf6      	blt.n	8020b62 <ppm_thread+0x4e2>
  return ch.vtlist.vt_systime;
 8020b74:	6abb      	ldr	r3, [r7, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8020b76:	6842      	ldr	r2, [r0, #4]
 8020b78:	1a9b      	subs	r3, r3, r2
 8020b7a:	ee07 3a90 	vmov	s15, r3
 8020b7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020b82:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8020b86:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8020b8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b8e:	d5e8      	bpl.n	8020b62 <ppm_thread+0x4e2>
							if (config.tc) {
 8020b90:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 8020b94:	2b00      	cmp	r3, #0
 8020b96:	d1bf      	bne.n	8020b18 <ppm_thread+0x498>
							if (is_reverse) {
 8020b98:	f1ba 0f00 	cmp.w	sl, #0
 8020b9c:	d1dc      	bne.n	8020b58 <ppm_thread+0x4d8>
								comm_can_set_current(msg->id, current_out);
 8020b9e:	b2c8      	uxtb	r0, r1
 8020ba0:	eeb0 0a6a 	vmov.f32	s0, s21
 8020ba4:	f7f9 ff3c 	bl	801aa20 <comm_can_set_current>
 8020ba8:	e7db      	b.n	8020b62 <ppm_thread+0x4e2>
					if (config.tc) {
 8020baa:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 8020bae:	b923      	cbnz	r3, 8020bba <ppm_thread+0x53a>
				if (is_reverse) {
 8020bb0:	f1ba 0f00 	cmp.w	sl, #0
 8020bb4:	f43f aece 	beq.w	8020954 <ppm_thread+0x2d4>
 8020bb8:	e798      	b.n	8020aec <ppm_thread+0x46c>
						current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020bba:	ed94 1a0d 	vldr	s2, [r4, #52]	; 0x34
 8020bbe:	eddf 0a44 	vldr	s1, [pc, #272]	; 8020cd0 <ppm_thread+0x650>
 8020bc2:	eef0 1a6b 	vmov.f32	s3, s23
 8020bc6:	ee3b 0a48 	vsub.f32	s0, s22, s16
 8020bca:	eeb0 2a68 	vmov.f32	s4, s17
 8020bce:	f7f4 ff97 	bl	8015b00 <utils_map>
						if (current_out < mcconf->cc_min_current) {
 8020bd2:	edd9 7a50 	vldr	s15, [r9, #320]	; 0x140
							current_out = 0.0;
 8020bd6:	eef4 7a40 	vcmp.f32	s15, s0
						current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020bda:	eef0 aa40 	vmov.f32	s21, s0
							current_out = 0.0;
 8020bde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020be2:	bfc8      	it	gt
 8020be4:	eef0 aa68 	vmovgt.f32	s21, s17
				if (is_reverse) {
 8020be8:	f1ba 0f00 	cmp.w	sl, #0
 8020bec:	f43f aeb2 	beq.w	8020954 <ppm_thread+0x2d4>
 8020bf0:	e77c      	b.n	8020aec <ppm_thread+0x46c>
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020bf2:	ee30 0a48 	vsub.f32	s0, s0, s16
 8020bf6:	eeb0 2a68 	vmov.f32	s4, s17
 8020bfa:	eef0 1a6b 	vmov.f32	s3, s23
 8020bfe:	f7f4 ff7f 	bl	8015b00 <utils_map>
								if (current_out < mcconf->cc_min_current) {
 8020c02:	edd9 7a50 	vldr	s15, [r9, #320]	; 0x140
 8020c06:	9800      	ldr	r0, [sp, #0]
 8020c08:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8020c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8020c10:	eef0 aa40 	vmov.f32	s21, s0
 8020c14:	6801      	ldr	r1, [r0, #0]
								if (current_out < mcconf->cc_min_current) {
 8020c16:	d5c2      	bpl.n	8020b9e <ppm_thread+0x51e>
									current_out = 0.0;
 8020c18:	eddf aa2d 	vldr	s21, [pc, #180]	; 8020cd0 <ppm_thread+0x650>
 8020c1c:	e7bf      	b.n	8020b9e <ppm_thread+0x51e>
				mc_interface_set_brake_current(current);
 8020c1e:	eeb0 0a6a 	vmov.f32	s0, s21
 8020c22:	f7fb fbad 	bl	801c380 <mc_interface_set_brake_current>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020c26:	2500      	movs	r5, #0
 8020c28:	e002      	b.n	8020c30 <ppm_thread+0x5b0>
 8020c2a:	2d0a      	cmp	r5, #10
 8020c2c:	f43f ad4c 	beq.w	80206c8 <ppm_thread+0x48>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 8020c30:	4628      	mov	r0, r5
 8020c32:	f7f9 ff35 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020c36:	6802      	ldr	r2, [r0, #0]
 8020c38:	2a00      	cmp	r2, #0
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020c3a:	f105 0501 	add.w	r5, r5, #1
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020c3e:	dbf4      	blt.n	8020c2a <ppm_thread+0x5aa>
 8020c40:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 8020c42:	6abb      	ldr	r3, [r7, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8020c44:	1a5b      	subs	r3, r3, r1
 8020c46:	ee07 3a90 	vmov	s15, r3
 8020c4a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020c4e:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8020c52:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8020c56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020c5a:	d5e6      	bpl.n	8020c2a <ppm_thread+0x5aa>
						comm_can_set_current_brake(msg->id, current);
 8020c5c:	b2d0      	uxtb	r0, r2
 8020c5e:	eeb0 0a6a 	vmov.f32	s0, s21
 8020c62:	f7f9 fefd 	bl	801aa60 <comm_can_set_current_brake>
 8020c66:	e7e0      	b.n	8020c2a <ppm_thread+0x5aa>
			float current = mc_interface_get_tot_current_directional_filtered();
 8020c68:	f7fa fd0a 	bl	801b680 <mc_interface_get_tot_current_directional_filtered>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020c6c:	2500      	movs	r5, #0
			float current = mc_interface_get_tot_current_directional_filtered();
 8020c6e:	eef0 ba40 	vmov.f32	s23, s0
 8020c72:	e002      	b.n	8020c7a <ppm_thread+0x5fa>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020c74:	2d0a      	cmp	r5, #10
 8020c76:	f43f ae5a 	beq.w	802092e <ppm_thread+0x2ae>
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 8020c7a:	4628      	mov	r0, r5
 8020c7c:	f7f9 ff10 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020c80:	6802      	ldr	r2, [r0, #0]
 8020c82:	2a00      	cmp	r2, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8020c84:	f105 0501 	add.w	r5, r5, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020c88:	dbf4      	blt.n	8020c74 <ppm_thread+0x5f4>
 8020c8a:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 8020c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8020c8e:	1a5b      	subs	r3, r3, r1
 8020c90:	ee07 3a90 	vmov	s15, r3
 8020c94:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020c98:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8020c9c:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8020ca0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ca4:	d5e6      	bpl.n	8020c74 <ppm_thread+0x5f4>
					comm_can_set_current(msg->id, current);
 8020ca6:	b2d0      	uxtb	r0, r2
 8020ca8:	eeb0 0a6b 	vmov.f32	s0, s23
 8020cac:	f7f9 feb8 	bl	801aa20 <comm_can_set_current>
 8020cb0:	e7e0      	b.n	8020c74 <ppm_thread+0x5f4>
				if (config.multi_esc) {
 8020cb2:	eef0 ba6a 	vmov.f32	s23, s21
 8020cb6:	e72d      	b.n	8020b14 <ppm_thread+0x494>
			if ((servo_val >= 0.0 && rpm_now > 0.0) || (servo_val < 0.0 && rpm_now < 0.0)) {
 8020cb8:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8020cbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020cc0:	f57f aeff 	bpl.w	8020ac2 <ppm_thread+0x442>
 8020cc4:	e605      	b.n	80208d2 <ppm_thread+0x252>
									current_out = 0.0;
 8020cc6:	eddf aa02 	vldr	s21, [pc, #8]	; 8020cd0 <ppm_thread+0x650>
 8020cca:	e745      	b.n	8020b58 <ppm_thread+0x4d8>
 8020ccc:	2000defc 	.word	0x2000defc
 8020cd0:	00000000 	.word	0x00000000
 8020cd4:	2000df00 	.word	0x2000df00
	...

08020ce0 <servodec_func>:
static void servodec_func(void) {
 8020ce0:	b508      	push	{r3, lr}
 8020ce2:	2320      	movs	r3, #32
 8020ce4:	f383 8811 	msr	BASEPRI, r3
	timeout_reset();
 8020ce8:	f7f9 fa3a 	bl	801a160 <timeout_reset>
	chEvtSignalI(ppm_tp, (eventmask_t) 1);
 8020cec:	4b04      	ldr	r3, [pc, #16]	; (8020d00 <servodec_func+0x20>)
 8020cee:	2101      	movs	r1, #1
 8020cf0:	6818      	ldr	r0, [r3, #0]
 8020cf2:	f7ed f895 	bl	800de20 <chEvtSignalI>
 8020cf6:	2300      	movs	r3, #0
 8020cf8:	f383 8811 	msr	BASEPRI, r3
}
 8020cfc:	bd08      	pop	{r3, pc}
 8020cfe:	bf00      	nop
 8020d00:	2000def8 	.word	0x2000def8
	...

08020d10 <update>:
	if (!is_running) {
 8020d10:	4b0e      	ldr	r3, [pc, #56]	; (8020d4c <update+0x3c>)
 8020d12:	781b      	ldrb	r3, [r3, #0]
 8020d14:	b903      	cbnz	r3, 8020d18 <update+0x8>
 8020d16:	4770      	bx	lr
static void update(void *p) {
 8020d18:	b510      	push	{r4, lr}
 8020d1a:	2320      	movs	r3, #32
 8020d1c:	4604      	mov	r4, r0
 8020d1e:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8020d22:	480b      	ldr	r0, [pc, #44]	; (8020d50 <update+0x40>)
 8020d24:	68c3      	ldr	r3, [r0, #12]
 8020d26:	b10b      	cbz	r3, 8020d2c <update+0x1c>
    chVTDoResetI(vtp);
 8020d28:	f7ec fc6a 	bl	800d600 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8020d2c:	4623      	mov	r3, r4
 8020d2e:	4a09      	ldr	r2, [pc, #36]	; (8020d54 <update+0x44>)
 8020d30:	4807      	ldr	r0, [pc, #28]	; (8020d50 <update+0x40>)
 8020d32:	2114      	movs	r1, #20
 8020d34:	f7ec fc44 	bl	800d5c0 <chVTDoSetI>
	chEvtSignalI(ppm_tp, (eventmask_t) 1);
 8020d38:	4b07      	ldr	r3, [pc, #28]	; (8020d58 <update+0x48>)
 8020d3a:	2101      	movs	r1, #1
 8020d3c:	6818      	ldr	r0, [r3, #0]
 8020d3e:	f7ed f86f 	bl	800de20 <chEvtSignalI>
 8020d42:	2300      	movs	r3, #0
 8020d44:	f383 8811 	msr	BASEPRI, r3
}
 8020d48:	bd10      	pop	{r4, pc}
 8020d4a:	bf00      	nop
 8020d4c:	2000d958 	.word	0x2000d958
 8020d50:	2000df08 	.word	0x2000df08
 8020d54:	08020d11 	.word	0x08020d11
 8020d58:	2000def8 	.word	0x2000def8
 8020d5c:	00000000 	.word	0x00000000

08020d60 <app_ppm_configure>:
void app_ppm_configure(ppm_config *conf) {
 8020d60:	b4f0      	push	{r4, r5, r6, r7}
	config = *conf;
 8020d62:	4605      	mov	r5, r0
 8020d64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020d66:	4e0d      	ldr	r6, [pc, #52]	; (8020d9c <app_ppm_configure+0x3c>)
	pulses_without_power = 0;
 8020d68:	4f0d      	ldr	r7, [pc, #52]	; (8020da0 <app_ppm_configure+0x40>)
	config = *conf;
 8020d6a:	4634      	mov	r4, r6
 8020d6c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020d6e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020d70:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020d72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020d74:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020d76:	e895 0003 	ldmia.w	r5, {r0, r1}
 8020d7a:	e884 0003 	stmia.w	r4, {r0, r1}
	pulses_without_power = 0;
 8020d7e:	2200      	movs	r2, #0
	if (is_running) {
 8020d80:	4b08      	ldr	r3, [pc, #32]	; (8020da4 <app_ppm_configure+0x44>)
	pulses_without_power = 0;
 8020d82:	603a      	str	r2, [r7, #0]
	if (is_running) {
 8020d84:	781b      	ldrb	r3, [r3, #0]
 8020d86:	b90b      	cbnz	r3, 8020d8c <app_ppm_configure+0x2c>
}
 8020d88:	bcf0      	pop	{r4, r5, r6, r7}
 8020d8a:	4770      	bx	lr
		servodec_set_pulse_options(config.pulse_start, config.pulse_end, config.median_filter);
 8020d8c:	ed96 0a03 	vldr	s0, [r6, #12]
 8020d90:	edd6 0a04 	vldr	s1, [r6, #16]
 8020d94:	7e30      	ldrb	r0, [r6, #24]
}
 8020d96:	bcf0      	pop	{r4, r5, r6, r7}
		servodec_set_pulse_options(config.pulse_start, config.pulse_end, config.median_filter);
 8020d98:	f7f4 bdc2 	b.w	8015920 <servodec_set_pulse_options>
 8020d9c:	2000d91c 	.word	0x2000d91c
 8020da0:	2000defc 	.word	0x2000defc
 8020da4:	2000d958 	.word	0x2000d958
	...

08020db0 <app_ppm_start>:
void app_ppm_start(void) {
 8020db0:	b530      	push	{r4, r5, lr}
 8020db2:	b083      	sub	sp, #12
	stop_now = false;
 8020db4:	2400      	movs	r4, #0
 8020db6:	4d0e      	ldr	r5, [pc, #56]	; (8020df0 <app_ppm_start+0x40>)
	chThdCreateStatic(ppm_thread_wa, sizeof(ppm_thread_wa), NORMALPRIO, ppm_thread, NULL);
 8020db8:	4b0e      	ldr	r3, [pc, #56]	; (8020df4 <app_ppm_start+0x44>)
 8020dba:	9400      	str	r4, [sp, #0]
 8020dbc:	2240      	movs	r2, #64	; 0x40
 8020dbe:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 8020dc2:	480d      	ldr	r0, [pc, #52]	; (8020df8 <app_ppm_start+0x48>)
	stop_now = false;
 8020dc4:	702c      	strb	r4, [r5, #0]
	chThdCreateStatic(ppm_thread_wa, sizeof(ppm_thread_wa), NORMALPRIO, ppm_thread, NULL);
 8020dc6:	f7ec fdd3 	bl	800d970 <chThdCreateStatic>
 8020dca:	2320      	movs	r3, #32
 8020dcc:	f383 8811 	msr	BASEPRI, r3
  if (chVTIsArmedI(vtp)) {
 8020dd0:	480a      	ldr	r0, [pc, #40]	; (8020dfc <app_ppm_start+0x4c>)
 8020dd2:	68c3      	ldr	r3, [r0, #12]
 8020dd4:	b10b      	cbz	r3, 8020dda <app_ppm_start+0x2a>
    chVTDoResetI(vtp);
 8020dd6:	f7ec fc13 	bl	800d600 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8020dda:	2300      	movs	r3, #0
 8020ddc:	4a08      	ldr	r2, [pc, #32]	; (8020e00 <app_ppm_start+0x50>)
 8020dde:	4807      	ldr	r0, [pc, #28]	; (8020dfc <app_ppm_start+0x4c>)
 8020de0:	210a      	movs	r1, #10
 8020de2:	f7ec fbed 	bl	800d5c0 <chVTDoSetI>
 8020de6:	2300      	movs	r3, #0
 8020de8:	f383 8811 	msr	BASEPRI, r3
}
 8020dec:	b003      	add	sp, #12
 8020dee:	bd30      	pop	{r4, r5, pc}
 8020df0:	2000104e 	.word	0x2000104e
 8020df4:	08020681 	.word	0x08020681
 8020df8:	2000d960 	.word	0x2000d960
 8020dfc:	2000df08 	.word	0x2000df08
 8020e00:	08020d11 	.word	0x08020d11
	...

08020e10 <app_ppm_stop>:
	stop_now = true;
 8020e10:	4b0a      	ldr	r3, [pc, #40]	; (8020e3c <app_ppm_stop+0x2c>)
void app_ppm_stop(void) {
 8020e12:	b510      	push	{r4, lr}
	stop_now = true;
 8020e14:	2101      	movs	r1, #1
	if (is_running) {
 8020e16:	4c0a      	ldr	r4, [pc, #40]	; (8020e40 <app_ppm_stop+0x30>)
	stop_now = true;
 8020e18:	7019      	strb	r1, [r3, #0]
	if (is_running) {
 8020e1a:	7823      	ldrb	r3, [r4, #0]
 8020e1c:	b11b      	cbz	r3, 8020e26 <app_ppm_stop+0x16>
 8020e1e:	e006      	b.n	8020e2e <app_ppm_stop+0x1e>
		chThdSleepMilliseconds(1);
 8020e20:	200a      	movs	r0, #10
 8020e22:	f7ec fddd 	bl	800d9e0 <chThdSleep>
	while(is_running) {
 8020e26:	7823      	ldrb	r3, [r4, #0]
 8020e28:	2b00      	cmp	r3, #0
 8020e2a:	d1f9      	bne.n	8020e20 <app_ppm_stop+0x10>
}
 8020e2c:	bd10      	pop	{r4, pc}
		chEvtSignalI(ppm_tp, (eventmask_t) 1);
 8020e2e:	4b05      	ldr	r3, [pc, #20]	; (8020e44 <app_ppm_stop+0x34>)
 8020e30:	6818      	ldr	r0, [r3, #0]
 8020e32:	f7ec fff5 	bl	800de20 <chEvtSignalI>
		servodec_stop();
 8020e36:	f7f4 fd43 	bl	80158c0 <servodec_stop>
 8020e3a:	e7f4      	b.n	8020e26 <app_ppm_stop+0x16>
 8020e3c:	2000104e 	.word	0x2000104e
 8020e40:	2000d958 	.word	0x2000d958
 8020e44:	2000def8 	.word	0x2000def8
	...

08020e50 <app_ppm_get_decoded_level>:
	return input_val;
 8020e50:	4b01      	ldr	r3, [pc, #4]	; (8020e58 <app_ppm_get_decoded_level+0x8>)
}
 8020e52:	ed93 0a00 	vldr	s0, [r3]
 8020e56:	4770      	bx	lr
 8020e58:	2000d954 	.word	0x2000d954
 8020e5c:	00000000 	.word	0x00000000

08020e60 <adc_thread>:
float app_adc_get_voltage2(void) {
	return read_voltage2;
}


static THD_FUNCTION(adc_thread, arg) {
 8020e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)arg;

	chRegSetThreadName("APP_ADC");

	// Set servo pin as an input with pullup
	if (use_rx_tx_as_buttons) {
 8020e64:	4bbd      	ldr	r3, [pc, #756]	; (802115c <adc_thread+0x2fc>)
 8020e66:	f8df 8348 	ldr.w	r8, [pc, #840]	; 80211b0 <adc_thread+0x350>
 8020e6a:	781b      	ldrb	r3, [r3, #0]
 8020e6c:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8020e70:	49bb      	ldr	r1, [pc, #748]	; (8021160 <adc_thread+0x300>)
static THD_FUNCTION(adc_thread, arg) {
 8020e72:	ed2d 8b08 	vpush	{d8-d11}
 8020e76:	6191      	str	r1, [r2, #24]
 8020e78:	b085      	sub	sp, #20
		palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT_PULLUP);
 8020e7a:	2220      	movs	r2, #32
	if (use_rx_tx_as_buttons) {
 8020e7c:	2b00      	cmp	r3, #0
 8020e7e:	f000 8424 	beq.w	80216ca <adc_thread+0x86a>
		palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT_PULLUP);
 8020e82:	2140      	movs	r1, #64	; 0x40
 8020e84:	48b7      	ldr	r0, [pc, #732]	; (8021164 <adc_thread+0x304>)
 8020e86:	f7ee ffeb 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_INPUT_PULLUP);
 8020e8a:	2220      	movs	r2, #32
 8020e8c:	2180      	movs	r1, #128	; 0x80
 8020e8e:	48b5      	ldr	r0, [pc, #724]	; (8021164 <adc_thread+0x304>)
 8020e90:	f7ee ffe6 	bl	800fe60 <_pal_lld_setgroupmode>
	} else {
		palSetPadMode(HW_ICU_GPIO, HW_ICU_PIN, PAL_MODE_INPUT_PULLUP);
	}

	is_running = true;
 8020e94:	4ab4      	ldr	r2, [pc, #720]	; (8021168 <adc_thread+0x308>)
 8020e96:	4cb5      	ldr	r4, [pc, #724]	; (802116c <adc_thread+0x30c>)
			return;
		}

		// For safe start when fault codes occur
		if (mc_interface_get_fault() != FAULT_CODE_NONE) {
			ms_without_power = 0;
 8020e98:	ed9f 8ab5 	vldr	s16, [pc, #724]	; 8021170 <adc_thread+0x310>
		}

		// Read the external ADC pin and convert the value to a voltage.
		float pwr = (float)ADC_Value[ADC_IND_EXT];
		pwr /= 4095;
 8020e9c:	eddf 9ab5 	vldr	s19, [pc, #724]	; 8021174 <adc_thread+0x314>
				// Traction control
				if (config.multi_esc) {
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
						can_status_msg *msg = comm_can_get_status_msg_index(i);

						if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8020ea0:	eddf 8ab5 	vldr	s17, [pc, #724]	; 8021178 <adc_thread+0x318>
 8020ea4:	ed9f 9ab5 	vldr	s18, [pc, #724]	; 802117c <adc_thread+0x31c>
	is_running = true;
 8020ea8:	2301      	movs	r3, #1
 8020eaa:	7013      	strb	r3, [r2, #0]
		systime_t sleep_time = CH_CFG_ST_FREQUENCY / config.update_rate_hz;
 8020eac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8020eae:	f242 7510 	movw	r5, #10000	; 0x2710
 8020eb2:	fbb5 f5f3 	udiv	r5, r5, r3
			sleep_time = 1;
 8020eb6:	2d00      	cmp	r5, #0
 8020eb8:	bf08      	it	eq
 8020eba:	2501      	moveq	r5, #1
		chThdSleep(sleep_time);
 8020ebc:	4628      	mov	r0, r5
 8020ebe:	f7ec fd8f 	bl	800d9e0 <chThdSleep>
		if (stop_now) {
 8020ec2:	4baf      	ldr	r3, [pc, #700]	; (8021180 <adc_thread+0x320>)
 8020ec4:	781b      	ldrb	r3, [r3, #0]
 8020ec6:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 8020eca:	2b00      	cmp	r3, #0
 8020ecc:	f040 83a5 	bne.w	802161a <adc_thread+0x7ba>
		if (mc_interface_get_fault() != FAULT_CODE_NONE) {
 8020ed0:	f7fa fac6 	bl	801b460 <mc_interface_get_fault>
 8020ed4:	b118      	cbz	r0, 8020ede <adc_thread+0x7e>
			ms_without_power = 0;
 8020ed6:	f8df b2dc 	ldr.w	fp, [pc, #732]	; 80211b4 <adc_thread+0x354>
 8020eda:	ed8b 8a00 	vstr	s16, [fp]
		float pwr = (float)ADC_Value[ADC_IND_EXT];
 8020ede:	4ea9      	ldr	r6, [pc, #676]	; (8021184 <adc_thread+0x324>)
		pwr *= V_REG;
 8020ee0:	ed9f 0aa9 	vldr	s0, [pc, #676]	; 8021188 <adc_thread+0x328>
		float pwr = (float)ADC_Value[ADC_IND_EXT];
 8020ee4:	8ab3      	ldrh	r3, [r6, #20]
 8020ee6:	ee07 3a10 	vmov	s14, r3
 8020eea:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		read_voltage = pwr;
 8020eee:	4ba7      	ldr	r3, [pc, #668]	; (802118c <adc_thread+0x32c>)
		pwr /= 4095;
 8020ef0:	eec7 7a29 	vdiv.f32	s15, s14, s19
		pwr *= V_REG;
 8020ef4:	ee27 0a80 	vmul.f32	s0, s15, s0
		read_voltage = pwr;
 8020ef8:	ed83 0a00 	vstr	s0, [r3]
		if (config.use_filter) {
 8020efc:	7f23      	ldrb	r3, [r4, #28]
		pwr *= V_REG;
 8020efe:	ed8d 0a02 	vstr	s0, [sp, #8]
		if (config.use_filter) {
 8020f02:	b33b      	cbz	r3, 8020f54 <adc_thread+0xf4>
			filter_buffer[filter_ptr++] = pwr;
 8020f04:	49a2      	ldr	r1, [pc, #648]	; (8021190 <adc_thread+0x330>)
 8020f06:	4ba3      	ldr	r3, [pc, #652]	; (8021194 <adc_thread+0x334>)
 8020f08:	680a      	ldr	r2, [r1, #0]
 8020f0a:	1c50      	adds	r0, r2, #1
 8020f0c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8020f10:	ed82 0a00 	vstr	s0, [r2]
				pwr += filter_buffer[i];
 8020f14:	edd3 7a00 	vldr	s15, [r3]
 8020f18:	edd3 5a01 	vldr	s11, [r3, #4]
 8020f1c:	ed93 6a02 	vldr	s12, [r3, #8]
 8020f20:	edd3 6a03 	vldr	s13, [r3, #12]
 8020f24:	ed93 7a04 	vldr	s14, [r3, #16]
			filter_buffer[filter_ptr++] = pwr;
 8020f28:	6008      	str	r0, [r1, #0]
				pwr += filter_buffer[i];
 8020f2a:	ee77 7a88 	vadd.f32	s15, s15, s16
			pwr /= FILTER_SAMPLES;
 8020f2e:	eeb1 5a04 	vmov.f32	s10, #20	; 0x40a00000  5.0
				pwr += filter_buffer[i];
 8020f32:	ee77 7aa5 	vadd.f32	s15, s15, s11
			if (filter_ptr >= FILTER_SAMPLES) {
 8020f36:	2804      	cmp	r0, #4
				pwr += filter_buffer[i];
 8020f38:	ee77 7a86 	vadd.f32	s15, s15, s12
				filter_ptr = 0;
 8020f3c:	bfc8      	it	gt
 8020f3e:	2200      	movgt	r2, #0
				pwr += filter_buffer[i];
 8020f40:	ee77 7aa6 	vadd.f32	s15, s15, s13
				filter_ptr = 0;
 8020f44:	bfc8      	it	gt
 8020f46:	600a      	strgt	r2, [r1, #0]
				pwr += filter_buffer[i];
 8020f48:	ee77 7a87 	vadd.f32	s15, s15, s14
			pwr /= FILTER_SAMPLES;
 8020f4c:	ee87 0a85 	vdiv.f32	s0, s15, s10
 8020f50:	ed8d 0a02 	vstr	s0, [sp, #8]
		switch (config.ctrl_type) {
 8020f54:	7823      	ldrb	r3, [r4, #0]
 8020f56:	b2db      	uxtb	r3, r3
 8020f58:	2b0c      	cmp	r3, #12
 8020f5a:	f200 8260 	bhi.w	802141e <adc_thread+0x5be>
 8020f5e:	2201      	movs	r2, #1
 8020f60:	fa02 f303 	lsl.w	r3, r2, r3
 8020f64:	f241 2224 	movw	r2, #4644	; 0x1224
 8020f68:	4213      	tst	r3, r2
 8020f6a:	f000 8258 	beq.w	802141e <adc_thread+0x5be>
			if (pwr < config.voltage_center) {
 8020f6e:	edd4 7a04 	vldr	s15, [r4, #16]
 8020f72:	eef4 7ac0 	vcmpe.f32	s15, s0
 8020f76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020f7a:	f340 8356 	ble.w	802162a <adc_thread+0x7ca>
				pwr = utils_map(pwr, config.voltage_start,
 8020f7e:	edd4 0a02 	vldr	s1, [r4, #8]
 8020f82:	ed94 1a04 	vldr	s2, [r4, #16]
 8020f86:	eeb6 2a00 	vmov.f32	s4, #96	; 0x3f000000  0.5
 8020f8a:	eef0 1a48 	vmov.f32	s3, s16
 8020f8e:	f7f4 fdb7 	bl	8015b00 <utils_map>
 8020f92:	ed8d 0a02 	vstr	s0, [sp, #8]
		utils_truncate_number(&pwr, 0.0, 1.0);
 8020f96:	a802      	add	r0, sp, #8
 8020f98:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8020f9c:	eeb0 0a48 	vmov.f32	s0, s16
 8020fa0:	f7f4 fd6e 	bl	8015a80 <utils_truncate_number>
		if (config.voltage_inverted) {
 8020fa4:	f894 3020 	ldrb.w	r3, [r4, #32]
			pwr = 1.0 - pwr;
 8020fa8:	eddd 7a02 	vldr	s15, [sp, #8]
		if (config.voltage_inverted) {
 8020fac:	b12b      	cbz	r3, 8020fba <adc_thread+0x15a>
			pwr = 1.0 - pwr;
 8020fae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8020fb2:	ee77 7a67 	vsub.f32	s15, s14, s15
 8020fb6:	edcd 7a02 	vstr	s15, [sp, #8]
		decoded_level = pwr;
 8020fba:	4b77      	ldr	r3, [pc, #476]	; (8021198 <adc_thread+0x338>)
		brake *= V_REG;
 8020fbc:	ed9f 0a72 	vldr	s0, [pc, #456]	; 8021188 <adc_thread+0x328>
		decoded_level = pwr;
 8020fc0:	edc3 7a00 	vstr	s15, [r3]
		float brake = (float)ADC_Value[ADC_IND_EXT2];
 8020fc4:	89f3      	ldrh	r3, [r6, #14]
 8020fc6:	ee07 3a10 	vmov	s14, r3
 8020fca:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		read_voltage2 = brake;
 8020fce:	4b73      	ldr	r3, [pc, #460]	; (802119c <adc_thread+0x33c>)
		brake /= 4095;
 8020fd0:	eec7 7a29 	vdiv.f32	s15, s14, s19
		brake *= V_REG;
 8020fd4:	ee27 0a80 	vmul.f32	s0, s15, s0
		read_voltage2 = brake;
 8020fd8:	ed83 0a00 	vstr	s0, [r3]
		if (config.use_filter) {
 8020fdc:	7f23      	ldrb	r3, [r4, #28]
		brake *= V_REG;
 8020fde:	ed8d 0a03 	vstr	s0, [sp, #12]
		if (config.use_filter) {
 8020fe2:	b33b      	cbz	r3, 8021034 <adc_thread+0x1d4>
			filter_buffer2[filter_ptr2++] = brake;
 8020fe4:	496e      	ldr	r1, [pc, #440]	; (80211a0 <adc_thread+0x340>)
 8020fe6:	4b6f      	ldr	r3, [pc, #444]	; (80211a4 <adc_thread+0x344>)
 8020fe8:	680a      	ldr	r2, [r1, #0]
 8020fea:	1c50      	adds	r0, r2, #1
 8020fec:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8020ff0:	ed82 0a00 	vstr	s0, [r2]
				brake += filter_buffer2[i];
 8020ff4:	edd3 7a00 	vldr	s15, [r3]
 8020ff8:	edd3 5a01 	vldr	s11, [r3, #4]
 8020ffc:	ed93 6a02 	vldr	s12, [r3, #8]
 8021000:	edd3 6a03 	vldr	s13, [r3, #12]
 8021004:	ed93 7a04 	vldr	s14, [r3, #16]
			filter_buffer2[filter_ptr2++] = brake;
 8021008:	6008      	str	r0, [r1, #0]
				brake += filter_buffer2[i];
 802100a:	ee77 7a88 	vadd.f32	s15, s15, s16
			brake /= FILTER_SAMPLES;
 802100e:	eeb1 5a04 	vmov.f32	s10, #20	; 0x40a00000  5.0
				brake += filter_buffer2[i];
 8021012:	ee77 7aa5 	vadd.f32	s15, s15, s11
			if (filter_ptr2 >= FILTER_SAMPLES) {
 8021016:	2804      	cmp	r0, #4
				brake += filter_buffer2[i];
 8021018:	ee77 7a86 	vadd.f32	s15, s15, s12
				filter_ptr2 = 0;
 802101c:	bfc8      	it	gt
 802101e:	2200      	movgt	r2, #0
				brake += filter_buffer2[i];
 8021020:	ee77 7aa6 	vadd.f32	s15, s15, s13
				filter_ptr2 = 0;
 8021024:	bfc8      	it	gt
 8021026:	600a      	strgt	r2, [r1, #0]
				brake += filter_buffer2[i];
 8021028:	ee77 7a87 	vadd.f32	s15, s15, s14
			brake /= FILTER_SAMPLES;
 802102c:	ee87 0a85 	vdiv.f32	s0, s15, s10
 8021030:	ed8d 0a03 	vstr	s0, [sp, #12]
		brake = utils_map(brake, config.voltage2_start, config.voltage2_end, 0.0, 1.0);
 8021034:	edd4 0a05 	vldr	s1, [r4, #20]
 8021038:	ed94 1a06 	vldr	s2, [r4, #24]
 802103c:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 8021040:	eef0 1a48 	vmov.f32	s3, s16
 8021044:	f7f4 fd5c 	bl	8015b00 <utils_map>
 8021048:	a804      	add	r0, sp, #16
 802104a:	ed20 0a01 	vstmdb	r0!, {s0}
		utils_truncate_number(&brake, 0.0, 1.0);
 802104e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8021052:	eeb0 0a48 	vmov.f32	s0, s16
 8021056:	f7f4 fd13 	bl	8015a80 <utils_truncate_number>
		if (config.voltage2_inverted) {
 802105a:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
			brake = 1.0 - brake;
 802105e:	eddd 7a03 	vldr	s15, [sp, #12]
		if (config.voltage2_inverted) {
 8021062:	b12b      	cbz	r3, 8021070 <adc_thread+0x210>
			brake = 1.0 - brake;
 8021064:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8021068:	ee77 7a67 	vsub.f32	s15, s14, s15
 802106c:	edcd 7a03 	vstr	s15, [sp, #12]
		decoded_level2 = brake;
 8021070:	4b4d      	ldr	r3, [pc, #308]	; (80211a8 <adc_thread+0x348>)
 8021072:	edc3 7a00 	vstr	s15, [r3]
		if (use_rx_tx_as_buttons) {
 8021076:	4b39      	ldr	r3, [pc, #228]	; (802115c <adc_thread+0x2fc>)
 8021078:	781b      	ldrb	r3, [r3, #0]
 802107a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 802107e:	2b00      	cmp	r3, #0
 8021080:	f000 81da 	beq.w	8021438 <adc_thread+0x5d8>
			cc_button = !palReadPad(HW_UART_TX_PORT, HW_UART_TX_PIN);
 8021084:	4b37      	ldr	r3, [pc, #220]	; (8021164 <adc_thread+0x304>)
 8021086:	691f      	ldr	r7, [r3, #16]
			if (config.cc_button_inverted) {
 8021088:	7fa3      	ldrb	r3, [r4, #30]
			cc_button = !palReadPad(HW_UART_TX_PORT, HW_UART_TX_PIN);
 802108a:	09bf      	lsrs	r7, r7, #6
			if (config.cc_button_inverted) {
 802108c:	b903      	cbnz	r3, 8021090 <adc_thread+0x230>
 802108e:	43ff      	mvns	r7, r7
			rev_button = !palReadPad(HW_UART_RX_PORT, HW_UART_RX_PIN);
 8021090:	4b34      	ldr	r3, [pc, #208]	; (8021164 <adc_thread+0x304>)
 8021092:	691e      	ldr	r6, [r3, #16]
			if (config.rev_button_inverted) {
 8021094:	7fe3      	ldrb	r3, [r4, #31]
			rev_button = !palReadPad(HW_UART_RX_PORT, HW_UART_RX_PIN);
 8021096:	09f6      	lsrs	r6, r6, #7
 8021098:	f007 0701 	and.w	r7, r7, #1
 802109c:	43f2      	mvns	r2, r6
			if (config.rev_button_inverted) {
 802109e:	2b00      	cmp	r3, #0
 80210a0:	f000 827b 	beq.w	802159a <adc_thread+0x73a>
				rev_button = !rev_button;
 80210a4:	f006 0601 	and.w	r6, r6, #1
		switch (config.ctrl_type) {
 80210a8:	7823      	ldrb	r3, [r4, #0]
 80210aa:	b2db      	uxtb	r3, r3
 80210ac:	2b0d      	cmp	r3, #13
 80210ae:	d810      	bhi.n	80210d2 <adc_thread+0x272>
 80210b0:	2201      	movs	r2, #1
 80210b2:	fa02 f303 	lsl.w	r3, r2, r3
 80210b6:	f242 4248 	movw	r2, #9288	; 0x2448
 80210ba:	4213      	tst	r3, r2
 80210bc:	f040 82a3 	bne.w	8021606 <adc_thread+0x7a6>
 80210c0:	f241 2224 	movw	r2, #4644	; 0x1224
 80210c4:	4213      	tst	r3, r2
 80210c6:	f040 82bd 	bne.w	8021644 <adc_thread+0x7e4>
 80210ca:	f013 0f90 	tst.w	r3, #144	; 0x90
 80210ce:	f040 830a 	bne.w	80216e6 <adc_thread+0x886>
		utils_deadband(&pwr, config.hyst, 1.0);
 80210d2:	ed94 0a01 	vldr	s0, [r4, #4]
		const float ramp_time = fabsf(pwr) > fabsf(pwr_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 80210d6:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 80211b8 <adc_thread+0x358>
		utils_deadband(&pwr, config.hyst, 1.0);
 80210da:	a802      	add	r0, sp, #8
 80210dc:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80210e0:	f7f4 fd1e 	bl	8015b20 <utils_deadband>
		pwr = utils_throttle_curve(pwr, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 80210e4:	edd4 0a09 	vldr	s1, [r4, #36]	; 0x24
 80210e8:	ed9d 0a02 	vldr	s0, [sp, #8]
 80210ec:	ed94 1a0a 	vldr	s2, [r4, #40]	; 0x28
 80210f0:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 80210f4:	f7f4 ff2c 	bl	8015f50 <utils_throttle_curve>
		const float ramp_time = fabsf(pwr) > fabsf(pwr_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 80210f8:	edda 7a00 	vldr	s15, [sl]
		pwr = utils_throttle_curve(pwr, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 80210fc:	ed8d 0a02 	vstr	s0, [sp, #8]
		const float ramp_time = fabsf(pwr) > fabsf(pwr_ramp) ? config.ramp_time_pos : config.ramp_time_neg;
 8021100:	eef0 7ae7 	vabs.f32	s15, s15
 8021104:	eeb0 7ac0 	vabs.f32	s14, s0
 8021108:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802110c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021110:	bfcc      	ite	gt
 8021112:	edd4 0a0c 	vldrgt	s1, [r4, #48]	; 0x30
 8021116:	edd4 0a0d 	vldrle	s1, [r4, #52]	; 0x34
		if (ramp_time > 0.01) {
 802111a:	eddf 7a24 	vldr	s15, [pc, #144]	; 80211ac <adc_thread+0x34c>
 802111e:	eef4 0ae7 	vcmpe.f32	s1, s15
 8021122:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021126:	f300 8248 	bgt.w	80215ba <adc_thread+0x75a>
		const volatile mc_configuration *mcconf = mc_interface_get_configuration();
 802112a:	f7fa f969 	bl	801b400 <mc_interface_get_configuration>
 802112e:	4682      	mov	sl, r0
		const float rpm_now = mc_interface_get_rpm();
 8021130:	f7fa f9f6 	bl	801b520 <mc_interface_get_rpm>
		switch (config.ctrl_type) {
 8021134:	7823      	ldrb	r3, [r4, #0]
 8021136:	3b01      	subs	r3, #1
 8021138:	2b0c      	cmp	r3, #12
 802113a:	f63f aeb7 	bhi.w	8020eac <adc_thread+0x4c>
 802113e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8021142:	0125      	.short	0x0125
 8021144:	01250125 	.word	0x01250125
 8021148:	00ba00ba 	.word	0x00ba00ba
 802114c:	00ba00ba 	.word	0x00ba00ba
 8021150:	008c008c 	.word	0x008c008c
 8021154:	003d008c 	.word	0x003d008c
 8021158:	003d003d 	.word	0x003d003d
 802115c:	2000e578 	.word	0x2000e578
 8021160:	0802f5e0 	.word	0x0802f5e0
 8021164:	40020800 	.word	0x40020800
 8021168:	2000e558 	.word	0x2000e558
 802116c:	2000e4b8 	.word	0x2000e4b8
 8021170:	00000000 	.word	0x00000000
 8021174:	457ff000 	.word	0x457ff000
 8021178:	461c4000 	.word	0x461c4000
 802117c:	3dcccccd 	.word	0x3dcccccd
 8021180:	2000104f 	.word	0x2000104f
 8021184:	2000c03c 	.word	0x2000c03c
 8021188:	40533333 	.word	0x40533333
 802118c:	2000e570 	.word	0x2000e570
 8021190:	2000e54c 	.word	0x2000e54c
 8021194:	2000e504 	.word	0x2000e504
 8021198:	2000e4fc 	.word	0x2000e4fc
 802119c:	2000e574 	.word	0x2000e574
 80211a0:	2000e554 	.word	0x2000e554
 80211a4:	2000e538 	.word	0x2000e538
 80211a8:	2000e500 	.word	0x2000e500
 80211ac:	3c23d70a 	.word	0x3c23d70a
 80211b0:	20001a48 	.word	0x20001a48
 80211b4:	2000e560 	.word	0x2000e560
 80211b8:	2000e56c 	.word	0x2000e56c
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 80211bc:	eddd 7a02 	vldr	s15, [sp, #8]
 80211c0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80211c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80211c8:	f2c0 811c 	blt.w	8021404 <adc_thread+0x5a4>
 80211cc:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80211d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80211d4:	f340 8116 	ble.w	8021404 <adc_thread+0x5a4>
				current = pwr * mcconf->lo_current_motor_max_now;
 80211d8:	ed9a aa1d 	vldr	s20, [sl, #116]	; 0x74
 80211dc:	ee27 aa8a 	vmul.f32	s20, s15, s20
			if (!(ms_without_power < MIN_MS_WITHOUT_POWER && config.safe_start)) {
 80211e0:	f8df b360 	ldr.w	fp, [pc, #864]	; 8021544 <adc_thread+0x6e4>
 80211e4:	ed9f 7acf 	vldr	s14, [pc, #828]	; 8021524 <adc_thread+0x6c4>
 80211e8:	eddb 6a00 	vldr	s13, [fp]
 80211ec:	eef4 6ac7 	vcmpe.f32	s13, s14
 80211f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80211f4:	d503      	bpl.n	80211fe <adc_thread+0x39e>
 80211f6:	7f63      	ldrb	r3, [r4, #29]
 80211f8:	2b00      	cmp	r3, #0
 80211fa:	f040 827b 	bne.w	80216f4 <adc_thread+0x894>
				if (pwr >= 0.0) {
 80211fe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021202:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					speed = pwr * fabsf(mcconf->l_min_erpm);
 8021206:	bfb6      	itet	lt
 8021208:	ed9a 0a06 	vldrlt	s0, [sl, #24]
					speed = pwr * mcconf->l_max_erpm;
 802120c:	ed9a 0a07 	vldrge	s0, [sl, #28]
					speed = pwr * fabsf(mcconf->l_min_erpm);
 8021210:	eeb0 0ac0 	vabslt.f32	s0, s0
 8021214:	ee20 0a27 	vmul.f32	s0, s0, s15
				mc_interface_set_pid_speed(speed);
 8021218:	f7fa ffea 	bl	801c1f0 <mc_interface_set_pid_speed>
 802121c:	eddd 7a02 	vldr	s15, [sp, #8]
				send_duty = true;
 8021220:	2601      	movs	r6, #1
			if (fabsf(pwr) < 0.001) {
 8021222:	ed9f 7ac1 	vldr	s14, [pc, #772]	; 8021528 <adc_thread+0x6c8>
 8021226:	eef0 7ae7 	vabs.f32	s15, s15
 802122a:	eef4 7ac7 	vcmpe.f32	s15, s14
 802122e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021232:	f140 8212 	bpl.w	802165a <adc_thread+0x7fa>
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 8021236:	ee07 5a90 	vmov	s15, r5
 802123a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802123e:	eddf 7abb 	vldr	s15, [pc, #748]	; 802152c <adc_thread+0x6cc>
 8021242:	eddb 6a00 	vldr	s13, [fp]
 8021246:	ee67 7a27 	vmul.f32	s15, s14, s15
		bool current_mode = false;
 802124a:	2500      	movs	r5, #0
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 802124c:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 8021250:	ee77 7a26 	vadd.f32	s15, s14, s13
 8021254:	edcb 7a00 	vstr	s15, [fp]
 8021258:	e04b      	b.n	80212f2 <adc_thread+0x492>
			if (fabsf(pwr) < 0.001) {
 802125a:	ed9d 0a02 	vldr	s0, [sp, #8]
 802125e:	eddf 7ab2 	vldr	s15, [pc, #712]	; 8021528 <adc_thread+0x6c8>
 8021262:	eeb0 7ac0 	vabs.f32	s14, s0
 8021266:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802126a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802126e:	f100 8214 	bmi.w	802169a <adc_thread+0x83a>
 8021272:	f8df b2d0 	ldr.w	fp, [pc, #720]	; 8021544 <adc_thread+0x6e4>
			if (!(ms_without_power < MIN_MS_WITHOUT_POWER && config.safe_start)) {
 8021276:	ed9b 7a00 	vldr	s14, [fp]
 802127a:	eddf 7aaa 	vldr	s15, [pc, #680]	; 8021524 <adc_thread+0x6c4>
 802127e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8021282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021286:	d503      	bpl.n	8021290 <adc_thread+0x430>
 8021288:	7f63      	ldrb	r3, [r4, #29]
 802128a:	2b00      	cmp	r3, #0
 802128c:	f040 8226 	bne.w	80216dc <adc_thread+0x87c>
				mc_interface_set_duty(utils_map(pwr, -1.0, 1.0, -mcconf->l_max_duty, mcconf->l_max_duty));
 8021290:	edda 1a16 	vldr	s3, [sl, #88]	; 0x58
 8021294:	ed9a 2a16 	vldr	s4, [sl, #88]	; 0x58
		float current = 0.0;
 8021298:	ed9f aaa5 	vldr	s20, [pc, #660]	; 8021530 <adc_thread+0x6d0>
				mc_interface_set_duty(utils_map(pwr, -1.0, 1.0, -mcconf->l_max_duty, mcconf->l_max_duty));
 802129c:	eef1 1a61 	vneg.f32	s3, s3
 80212a0:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80212a4:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 80212a8:	f7f4 fc2a 	bl	8015b00 <utils_map>
 80212ac:	f7fa ff70 	bl	801c190 <mc_interface_set_duty>
		bool current_mode = false;
 80212b0:	2500      	movs	r5, #0
				send_duty = true;
 80212b2:	2601      	movs	r6, #1
 80212b4:	e01d      	b.n	80212f2 <adc_thread+0x492>
			if (pwr >= 0.0) {
 80212b6:	eddd 7a02 	vldr	s15, [sp, #8]
 80212ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80212be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80212c2:	f2c0 82b8 	blt.w	8021836 <adc_thread+0x9d6>
				current = pwr * mcconf->lo_current_motor_max_now;
 80212c6:	ed9a aa1d 	vldr	s20, [sl, #116]	; 0x74
 80212ca:	ee27 aa8a 	vmul.f32	s20, s15, s20
		bool current_mode_brake = false;
 80212ce:	f04f 0900 	mov.w	r9, #0
			if (pwr < 0.001) {
 80212d2:	ed9f 7a95 	vldr	s14, [pc, #596]	; 8021528 <adc_thread+0x6c8>
 80212d6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80212da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80212de:	f100 81be 	bmi.w	802165e <adc_thread+0x7fe>
			if (config.ctrl_type == ADC_CTRL_TYPE_CURRENT_REV_BUTTON_BRAKE_ADC && rev_button) {
 80212e2:	7823      	ldrb	r3, [r4, #0]
 80212e4:	f8df b25c 	ldr.w	fp, [pc, #604]	; 8021544 <adc_thread+0x6e4>
 80212e8:	2b04      	cmp	r3, #4
 80212ea:	f000 81ce 	beq.w	802168a <adc_thread+0x82a>
		bool send_duty = false;
 80212ee:	2600      	movs	r6, #0
			current_mode = true;
 80212f0:	2501      	movs	r5, #1
		if (ms_without_power < MIN_MS_WITHOUT_POWER && config.safe_start) {
 80212f2:	ed9b 7a00 	vldr	s14, [fp]
 80212f6:	eddf 7a8b 	vldr	s15, [pc, #556]	; 8021524 <adc_thread+0x6c4>
 80212fa:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80212fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021302:	f140 80b3 	bpl.w	802146c <adc_thread+0x60c>
 8021306:	7f63      	ldrb	r3, [r4, #29]
 8021308:	2b00      	cmp	r3, #0
 802130a:	f000 80af 	beq.w	802146c <adc_thread+0x60c>
			if (ms_without_power == pulses_without_power_before) {
 802130e:	4b89      	ldr	r3, [pc, #548]	; (8021534 <adc_thread+0x6d4>)
 8021310:	ed9b 7a00 	vldr	s14, [fp]
 8021314:	edd3 7a00 	vldr	s15, [r3]
 8021318:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802131c:	eef4 7a47 	vcmp.f32	s15, s14
 8021320:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				ms_without_power = 0;
 8021324:	bf08      	it	eq
 8021326:	ed8b 8a00 	vstreq	s16, [fp]
			pulses_without_power_before = ms_without_power;
 802132a:	eddb 7a00 	vldr	s15, [fp]
 802132e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8021332:	edc3 7a00 	vstr	s15, [r3]
			mc_interface_set_brake_current(timeout_get_brake_current());
 8021336:	f7f8 ff33 	bl	801a1a0 <timeout_get_brake_current>
 802133a:	f7fb f821 	bl	801c380 <mc_interface_set_brake_current>
			if (config.multi_esc) {
 802133e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8021342:	2b00      	cmp	r3, #0
 8021344:	f43f adb2 	beq.w	8020eac <adc_thread+0x4c>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021348:	2500      	movs	r5, #0
 802134a:	e002      	b.n	8021352 <adc_thread+0x4f2>
 802134c:	2d0a      	cmp	r5, #10
 802134e:	f43f adad 	beq.w	8020eac <adc_thread+0x4c>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 8021352:	4628      	mov	r0, r5
 8021354:	f7f9 fba4 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021358:	6806      	ldr	r6, [r0, #0]
 802135a:	2e00      	cmp	r6, #0
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802135c:	f105 0501 	add.w	r5, r5, #1
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021360:	dbf4      	blt.n	802134c <adc_thread+0x4ec>
  return chVTGetSystemTimeX() - start;
 8021362:	6842      	ldr	r2, [r0, #4]
  return ch.vtlist.vt_systime;
 8021364:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021368:	1a9b      	subs	r3, r3, r2
 802136a:	ee07 3a90 	vmov	s15, r3
 802136e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021372:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 8021376:	eeb4 7ac9 	vcmpe.f32	s14, s18
 802137a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802137e:	d5e5      	bpl.n	802134c <adc_thread+0x4ec>
						comm_can_set_current_brake(msg->id, timeout_get_brake_current());
 8021380:	f7f8 ff0e 	bl	801a1a0 <timeout_get_brake_current>
 8021384:	b2f0      	uxtb	r0, r6
 8021386:	f7f9 fb6b 	bl	801aa60 <comm_can_set_current_brake>
 802138a:	e7df      	b.n	802134c <adc_thread+0x4ec>
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 802138c:	eddd 7a02 	vldr	s15, [sp, #8]
 8021390:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021394:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021398:	db27      	blt.n	80213ea <adc_thread+0x58a>
 802139a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802139e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80213a2:	dd22      	ble.n	80213ea <adc_thread+0x58a>
				current = pwr * mcconf->lo_current_motor_max_now;
 80213a4:	ed9a aa1d 	vldr	s20, [sl, #116]	; 0x74
 80213a8:	ee27 aa8a 	vmul.f32	s20, s15, s20
			if (fabsf(pwr) < 0.001) {
 80213ac:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 8021528 <adc_thread+0x6c8>
 80213b0:	eef0 7ae7 	vabs.f32	s15, s15
 80213b4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80213b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80213bc:	f140 8180 	bpl.w	80216c0 <adc_thread+0x860>
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 80213c0:	ee07 5a90 	vmov	s15, r5
 80213c4:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80213c8:	eddf 7a58 	vldr	s15, [pc, #352]	; 802152c <adc_thread+0x6cc>
 80213cc:	f8df b174 	ldr.w	fp, [pc, #372]	; 8021544 <adc_thread+0x6e4>
 80213d0:	ee66 6aa7 	vmul.f32	s13, s13, s15
 80213d4:	eddb 7a00 	vldr	s15, [fp]
 80213d8:	ee86 7aa8 	vdiv.f32	s14, s13, s17
		bool send_duty = false;
 80213dc:	2600      	movs	r6, #0
			current_mode = true;
 80213de:	2501      	movs	r5, #1
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 80213e0:	ee77 7a27 	vadd.f32	s15, s14, s15
 80213e4:	edcb 7a00 	vstr	s15, [fp]
 80213e8:	e783      	b.n	80212f2 <adc_thread+0x492>
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 80213ea:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80213ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80213f2:	f100 81a7 	bmi.w	8021744 <adc_thread+0x8e4>
				current = pwr * fabsf(mcconf->lo_current_motor_min_now);
 80213f6:	ed9a aa1e 	vldr	s20, [sl, #120]	; 0x78
 80213fa:	eeb0 aaca 	vabs.f32	s20, s20
 80213fe:	ee2a aa27 	vmul.f32	s20, s20, s15
 8021402:	e7d3      	b.n	80213ac <adc_thread+0x54c>
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 8021404:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021408:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802140c:	f100 81a7 	bmi.w	802175e <adc_thread+0x8fe>
				current = pwr * fabsf(mcconf->lo_current_motor_min_now);
 8021410:	ed9a aa1e 	vldr	s20, [sl, #120]	; 0x78
 8021414:	eeb0 aaca 	vabs.f32	s20, s20
 8021418:	ee2a aa27 	vmul.f32	s20, s20, s15
 802141c:	e6e0      	b.n	80211e0 <adc_thread+0x380>
			pwr = utils_map(pwr, config.voltage_start, config.voltage_end, 0.0, 1.0);
 802141e:	edd4 0a02 	vldr	s1, [r4, #8]
 8021422:	ed94 1a03 	vldr	s2, [r4, #12]
 8021426:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 802142a:	eef0 1a48 	vmov.f32	s3, s16
 802142e:	f7f4 fb67 	bl	8015b00 <utils_map>
 8021432:	ed8d 0a02 	vstr	s0, [sp, #8]
			break;
 8021436:	e5ae      	b.n	8020f96 <adc_thread+0x136>
			if (config.ctrl_type == ADC_CTRL_TYPE_CURRENT_REV_BUTTON ||
 8021438:	7823      	ldrb	r3, [r4, #0]
 802143a:	2b03      	cmp	r3, #3
 802143c:	f000 80b0 	beq.w	80215a0 <adc_thread+0x740>
					config.ctrl_type == ADC_CTRL_TYPE_CURRENT_NOREV_BRAKE_BUTTON ||
 8021440:	7823      	ldrb	r3, [r4, #0]
			if (config.ctrl_type == ADC_CTRL_TYPE_CURRENT_REV_BUTTON ||
 8021442:	2b06      	cmp	r3, #6
 8021444:	f000 80ac 	beq.w	80215a0 <adc_thread+0x740>
					config.ctrl_type == ADC_CTRL_TYPE_DUTY_REV_BUTTON) {
 8021448:	7823      	ldrb	r3, [r4, #0]
					config.ctrl_type == ADC_CTRL_TYPE_CURRENT_NOREV_BRAKE_BUTTON ||
 802144a:	2b0a      	cmp	r3, #10
 802144c:	f000 80a8 	beq.w	80215a0 <adc_thread+0x740>
				cc_button = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);
 8021450:	4b39      	ldr	r3, [pc, #228]	; (8021538 <adc_thread+0x6d8>)
 8021452:	691f      	ldr	r7, [r3, #16]
				if (config.cc_button_inverted) {
 8021454:	7fa3      	ldrb	r3, [r4, #30]
				cc_button = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);
 8021456:	097f      	lsrs	r7, r7, #5
 8021458:	43f9      	mvns	r1, r7
				if (config.cc_button_inverted) {
 802145a:	f003 06ff 	and.w	r6, r3, #255	; 0xff
 802145e:	2b00      	cmp	r3, #0
 8021460:	f000 8139 	beq.w	80216d6 <adc_thread+0x876>
					cc_button = !cc_button;
 8021464:	f007 0701 	and.w	r7, r7, #1
		bool rev_button = false;
 8021468:	4616      	mov	r6, r2
 802146a:	e61d      	b.n	80210a8 <adc_thread+0x248>
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 802146c:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 8021548 <adc_thread+0x6e8>
		timeout_reset();
 8021470:	f7f8 fe76 	bl	801a160 <timeout_reset>
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021474:	f8db 1000 	ldr.w	r1, [fp]
 8021478:	9101      	str	r1, [sp, #4]
 802147a:	1c4b      	adds	r3, r1, #1
 802147c:	f8cb 3000 	str.w	r3, [fp]
 8021480:	f7fa f84e 	bl	801b520 <mc_interface_get_rpm>
		if (filter_ptr >= RPM_FILTER_SAMPLES) {
 8021484:	f8db 2000 	ldr.w	r2, [fp]
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021488:	4b2c      	ldr	r3, [pc, #176]	; (802153c <adc_thread+0x6dc>)
 802148a:	9901      	ldr	r1, [sp, #4]
		float rpm_filtered = 0.0;
 802148c:	eddf 7a28 	vldr	s15, [pc, #160]	; 8021530 <adc_thread+0x6d0>
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021490:	eb03 0381 	add.w	r3, r3, r1, lsl #2
		if (filter_ptr >= RPM_FILTER_SAMPLES) {
 8021494:	2a07      	cmp	r2, #7
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021496:	ed83 0a00 	vstr	s0, [r3]
			filter_ptr = 0;
 802149a:	bfc4      	itt	gt
 802149c:	2300      	movgt	r3, #0
 802149e:	f8cb 3000 	strgt.w	r3, [fp]
 80214a2:	4b26      	ldr	r3, [pc, #152]	; (802153c <adc_thread+0x6dc>)
 80214a4:	f103 0220 	add.w	r2, r3, #32
			rpm_filtered += filter_buffer[i];
 80214a8:	ecb3 7a01 	vldmia	r3!, {s14}
		for (int i = 0;i < RPM_FILTER_SAMPLES;i++) {
 80214ac:	429a      	cmp	r2, r3
			rpm_filtered += filter_buffer[i];
 80214ae:	ee77 7a87 	vadd.f32	s15, s15, s14
		for (int i = 0;i < RPM_FILTER_SAMPLES;i++) {
 80214b2:	d1f9      	bne.n	80214a8 <adc_thread+0x648>
		if (current_mode && cc_button && fabsf(pwr) < 0.001) {
 80214b4:	b165      	cbz	r5, 80214d0 <adc_thread+0x670>
 80214b6:	b15f      	cbz	r7, 80214d0 <adc_thread+0x670>
 80214b8:	ed9d 7a02 	vldr	s14, [sp, #8]
 80214bc:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8021528 <adc_thread+0x6c8>
 80214c0:	eeb0 7ac7 	vabs.f32	s14, s14
 80214c4:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80214c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80214cc:	f100 81c9 	bmi.w	8021862 <adc_thread+0xa02>
		was_pid = false;
 80214d0:	4b1b      	ldr	r3, [pc, #108]	; (8021540 <adc_thread+0x6e0>)
 80214d2:	2700      	movs	r7, #0
 80214d4:	701f      	strb	r7, [r3, #0]
		float rpm_local = mc_interface_get_rpm();
 80214d6:	f7fa f823 	bl	801b520 <mc_interface_get_rpm>
		if (config.multi_esc) {
 80214da:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
		float rpm_local = mc_interface_get_rpm();
 80214de:	eeb0 ba40 	vmov.f32	s22, s0
		float rpm_lowest = rpm_local;
 80214e2:	eef0 aa40 	vmov.f32	s21, s0
		if (config.multi_esc) {
 80214e6:	bb8b      	cbnz	r3, 802154c <adc_thread+0x6ec>
		if (send_duty && config.multi_esc) {
 80214e8:	b126      	cbz	r6, 80214f4 <adc_thread+0x694>
 80214ea:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 80214ee:	2b00      	cmp	r3, #0
 80214f0:	f040 8102 	bne.w	80216f8 <adc_thread+0x898>
		if (current_mode) {
 80214f4:	2d00      	cmp	r5, #0
 80214f6:	f43f acd9 	beq.w	8020eac <adc_thread+0x4c>
			if (current_mode_brake) {
 80214fa:	f1b9 0f00 	cmp.w	r9, #0
 80214fe:	f040 81fb 	bne.w	80218f8 <adc_thread+0xa98>
				if (current_out < 0.0) {
 8021502:	eeb5 aac0 	vcmpe.f32	s20, #0.0
 8021506:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				if (config.multi_esc) {
 802150a:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
				if (current_out < 0.0) {
 802150e:	f100 819b 	bmi.w	8021848 <adc_thread+0x9e8>
				if (config.multi_esc) {
 8021512:	2b00      	cmp	r3, #0
 8021514:	f040 8130 	bne.w	8021778 <adc_thread+0x918>
				}

				if (is_reverse) {
					mc_interface_set_current(-current_out);
				} else {
					mc_interface_set_current(current_out);
 8021518:	eeb0 0a4a 	vmov.f32	s0, s20
 802151c:	f7fa fee0 	bl	801c2e0 <mc_interface_set_current>
 8021520:	e4c4      	b.n	8020eac <adc_thread+0x4c>
 8021522:	bf00      	nop
 8021524:	43fa0000 	.word	0x43fa0000
 8021528:	3a83126f 	.word	0x3a83126f
 802152c:	447a0000 	.word	0x447a0000
 8021530:	00000000 	.word	0x00000000
 8021534:	2000e568 	.word	0x2000e568
 8021538:	40020400 	.word	0x40020400
 802153c:	2000e518 	.word	0x2000e518
 8021540:	2000e579 	.word	0x2000e579
 8021544:	2000e560 	.word	0x2000e560
 8021548:	2000e550 	.word	0x2000e550
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 802154c:	4638      	mov	r0, r7
 802154e:	f7f9 faa7 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021552:	6803      	ldr	r3, [r0, #0]
 8021554:	2b00      	cmp	r3, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021556:	f107 0701 	add.w	r7, r7, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 802155a:	db1b      	blt.n	8021594 <adc_thread+0x734>
  return ch.vtlist.vt_systime;
 802155c:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021560:	6843      	ldr	r3, [r0, #4]
 8021562:	1ad3      	subs	r3, r2, r3
 8021564:	ee07 3a90 	vmov	s15, r3
 8021568:	eef8 7a67 	vcvt.f32.u32	s15, s15
					if (fabsf(rpm_tmp) < fabsf(rpm_lowest)) {
 802156c:	eef0 6aea 	vabs.f32	s13, s21
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021570:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 8021574:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8021578:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802157c:	d50a      	bpl.n	8021594 <adc_thread+0x734>
					float rpm_tmp = msg->rpm;
 802157e:	edd0 7a02 	vldr	s15, [r0, #8]
					if (fabsf(rpm_tmp) < fabsf(rpm_lowest)) {
 8021582:	eeb0 7ae7 	vabs.f32	s14, s15
						rpm_lowest = rpm_tmp;
 8021586:	eeb4 7a66 	vcmp.f32	s14, s13
 802158a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802158e:	bf48      	it	mi
 8021590:	eef0 aa67 	vmovmi.f32	s21, s15
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021594:	2f0a      	cmp	r7, #10
 8021596:	d1d9      	bne.n	802154c <adc_thread+0x6ec>
 8021598:	e7a6      	b.n	80214e8 <adc_thread+0x688>
				rev_button = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);
 802159a:	f002 0601 	and.w	r6, r2, #1
 802159e:	e583      	b.n	80210a8 <adc_thread+0x248>
 80215a0:	4bd8      	ldr	r3, [pc, #864]	; (8021904 <adc_thread+0xaa4>)
 80215a2:	691e      	ldr	r6, [r3, #16]
				if (config.rev_button_inverted) {
 80215a4:	7fe3      	ldrb	r3, [r4, #31]
				rev_button = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);
 80215a6:	0976      	lsrs	r6, r6, #5
 80215a8:	43f2      	mvns	r2, r6
				if (config.rev_button_inverted) {
 80215aa:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 80215ae:	2b00      	cmp	r3, #0
 80215b0:	d0f3      	beq.n	802159a <adc_thread+0x73a>
					rev_button = !rev_button;
 80215b2:	f006 0601 	and.w	r6, r6, #1
		bool cc_button = false;
 80215b6:	2700      	movs	r7, #0
 80215b8:	e576      	b.n	80210a8 <adc_thread+0x248>
			const float ramp_step = (float)ST2MS(chVTTimeElapsedSinceX(last_time)) / (ramp_time * 1000.0);
 80215ba:	f8df b368 	ldr.w	fp, [pc, #872]	; 8021924 <adc_thread+0xac4>
  return ch.vtlist.vt_systime;
 80215be:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 80215c2:	f8db 2000 	ldr.w	r2, [fp]
 80215c6:	49d0      	ldr	r1, [pc, #832]	; (8021908 <adc_thread+0xaa8>)
 80215c8:	ed9f 7ad0 	vldr	s14, [pc, #832]	; 802190c <adc_thread+0xaac>
 80215cc:	1a9b      	subs	r3, r3, r2
 80215ce:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80215d2:	f242 720f 	movw	r2, #9999	; 0x270f
 80215d6:	fb00 2303 	mla	r3, r0, r3, r2
 80215da:	fba1 2303 	umull	r2, r3, r1, r3
 80215de:	0b5b      	lsrs	r3, r3, #13
 80215e0:	ee07 3a90 	vmov	s15, r3
 80215e4:	ee60 0a87 	vmul.f32	s1, s1, s14
 80215e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			utils_step_towards(&pwr_ramp, pwr, ramp_step);
 80215ec:	48c8      	ldr	r0, [pc, #800]	; (8021910 <adc_thread+0xab0>)
 80215ee:	eec7 0aa0 	vdiv.f32	s1, s15, s1
 80215f2:	f7f4 f9d5 	bl	80159a0 <utils_step_towards>
  return ch.vtlist.vt_systime;
 80215f6:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
			last_time = chVTGetSystemTimeX();
 80215fa:	f8cb 3000 	str.w	r3, [fp]
			pwr = pwr_ramp;
 80215fe:	f8da 3000 	ldr.w	r3, [sl]
 8021602:	9302      	str	r3, [sp, #8]
 8021604:	e591      	b.n	802112a <adc_thread+0x2ca>
			if (rev_button) {
 8021606:	2e00      	cmp	r6, #0
 8021608:	f43f ad63 	beq.w	80210d2 <adc_thread+0x272>
				pwr = -pwr;
 802160c:	eddd 7a02 	vldr	s15, [sp, #8]
 8021610:	eef1 7a67 	vneg.f32	s15, s15
 8021614:	edcd 7a02 	vstr	s15, [sp, #8]
 8021618:	e55b      	b.n	80210d2 <adc_thread+0x272>
			is_running = false;
 802161a:	4abe      	ldr	r2, [pc, #760]	; (8021914 <adc_thread+0xab4>)
 802161c:	2300      	movs	r3, #0
 802161e:	7013      	strb	r3, [r2, #0]
				}
			}
		}
	}
}
 8021620:	b005      	add	sp, #20
 8021622:	ecbd 8b08 	vpop	{d8-d11}
 8021626:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				pwr = utils_map(pwr, config.voltage_center,
 802162a:	edd4 0a04 	vldr	s1, [r4, #16]
 802162e:	ed94 1a03 	vldr	s2, [r4, #12]
 8021632:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 8021636:	eef6 1a00 	vmov.f32	s3, #96	; 0x3f000000  0.5
 802163a:	f7f4 fa61 	bl	8015b00 <utils_map>
 802163e:	ed8d 0a02 	vstr	s0, [sp, #8]
 8021642:	e4a8      	b.n	8020f96 <adc_thread+0x136>
			pwr -= 1.0;
 8021644:	eddd 6a02 	vldr	s13, [sp, #8]
 8021648:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 802164c:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8021650:	eee6 7a87 	vfma.f32	s15, s13, s14
 8021654:	edcd 7a02 	vstr	s15, [sp, #8]
			break;
 8021658:	e53b      	b.n	80210d2 <adc_thread+0x272>
		bool current_mode = false;
 802165a:	2500      	movs	r5, #0
 802165c:	e649      	b.n	80212f2 <adc_thread+0x492>
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 802165e:	ee07 5a90 	vmov	s15, r5
 8021662:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8021666:	eddf 7aa9 	vldr	s15, [pc, #676]	; 802190c <adc_thread+0xaac>
 802166a:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 8021928 <adc_thread+0xac8>
 802166e:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8021672:	eddb 7a00 	vldr	s15, [fp]
 8021676:	ee86 7aa8 	vdiv.f32	s14, s13, s17
 802167a:	ee77 7a27 	vadd.f32	s15, s14, s15
 802167e:	edcb 7a00 	vstr	s15, [fp]
			if (config.ctrl_type == ADC_CTRL_TYPE_CURRENT_REV_BUTTON_BRAKE_ADC && rev_button) {
 8021682:	7823      	ldrb	r3, [r4, #0]
 8021684:	2b04      	cmp	r3, #4
 8021686:	f47f ae32 	bne.w	80212ee <adc_thread+0x48e>
 802168a:	2e00      	cmp	r6, #0
 802168c:	f000 816e 	beq.w	802196c <adc_thread+0xb0c>
			current_mode = true;
 8021690:	4635      	mov	r5, r6
				current = -current;
 8021692:	eeb1 aa4a 	vneg.f32	s20, s20
		bool send_duty = false;
 8021696:	2600      	movs	r6, #0
 8021698:	e62b      	b.n	80212f2 <adc_thread+0x492>
				ms_without_power += (1000.0 * (float)sleep_time) / (float)CH_CFG_ST_FREQUENCY;
 802169a:	ee07 5a90 	vmov	s15, r5
 802169e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80216a2:	eddf 7a9a 	vldr	s15, [pc, #616]	; 802190c <adc_thread+0xaac>
 80216a6:	f8df b280 	ldr.w	fp, [pc, #640]	; 8021928 <adc_thread+0xac8>
 80216aa:	ee66 6aa7 	vmul.f32	s13, s13, s15
 80216ae:	eddb 7a00 	vldr	s15, [fp]
 80216b2:	ee86 7aa8 	vdiv.f32	s14, s13, s17
 80216b6:	ee77 7a27 	vadd.f32	s15, s14, s15
 80216ba:	edcb 7a00 	vstr	s15, [fp]
 80216be:	e5da      	b.n	8021276 <adc_thread+0x416>
		bool send_duty = false;
 80216c0:	2600      	movs	r6, #0
			current_mode = true;
 80216c2:	2501      	movs	r5, #1
 80216c4:	f8df b260 	ldr.w	fp, [pc, #608]	; 8021928 <adc_thread+0xac8>
 80216c8:	e613      	b.n	80212f2 <adc_thread+0x492>
		palSetPadMode(HW_ICU_GPIO, HW_ICU_PIN, PAL_MODE_INPUT_PULLUP);
 80216ca:	4611      	mov	r1, r2
 80216cc:	488d      	ldr	r0, [pc, #564]	; (8021904 <adc_thread+0xaa4>)
 80216ce:	f7ee fbc7 	bl	800fe60 <_pal_lld_setgroupmode>
 80216d2:	f7ff bbdf 	b.w	8020e94 <adc_thread+0x34>
				cc_button = !palReadPad(HW_ICU_GPIO, HW_ICU_PIN);
 80216d6:	f001 0701 	and.w	r7, r1, #1
 80216da:	e4e5      	b.n	80210a8 <adc_thread+0x248>
		bool send_duty = false;
 80216dc:	2600      	movs	r6, #0
		bool current_mode = false;
 80216de:	4635      	mov	r5, r6
		float current = 0.0;
 80216e0:	ed9f aa8d 	vldr	s20, [pc, #564]	; 8021918 <adc_thread+0xab8>
 80216e4:	e605      	b.n	80212f2 <adc_thread+0x492>
			pwr -= brake;
 80216e6:	ed9d 7a02 	vldr	s14, [sp, #8]
 80216ea:	ee77 7a67 	vsub.f32	s15, s14, s15
 80216ee:	edcd 7a02 	vstr	s15, [sp, #8]
			break;
 80216f2:	e4ee      	b.n	80210d2 <adc_thread+0x272>
		bool send_duty = false;
 80216f4:	2600      	movs	r6, #0
 80216f6:	e594      	b.n	8021222 <adc_thread+0x3c2>
			float duty = mc_interface_get_duty_cycle_now();
 80216f8:	f7f9 feda 	bl	801b4b0 <mc_interface_get_duty_cycle_now>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 80216fc:	2600      	movs	r6, #0
			float duty = mc_interface_get_duty_cycle_now();
 80216fe:	eef0 ba40 	vmov.f32	s23, s0
 8021702:	e002      	b.n	802170a <adc_thread+0x8aa>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021704:	2e0a      	cmp	r6, #10
 8021706:	f43f aef5 	beq.w	80214f4 <adc_thread+0x694>
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 802170a:	4630      	mov	r0, r6
 802170c:	f7f9 f9c8 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021710:	6802      	ldr	r2, [r0, #0]
 8021712:	2a00      	cmp	r2, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021714:	f106 0601 	add.w	r6, r6, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021718:	dbf4      	blt.n	8021704 <adc_thread+0x8a4>
  return chVTGetSystemTimeX() - start;
 802171a:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 802171c:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021720:	1a5b      	subs	r3, r3, r1
 8021722:	ee07 3a90 	vmov	s15, r3
 8021726:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802172a:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 802172e:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8021732:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021736:	d5e5      	bpl.n	8021704 <adc_thread+0x8a4>
					comm_can_set_duty(msg->id, duty);
 8021738:	b2d0      	uxtb	r0, r2
 802173a:	eeb0 0a6b 	vmov.f32	s0, s23
 802173e:	f7f9 f94f 	bl	801a9e0 <comm_can_set_duty>
 8021742:	e7df      	b.n	8021704 <adc_thread+0x8a4>
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 8021744:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8021748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802174c:	f53f ae2a 	bmi.w	80213a4 <adc_thread+0x544>
				current = pwr * fabsf(mcconf->lo_current_motor_min_now);
 8021750:	ed9a aa1e 	vldr	s20, [sl, #120]	; 0x78
 8021754:	eeb0 aaca 	vabs.f32	s20, s20
 8021758:	ee2a aa27 	vmul.f32	s20, s20, s15
 802175c:	e626      	b.n	80213ac <adc_thread+0x54c>
			if ((pwr >= 0.0 && rpm_now > 0.0) || (pwr < 0.0 && rpm_now < 0.0)) {
 802175e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8021762:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021766:	f53f ad37 	bmi.w	80211d8 <adc_thread+0x378>
				current = pwr * fabsf(mcconf->lo_current_motor_min_now);
 802176a:	ed9a aa1e 	vldr	s20, [sl, #120]	; 0x78
 802176e:	eeb0 aaca 	vabs.f32	s20, s20
 8021772:	ee2a aa27 	vmul.f32	s20, s20, s15
 8021776:	e533      	b.n	80211e0 <adc_thread+0x380>
				if (config.multi_esc) {
 8021778:	eef0 ba4a 	vmov.f32	s23, s20
					current = -current;
 802177c:	2500      	movs	r5, #0
 802177e:	464e      	mov	r6, r9
 8021780:	e027      	b.n	80217d2 <adc_thread+0x972>
								float rpm_tmp = msg->rpm;
 8021782:	ed90 0a02 	vldr	s0, [r0, #8]
 8021786:	9001      	str	r0, [sp, #4]
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8021788:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 802178c:	eddf 0a62 	vldr	s1, [pc, #392]	; 8021918 <adc_thread+0xab8>
								if (is_reverse) {
 8021790:	2e00      	cmp	r6, #0
 8021792:	f000 809b 	beq.w	80218cc <adc_thread+0xa6c>
									rpm_tmp = -rpm_tmp;
 8021796:	eeb1 0a40 	vneg.f32	s0, s0
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 802179a:	ee30 0a6a 	vsub.f32	s0, s0, s21
 802179e:	eeb0 2a48 	vmov.f32	s4, s16
 80217a2:	eef0 1a6b 	vmov.f32	s3, s23
 80217a6:	f7f4 f9ab 	bl	8015b00 <utils_map>
								if (current_out < mcconf->cc_min_current) {
 80217aa:	edda 7a50 	vldr	s15, [sl, #320]	; 0x140
 80217ae:	9801      	ldr	r0, [sp, #4]
 80217b0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80217b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80217b8:	eeb0 aa40 	vmov.f32	s20, s0
 80217bc:	6802      	ldr	r2, [r0, #0]
								if (current_out < mcconf->cc_min_current) {
 80217be:	f100 8104 	bmi.w	80219ca <adc_thread+0xb6a>
								comm_can_set_current(msg->id, -current_out);
 80217c2:	b2d0      	uxtb	r0, r2
 80217c4:	eeb1 0a4a 	vneg.f32	s0, s20
 80217c8:	f7f9 f92a 	bl	801aa20 <comm_can_set_current>
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 80217cc:	3501      	adds	r5, #1
 80217ce:	2d0a      	cmp	r5, #10
 80217d0:	d022      	beq.n	8021818 <adc_thread+0x9b8>
						can_status_msg *msg = comm_can_get_status_msg_index(i);
 80217d2:	4628      	mov	r0, r5
 80217d4:	f7f9 f964 	bl	801aaa0 <comm_can_get_status_msg_index>
						if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 80217d8:	6802      	ldr	r2, [r0, #0]
 80217da:	2a00      	cmp	r2, #0
 80217dc:	dbf6      	blt.n	80217cc <adc_thread+0x96c>
  return ch.vtlist.vt_systime;
 80217de:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 80217e2:	6841      	ldr	r1, [r0, #4]
 80217e4:	1a5b      	subs	r3, r3, r1
 80217e6:	ee07 3a90 	vmov	s15, r3
 80217ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80217ee:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 80217f2:	eeb4 7ac9 	vcmpe.f32	s14, s18
 80217f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80217fa:	d5e7      	bpl.n	80217cc <adc_thread+0x96c>
							if (config.tc) {
 80217fc:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8021800:	2b00      	cmp	r3, #0
 8021802:	d1be      	bne.n	8021782 <adc_thread+0x922>
							if (is_reverse) {
 8021804:	2e00      	cmp	r6, #0
 8021806:	d1dc      	bne.n	80217c2 <adc_thread+0x962>
								comm_can_set_current(msg->id, current_out);
 8021808:	b2d0      	uxtb	r0, r2
 802180a:	eeb0 0a4a 	vmov.f32	s0, s20
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802180e:	3501      	adds	r5, #1
								comm_can_set_current(msg->id, current_out);
 8021810:	f7f9 f906 	bl	801aa20 <comm_can_set_current>
					for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021814:	2d0a      	cmp	r5, #10
 8021816:	d1dc      	bne.n	80217d2 <adc_thread+0x972>
					if (config.tc) {
 8021818:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 802181c:	46b1      	mov	r9, r6
 802181e:	2b00      	cmp	r3, #0
 8021820:	f040 80b0 	bne.w	8021984 <adc_thread+0xb24>
				if (is_reverse) {
 8021824:	f1b9 0f00 	cmp.w	r9, #0
 8021828:	d115      	bne.n	8021856 <adc_thread+0x9f6>
					mc_interface_set_current(current_out);
 802182a:	eeb0 0a4a 	vmov.f32	s0, s20
 802182e:	f7fa fd57 	bl	801c2e0 <mc_interface_set_current>
 8021832:	f7ff bb3b 	b.w	8020eac <adc_thread+0x4c>
				current = fabsf(pwr * mcconf->lo_current_motor_min_now);
 8021836:	ed9a aa1e 	vldr	s20, [sl, #120]	; 0x78
 802183a:	ee27 aa8a 	vmul.f32	s20, s15, s20
				current_mode_brake = true;
 802183e:	f04f 0901 	mov.w	r9, #1
				current = fabsf(pwr * mcconf->lo_current_motor_min_now);
 8021842:	eeb0 aaca 	vabs.f32	s20, s20
 8021846:	e544      	b.n	80212d2 <adc_thread+0x472>
					current_out = -current_out;
 8021848:	eeb1 aa4a 	vneg.f32	s20, s20
				if (config.multi_esc) {
 802184c:	f003 09ff 	and.w	r9, r3, #255	; 0xff
 8021850:	2b00      	cmp	r3, #0
 8021852:	f040 80b3 	bne.w	80219bc <adc_thread+0xb5c>
					mc_interface_set_current(-current_out);
 8021856:	eeb1 0a4a 	vneg.f32	s0, s20
 802185a:	f7fa fd41 	bl	801c2e0 <mc_interface_set_current>
 802185e:	f7ff bb25 	b.w	8020eac <adc_thread+0x4c>
			if (!was_pid) {
 8021862:	4b2e      	ldr	r3, [pc, #184]	; (802191c <adc_thread+0xabc>)
 8021864:	781a      	ldrb	r2, [r3, #0]
 8021866:	2a00      	cmp	r2, #0
 8021868:	f000 8082 	beq.w	8021970 <adc_thread+0xb10>
 802186c:	4b2c      	ldr	r3, [pc, #176]	; (8021920 <adc_thread+0xac0>)
 802186e:	ed93 0a00 	vldr	s0, [r3]
			mc_interface_set_pid_speed(pid_rpm);
 8021872:	f7fa fcbd 	bl	801c1f0 <mc_interface_set_pid_speed>
			if (config.multi_esc) {
 8021876:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 802187a:	2b00      	cmp	r3, #0
 802187c:	f43f ab16 	beq.w	8020eac <adc_thread+0x4c>
				float current = mc_interface_get_tot_current_directional_filtered();
 8021880:	f7f9 fefe 	bl	801b680 <mc_interface_get_tot_current_directional_filtered>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021884:	2500      	movs	r5, #0
				float current = mc_interface_get_tot_current_directional_filtered();
 8021886:	eeb0 aa40 	vmov.f32	s20, s0
 802188a:	e002      	b.n	8021892 <adc_thread+0xa32>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802188c:	2d0a      	cmp	r5, #10
 802188e:	f43f ab0d 	beq.w	8020eac <adc_thread+0x4c>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 8021892:	4628      	mov	r0, r5
 8021894:	f7f9 f904 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021898:	6802      	ldr	r2, [r0, #0]
 802189a:	2a00      	cmp	r2, #0
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802189c:	f105 0501 	add.w	r5, r5, #1
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 80218a0:	dbf4      	blt.n	802188c <adc_thread+0xa2c>
 80218a2:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 80218a4:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 80218a8:	1a5b      	subs	r3, r3, r1
 80218aa:	ee07 3a90 	vmov	s15, r3
 80218ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80218b2:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 80218b6:	eeb4 7ac9 	vcmpe.f32	s14, s18
 80218ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80218be:	d5e5      	bpl.n	802188c <adc_thread+0xa2c>
						comm_can_set_current(msg->id, current);
 80218c0:	b2d0      	uxtb	r0, r2
 80218c2:	eeb0 0a4a 	vmov.f32	s0, s20
 80218c6:	f7f9 f8ab 	bl	801aa20 <comm_can_set_current>
 80218ca:	e7df      	b.n	802188c <adc_thread+0xa2c>
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80218cc:	ee30 0a6a 	vsub.f32	s0, s0, s21
 80218d0:	eeb0 2a48 	vmov.f32	s4, s16
 80218d4:	eef0 1a6b 	vmov.f32	s3, s23
 80218d8:	f7f4 f912 	bl	8015b00 <utils_map>
								if (current_out < mcconf->cc_min_current) {
 80218dc:	edda 7a50 	vldr	s15, [sl, #320]	; 0x140
 80218e0:	9801      	ldr	r0, [sp, #4]
 80218e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80218e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80218ea:	eeb0 aa40 	vmov.f32	s20, s0
 80218ee:	6802      	ldr	r2, [r0, #0]
								if (current_out < mcconf->cc_min_current) {
 80218f0:	d58a      	bpl.n	8021808 <adc_thread+0x9a8>
									current_out = 0.0;
 80218f2:	ed9f aa09 	vldr	s20, [pc, #36]	; 8021918 <adc_thread+0xab8>
 80218f6:	e787      	b.n	8021808 <adc_thread+0x9a8>
				mc_interface_set_brake_current(current);
 80218f8:	eeb0 0a4a 	vmov.f32	s0, s20
 80218fc:	f7fa fd40 	bl	801c380 <mc_interface_set_brake_current>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021900:	2500      	movs	r5, #0
 8021902:	e016      	b.n	8021932 <adc_thread+0xad2>
 8021904:	40020400 	.word	0x40020400
 8021908:	d1b71759 	.word	0xd1b71759
 802190c:	447a0000 	.word	0x447a0000
 8021910:	2000e56c 	.word	0x2000e56c
 8021914:	2000e558 	.word	0x2000e558
 8021918:	00000000 	.word	0x00000000
 802191c:	2000e579 	.word	0x2000e579
 8021920:	2000e564 	.word	0x2000e564
 8021924:	2000e55c 	.word	0x2000e55c
 8021928:	2000e560 	.word	0x2000e560
 802192c:	2d0a      	cmp	r5, #10
 802192e:	f43f aabd 	beq.w	8020eac <adc_thread+0x4c>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 8021932:	4628      	mov	r0, r5
 8021934:	f7f9 f8b4 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021938:	6802      	ldr	r2, [r0, #0]
 802193a:	2a00      	cmp	r2, #0
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802193c:	f105 0501 	add.w	r5, r5, #1
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021940:	dbf4      	blt.n	802192c <adc_thread+0xacc>
 8021942:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 8021944:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021948:	1a5b      	subs	r3, r3, r1
 802194a:	ee07 3a90 	vmov	s15, r3
 802194e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021952:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 8021956:	eeb4 7ac9 	vcmpe.f32	s14, s18
 802195a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802195e:	d5e5      	bpl.n	802192c <adc_thread+0xacc>
						comm_can_set_current_brake(msg->id, current);
 8021960:	b2d0      	uxtb	r0, r2
 8021962:	eeb0 0a4a 	vmov.f32	s0, s20
 8021966:	f7f9 f87b 	bl	801aa60 <comm_can_set_current_brake>
 802196a:	e7df      	b.n	802192c <adc_thread+0xacc>
			current_mode = true;
 802196c:	2501      	movs	r5, #1
 802196e:	e4c0      	b.n	80212f2 <adc_thread+0x492>
		rpm_filtered /= RPM_FILTER_SAMPLES;
 8021970:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 8021974:	ee27 0a80 	vmul.f32	s0, s15, s0
				pid_rpm = rpm_filtered;
 8021978:	4915      	ldr	r1, [pc, #84]	; (80219d0 <adc_thread+0xb70>)
				was_pid = true;
 802197a:	2201      	movs	r2, #1
				pid_rpm = rpm_filtered;
 802197c:	ed81 0a00 	vstr	s0, [r1]
				was_pid = true;
 8021980:	701a      	strb	r2, [r3, #0]
 8021982:	e776      	b.n	8021872 <adc_thread+0xa12>
						current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 8021984:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 8021988:	eddf 0a12 	vldr	s1, [pc, #72]	; 80219d4 <adc_thread+0xb74>
 802198c:	eef0 1a6b 	vmov.f32	s3, s23
 8021990:	ee3b 0a6a 	vsub.f32	s0, s22, s21
 8021994:	eeb0 2a48 	vmov.f32	s4, s16
 8021998:	f7f4 f8b2 	bl	8015b00 <utils_map>
						if (current_out < mcconf->cc_min_current) {
 802199c:	edda 7a50 	vldr	s15, [sl, #320]	; 0x140
							current_out = 0.0;
 80219a0:	eef4 7a40 	vcmp.f32	s15, s0
						current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80219a4:	eeb0 aa40 	vmov.f32	s20, s0
							current_out = 0.0;
 80219a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80219ac:	bfc8      	it	gt
 80219ae:	eeb0 aa48 	vmovgt.f32	s20, s16
				if (is_reverse) {
 80219b2:	f1b9 0f00 	cmp.w	r9, #0
 80219b6:	f43f af38 	beq.w	802182a <adc_thread+0x9ca>
 80219ba:	e74c      	b.n	8021856 <adc_thread+0x9f6>
					rpm_local = -rpm_local;
 80219bc:	eeb1 ba4b 	vneg.f32	s22, s22
					rpm_lowest = -rpm_lowest;
 80219c0:	eef1 aa6a 	vneg.f32	s21, s21
					current = -current;
 80219c4:	eef0 ba4a 	vmov.f32	s23, s20
 80219c8:	e6d8      	b.n	802177c <adc_thread+0x91c>
									current_out = 0.0;
 80219ca:	ed9f aa02 	vldr	s20, [pc, #8]	; 80219d4 <adc_thread+0xb74>
 80219ce:	e6f8      	b.n	80217c2 <adc_thread+0x962>
 80219d0:	2000e564 	.word	0x2000e564
	...

080219e0 <app_adc_configure>:
void app_adc_configure(adc_config *conf) {
 80219e0:	b508      	push	{r3, lr}
	config = *conf;
 80219e2:	4601      	mov	r1, r0
 80219e4:	2244      	movs	r2, #68	; 0x44
 80219e6:	4803      	ldr	r0, [pc, #12]	; (80219f4 <app_adc_configure+0x14>)
 80219e8:	f7eb f89a 	bl	800cb20 <memcpy>
	ms_without_power = 0.0;
 80219ec:	4b02      	ldr	r3, [pc, #8]	; (80219f8 <app_adc_configure+0x18>)
 80219ee:	2200      	movs	r2, #0
 80219f0:	601a      	str	r2, [r3, #0]
}
 80219f2:	bd08      	pop	{r3, pc}
 80219f4:	2000e4b8 	.word	0x2000e4b8
 80219f8:	2000e560 	.word	0x2000e560
 80219fc:	00000000 	.word	0x00000000

08021a00 <app_adc_start>:
void app_adc_start(bool use_rx_tx) {
 8021a00:	b530      	push	{r4, r5, lr}
	use_rx_tx_as_buttons = use_rx_tx;
 8021a02:	4908      	ldr	r1, [pc, #32]	; (8021a24 <app_adc_start+0x24>)
	stop_now = false;
 8021a04:	4d08      	ldr	r5, [pc, #32]	; (8021a28 <app_adc_start+0x28>)
	chThdCreateStatic(adc_thread_wa, sizeof(adc_thread_wa), NORMALPRIO, adc_thread, NULL);
 8021a06:	4b09      	ldr	r3, [pc, #36]	; (8021a2c <app_adc_start+0x2c>)
void app_adc_start(bool use_rx_tx) {
 8021a08:	b083      	sub	sp, #12
	stop_now = false;
 8021a0a:	2400      	movs	r4, #0
	chThdCreateStatic(adc_thread_wa, sizeof(adc_thread_wa), NORMALPRIO, adc_thread, NULL);
 8021a0c:	9400      	str	r4, [sp, #0]
 8021a0e:	2240      	movs	r2, #64	; 0x40
	use_rx_tx_as_buttons = use_rx_tx;
 8021a10:	7008      	strb	r0, [r1, #0]
	chThdCreateStatic(adc_thread_wa, sizeof(adc_thread_wa), NORMALPRIO, adc_thread, NULL);
 8021a12:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 8021a16:	4806      	ldr	r0, [pc, #24]	; (8021a30 <app_adc_start+0x30>)
	stop_now = false;
 8021a18:	702c      	strb	r4, [r5, #0]
	chThdCreateStatic(adc_thread_wa, sizeof(adc_thread_wa), NORMALPRIO, adc_thread, NULL);
 8021a1a:	f7eb ffa9 	bl	800d970 <chThdCreateStatic>
}
 8021a1e:	b003      	add	sp, #12
 8021a20:	bd30      	pop	{r4, r5, pc}
 8021a22:	bf00      	nop
 8021a24:	2000e578 	.word	0x2000e578
 8021a28:	2000104f 	.word	0x2000104f
 8021a2c:	08020e61 	.word	0x08020e61
 8021a30:	2000df20 	.word	0x2000df20
	...

08021a40 <app_adc_stop>:
	stop_now = true;
 8021a40:	4b06      	ldr	r3, [pc, #24]	; (8021a5c <app_adc_stop+0x1c>)
void app_adc_stop(void) {
 8021a42:	b510      	push	{r4, lr}
	stop_now = true;
 8021a44:	2201      	movs	r2, #1
	while (is_running) {
 8021a46:	4c06      	ldr	r4, [pc, #24]	; (8021a60 <app_adc_stop+0x20>)
	stop_now = true;
 8021a48:	701a      	strb	r2, [r3, #0]
	while (is_running) {
 8021a4a:	7823      	ldrb	r3, [r4, #0]
 8021a4c:	b12b      	cbz	r3, 8021a5a <app_adc_stop+0x1a>
		chThdSleepMilliseconds(1);
 8021a4e:	200a      	movs	r0, #10
 8021a50:	f7eb ffc6 	bl	800d9e0 <chThdSleep>
	while (is_running) {
 8021a54:	7823      	ldrb	r3, [r4, #0]
 8021a56:	2b00      	cmp	r3, #0
 8021a58:	d1f9      	bne.n	8021a4e <app_adc_stop+0xe>
}
 8021a5a:	bd10      	pop	{r4, pc}
 8021a5c:	2000104f 	.word	0x2000104f
 8021a60:	2000e558 	.word	0x2000e558
	...

08021a70 <app_adc_get_decoded_level>:
	return decoded_level;
 8021a70:	4b01      	ldr	r3, [pc, #4]	; (8021a78 <app_adc_get_decoded_level+0x8>)
 8021a72:	ed93 0a00 	vldr	s0, [r3]
}
 8021a76:	4770      	bx	lr
 8021a78:	2000e4fc 	.word	0x2000e4fc
 8021a7c:	00000000 	.word	0x00000000

08021a80 <app_adc_get_voltage>:
	return read_voltage;
 8021a80:	4b01      	ldr	r3, [pc, #4]	; (8021a88 <app_adc_get_voltage+0x8>)
 8021a82:	ed93 0a00 	vldr	s0, [r3]
}
 8021a86:	4770      	bx	lr
 8021a88:	2000e570 	.word	0x2000e570
 8021a8c:	00000000 	.word	0x00000000

08021a90 <app_adc_get_decoded_level2>:
	return decoded_level2;
 8021a90:	4b01      	ldr	r3, [pc, #4]	; (8021a98 <app_adc_get_decoded_level2+0x8>)
 8021a92:	ed93 0a00 	vldr	s0, [r3]
}
 8021a96:	4770      	bx	lr
 8021a98:	2000e500 	.word	0x2000e500
 8021a9c:	00000000 	.word	0x00000000

08021aa0 <app_adc_get_voltage2>:
	return read_voltage2;
 8021aa0:	4b01      	ldr	r3, [pc, #4]	; (8021aa8 <app_adc_get_voltage2+0x8>)
 8021aa2:	ed93 0a00 	vldr	s0, [r3]
}
 8021aa6:	4770      	bx	lr
 8021aa8:	2000e574 	.word	0x2000e574
 8021aac:	00000000 	.word	0x00000000

08021ab0 <txend1>:
 * This callback is invoked when a transmission buffer has been completely
 * read by the driver.
 */
static void txend1(UARTDriver *uartp) {
	(void)uartp;
}
 8021ab0:	4770      	bx	lr
 8021ab2:	bf00      	nop
	...

08021ac0 <rxerr>:
 * as parameter.
 */
static void rxerr(UARTDriver *uartp, uartflags_t e) {
	(void)uartp;
	(void)e;
}
 8021ac0:	4770      	bx	lr
 8021ac2:	bf00      	nop
	...

08021ad0 <rxchar>:
 * This callback is invoked when a character is received but the application
 * was not ready to receive it, the character is passed as parameter.
 */
static void rxchar(UARTDriver *uartp, uint16_t c) {
	(void)uartp;
	serial_rx_buffer[serial_rx_write_pos++] = c;
 8021ad0:	4b0b      	ldr	r3, [pc, #44]	; (8021b00 <rxchar+0x30>)
 8021ad2:	6818      	ldr	r0, [r3, #0]
 8021ad4:	1c42      	adds	r2, r0, #1
static void rxchar(UARTDriver *uartp, uint16_t c) {
 8021ad6:	b510      	push	{r4, lr}

	if (serial_rx_write_pos == SERIAL_RX_BUFFER_SIZE) {
 8021ad8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
	serial_rx_buffer[serial_rx_write_pos++] = c;
 8021adc:	4c09      	ldr	r4, [pc, #36]	; (8021b04 <rxchar+0x34>)
 8021ade:	601a      	str	r2, [r3, #0]
		serial_rx_write_pos = 0;
 8021ae0:	bf04      	itt	eq
 8021ae2:	2200      	moveq	r2, #0
 8021ae4:	601a      	streq	r2, [r3, #0]
	serial_rx_buffer[serial_rx_write_pos++] = c;
 8021ae6:	5421      	strb	r1, [r4, r0]
 8021ae8:	2320      	movs	r3, #32
 8021aea:	f383 8811 	msr	BASEPRI, r3
	}

	chSysLockFromISR();
	chEvtSignalI(process_tp, (eventmask_t) 1);
 8021aee:	4b06      	ldr	r3, [pc, #24]	; (8021b08 <rxchar+0x38>)
 8021af0:	2101      	movs	r1, #1
 8021af2:	6818      	ldr	r0, [r3, #0]
 8021af4:	f7ec f994 	bl	800de20 <chEvtSignalI>
 8021af8:	2300      	movs	r3, #0
 8021afa:	f383 8811 	msr	BASEPRI, r3
	chSysUnlockFromISR();
}
 8021afe:	bd10      	pop	{r4, pc}
 8021b00:	2000ff28 	.word	0x2000ff28
 8021b04:	2000fb24 	.word	0x2000fb24
 8021b08:	2000fb20 	.word	0x2000fb20
 8021b0c:	00000000 	.word	0x00000000

08021b10 <packet_process_thread>:
 8021b10:	4b11      	ldr	r3, [pc, #68]	; (8021b58 <packet_process_thread+0x48>)
static THD_FUNCTION(packet_process_thread, arg) {
	(void)arg;

	chRegSetThreadName("uartcomm process");

	process_tp = chThdGetSelfX();
 8021b12:	4a12      	ldr	r2, [pc, #72]	; (8021b5c <packet_process_thread+0x4c>)
 8021b14:	699b      	ldr	r3, [r3, #24]
 8021b16:	4912      	ldr	r1, [pc, #72]	; (8021b60 <packet_process_thread+0x50>)
 8021b18:	4c12      	ldr	r4, [pc, #72]	; (8021b64 <packet_process_thread+0x54>)
 8021b1a:	4e13      	ldr	r6, [pc, #76]	; (8021b68 <packet_process_thread+0x58>)
static THD_FUNCTION(packet_process_thread, arg) {
 8021b1c:	b580      	push	{r7, lr}
 8021b1e:	4f13      	ldr	r7, [pc, #76]	; (8021b6c <packet_process_thread+0x5c>)
 8021b20:	6199      	str	r1, [r3, #24]
	process_tp = chThdGetSelfX();
 8021b22:	6013      	str	r3, [r2, #0]

		while (serial_rx_read_pos != serial_rx_write_pos) {
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);

			if (serial_rx_read_pos == SERIAL_RX_BUFFER_SIZE) {
				serial_rx_read_pos = 0;
 8021b24:	f04f 0800 	mov.w	r8, #0
		chEvtWaitAny((eventmask_t) 1);
 8021b28:	2001      	movs	r0, #1
 8021b2a:	f7ec f9b9 	bl	800dea0 <chEvtWaitAny>
 8021b2e:	6823      	ldr	r3, [r4, #0]
		while (serial_rx_read_pos != serial_rx_write_pos) {
 8021b30:	6832      	ldr	r2, [r6, #0]
 8021b32:	429a      	cmp	r2, r3
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8021b34:	f103 0501 	add.w	r5, r3, #1
 8021b38:	f04f 0101 	mov.w	r1, #1
		while (serial_rx_read_pos != serial_rx_write_pos) {
 8021b3c:	d0f4      	beq.n	8021b28 <packet_process_thread+0x18>
			packet_process_byte(serial_rx_buffer[serial_rx_read_pos++], PACKET_HANDLER);
 8021b3e:	5cf8      	ldrb	r0, [r7, r3]
 8021b40:	6025      	str	r5, [r4, #0]
 8021b42:	f7f4 fb4d 	bl	80161e0 <packet_process_byte>
			if (serial_rx_read_pos == SERIAL_RX_BUFFER_SIZE) {
 8021b46:	6823      	ldr	r3, [r4, #0]
 8021b48:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
				serial_rx_read_pos = 0;
 8021b4c:	bf04      	itt	eq
 8021b4e:	f8c4 8000 	streq.w	r8, [r4]
 8021b52:	2300      	moveq	r3, #0
 8021b54:	e7ec      	b.n	8021b30 <packet_process_thread+0x20>
 8021b56:	bf00      	nop
 8021b58:	20001a48 	.word	0x20001a48
 8021b5c:	2000fb20 	.word	0x2000fb20
 8021b60:	0802f5f0 	.word	0x0802f5f0
 8021b64:	2000ff24 	.word	0x2000ff24
 8021b68:	2000ff28 	.word	0x2000ff28
 8021b6c:	2000fb24 	.word	0x2000fb24

08021b70 <process_packet>:
static void process_packet(unsigned char *data, unsigned int len) {
 8021b70:	b538      	push	{r3, r4, r5, lr}
 8021b72:	4604      	mov	r4, r0
 8021b74:	460d      	mov	r5, r1
	commands_set_send_func(send_packet_wrapper);
 8021b76:	4804      	ldr	r0, [pc, #16]	; (8021b88 <process_packet+0x18>)
 8021b78:	f7f6 fd52 	bl	8018620 <commands_set_send_func>
	commands_process_packet(data, len);
 8021b7c:	4629      	mov	r1, r5
 8021b7e:	4620      	mov	r0, r4
}
 8021b80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	commands_process_packet(data, len);
 8021b84:	f7f6 bf14 	b.w	80189b0 <commands_process_packet>
 8021b88:	08021b91 	.word	0x08021b91
 8021b8c:	00000000 	.word	0x00000000

08021b90 <send_packet_wrapper>:
	packet_send_packet(data, len, PACKET_HANDLER);
 8021b90:	2201      	movs	r2, #1
 8021b92:	f7f4 bab5 	b.w	8016100 <packet_send_packet>
 8021b96:	bf00      	nop
	...

08021ba0 <send_packet>:
static void send_packet(unsigned char *data, unsigned int len) {
 8021ba0:	b570      	push	{r4, r5, r6, lr}
	while (HW_UART_DEV.txstate == UART_TX_ACTIVE) {
 8021ba2:	4c0c      	ldr	r4, [pc, #48]	; (8021bd4 <send_packet+0x34>)
 8021ba4:	7863      	ldrb	r3, [r4, #1]
 8021ba6:	2b01      	cmp	r3, #1
static void send_packet(unsigned char *data, unsigned int len) {
 8021ba8:	4606      	mov	r6, r0
 8021baa:	460d      	mov	r5, r1
	while (HW_UART_DEV.txstate == UART_TX_ACTIVE) {
 8021bac:	d105      	bne.n	8021bba <send_packet+0x1a>
		chThdSleep(1);
 8021bae:	2001      	movs	r0, #1
 8021bb0:	f7eb ff16 	bl	800d9e0 <chThdSleep>
	while (HW_UART_DEV.txstate == UART_TX_ACTIVE) {
 8021bb4:	7863      	ldrb	r3, [r4, #1]
 8021bb6:	2b01      	cmp	r3, #1
 8021bb8:	d0f9      	beq.n	8021bae <send_packet+0xe>
	memcpy(buffer, data, len);
 8021bba:	4631      	mov	r1, r6
 8021bbc:	462a      	mov	r2, r5
 8021bbe:	4806      	ldr	r0, [pc, #24]	; (8021bd8 <send_packet+0x38>)
 8021bc0:	f7ea ffae 	bl	800cb20 <memcpy>
	uartStartSend(&HW_UART_DEV, len, buffer);
 8021bc4:	4629      	mov	r1, r5
 8021bc6:	4a04      	ldr	r2, [pc, #16]	; (8021bd8 <send_packet+0x38>)
 8021bc8:	4802      	ldr	r0, [pc, #8]	; (8021bd4 <send_packet+0x34>)
}
 8021bca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	uartStartSend(&HW_UART_DEV, len, buffer);
 8021bce:	f7ec bf7f 	b.w	800ead0 <uartStartSend>
 8021bd2:	bf00      	nop
 8021bd4:	200020bc 	.word	0x200020bc
 8021bd8:	2000e57c 	.word	0x2000e57c
 8021bdc:	00000000 	.word	0x00000000

08021be0 <rxend>:
 8021be0:	4770      	bx	lr
 8021be2:	bf00      	nop
	...

08021bf0 <txend2>:
 8021bf0:	4770      	bx	lr
 8021bf2:	bf00      	nop
	...

08021c00 <app_uartcomm_start>:
void app_uartcomm_start(void) {
 8021c00:	b530      	push	{r4, r5, lr}
	if (!is_running) {
 8021c02:	4c16      	ldr	r4, [pc, #88]	; (8021c5c <app_uartcomm_start+0x5c>)
	packet_init(send_packet, process_packet, PACKET_HANDLER);
 8021c04:	4916      	ldr	r1, [pc, #88]	; (8021c60 <app_uartcomm_start+0x60>)
 8021c06:	4817      	ldr	r0, [pc, #92]	; (8021c64 <app_uartcomm_start+0x64>)
 8021c08:	2201      	movs	r2, #1
void app_uartcomm_start(void) {
 8021c0a:	b083      	sub	sp, #12
	packet_init(send_packet, process_packet, PACKET_HANDLER);
 8021c0c:	f7f4 fa68 	bl	80160e0 <packet_init>
	serial_rx_read_pos = 0;
 8021c10:	4815      	ldr	r0, [pc, #84]	; (8021c68 <app_uartcomm_start+0x68>)
	serial_rx_write_pos = 0;
 8021c12:	4916      	ldr	r1, [pc, #88]	; (8021c6c <app_uartcomm_start+0x6c>)
	if (!is_running) {
 8021c14:	7823      	ldrb	r3, [r4, #0]
	serial_rx_read_pos = 0;
 8021c16:	2200      	movs	r2, #0
 8021c18:	6002      	str	r2, [r0, #0]
	serial_rx_write_pos = 0;
 8021c1a:	600a      	str	r2, [r1, #0]
	if (!is_running) {
 8021c1c:	b95b      	cbnz	r3, 8021c36 <app_uartcomm_start+0x36>
 8021c1e:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		chThdCreateStatic(packet_process_thread_wa, sizeof(packet_process_thread_wa),
 8021c22:	9500      	str	r5, [sp, #0]
 8021c24:	4b12      	ldr	r3, [pc, #72]	; (8021c70 <app_uartcomm_start+0x70>)
 8021c26:	4813      	ldr	r0, [pc, #76]	; (8021c74 <app_uartcomm_start+0x74>)
 8021c28:	2240      	movs	r2, #64	; 0x40
 8021c2a:	f241 1198 	movw	r1, #4504	; 0x1198
 8021c2e:	f7eb fe9f 	bl	800d970 <chThdCreateStatic>
		is_running = true;
 8021c32:	2301      	movs	r3, #1
 8021c34:	7023      	strb	r3, [r4, #0]
	uartStart(&HW_UART_DEV, &uart_cfg);
 8021c36:	4910      	ldr	r1, [pc, #64]	; (8021c78 <app_uartcomm_start+0x78>)
 8021c38:	4810      	ldr	r0, [pc, #64]	; (8021c7c <app_uartcomm_start+0x7c>)
 8021c3a:	f7ec ff29 	bl	800ea90 <uartStart>
	palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_ALTERNATE(HW_UART_GPIO_AF) |
 8021c3e:	f240 423a 	movw	r2, #1082	; 0x43a
 8021c42:	2140      	movs	r1, #64	; 0x40
 8021c44:	480e      	ldr	r0, [pc, #56]	; (8021c80 <app_uartcomm_start+0x80>)
 8021c46:	f7ee f90b 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_ALTERNATE(HW_UART_GPIO_AF) |
 8021c4a:	480d      	ldr	r0, [pc, #52]	; (8021c80 <app_uartcomm_start+0x80>)
 8021c4c:	f240 423a 	movw	r2, #1082	; 0x43a
 8021c50:	2180      	movs	r1, #128	; 0x80
}
 8021c52:	b003      	add	sp, #12
 8021c54:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_ALTERNATE(HW_UART_GPIO_AF) |
 8021c58:	f7ee b902 	b.w	800fe60 <_pal_lld_setgroupmode>
 8021c5c:	2000e981 	.word	0x2000e981
 8021c60:	08021b71 	.word	0x08021b71
 8021c64:	08021ba1 	.word	0x08021ba1
 8021c68:	2000ff24 	.word	0x2000ff24
 8021c6c:	2000ff28 	.word	0x2000ff28
 8021c70:	08021b11 	.word	0x08021b11
 8021c74:	2000e988 	.word	0x2000e988
 8021c78:	20001050 	.word	0x20001050
 8021c7c:	200020bc 	.word	0x200020bc
 8021c80:	40020800 	.word	0x40020800
	...

08021c90 <app_uartcomm_stop>:
void app_uartcomm_stop(void) {
 8021c90:	b510      	push	{r4, lr}
	palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT_PULLUP);
 8021c92:	4c08      	ldr	r4, [pc, #32]	; (8021cb4 <app_uartcomm_stop+0x24>)
	uartStop(&HW_UART_DEV);
 8021c94:	4808      	ldr	r0, [pc, #32]	; (8021cb8 <app_uartcomm_stop+0x28>)
 8021c96:	f7ec ff0b 	bl	800eab0 <uartStop>
	palSetPadMode(HW_UART_TX_PORT, HW_UART_TX_PIN, PAL_MODE_INPUT_PULLUP);
 8021c9a:	4620      	mov	r0, r4
 8021c9c:	2220      	movs	r2, #32
 8021c9e:	2140      	movs	r1, #64	; 0x40
 8021ca0:	f7ee f8de 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_INPUT_PULLUP);
 8021ca4:	4620      	mov	r0, r4
 8021ca6:	2220      	movs	r2, #32
 8021ca8:	2180      	movs	r1, #128	; 0x80
}
 8021caa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	palSetPadMode(HW_UART_RX_PORT, HW_UART_RX_PIN, PAL_MODE_INPUT_PULLUP);
 8021cae:	f7ee b8d7 	b.w	800fe60 <_pal_lld_setgroupmode>
 8021cb2:	bf00      	nop
 8021cb4:	40020800 	.word	0x40020800
 8021cb8:	200020bc 	.word	0x200020bc
 8021cbc:	00000000 	.word	0x00000000

08021cc0 <app_uartcomm_configure>:
	if (is_running) {
 8021cc0:	4b04      	ldr	r3, [pc, #16]	; (8021cd4 <app_uartcomm_configure+0x14>)
	uart_cfg.speed = baudrate;
 8021cc2:	4905      	ldr	r1, [pc, #20]	; (8021cd8 <app_uartcomm_configure+0x18>)
	if (is_running) {
 8021cc4:	781b      	ldrb	r3, [r3, #0]
	uart_cfg.speed = baudrate;
 8021cc6:	6148      	str	r0, [r1, #20]
	if (is_running) {
 8021cc8:	b903      	cbnz	r3, 8021ccc <app_uartcomm_configure+0xc>
}
 8021cca:	4770      	bx	lr
		uartStart(&HW_UART_DEV, &uart_cfg);
 8021ccc:	4803      	ldr	r0, [pc, #12]	; (8021cdc <app_uartcomm_configure+0x1c>)
 8021cce:	f7ec bedf 	b.w	800ea90 <uartStart>
 8021cd2:	bf00      	nop
 8021cd4:	2000e981 	.word	0x2000e981
 8021cd8:	20001050 	.word	0x20001050
 8021cdc:	200020bc 	.word	0x200020bc

08021ce0 <terminal_cmd_nunchuk_status>:
			}
		}
	}
}

static void terminal_cmd_nunchuk_status(int argc, const char **argv) {
 8021ce0:	b508      	push	{r3, lr}
	(void)argc;
	(void)argv;

	commands_printf("Nunchuk Status");
 8021ce2:	4809      	ldr	r0, [pc, #36]	; (8021d08 <terminal_cmd_nunchuk_status+0x28>)
 8021ce4:	f7f6 fcac 	bl	8018640 <commands_printf>
	commands_printf("Output: %s", output_running ? "On" : "Off");
 8021ce8:	4b08      	ldr	r3, [pc, #32]	; (8021d0c <terminal_cmd_nunchuk_status+0x2c>)
 8021cea:	4a09      	ldr	r2, [pc, #36]	; (8021d10 <terminal_cmd_nunchuk_status+0x30>)
 8021cec:	7819      	ldrb	r1, [r3, #0]
 8021cee:	4b09      	ldr	r3, [pc, #36]	; (8021d14 <terminal_cmd_nunchuk_status+0x34>)
 8021cf0:	4809      	ldr	r0, [pc, #36]	; (8021d18 <terminal_cmd_nunchuk_status+0x38>)
 8021cf2:	2900      	cmp	r1, #0
 8021cf4:	bf14      	ite	ne
 8021cf6:	4611      	movne	r1, r2
 8021cf8:	4619      	moveq	r1, r3
 8021cfa:	f7f6 fca1 	bl	8018640 <commands_printf>
	commands_printf(" ");
 8021cfe:	4807      	ldr	r0, [pc, #28]	; (8021d1c <terminal_cmd_nunchuk_status+0x3c>)
}
 8021d00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	commands_printf(" ");
 8021d04:	f7f6 bc9c 	b.w	8018640 <commands_printf>
 8021d08:	0802f678 	.word	0x0802f678
 8021d0c:	20010538 	.word	0x20010538
 8021d10:	0802f670 	.word	0x0802f670
 8021d14:	0802f674 	.word	0x0802f674
 8021d18:	0802f688 	.word	0x0802f688
 8021d1c:	0802e26c 	.word	0x0802e26c

08021d20 <output_thread>:
static THD_FUNCTION(output_thread, arg) {
 8021d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021d24:	f8df 837c 	ldr.w	r8, [pc, #892]	; 80220a4 <output_thread+0x384>
 8021d28:	4ac9      	ldr	r2, [pc, #804]	; (8022050 <output_thread+0x330>)
 8021d2a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8021d2e:	4fc9      	ldr	r7, [pc, #804]	; (8022054 <output_thread+0x334>)
 8021d30:	4cc9      	ldr	r4, [pc, #804]	; (8022058 <output_thread+0x338>)
 8021d32:	4eca      	ldr	r6, [pc, #808]	; (802205c <output_thread+0x33c>)
 8021d34:	f8df b370 	ldr.w	fp, [pc, #880]	; 80220a8 <output_thread+0x388>
 8021d38:	ed2d 8b0c 	vpush	{d8-d13}
 8021d3c:	619a      	str	r2, [r3, #24]
 8021d3e:	4bc8      	ldr	r3, [pc, #800]	; (8022060 <output_thread+0x340>)
		const float max_current_diff = mcconf->l_current_max * 0.2;
 8021d40:	eddf aac8 	vldr	s21, [pc, #800]	; 8022064 <output_thread+0x344>
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 8021d44:	ed9f aac8 	vldr	s20, [pc, #800]	; 8022068 <output_thread+0x348>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021d48:	eddf 9ac8 	vldr	s19, [pc, #800]	; 802206c <output_thread+0x34c>
 8021d4c:	ed9f 9ac8 	vldr	s18, [pc, #800]	; 8022070 <output_thread+0x350>
static THD_FUNCTION(output_thread, arg) {
 8021d50:	b087      	sub	sp, #28
 8021d52:	f103 0520 	add.w	r5, r3, #32
		chThdSleepMilliseconds(OUTPUT_ITERATION_TIME_MS);
 8021d56:	200a      	movs	r0, #10
 8021d58:	f7eb fe42 	bl	800d9e0 <chThdSleep>
		if (timeout_has_timeout() || chuck_error != 0 || config.ctrl_type == CHUK_CTRL_TYPE_NONE) {
 8021d5c:	f7f8 fa10 	bl	801a180 <timeout_has_timeout>
 8021d60:	2800      	cmp	r0, #0
 8021d62:	d1f8      	bne.n	8021d56 <output_thread+0x36>
 8021d64:	683b      	ldr	r3, [r7, #0]
 8021d66:	2b00      	cmp	r3, #0
 8021d68:	d1f5      	bne.n	8021d56 <output_thread+0x36>
 8021d6a:	7823      	ldrb	r3, [r4, #0]
 8021d6c:	2b00      	cmp	r3, #0
 8021d6e:	d0f2      	beq.n	8021d56 <output_thread+0x36>
		if (chVTTimeElapsedSinceX(last_update_time) > MS2ST(LOCAL_TIMEOUT)) {
 8021d70:	4bc0      	ldr	r3, [pc, #768]	; (8022074 <output_thread+0x354>)
 8021d72:	681a      	ldr	r2, [r3, #0]
  return ch.vtlist.vt_systime;
 8021d74:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021d78:	1a9b      	subs	r3, r3, r2
 8021d7a:	f644 6220 	movw	r2, #20000	; 0x4e20
 8021d7e:	4293      	cmp	r3, r2
 8021d80:	d8e9      	bhi.n	8021d56 <output_thread+0x36>
		const volatile mc_configuration *mcconf = mc_interface_get_configuration();
 8021d82:	f7f9 fb3d 	bl	801b400 <mc_interface_get_configuration>
 8021d86:	4681      	mov	r9, r0
		const float current_now = mc_interface_get_tot_current_directional_filtered();
 8021d88:	f7f9 fc7a 	bl	801b680 <mc_interface_get_tot_current_directional_filtered>
		const float max_current_diff = mcconf->l_current_max * 0.2;
 8021d8c:	ed99 ba01 	vldr	s22, [r9, #4]
		if (chuck_d.bt_c && chuck_d.bt_z) {
 8021d90:	7d33      	ldrb	r3, [r6, #20]
		const float current_now = mc_interface_get_tot_current_directional_filtered();
 8021d92:	eef0 8a40 	vmov.f32	s17, s0
		const float max_current_diff = mcconf->l_current_max * 0.2;
 8021d96:	ee2b ba2a 	vmul.f32	s22, s22, s21
		if (chuck_d.bt_c && chuck_d.bt_z) {
 8021d9a:	b11b      	cbz	r3, 8021da4 <output_thread+0x84>
 8021d9c:	7d73      	ldrb	r3, [r6, #21]
 8021d9e:	2b00      	cmp	r3, #0
 8021da0:	f040 810b 	bne.w	8021fba <output_thread+0x29a>
 8021da4:	4ab4      	ldr	r2, [pc, #720]	; (8022078 <output_thread+0x358>)
		if (chuck_d.bt_z && !was_z && config.ctrl_type == CHUK_CTRL_TYPE_CURRENT &&
 8021da6:	7d73      	ldrb	r3, [r6, #21]
 8021da8:	7810      	ldrb	r0, [r2, #0]
 8021daa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8021dae:	b13b      	cbz	r3, 8021dc0 <output_thread+0xa0>
 8021db0:	4bb2      	ldr	r3, [pc, #712]	; (802207c <output_thread+0x35c>)
 8021db2:	781b      	ldrb	r3, [r3, #0]
 8021db4:	b923      	cbnz	r3, 8021dc0 <output_thread+0xa0>
 8021db6:	7821      	ldrb	r1, [r4, #0]
 8021db8:	b2c9      	uxtb	r1, r1
 8021dba:	2901      	cmp	r1, #1
 8021dbc:	f000 8276 	beq.w	80222ac <output_thread+0x58c>
		was_z = chuck_d.bt_z;
 8021dc0:	4aae      	ldr	r2, [pc, #696]	; (802207c <output_thread+0x35c>)
 8021dc2:	7d73      	ldrb	r3, [r6, #21]
 8021dc4:	7013      	strb	r3, [r2, #0]
		led_external_set_reversed(is_reverse);
 8021dc6:	f7f8 fe83 	bl	801aad0 <led_external_set_reversed>
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 8021dca:	edd6 7a01 	vldr	s15, [r6, #4]
 8021dce:	ed9f 8aac 	vldr	s16, [pc, #688]	; 8022080 <output_thread+0x360>
		utils_deadband(&out_val, config.hyst, 1.0);
 8021dd2:	ed94 0a01 	vldr	s0, [r4, #4]
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 8021dd6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		utils_deadband(&out_val, config.hyst, 1.0);
 8021dda:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 8021dde:	ee77 7aca 	vsub.f32	s15, s15, s20
		utils_deadband(&out_val, config.hyst, 1.0);
 8021de2:	a803      	add	r0, sp, #12
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 8021de4:	ee67 7a88 	vmul.f32	s15, s15, s16
		float out_val = app_nunchuk_get_decoded_chuk();
 8021de8:	edcd 7a03 	vstr	s15, [sp, #12]
		utils_deadband(&out_val, config.hyst, 1.0);
 8021dec:	f7f3 fe98 	bl	8015b20 <utils_deadband>
		out_val = utils_throttle_curve(out_val, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 8021df0:	edd4 0a05 	vldr	s1, [r4, #20]
 8021df4:	ed9d 0a03 	vldr	s0, [sp, #12]
 8021df8:	ed94 1a06 	vldr	s2, [r4, #24]
 8021dfc:	7f20      	ldrb	r0, [r4, #28]
 8021dfe:	f7f4 f8a7 	bl	8015f50 <utils_throttle_curve>
		float x_axis = ((float)chuck_d.js_x - 128.0) / 128.0;
 8021e02:	edd6 7a00 	vldr	s15, [r6]
		if (out_val < -0.001) {
 8021e06:	ed9f 7a9f 	vldr	s14, [pc, #636]	; 8022084 <output_thread+0x364>
		out_val = utils_throttle_curve(out_val, config.throttle_exp, config.throttle_exp_brake, config.throttle_exp_mode);
 8021e0a:	ed8d 0a03 	vstr	s0, [sp, #12]
		float x_axis = ((float)chuck_d.js_x - 128.0) / 128.0;
 8021e0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		if (out_val < -0.001) {
 8021e12:	eeb4 0ac7 	vcmpe.f32	s0, s14
		float x_axis = ((float)chuck_d.js_x - 128.0) / 128.0;
 8021e16:	ee77 7aca 	vsub.f32	s15, s15, s20
		if (out_val < -0.001) {
 8021e1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float x_axis = ((float)chuck_d.js_x - 128.0) / 128.0;
 8021e1e:	ee27 8a88 	vmul.f32	s16, s15, s16
			if (x_axis < -0.4) {
 8021e22:	eddf 7a99 	vldr	s15, [pc, #612]	; 8022088 <output_thread+0x368>
 8021e26:	eeb4 8ae7 	vcmpe.f32	s16, s15
		if (out_val < -0.001) {
 8021e2a:	f140 80b6 	bpl.w	8021f9a <output_thread+0x27a>
			if (x_axis < -0.4) {
 8021e2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021e32:	f100 81d1 	bmi.w	80221d8 <output_thread+0x4b8>
			} else if (x_axis > 0.4) {
 8021e36:	eddf 7a95 	vldr	s15, [pc, #596]	; 802208c <output_thread+0x36c>
 8021e3a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8021e3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				led_external_set_state(LED_EXT_BRAKE_TURN_RIGHT);
 8021e42:	bfcc      	ite	gt
 8021e44:	2006      	movgt	r0, #6
				led_external_set_state(LED_EXT_BRAKE);
 8021e46:	2002      	movle	r0, #2
 8021e48:	f7f8 fe3a 	bl	801aac0 <led_external_set_state>
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021e4c:	f8db a000 	ldr.w	sl, [fp]
 8021e50:	f10a 0301 	add.w	r3, sl, #1
 8021e54:	f8cb 3000 	str.w	r3, [fp]
 8021e58:	f7f9 fb62 	bl	801b520 <mc_interface_get_rpm>
		if (filter_ptr >= RPM_FILTER_SAMPLES) {
 8021e5c:	f8db 3000 	ldr.w	r3, [fp]
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021e60:	4a7f      	ldr	r2, [pc, #508]	; (8022060 <output_thread+0x340>)
		if (filter_ptr >= RPM_FILTER_SAMPLES) {
 8021e62:	2b07      	cmp	r3, #7
			filter_ptr = 0;
 8021e64:	bfc8      	it	gt
 8021e66:	2300      	movgt	r3, #0
		filter_buffer[filter_ptr++] = mc_interface_get_rpm();
 8021e68:	eb02 0a8a 	add.w	sl, r2, sl, lsl #2
 8021e6c:	ed8a 0a00 	vstr	s0, [sl]
			filter_ptr = 0;
 8021e70:	bfc8      	it	gt
 8021e72:	f8cb 3000 	strgt.w	r3, [fp]
		float rpm_filtered = 0.0;
 8021e76:	ed9f 0a86 	vldr	s0, [pc, #536]	; 8022090 <output_thread+0x370>
 8021e7a:	4b79      	ldr	r3, [pc, #484]	; (8022060 <output_thread+0x340>)
			rpm_filtered += filter_buffer[i];
 8021e7c:	ecf3 7a01 	vldmia	r3!, {s15}
		for (int i = 0;i < RPM_FILTER_SAMPLES;i++) {
 8021e80:	42ab      	cmp	r3, r5
			rpm_filtered += filter_buffer[i];
 8021e82:	ee30 0a27 	vadd.f32	s0, s0, s15
		for (int i = 0;i < RPM_FILTER_SAMPLES;i++) {
 8021e86:	d1f9      	bne.n	8021e7c <output_thread+0x15c>
		if (chuck_d.bt_c) {
 8021e88:	7d33      	ldrb	r3, [r6, #20]
 8021e8a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8021e8e:	b39b      	cbz	r3, 8021ef8 <output_thread+0x1d8>
			if (!was_pid) {
 8021e90:	4b80      	ldr	r3, [pc, #512]	; (8022094 <output_thread+0x374>)
 8021e92:	781a      	ldrb	r2, [r3, #0]
 8021e94:	4b78      	ldr	r3, [pc, #480]	; (8022078 <output_thread+0x358>)
		rpm_filtered /= RPM_FILTER_SAMPLES;
 8021e96:	eef4 7a00 	vmov.f32	s15, #64	; 0x3e000000  0.125
 8021e9a:	781b      	ldrb	r3, [r3, #0]
 8021e9c:	ee20 0a27 	vmul.f32	s0, s0, s15
			if (!was_pid) {
 8021ea0:	2a00      	cmp	r2, #0
 8021ea2:	f040 813f 	bne.w	8022124 <output_thread+0x404>
				pid_rpm = rpm_filtered;
 8021ea6:	4a7c      	ldr	r2, [pc, #496]	; (8022098 <output_thread+0x378>)
				if ((is_reverse && pid_rpm > 0.0) || (!is_reverse && pid_rpm < 0.0)) {
 8021ea8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
				pid_rpm = rpm_filtered;
 8021eac:	ed82 0a00 	vstr	s0, [r2]
				if ((is_reverse && pid_rpm > 0.0) || (!is_reverse && pid_rpm < 0.0)) {
 8021eb0:	2b00      	cmp	r3, #0
 8021eb2:	f000 8199 	beq.w	80221e8 <output_thread+0x4c8>
 8021eb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021eba:	dd10      	ble.n	8021ede <output_thread+0x1be>
					if (fabsf(pid_rpm) > mcconf->s_pid_min_erpm) {
 8021ebc:	edd9 7a49 	vldr	s15, [r9, #292]	; 0x124
 8021ec0:	eeb0 0ac0 	vabs.f32	s0, s0
 8021ec4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8021ec8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021ecc:	f73f af43 	bgt.w	8021d56 <output_thread+0x36>
						pid_rpm = 0.0;
 8021ed0:	eddf 7a6f 	vldr	s15, [pc, #444]	; 8022090 <output_thread+0x370>
 8021ed4:	4b70      	ldr	r3, [pc, #448]	; (8022098 <output_thread+0x378>)
 8021ed6:	eeb0 0a67 	vmov.f32	s0, s15
 8021eda:	edc3 7a00 	vstr	s15, [r3]
				was_pid = true;
 8021ede:	4a6d      	ldr	r2, [pc, #436]	; (8022094 <output_thread+0x374>)
 8021ee0:	2301      	movs	r3, #1
 8021ee2:	7013      	strb	r3, [r2, #0]
			mc_interface_set_pid_speed(pid_rpm);
 8021ee4:	f7fa f984 	bl	801c1f0 <mc_interface_set_pid_speed>
			if (config.multi_esc) {
 8021ee8:	7f63      	ldrb	r3, [r4, #29]
 8021eea:	2b00      	cmp	r3, #0
 8021eec:	f040 814c 	bne.w	8022188 <output_thread+0x468>
			prev_current = current_now;
 8021ef0:	4b6a      	ldr	r3, [pc, #424]	; (802209c <output_thread+0x37c>)
 8021ef2:	edc3 8a00 	vstr	s17, [r3]
			continue;
 8021ef6:	e72e      	b.n	8021d56 <output_thread+0x36>
		if (out_val >= 0.0) {
 8021ef8:	eddd 7a03 	vldr	s15, [sp, #12]
		was_pid = false;
 8021efc:	4b65      	ldr	r3, [pc, #404]	; (8022094 <output_thread+0x374>)
		if (out_val >= 0.0) {
 8021efe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021f02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			current = out_val * fabsf(mcconf->lo_current_motor_min_now);
 8021f06:	bfb4      	ite	lt
 8021f08:	ed99 8a1e 	vldrlt	s16, [r9, #120]	; 0x78
			current = out_val * mcconf->lo_current_motor_max_now;
 8021f0c:	ed99 8a1d 	vldrge	s16, [r9, #116]	; 0x74
		was_pid = false;
 8021f10:	701a      	strb	r2, [r3, #0]
			current = out_val * fabsf(mcconf->lo_current_motor_min_now);
 8021f12:	bfb8      	it	lt
 8021f14:	eeb0 8ac8 	vabslt.f32	s16, s16
 8021f18:	ee28 8a27 	vmul.f32	s16, s16, s15
		float rpm_local = mc_interface_get_rpm();
 8021f1c:	f7f9 fb00 	bl	801b520 <mc_interface_get_rpm>
		if (is_reverse) {
 8021f20:	4b55      	ldr	r3, [pc, #340]	; (8022078 <output_thread+0x358>)
 8021f22:	781b      	ldrb	r3, [r3, #0]
		float rpm_local = mc_interface_get_rpm();
 8021f24:	eeb0 ca40 	vmov.f32	s24, s0
		if (is_reverse) {
 8021f28:	b10b      	cbz	r3, 8021f2e <output_thread+0x20e>
			rpm_local = -rpm_local;
 8021f2a:	eeb1 ca40 	vneg.f32	s24, s0
		if (config.multi_esc) {
 8021f2e:	7f63      	ldrb	r3, [r4, #29]
		float rpm_lowest = rpm_local;
 8021f30:	eef0 ba4c 	vmov.f32	s23, s24
		if (config.multi_esc) {
 8021f34:	2b00      	cmp	r3, #0
 8021f36:	d149      	bne.n	8021fcc <output_thread+0x2ac>
		const float ramp_time = fabsf(current) > fabsf(prev_current) ? config.ramp_time_pos : config.ramp_time_neg;
 8021f38:	4b58      	ldr	r3, [pc, #352]	; (802209c <output_thread+0x37c>)
		const float current_range = mcconf->l_current_max + fabsf(mcconf->l_current_min);
 8021f3a:	edd9 7a01 	vldr	s15, [r9, #4]
		const float ramp_time = fabsf(current) > fabsf(prev_current) ? config.ramp_time_pos : config.ramp_time_neg;
 8021f3e:	edd3 ca00 	vldr	s25, [r3]
		const float current_range = mcconf->l_current_max + fabsf(mcconf->l_current_min);
 8021f42:	ed99 7a02 	vldr	s14, [r9, #8]
		const float ramp_time = fabsf(current) > fabsf(prev_current) ? config.ramp_time_pos : config.ramp_time_neg;
 8021f46:	eef0 6aec 	vabs.f32	s13, s25
 8021f4a:	eeb0 6ac8 	vabs.f32	s12, s16
 8021f4e:	eeb4 6ae6 	vcmpe.f32	s12, s13
 8021f52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021f56:	bfcc      	ite	gt
 8021f58:	edd4 6a02 	vldrgt	s13, [r4, #8]
 8021f5c:	edd4 6a03 	vldrle	s13, [r4, #12]
		if (ramp_time > 0.01) {
 8021f60:	ed9f 6a4f 	vldr	s12, [pc, #316]	; 80220a0 <output_thread+0x380>
 8021f64:	eef4 6ac6 	vcmpe.f32	s13, s12
 8021f68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021f6c:	f300 80a0 	bgt.w	80220b0 <output_thread+0x390>
		prev_current = current;
 8021f70:	4b4a      	ldr	r3, [pc, #296]	; (802209c <output_thread+0x37c>)
		if (current < 0.0) {
 8021f72:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8021f76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		prev_current = current;
 8021f7a:	ed83 8a00 	vstr	s16, [r3]
		if (current < 0.0) {
 8021f7e:	f100 81ee 	bmi.w	802235e <output_thread+0x63e>
			if (config.multi_esc) {
 8021f82:	7f63      	ldrb	r3, [r4, #29]
 8021f84:	2b00      	cmp	r3, #0
 8021f86:	f040 8134 	bne.w	80221f2 <output_thread+0x4d2>
			if (is_reverse) {
 8021f8a:	4b3b      	ldr	r3, [pc, #236]	; (8022078 <output_thread+0x358>)
 8021f8c:	781b      	ldrb	r3, [r3, #0]
 8021f8e:	b1c3      	cbz	r3, 8021fc2 <output_thread+0x2a2>
				mc_interface_set_current(-current_out);
 8021f90:	eeb1 0a48 	vneg.f32	s0, s16
 8021f94:	f7fa f9a4 	bl	801c2e0 <mc_interface_set_current>
 8021f98:	e6dd      	b.n	8021d56 <output_thread+0x36>
			if (x_axis < -0.4) {
 8021f9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021f9e:	f100 811f 	bmi.w	80221e0 <output_thread+0x4c0>
			} else if (x_axis > 0.4) {
 8021fa2:	eddf 7a3a 	vldr	s15, [pc, #232]	; 802208c <output_thread+0x36c>
 8021fa6:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8021faa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				led_external_set_state(LED_EXT_TURN_RIGHT);
 8021fae:	bfcc      	ite	gt
 8021fb0:	2004      	movgt	r0, #4
				led_external_set_state(LED_EXT_NORMAL);
 8021fb2:	2001      	movle	r0, #1
 8021fb4:	f7f8 fd84 	bl	801aac0 <led_external_set_state>
 8021fb8:	e748      	b.n	8021e4c <output_thread+0x12c>
			led_external_set_state(LED_EXT_BATT);
 8021fba:	2007      	movs	r0, #7
 8021fbc:	f7f8 fd80 	bl	801aac0 <led_external_set_state>
			continue;
 8021fc0:	e6c9      	b.n	8021d56 <output_thread+0x36>
				mc_interface_set_current(current_out);
 8021fc2:	eeb0 0a48 	vmov.f32	s0, s16
 8021fc6:	f7fa f98b 	bl	801c2e0 <mc_interface_set_current>
 8021fca:	e6c4      	b.n	8021d56 <output_thread+0x36>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021fcc:	f04f 0a00 	mov.w	sl, #0
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 8021fd0:	4650      	mov	r0, sl
 8021fd2:	f7f8 fd65 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021fd6:	6803      	ldr	r3, [r0, #0]
 8021fd8:	2b00      	cmp	r3, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8021fda:	f10a 0a01 	add.w	sl, sl, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021fde:	db32      	blt.n	8022046 <output_thread+0x326>
  return ch.vtlist.vt_systime;
 8021fe0:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8021fe4:	6842      	ldr	r2, [r0, #4]
 8021fe6:	1a9b      	subs	r3, r3, r2
 8021fe8:	ee07 3a90 	vmov	s15, r3
 8021fec:	eef8 7a67 	vcvt.f32.u32	s15, s15
					if (fabsf(msg_current) > fabsf(current_highest_abs)) {
 8021ff0:	eef0 6ae8 	vabs.f32	s13, s17
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8021ff4:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8021ff8:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8021ffc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022000:	d521      	bpl.n	8022046 <output_thread+0x326>
					if (is_reverse) {
 8022002:	4b1d      	ldr	r3, [pc, #116]	; (8022078 <output_thread+0x358>)
					float rpm_tmp = msg->rpm;
 8022004:	edd0 7a02 	vldr	s15, [r0, #8]
					if (is_reverse) {
 8022008:	781b      	ldrb	r3, [r3, #0]
 802200a:	b10b      	cbz	r3, 8022010 <output_thread+0x2f0>
						rpm_tmp = -rpm_tmp;
 802200c:	eef1 7a67 	vneg.f32	s15, s15
					if (msg->duty < 0.0) {
 8022010:	ed90 6a04 	vldr	s12, [r0, #16]
					float msg_current = msg->current;
 8022014:	ed90 7a03 	vldr	s14, [r0, #12]
						rpm_lowest = rpm_tmp;
 8022018:	eef4 7a6b 	vcmp.f32	s15, s23
 802201c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					if (msg->duty < 0.0) {
 8022020:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
						rpm_lowest = rpm_tmp;
 8022024:	bf48      	it	mi
 8022026:	eef0 ba67 	vmovmi.f32	s23, s15
					if (msg->duty < 0.0) {
 802202a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
						msg_current = -msg_current;
 802202e:	bf48      	it	mi
 8022030:	eeb1 7a47 	vnegmi.f32	s14, s14
					if (fabsf(msg_current) > fabsf(current_highest_abs)) {
 8022034:	eef0 7ac7 	vabs.f32	s15, s14
						current_highest_abs = msg_current;
 8022038:	eef4 7a66 	vcmp.f32	s15, s13
 802203c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022040:	bfc8      	it	gt
 8022042:	eef0 8a47 	vmovgt.f32	s17, s14
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022046:	f1ba 0f0a 	cmp.w	sl, #10
 802204a:	d1c1      	bne.n	8021fd0 <output_thread+0x2b0>
 802204c:	e774      	b.n	8021f38 <output_thread+0x218>
 802204e:	bf00      	nop
 8022050:	0802f660 	.word	0x0802f660
 8022054:	2000ff44 	.word	0x2000ff44
 8022058:	200104e0 	.word	0x200104e0
 802205c:	2000ff2c 	.word	0x2000ff2c
 8022060:	20010504 	.word	0x20010504
 8022064:	3e4ccccd 	.word	0x3e4ccccd
 8022068:	43000000 	.word	0x43000000
 802206c:	461c4000 	.word	0x461c4000
 8022070:	3dcccccd 	.word	0x3dcccccd
 8022074:	20010534 	.word	0x20010534
 8022078:	20010528 	.word	0x20010528
 802207c:	20010ae1 	.word	0x20010ae1
 8022080:	3c000000 	.word	0x3c000000
 8022084:	ba83126f 	.word	0xba83126f
 8022088:	becccccd 	.word	0xbecccccd
 802208c:	3ecccccd 	.word	0x3ecccccd
 8022090:	00000000 	.word	0x00000000
 8022094:	20010ae0 	.word	0x20010ae0
 8022098:	20010ad8 	.word	0x20010ad8
 802209c:	20010adc 	.word	0x20010adc
 80220a0:	3c23d70a 	.word	0x3c23d70a
 80220a4:	20001a48 	.word	0x20001a48
 80220a8:	20010524 	.word	0x20010524
 80220ac:	447a0000 	.word	0x447a0000
			const float ramp_step = ((float)OUTPUT_ITERATION_TIME_MS * current_range) / (ramp_time * 1000.0);
 80220b0:	ed1f 6a02 	vldr	s12, [pc, #-8]	; 80220ac <output_thread+0x38c>
			float current_goal = prev_current;
 80220b4:	edcd ca04 	vstr	s25, [sp, #16]
		const float current_range = mcconf->l_current_max + fabsf(mcconf->l_current_min);
 80220b8:	eeb0 7ac7 	vabs.f32	s14, s14
 80220bc:	ee77 7a27 	vadd.f32	s15, s14, s15
			const float ramp_step = ((float)OUTPUT_ITERATION_TIME_MS * current_range) / (ramp_time * 1000.0);
 80220c0:	ee66 6a86 	vmul.f32	s13, s13, s12
			utils_step_towards(&current_goal, current, ramp_step);
 80220c4:	eeb0 0a48 	vmov.f32	s0, s16
			const float ramp_step = ((float)OUTPUT_ITERATION_TIME_MS * current_range) / (ramp_time * 1000.0);
 80220c8:	ee87 daa6 	vdiv.f32	s26, s15, s13
			utils_step_towards(&current_goal, current, ramp_step);
 80220cc:	a804      	add	r0, sp, #16
 80220ce:	eef0 0a4d 	vmov.f32	s1, s26
 80220d2:	f7f3 fc65 	bl	80159a0 <utils_step_towards>
			if (is_reverse) {
 80220d6:	4bc9      	ldr	r3, [pc, #804]	; (80223fc <output_thread+0x6dc>)
			bool is_decreasing = current_goal < goal_tmp;
 80220d8:	ed9d 8a04 	vldr	s16, [sp, #16]
			if (is_reverse) {
 80220dc:	781b      	ldrb	r3, [r3, #0]
			float goal_tmp2 = current_goal;
 80220de:	ed8d 8a05 	vstr	s16, [sp, #20]
			if (is_reverse) {
 80220e2:	2b00      	cmp	r3, #0
 80220e4:	f000 80f1 	beq.w	80222ca <output_thread+0x5aa>
				if (fabsf(current_goal + current_highest_abs) > max_current_diff) {
 80220e8:	ee78 7a28 	vadd.f32	s15, s16, s17
 80220ec:	eef0 7ae7 	vabs.f32	s15, s15
 80220f0:	eef4 7acb 	vcmpe.f32	s15, s22
 80220f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80220f8:	f300 8173 	bgt.w	80223e2 <output_thread+0x6c2>
			if ((!is_decreasing || is_decreasing2) && fabsf(out_val) > 0.001) {
 80220fc:	eef4 cac8 	vcmpe.f32	s25, s16
 8022100:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022104:	f73f af34 	bgt.w	8021f70 <output_thread+0x250>
 8022108:	eddd 7a03 	vldr	s15, [sp, #12]
 802210c:	ed9f 7abc 	vldr	s14, [pc, #752]	; 8022400 <output_thread+0x6e0>
 8022110:	eef0 7ae7 	vabs.f32	s15, s15
 8022114:	eef4 7ac7 	vcmpe.f32	s15, s14
 8022118:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802211c:	bfd8      	it	le
 802211e:	ed9d 8a04 	vldrle	s16, [sp, #16]
 8022122:	e725      	b.n	8021f70 <output_thread+0x250>
 8022124:	4ab7      	ldr	r2, [pc, #732]	; (8022404 <output_thread+0x6e4>)
 8022126:	edd2 7a00 	vldr	s15, [r2]
					if (pid_rpm > 0.0) {
 802212a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
				if (is_reverse) {
 802212e:	2b00      	cmp	r3, #0
 8022130:	f000 80f1 	beq.w	8022316 <output_thread+0x5f6>
					pid_rpm -= (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022134:	edd4 6a04 	vldr	s13, [r4, #16]
 8022138:	ed9d 7a03 	vldr	s14, [sp, #12]
 802213c:	eddf 5ab2 	vldr	s11, [pc, #712]	; 8022408 <output_thread+0x6e8>
					if (pid_rpm < (rpm_filtered - config.stick_erpm_per_s_in_cc)) {
 8022140:	ed94 6a04 	vldr	s12, [r4, #16]
					pid_rpm -= (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022144:	4baf      	ldr	r3, [pc, #700]	; (8022404 <output_thread+0x6e4>)
 8022146:	ee66 6a87 	vmul.f32	s13, s13, s14
					if (pid_rpm > 0.0) {
 802214a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					pid_rpm -= (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 802214e:	ee86 7aa5 	vdiv.f32	s14, s13, s11
 8022152:	bfc8      	it	gt
 8022154:	eddf 7aad 	vldrgt	s15, [pc, #692]	; 802240c <output_thread+0x6ec>
					if (pid_rpm < (rpm_filtered - config.stick_erpm_per_s_in_cc)) {
 8022158:	ee30 6a46 	vsub.f32	s12, s0, s12
					pid_rpm -= (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 802215c:	ee77 7ac7 	vsub.f32	s15, s15, s14
					if (pid_rpm < (rpm_filtered - config.stick_erpm_per_s_in_cc)) {
 8022160:	eef4 7ac6 	vcmpe.f32	s15, s12
 8022164:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					pid_rpm -= (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022168:	edc3 7a00 	vstr	s15, [r3]
					if (pid_rpm < (rpm_filtered - config.stick_erpm_per_s_in_cc)) {
 802216c:	f140 80d0 	bpl.w	8022310 <output_thread+0x5f0>
						pid_rpm = rpm_filtered - config.stick_erpm_per_s_in_cc;
 8022170:	edd4 7a04 	vldr	s15, [r4, #16]
 8022174:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022178:	ed83 0a00 	vstr	s0, [r3]
			mc_interface_set_pid_speed(pid_rpm);
 802217c:	f7fa f838 	bl	801c1f0 <mc_interface_set_pid_speed>
			if (config.multi_esc) {
 8022180:	7f63      	ldrb	r3, [r4, #29]
 8022182:	2b00      	cmp	r3, #0
 8022184:	f43f aeb4 	beq.w	8021ef0 <output_thread+0x1d0>
				float current = mc_interface_get_tot_current_directional_filtered();
 8022188:	f7f9 fa7a 	bl	801b680 <mc_interface_get_tot_current_directional_filtered>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802218c:	f04f 0900 	mov.w	r9, #0
				float current = mc_interface_get_tot_current_directional_filtered();
 8022190:	eeb0 8a40 	vmov.f32	s16, s0
 8022194:	e003      	b.n	802219e <output_thread+0x47e>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022196:	f1b9 0f0a 	cmp.w	r9, #10
 802219a:	f43f aea9 	beq.w	8021ef0 <output_thread+0x1d0>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 802219e:	4648      	mov	r0, r9
 80221a0:	f7f8 fc7e 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 80221a4:	6802      	ldr	r2, [r0, #0]
 80221a6:	2a00      	cmp	r2, #0
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 80221a8:	f109 0901 	add.w	r9, r9, #1
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 80221ac:	dbf3      	blt.n	8022196 <output_thread+0x476>
 80221ae:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 80221b0:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 80221b4:	1a5b      	subs	r3, r3, r1
 80221b6:	ee07 3a90 	vmov	s15, r3
 80221ba:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80221be:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 80221c2:	eeb4 7ac9 	vcmpe.f32	s14, s18
 80221c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80221ca:	d5e4      	bpl.n	8022196 <output_thread+0x476>
						comm_can_set_current(msg->id, current);
 80221cc:	b2d0      	uxtb	r0, r2
 80221ce:	eeb0 0a48 	vmov.f32	s0, s16
 80221d2:	f7f8 fc25 	bl	801aa20 <comm_can_set_current>
 80221d6:	e7de      	b.n	8022196 <output_thread+0x476>
				led_external_set_state(LED_EXT_BRAKE_TURN_LEFT);
 80221d8:	2005      	movs	r0, #5
 80221da:	f7f8 fc71 	bl	801aac0 <led_external_set_state>
 80221de:	e635      	b.n	8021e4c <output_thread+0x12c>
				led_external_set_state(LED_EXT_TURN_LEFT);
 80221e0:	2003      	movs	r0, #3
 80221e2:	f7f8 fc6d 	bl	801aac0 <led_external_set_state>
 80221e6:	e631      	b.n	8021e4c <output_thread+0x12c>
				if ((is_reverse && pid_rpm > 0.0) || (!is_reverse && pid_rpm < 0.0)) {
 80221e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80221ec:	f53f ae66 	bmi.w	8021ebc <output_thread+0x19c>
 80221f0:	e675      	b.n	8021ede <output_thread+0x1be>
			float current_out = current;
 80221f2:	eef0 8a48 	vmov.f32	s17, s16
							current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80221f6:	ed9f ba85 	vldr	s22, [pc, #532]	; 802240c <output_thread+0x6ec>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 80221fa:	f04f 0a00 	mov.w	sl, #0
 80221fe:	e008      	b.n	8022212 <output_thread+0x4f2>
							comm_can_set_current(msg->id, -current_out);
 8022200:	eeb1 0a68 	vneg.f32	s0, s17
 8022204:	f7f8 fc0c 	bl	801aa20 <comm_can_set_current>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022208:	f10a 0a01 	add.w	sl, sl, #1
 802220c:	f1ba 0f0a 	cmp.w	sl, #10
 8022210:	d045      	beq.n	802229e <output_thread+0x57e>
					can_status_msg *msg = comm_can_get_status_msg_index(i);
 8022212:	4650      	mov	r0, sl
 8022214:	f7f8 fc44 	bl	801aaa0 <comm_can_get_status_msg_index>
					if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8022218:	6803      	ldr	r3, [r0, #0]
 802221a:	2b00      	cmp	r3, #0
 802221c:	dbf4      	blt.n	8022208 <output_thread+0x4e8>
  return ch.vtlist.vt_systime;
 802221e:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 8022222:	6842      	ldr	r2, [r0, #4]
 8022224:	1a8a      	subs	r2, r1, r2
 8022226:	ee07 2a90 	vmov	s15, r2
 802222a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802222e:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8022232:	eeb4 7ac9 	vcmpe.f32	s14, s18
 8022236:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802223a:	d5e5      	bpl.n	8022208 <output_thread+0x4e8>
 802223c:	4a6f      	ldr	r2, [pc, #444]	; (80223fc <output_thread+0x6dc>)
						if (config.tc) {
 802223e:	7fa1      	ldrb	r1, [r4, #30]
 8022240:	7812      	ldrb	r2, [r2, #0]
 8022242:	b301      	cbz	r1, 8022286 <output_thread+0x566>
							float rpm_tmp = msg->rpm;
 8022244:	ed90 0a02 	vldr	s0, [r0, #8]
							if (is_reverse) {
 8022248:	b10a      	cbz	r2, 802224e <output_thread+0x52e>
								rpm_tmp = -rpm_tmp;
 802224a:	eeb1 0a40 	vneg.f32	s0, s0
							current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 802224e:	ed94 1a08 	vldr	s2, [r4, #32]
 8022252:	eddf 0a6e 	vldr	s1, [pc, #440]	; 802240c <output_thread+0x6ec>
 8022256:	9001      	str	r0, [sp, #4]
 8022258:	ee30 0a6b 	vsub.f32	s0, s0, s23
 802225c:	eeb0 2a4b 	vmov.f32	s4, s22
 8022260:	eef0 1a48 	vmov.f32	s3, s16
 8022264:	f7f3 fc4c 	bl	8015b00 <utils_map>
							if (current_out < mcconf->cc_min_current) {
 8022268:	edd9 7a50 	vldr	s15, [r9, #320]	; 0x140
 802226c:	9801      	ldr	r0, [sp, #4]
 802226e:	4a63      	ldr	r2, [pc, #396]	; (80223fc <output_thread+0x6dc>)
 8022270:	6803      	ldr	r3, [r0, #0]
 8022272:	7812      	ldrb	r2, [r2, #0]
 8022274:	eef4 7ac0 	vcmpe.f32	s15, s0
 8022278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
							current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 802227c:	eef0 8a40 	vmov.f32	s17, s0
								current_out = 0.0;
 8022280:	bfc8      	it	gt
 8022282:	eef0 8a4b 	vmovgt.f32	s17, s22
 8022286:	b2d8      	uxtb	r0, r3
						if (is_reverse) {
 8022288:	2a00      	cmp	r2, #0
 802228a:	d1b9      	bne.n	8022200 <output_thread+0x4e0>
							comm_can_set_current(msg->id, current_out);
 802228c:	eeb0 0a68 	vmov.f32	s0, s17
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022290:	f10a 0a01 	add.w	sl, sl, #1
							comm_can_set_current(msg->id, current_out);
 8022294:	f7f8 fbc4 	bl	801aa20 <comm_can_set_current>
				for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022298:	f1ba 0f0a 	cmp.w	sl, #10
 802229c:	d1b9      	bne.n	8022212 <output_thread+0x4f2>
				if (config.tc) {
 802229e:	7fa3      	ldrb	r3, [r4, #30]
 80222a0:	2b00      	cmp	r3, #0
 80222a2:	f040 8084 	bne.w	80223ae <output_thread+0x68e>
 80222a6:	eeb0 8a68 	vmov.f32	s16, s17
 80222aa:	e66e      	b.n	8021f8a <output_thread+0x26a>
				fabsf(current_now) < max_current_diff) {
 80222ac:	eef0 7ae8 	vabs.f32	s15, s17
		if (chuck_d.bt_z && !was_z && config.ctrl_type == CHUK_CTRL_TYPE_CURRENT &&
 80222b0:	eef4 7acb 	vcmpe.f32	s15, s22
 80222b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80222b8:	f57f ad82 	bpl.w	8021dc0 <output_thread+0xa0>
			if (is_reverse) {
 80222bc:	2800      	cmp	r0, #0
 80222be:	f000 8098 	beq.w	80223f2 <output_thread+0x6d2>
				is_reverse = false;
 80222c2:	4a4e      	ldr	r2, [pc, #312]	; (80223fc <output_thread+0x6dc>)
 80222c4:	4618      	mov	r0, r3
 80222c6:	7013      	strb	r3, [r2, #0]
 80222c8:	e57a      	b.n	8021dc0 <output_thread+0xa0>
				if (fabsf(current_goal - current_highest_abs) > max_current_diff) {
 80222ca:	ee78 7a68 	vsub.f32	s15, s16, s17
 80222ce:	eef0 7ae7 	vabs.f32	s15, s15
 80222d2:	eef4 7acb 	vcmpe.f32	s15, s22
 80222d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80222da:	f77f af0f 	ble.w	80220fc <output_thread+0x3dc>
					utils_step_towards(&goal_tmp2, current_highest_abs, 2.0 * ramp_step);
 80222de:	ee7d 0a0d 	vadd.f32	s1, s26, s26
 80222e2:	eeb0 0a68 	vmov.f32	s0, s17
 80222e6:	a805      	add	r0, sp, #20
 80222e8:	f7f3 fb5a 	bl	80159a0 <utils_step_towards>
			if ((!is_decreasing || is_decreasing2) && fabsf(out_val) > 0.001) {
 80222ec:	eef4 cac8 	vcmpe.f32	s25, s16
 80222f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			bool is_decreasing2 = goal_tmp2 < current_goal;
 80222f4:	eddd 7a05 	vldr	s15, [sp, #20]
			if ((!is_decreasing || is_decreasing2) && fabsf(out_val) > 0.001) {
 80222f8:	dd07      	ble.n	802230a <output_thread+0x5ea>
			bool is_decreasing2 = goal_tmp2 < current_goal;
 80222fa:	ed9d 8a04 	vldr	s16, [sp, #16]
			if ((!is_decreasing || is_decreasing2) && fabsf(out_val) > 0.001) {
 80222fe:	eef4 7ac8 	vcmpe.f32	s15, s16
 8022302:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022306:	f57f ae33 	bpl.w	8021f70 <output_thread+0x250>
			bool is_decreasing2 = goal_tmp2 < current_goal;
 802230a:	eeb0 8a67 	vmov.f32	s16, s15
 802230e:	e6fb      	b.n	8022108 <output_thread+0x3e8>
 8022310:	eeb0 0a67 	vmov.f32	s0, s15
 8022314:	e5e6      	b.n	8021ee4 <output_thread+0x1c4>
					pid_rpm += (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022316:	edd4 6a04 	vldr	s13, [r4, #16]
 802231a:	ed9d 7a03 	vldr	s14, [sp, #12]
 802231e:	eddf 5a3a 	vldr	s11, [pc, #232]	; 8022408 <output_thread+0x6e8>
					if (pid_rpm > (rpm_filtered + config.stick_erpm_per_s_in_cc)) {
 8022322:	ed94 6a04 	vldr	s12, [r4, #16]
					pid_rpm += (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022326:	4b37      	ldr	r3, [pc, #220]	; (8022404 <output_thread+0x6e4>)
 8022328:	ee66 6a87 	vmul.f32	s13, s13, s14
					if (pid_rpm < 0.0) {
 802232c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					pid_rpm += (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 8022330:	ee86 7aa5 	vdiv.f32	s14, s13, s11
 8022334:	bf48      	it	mi
 8022336:	eddf 7a35 	vldrmi	s15, [pc, #212]	; 802240c <output_thread+0x6ec>
					if (pid_rpm > (rpm_filtered + config.stick_erpm_per_s_in_cc)) {
 802233a:	ee36 6a00 	vadd.f32	s12, s12, s0
					pid_rpm += (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 802233e:	ee77 7a27 	vadd.f32	s15, s14, s15
					if (pid_rpm > (rpm_filtered + config.stick_erpm_per_s_in_cc)) {
 8022342:	eef4 7ac6 	vcmpe.f32	s15, s12
 8022346:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					pid_rpm += (out_val * config.stick_erpm_per_s_in_cc) / ((float)OUTPUT_ITERATION_TIME_MS * 1000.0);
 802234a:	edc3 7a00 	vstr	s15, [r3]
					if (pid_rpm > (rpm_filtered + config.stick_erpm_per_s_in_cc)) {
 802234e:	dddf      	ble.n	8022310 <output_thread+0x5f0>
						pid_rpm = rpm_filtered + config.stick_erpm_per_s_in_cc;
 8022350:	edd4 7a04 	vldr	s15, [r4, #16]
 8022354:	ee30 0a27 	vadd.f32	s0, s0, s15
 8022358:	ed83 0a00 	vstr	s0, [r3]
 802235c:	e5c2      	b.n	8021ee4 <output_thread+0x1c4>
			mc_interface_set_brake_current(current);
 802235e:	eeb0 0a48 	vmov.f32	s0, s16
 8022362:	f7fa f80d 	bl	801c380 <mc_interface_set_brake_current>
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 8022366:	f04f 0900 	mov.w	r9, #0
 802236a:	e003      	b.n	8022374 <output_thread+0x654>
 802236c:	f1b9 0f0a 	cmp.w	r9, #10
 8022370:	f43f acf1 	beq.w	8021d56 <output_thread+0x36>
				can_status_msg *msg = comm_can_get_status_msg_index(i);
 8022374:	4648      	mov	r0, r9
 8022376:	f7f8 fb93 	bl	801aaa0 <comm_can_get_status_msg_index>
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 802237a:	6802      	ldr	r2, [r0, #0]
 802237c:	2a00      	cmp	r2, #0
			for (int i = 0;i < CAN_STATUS_MSGS_TO_STORE;i++) {
 802237e:	f109 0901 	add.w	r9, r9, #1
				if (msg->id >= 0 && UTILS_AGE_S(msg->rx_time) < MAX_CAN_AGE) {
 8022382:	dbf3      	blt.n	802236c <output_thread+0x64c>
 8022384:	6841      	ldr	r1, [r0, #4]
  return ch.vtlist.vt_systime;
 8022386:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  return chVTGetSystemTimeX() - start;
 802238a:	1a5b      	subs	r3, r3, r1
 802238c:	ee07 3a90 	vmov	s15, r3
 8022390:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8022394:	ee87 7aa9 	vdiv.f32	s14, s15, s19
 8022398:	eeb4 7ac9 	vcmpe.f32	s14, s18
 802239c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80223a0:	d5e4      	bpl.n	802236c <output_thread+0x64c>
					comm_can_set_current_brake(msg->id, current);
 80223a2:	b2d0      	uxtb	r0, r2
 80223a4:	eeb0 0a48 	vmov.f32	s0, s16
 80223a8:	f7f8 fb5a 	bl	801aa60 <comm_can_set_current_brake>
 80223ac:	e7de      	b.n	802236c <output_thread+0x64c>
					current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80223ae:	ed9f 2a17 	vldr	s4, [pc, #92]	; 802240c <output_thread+0x6ec>
 80223b2:	ed94 1a08 	vldr	s2, [r4, #32]
 80223b6:	eef0 1a48 	vmov.f32	s3, s16
 80223ba:	ee3c 0a6b 	vsub.f32	s0, s24, s23
 80223be:	eef0 0a42 	vmov.f32	s1, s4
 80223c2:	f7f3 fb9d 	bl	8015b00 <utils_map>
					if (current_out < mcconf->cc_min_current) {
 80223c6:	ed99 7a50 	vldr	s14, [r9, #320]	; 0x140
						current_out = 0.0;
 80223ca:	eddf 7a10 	vldr	s15, [pc, #64]	; 802240c <output_thread+0x6ec>
 80223ce:	eeb4 7a40 	vcmp.f32	s14, s0
					current_out = utils_map(diff, 0.0, config.tc_max_diff, current, 0.0);
 80223d2:	eeb0 8a40 	vmov.f32	s16, s0
						current_out = 0.0;
 80223d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80223da:	bfc8      	it	gt
 80223dc:	eeb0 8a67 	vmovgt.f32	s16, s15
 80223e0:	e5d3      	b.n	8021f8a <output_thread+0x26a>
					utils_step_towards(&goal_tmp2, -current_highest_abs, 2.0 * ramp_step);
 80223e2:	ee7d 0a0d 	vadd.f32	s1, s26, s26
 80223e6:	eeb1 0a68 	vneg.f32	s0, s17
 80223ea:	a805      	add	r0, sp, #20
 80223ec:	f7f3 fad8 	bl	80159a0 <utils_step_towards>
 80223f0:	e77c      	b.n	80222ec <output_thread+0x5cc>
				is_reverse = true;
 80223f2:	4b02      	ldr	r3, [pc, #8]	; (80223fc <output_thread+0x6dc>)
 80223f4:	4610      	mov	r0, r2
 80223f6:	7019      	strb	r1, [r3, #0]
 80223f8:	e4e2      	b.n	8021dc0 <output_thread+0xa0>
 80223fa:	bf00      	nop
 80223fc:	20010528 	.word	0x20010528
 8022400:	3a83126f 	.word	0x3a83126f
 8022404:	20010ad8 	.word	0x20010ad8
 8022408:	447a0000 	.word	0x447a0000
 802240c:	00000000 	.word	0x00000000

08022410 <app_nunchuk_configure>:
void app_nunchuk_configure(chuk_config *conf) {
 8022410:	b430      	push	{r4, r5}
	config = *conf;
 8022412:	4605      	mov	r5, r0
 8022414:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022416:	4c06      	ldr	r4, [pc, #24]	; (8022430 <app_nunchuk_configure+0x20>)
 8022418:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802241a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802241c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802241e:	682a      	ldr	r2, [r5, #0]
 8022420:	6022      	str	r2, [r4, #0]
	terminal_register_command_callback(
 8022422:	4b04      	ldr	r3, [pc, #16]	; (8022434 <app_nunchuk_configure+0x24>)
 8022424:	4904      	ldr	r1, [pc, #16]	; (8022438 <app_nunchuk_configure+0x28>)
 8022426:	4805      	ldr	r0, [pc, #20]	; (802243c <app_nunchuk_configure+0x2c>)
 8022428:	2200      	movs	r2, #0
}
 802242a:	bc30      	pop	{r4, r5}
	terminal_register_command_callback(
 802242c:	f7f5 b840 	b.w	80174b0 <terminal_register_command_callback>
 8022430:	200104e0 	.word	0x200104e0
 8022434:	08021ce1 	.word	0x08021ce1
 8022438:	0802f610 	.word	0x0802f610
 802243c:	0802f634 	.word	0x0802f634

08022440 <app_nunchuk_start>:
void app_nunchuk_start(void) {
 8022440:	b510      	push	{r4, lr}
	chuck_d.js_y = 128;
 8022442:	4a09      	ldr	r2, [pc, #36]	; (8022468 <app_nunchuk_start+0x28>)
	stop_now = false;
 8022444:	4b09      	ldr	r3, [pc, #36]	; (802246c <app_nunchuk_start+0x2c>)
void app_nunchuk_start(void) {
 8022446:	b082      	sub	sp, #8
	chuck_d.js_y = 128;
 8022448:	2180      	movs	r1, #128	; 0x80
	stop_now = false;
 802244a:	2400      	movs	r4, #0
	chuck_d.js_y = 128;
 802244c:	6051      	str	r1, [r2, #4]
	stop_now = false;
 802244e:	701c      	strb	r4, [r3, #0]
	hw_start_i2c();
 8022450:	f7fd fff6 	bl	8020440 <hw_start_i2c>
	chThdCreateStatic(chuk_thread_wa, sizeof(chuk_thread_wa), NORMALPRIO, chuk_thread, NULL);
 8022454:	9400      	str	r4, [sp, #0]
 8022456:	4b06      	ldr	r3, [pc, #24]	; (8022470 <app_nunchuk_start+0x30>)
 8022458:	4806      	ldr	r0, [pc, #24]	; (8022474 <app_nunchuk_start+0x34>)
 802245a:	2240      	movs	r2, #64	; 0x40
 802245c:	f44f 61b3 	mov.w	r1, #1432	; 0x598
 8022460:	f7eb fa86 	bl	800d970 <chThdCreateStatic>
}
 8022464:	b002      	add	sp, #8
 8022466:	bd10      	pop	{r4, pc}
 8022468:	2000ff2c 	.word	0x2000ff2c
 802246c:	20001070 	.word	0x20001070
 8022470:	08022561 	.word	0x08022561
 8022474:	2000ff48 	.word	0x2000ff48
	...

08022480 <app_nunchuk_stop>:
	stop_now = true;
 8022480:	4b08      	ldr	r3, [pc, #32]	; (80224a4 <app_nunchuk_stop+0x24>)
void app_nunchuk_stop(void) {
 8022482:	b510      	push	{r4, lr}
	stop_now = true;
 8022484:	2201      	movs	r2, #1
	if (is_running) {
 8022486:	4c08      	ldr	r4, [pc, #32]	; (80224a8 <app_nunchuk_stop+0x28>)
	stop_now = true;
 8022488:	701a      	strb	r2, [r3, #0]
	if (is_running) {
 802248a:	7823      	ldrb	r3, [r4, #0]
 802248c:	b11b      	cbz	r3, 8022496 <app_nunchuk_stop+0x16>
 802248e:	e006      	b.n	802249e <app_nunchuk_stop+0x1e>
		chThdSleepMilliseconds(1);
 8022490:	200a      	movs	r0, #10
 8022492:	f7eb faa5 	bl	800d9e0 <chThdSleep>
	while (is_running) {
 8022496:	7823      	ldrb	r3, [r4, #0]
 8022498:	2b00      	cmp	r3, #0
 802249a:	d1f9      	bne.n	8022490 <app_nunchuk_stop+0x10>
}
 802249c:	bd10      	pop	{r4, pc}
		hw_stop_i2c();
 802249e:	f7fd fff7 	bl	8020490 <hw_stop_i2c>
 80224a2:	e7f8      	b.n	8022496 <app_nunchuk_stop+0x16>
 80224a4:	20001070 	.word	0x20001070
 80224a8:	20010529 	.word	0x20010529
 80224ac:	00000000 	.word	0x00000000

080224b0 <app_nunchuk_get_decoded_chuk>:
	return ((float)chuck_d.js_y - 128.0) / 128.0;
 80224b0:	4b06      	ldr	r3, [pc, #24]	; (80224cc <app_nunchuk_get_decoded_chuk+0x1c>)
 80224b2:	ed9f 7a07 	vldr	s14, [pc, #28]	; 80224d0 <app_nunchuk_get_decoded_chuk+0x20>
 80224b6:	edd3 7a01 	vldr	s15, [r3, #4]
 80224ba:	ed9f 0a06 	vldr	s0, [pc, #24]	; 80224d4 <app_nunchuk_get_decoded_chuk+0x24>
 80224be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80224c2:	ee77 7ac7 	vsub.f32	s15, s15, s14
}
 80224c6:	ee27 0a80 	vmul.f32	s0, s15, s0
 80224ca:	4770      	bx	lr
 80224cc:	2000ff2c 	.word	0x2000ff2c
 80224d0:	43000000 	.word	0x43000000
 80224d4:	3c000000 	.word	0x3c000000
	...

080224e0 <app_nunchuk_update_output>:
void app_nunchuk_update_output(chuck_data *data) {
 80224e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!output_running) {
 80224e2:	4a16      	ldr	r2, [pc, #88]	; (802253c <app_nunchuk_update_output+0x5c>)
 80224e4:	7813      	ldrb	r3, [r2, #0]
void app_nunchuk_update_output(chuck_data *data) {
 80224e6:	b083      	sub	sp, #12
 80224e8:	4604      	mov	r4, r0
	if (!output_running) {
 80224ea:	b1ab      	cbz	r3, 8022518 <app_nunchuk_update_output+0x38>
 80224ec:	4e14      	ldr	r6, [pc, #80]	; (8022540 <app_nunchuk_update_output+0x60>)
	chuck_d = *data;
 80224ee:	4d15      	ldr	r5, [pc, #84]	; (8022544 <app_nunchuk_update_output+0x64>)
 80224f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80224f2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80224f4:	e894 0003 	ldmia.w	r4, {r0, r1}
 80224f8:	2320      	movs	r3, #32
 80224fa:	e885 0003 	stmia.w	r5, {r0, r1}
 80224fe:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.vt_systime;
 8022502:	4b11      	ldr	r3, [pc, #68]	; (8022548 <app_nunchuk_update_output+0x68>)
 8022504:	2200      	movs	r2, #0
 8022506:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022508:	f382 8811 	msr	BASEPRI, r2
	last_update_time = chVTGetSystemTime();
 802250c:	6033      	str	r3, [r6, #0]
}
 802250e:	b003      	add	sp, #12
 8022510:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	timeout_reset();
 8022514:	f7f7 be24 	b.w	801a160 <timeout_reset>
		last_update_time = 0;
 8022518:	4e09      	ldr	r6, [pc, #36]	; (8022540 <app_nunchuk_update_output+0x60>)
		chuck_d.js_y = 128;
 802251a:	480a      	ldr	r0, [pc, #40]	; (8022544 <app_nunchuk_update_output+0x64>)
 802251c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
		output_running = true;
 8022520:	2701      	movs	r7, #1
		chuck_d.js_y = 128;
 8022522:	2580      	movs	r5, #128	; 0x80
		chThdCreateStatic(output_thread_wa, sizeof(output_thread_wa), NORMALPRIO, output_thread, NULL);
 8022524:	9100      	str	r1, [sp, #0]
		last_update_time = 0;
 8022526:	6031      	str	r1, [r6, #0]
		chThdCreateStatic(output_thread_wa, sizeof(output_thread_wa), NORMALPRIO, output_thread, NULL);
 8022528:	4b08      	ldr	r3, [pc, #32]	; (802254c <app_nunchuk_update_output+0x6c>)
		output_running = true;
 802252a:	7017      	strb	r7, [r2, #0]
		chThdCreateStatic(output_thread_wa, sizeof(output_thread_wa), NORMALPRIO, output_thread, NULL);
 802252c:	f44f 61b3 	mov.w	r1, #1432	; 0x598
		chuck_d.js_y = 128;
 8022530:	6045      	str	r5, [r0, #4]
		chThdCreateStatic(output_thread_wa, sizeof(output_thread_wa), NORMALPRIO, output_thread, NULL);
 8022532:	2240      	movs	r2, #64	; 0x40
 8022534:	4806      	ldr	r0, [pc, #24]	; (8022550 <app_nunchuk_update_output+0x70>)
 8022536:	f7eb fa1b 	bl	800d970 <chThdCreateStatic>
 802253a:	e7d8      	b.n	80224ee <app_nunchuk_update_output+0xe>
 802253c:	20010538 	.word	0x20010538
 8022540:	20010534 	.word	0x20010534
 8022544:	2000ff2c 	.word	0x2000ff2c
 8022548:	20001a48 	.word	0x20001a48
 802254c:	08021d21 	.word	0x08021d21
 8022550:	20010540 	.word	0x20010540
	...

08022560 <chuk_thread>:
static THD_FUNCTION(chuk_thread, arg) {
 8022560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022564:	4b6e      	ldr	r3, [pc, #440]	; (8022720 <chuk_thread+0x1c0>)
 8022566:	4a6f      	ldr	r2, [pc, #444]	; (8022724 <chuk_thread+0x1c4>)
 8022568:	699b      	ldr	r3, [r3, #24]
		if (stop_now) {
 802256a:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 8022738 <chuk_thread+0x1d8>
 802256e:	619a      	str	r2, [r3, #24]
	is_running = true;
 8022570:	4a6d      	ldr	r2, [pc, #436]	; (8022728 <chuk_thread+0x1c8>)
 8022572:	2301      	movs	r3, #1
static THD_FUNCTION(chuk_thread, arg) {
 8022574:	b091      	sub	sp, #68	; 0x44
	is_running = true;
 8022576:	7013      	strb	r3, [r2, #0]
	hw_start_i2c();
 8022578:	f7fd ff62 	bl	8020440 <hw_start_i2c>
	chThdSleepMilliseconds(10);
 802257c:	2064      	movs	r0, #100	; 0x64
 802257e:	f7eb fa2f 	bl	800d9e0 <chThdSleep>
		if (stop_now) {
 8022582:	f89a 3000 	ldrb.w	r3, [sl]
 8022586:	2b00      	cmp	r3, #0
 8022588:	f040 80c6 	bne.w	8022718 <chuk_thread+0x1b8>
 802258c:	f8df b1a0 	ldr.w	fp, [pc, #416]	; 8022730 <chuk_thread+0x1d0>
 8022590:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 802273c <chuk_thread+0x1dc>
		i2cAcquireBus(&HW_I2C_DEV);
 8022594:	4c65      	ldr	r4, [pc, #404]	; (802272c <chuk_thread+0x1cc>)
 8022596:	f10b 0606 	add.w	r6, fp, #6
 802259a:	ad04      	add	r5, sp, #16
 802259c:	e00f      	b.n	80225be <chuk_thread+0x5e>
			chuck_error = 2;
 802259e:	2302      	movs	r3, #2
 80225a0:	f8c9 3000 	str.w	r3, [r9]
			hw_try_restore_i2c();
 80225a4:	f7fd ff9c 	bl	80204e0 <hw_try_restore_i2c>
			chThdSleepMilliseconds(100);
 80225a8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80225ac:	f7eb fa18 	bl	800d9e0 <chThdSleep>
		chThdSleepMilliseconds(10);
 80225b0:	2064      	movs	r0, #100	; 0x64
 80225b2:	f7eb fa15 	bl	800d9e0 <chThdSleep>
		if (stop_now) {
 80225b6:	f89a 3000 	ldrb.w	r3, [sl]
 80225ba:	2b00      	cmp	r3, #0
 80225bc:	d177      	bne.n	80226ae <chuk_thread+0x14e>
		txbuf[0] = 0xF0;
 80225be:	f245 53f0 	movw	r3, #22000	; 0x55f0
		i2cAcquireBus(&HW_I2C_DEV);
 80225c2:	4620      	mov	r0, r4
		txbuf[0] = 0xF0;
 80225c4:	f8ad 301c 	strh.w	r3, [sp, #28]
		status = i2cMasterTransmitTimeout(&HW_I2C_DEV, chuck_addr, txbuf, 2, rxbuf, 0, tmo);
 80225c8:	2732      	movs	r7, #50	; 0x32
		i2cAcquireBus(&HW_I2C_DEV);
 80225ca:	f7ec f829 	bl	800e620 <i2cAcquireBus>
		status = i2cMasterTransmitTimeout(&HW_I2C_DEV, chuck_addr, txbuf, 2, rxbuf, 0, tmo);
 80225ce:	2300      	movs	r3, #0
 80225d0:	e9cd 3701 	strd	r3, r7, [sp, #4]
 80225d4:	9500      	str	r5, [sp, #0]
 80225d6:	2302      	movs	r3, #2
 80225d8:	aa07      	add	r2, sp, #28
 80225da:	2152      	movs	r1, #82	; 0x52
 80225dc:	4620      	mov	r0, r4
 80225de:	f7eb ffe7 	bl	800e5b0 <i2cMasterTransmitTimeout>
 80225e2:	4680      	mov	r8, r0
		i2cReleaseBus(&HW_I2C_DEV);
 80225e4:	4620      	mov	r0, r4
 80225e6:	f7ec f823 	bl	800e630 <i2cReleaseBus>
		if (is_ok) {
 80225ea:	f1b8 0f00 	cmp.w	r8, #0
 80225ee:	d1d6      	bne.n	802259e <chuk_thread+0x3e>
			txbuf[0] = 0xFB;
 80225f0:	23fb      	movs	r3, #251	; 0xfb
			i2cAcquireBus(&HW_I2C_DEV);
 80225f2:	4620      	mov	r0, r4
			txbuf[0] = 0xFB;
 80225f4:	f8ad 301c 	strh.w	r3, [sp, #28]
			i2cAcquireBus(&HW_I2C_DEV);
 80225f8:	f7ec f812 	bl	800e620 <i2cAcquireBus>
			status = i2cMasterTransmitTimeout(&HW_I2C_DEV, chuck_addr, txbuf, 2, rxbuf, 0, tmo);
 80225fc:	e9cd 8701 	strd	r8, r7, [sp, #4]
 8022600:	9500      	str	r5, [sp, #0]
 8022602:	2302      	movs	r3, #2
 8022604:	aa07      	add	r2, sp, #28
 8022606:	2152      	movs	r1, #82	; 0x52
 8022608:	4620      	mov	r0, r4
 802260a:	f7eb ffd1 	bl	800e5b0 <i2cMasterTransmitTimeout>
 802260e:	4680      	mov	r8, r0
			i2cReleaseBus(&HW_I2C_DEV);
 8022610:	4620      	mov	r0, r4
 8022612:	f7ec f80d 	bl	800e630 <i2cReleaseBus>
		if (is_ok) {
 8022616:	f1b8 0f00 	cmp.w	r8, #0
 802261a:	d1c0      	bne.n	802259e <chuk_thread+0x3e>
			i2cAcquireBus(&HW_I2C_DEV);
 802261c:	4620      	mov	r0, r4
			txbuf[0] = 0x00;
 802261e:	f88d 801c 	strb.w	r8, [sp, #28]
			i2cAcquireBus(&HW_I2C_DEV);
 8022622:	f7eb fffd 	bl	800e620 <i2cAcquireBus>
			status = i2cMasterTransmitTimeout(&HW_I2C_DEV, chuck_addr, txbuf, 1, rxbuf, 0, tmo);
 8022626:	e9cd 8701 	strd	r8, r7, [sp, #4]
 802262a:	9500      	str	r5, [sp, #0]
 802262c:	2301      	movs	r3, #1
 802262e:	aa07      	add	r2, sp, #28
 8022630:	2152      	movs	r1, #82	; 0x52
 8022632:	4620      	mov	r0, r4
 8022634:	f7eb ffbc 	bl	800e5b0 <i2cMasterTransmitTimeout>
 8022638:	4680      	mov	r8, r0
			i2cReleaseBus(&HW_I2C_DEV);
 802263a:	4620      	mov	r0, r4
 802263c:	f7eb fff8 	bl	800e630 <i2cReleaseBus>
		if (is_ok) {
 8022640:	f1b8 0f00 	cmp.w	r8, #0
 8022644:	d1ab      	bne.n	802259e <chuk_thread+0x3e>
			chThdSleepMilliseconds(3);
 8022646:	201e      	movs	r0, #30
 8022648:	f7eb f9ca 	bl	800d9e0 <chThdSleep>
			i2cAcquireBus(&HW_I2C_DEV);
 802264c:	4620      	mov	r0, r4
 802264e:	f7eb ffe7 	bl	800e620 <i2cAcquireBus>
			status = i2cMasterReceiveTimeout(&HW_I2C_DEV, chuck_addr, rxbuf, 6, tmo);
 8022652:	9700      	str	r7, [sp, #0]
 8022654:	2306      	movs	r3, #6
 8022656:	462a      	mov	r2, r5
 8022658:	2152      	movs	r1, #82	; 0x52
 802265a:	4620      	mov	r0, r4
 802265c:	f7eb ffc8 	bl	800e5f0 <i2cMasterReceiveTimeout>
 8022660:	4607      	mov	r7, r0
			i2cReleaseBus(&HW_I2C_DEV);
 8022662:	4620      	mov	r0, r4
 8022664:	f7eb ffe4 	bl	800e630 <i2cReleaseBus>
		if (is_ok) {
 8022668:	2f00      	cmp	r7, #0
 802266a:	d198      	bne.n	802259e <chuk_thread+0x3e>
 802266c:	4b30      	ldr	r3, [pc, #192]	; (8022730 <chuk_thread+0x1d0>)
 802266e:	4629      	mov	r1, r5
			int same = 1;
 8022670:	2201      	movs	r2, #1
				if (last_buffer[i] != rxbuf[i]) {
 8022672:	f813 7b01 	ldrb.w	r7, [r3], #1
 8022676:	f811 0b01 	ldrb.w	r0, [r1], #1
					same = 0;
 802267a:	4287      	cmp	r7, r0
 802267c:	bf18      	it	ne
 802267e:	2200      	movne	r2, #0
			for (int i = 0;i < 6;i++) {
 8022680:	429e      	cmp	r6, r3
 8022682:	d1f6      	bne.n	8022672 <chuk_thread+0x112>
			memcpy(last_buffer, rxbuf, 6);
 8022684:	e895 0003 	ldmia.w	r5, {r0, r1}
 8022688:	4b2a      	ldr	r3, [pc, #168]	; (8022734 <chuk_thread+0x1d4>)
 802268a:	f8cb 0000 	str.w	r0, [fp]
 802268e:	8019      	strh	r1, [r3, #0]
			if (!same) {
 8022690:	b1aa      	cbz	r2, 80226be <chuk_thread+0x15e>
			if (timeout_has_timeout()) {
 8022692:	f7f7 fd75 	bl	801a180 <timeout_has_timeout>
 8022696:	2800      	cmp	r0, #0
 8022698:	d08a      	beq.n	80225b0 <chuk_thread+0x50>
				chuck_error = 1;
 802269a:	2301      	movs	r3, #1
		chThdSleepMilliseconds(10);
 802269c:	2064      	movs	r0, #100	; 0x64
				chuck_error = 1;
 802269e:	f8c9 3000 	str.w	r3, [r9]
		chThdSleepMilliseconds(10);
 80226a2:	f7eb f99d 	bl	800d9e0 <chThdSleep>
		if (stop_now) {
 80226a6:	f89a 3000 	ldrb.w	r3, [sl]
 80226aa:	2b00      	cmp	r3, #0
 80226ac:	d087      	beq.n	80225be <chuk_thread+0x5e>
			is_running = false;
 80226ae:	4a1e      	ldr	r2, [pc, #120]	; (8022728 <chuk_thread+0x1c8>)
 80226b0:	2300      	movs	r3, #0
 80226b2:	7013      	strb	r3, [r2, #0]
			chuck_error = 0;
 80226b4:	f8c9 3000 	str.w	r3, [r9]
}
 80226b8:	b011      	add	sp, #68	; 0x44
 80226ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				chuck_d_tmp.acc_x = (rxbuf[2] << 2) | ((rxbuf[5] >> 2) & 3);
 80226be:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80226c2:	f89d 0012 	ldrb.w	r0, [sp, #18]
				chuck_d_tmp.acc_y = (rxbuf[3] << 2) | ((rxbuf[5] >> 4) & 3);
 80226c6:	f89d 1013 	ldrb.w	r1, [sp, #19]
				chuck_error = 0;
 80226ca:	f8c9 2000 	str.w	r2, [r9]
				chuck_d_tmp.acc_x = (rxbuf[2] << 2) | ((rxbuf[5] >> 2) & 3);
 80226ce:	f3c3 0281 	ubfx	r2, r3, #2, #2
				chuck_d_tmp.acc_z = (rxbuf[4] << 2) | ((rxbuf[5] >> 6) & 3);
 80226d2:	f89d 7014 	ldrb.w	r7, [sp, #20]
				chuck_d_tmp.acc_x = (rxbuf[2] << 2) | ((rxbuf[5] >> 2) & 3);
 80226d6:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
				chuck_d_tmp.acc_y = (rxbuf[3] << 2) | ((rxbuf[5] >> 4) & 3);
 80226da:	f3c3 1001 	ubfx	r0, r3, #4, #2
 80226de:	ea40 0081 	orr.w	r0, r0, r1, lsl #2
				chuck_d_tmp.acc_z = (rxbuf[4] << 2) | ((rxbuf[5] >> 6) & 3);
 80226e2:	0999      	lsrs	r1, r3, #6
 80226e4:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
				chuck_d_tmp.acc_x = (rxbuf[2] << 2) | ((rxbuf[5] >> 2) & 3);
 80226e8:	920c      	str	r2, [sp, #48]	; 0x30
				chuck_d_tmp.js_x = rxbuf[0];
 80226ea:	f89d 7010 	ldrb.w	r7, [sp, #16]
				chuck_d_tmp.acc_z = (rxbuf[4] << 2) | ((rxbuf[5] >> 6) & 3);
 80226ee:	910e      	str	r1, [sp, #56]	; 0x38
				chuck_d_tmp.bt_z = !((rxbuf[5] >> 0) & 1);
 80226f0:	43da      	mvns	r2, r3
				chuck_d_tmp.js_y = rxbuf[1];
 80226f2:	f89d 1011 	ldrb.w	r1, [sp, #17]
				chuck_d_tmp.acc_y = (rxbuf[3] << 2) | ((rxbuf[5] >> 4) & 3);
 80226f6:	900d      	str	r0, [sp, #52]	; 0x34
				chuck_d_tmp.bt_c = !((rxbuf[5] >> 1) & 1);
 80226f8:	ea6f 0353 	mvn.w	r3, r3, lsr #1
				chuck_d_tmp.bt_z = !((rxbuf[5] >> 0) & 1);
 80226fc:	f002 0201 	and.w	r2, r2, #1
				chuck_d_tmp.bt_c = !((rxbuf[5] >> 1) & 1);
 8022700:	f003 0301 	and.w	r3, r3, #1
				app_nunchuk_update_output(&chuck_d_tmp);
 8022704:	a80a      	add	r0, sp, #40	; 0x28
				chuck_d_tmp.bt_z = !((rxbuf[5] >> 0) & 1);
 8022706:	f88d 203d 	strb.w	r2, [sp, #61]	; 0x3d
				chuck_d_tmp.bt_c = !((rxbuf[5] >> 1) & 1);
 802270a:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
				chuck_d_tmp.js_y = rxbuf[1];
 802270e:	e9cd 710a 	strd	r7, r1, [sp, #40]	; 0x28
				app_nunchuk_update_output(&chuck_d_tmp);
 8022712:	f7ff fee5 	bl	80224e0 <app_nunchuk_update_output>
 8022716:	e7bc      	b.n	8022692 <chuk_thread+0x132>
 8022718:	f8df 9020 	ldr.w	r9, [pc, #32]	; 802273c <chuk_thread+0x1dc>
 802271c:	e7c7      	b.n	80226ae <chuk_thread+0x14e>
 802271e:	bf00      	nop
 8022720:	20001a48 	.word	0x20001a48
 8022724:	0802f650 	.word	0x0802f650
 8022728:	20010529 	.word	0x20010529
 802272c:	20001d7c 	.word	0x20001d7c
 8022730:	2001052c 	.word	0x2001052c
 8022734:	20010530 	.word	0x20010530
 8022738:	20001070 	.word	0x20001070
 802273c:	2000ff44 	.word	0x2000ff44

08022740 <spi_sw_init.part.0>:
// Private functions
static void spi_sw_delay(void);

void spi_sw_init(void) {
	if (!m_init_done) {
		palSetPadMode(m_port_miso, m_pin_miso, PAL_MODE_INPUT);
 8022740:	4a1c      	ldr	r2, [pc, #112]	; (80227b4 <spi_sw_init.part.0+0x74>)
 8022742:	4b1d      	ldr	r3, [pc, #116]	; (80227b8 <spi_sw_init.part.0+0x78>)
 8022744:	6811      	ldr	r1, [r2, #0]
 8022746:	6818      	ldr	r0, [r3, #0]
void spi_sw_init(void) {
 8022748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		palSetPadMode(m_port_miso, m_pin_miso, PAL_MODE_INPUT);
 802274c:	2401      	movs	r4, #1
		palSetPadMode(m_port_csn, m_pin_csn, PAL_MODE_OUTPUT_PUSHPULL);
 802274e:	f8df 8084 	ldr.w	r8, [pc, #132]	; 80227d4 <spi_sw_init.part.0+0x94>
 8022752:	4e1a      	ldr	r6, [pc, #104]	; (80227bc <spi_sw_init.part.0+0x7c>)
		palSetPadMode(m_port_sck, m_pin_sck, PAL_MODE_OUTPUT_PUSHPULL);
 8022754:	4f1a      	ldr	r7, [pc, #104]	; (80227c0 <spi_sw_init.part.0+0x80>)
 8022756:	4d1b      	ldr	r5, [pc, #108]	; (80227c4 <spi_sw_init.part.0+0x84>)
		palSetPadMode(m_port_miso, m_pin_miso, PAL_MODE_INPUT);
 8022758:	fa04 f101 	lsl.w	r1, r4, r1
 802275c:	2200      	movs	r2, #0
 802275e:	f7ed fb7f 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(m_port_csn, m_pin_csn, PAL_MODE_OUTPUT_PUSHPULL);
 8022762:	f8d8 1000 	ldr.w	r1, [r8]
 8022766:	6830      	ldr	r0, [r6, #0]
 8022768:	fa04 f101 	lsl.w	r1, r4, r1
 802276c:	4622      	mov	r2, r4
 802276e:	f7ed fb77 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(m_port_sck, m_pin_sck, PAL_MODE_OUTPUT_PUSHPULL);
 8022772:	6839      	ldr	r1, [r7, #0]
 8022774:	6828      	ldr	r0, [r5, #0]
 8022776:	fa04 f101 	lsl.w	r1, r4, r1
 802277a:	4622      	mov	r2, r4
 802277c:	f7ed fb70 	bl	800fe60 <_pal_lld_setgroupmode>
		palSetPadMode(m_port_mosi, m_pin_mosi, PAL_MODE_OUTPUT_PUSHPULL);
 8022780:	4a11      	ldr	r2, [pc, #68]	; (80227c8 <spi_sw_init.part.0+0x88>)
 8022782:	4b12      	ldr	r3, [pc, #72]	; (80227cc <spi_sw_init.part.0+0x8c>)
 8022784:	6811      	ldr	r1, [r2, #0]
 8022786:	6818      	ldr	r0, [r3, #0]
 8022788:	fa04 f101 	lsl.w	r1, r4, r1
 802278c:	4622      	mov	r2, r4
 802278e:	f7ed fb67 	bl	800fe60 <_pal_lld_setgroupmode>

		palSetPad(m_port_csn, m_pin_csn);
 8022792:	f8d8 2000 	ldr.w	r2, [r8]
		palClearPad(m_port_sck, m_pin_sck);
 8022796:	683b      	ldr	r3, [r7, #0]
		palSetPad(m_port_csn, m_pin_csn);
 8022798:	6836      	ldr	r6, [r6, #0]
		palClearPad(m_port_sck, m_pin_sck);
 802279a:	6829      	ldr	r1, [r5, #0]
		m_init_done = true;
 802279c:	480c      	ldr	r0, [pc, #48]	; (80227d0 <spi_sw_init.part.0+0x90>)
		palSetPad(m_port_csn, m_pin_csn);
 802279e:	fa04 f202 	lsl.w	r2, r4, r2
		palClearPad(m_port_sck, m_pin_sck);
 80227a2:	fa04 f303 	lsl.w	r3, r4, r3
		palSetPad(m_port_csn, m_pin_csn);
 80227a6:	b292      	uxth	r2, r2
		palClearPad(m_port_sck, m_pin_sck);
 80227a8:	b29b      	uxth	r3, r3
		palSetPad(m_port_csn, m_pin_csn);
 80227aa:	8332      	strh	r2, [r6, #24]
		m_init_done = true;
 80227ac:	7004      	strb	r4, [r0, #0]
		palClearPad(m_port_sck, m_pin_sck);
 80227ae:	834b      	strh	r3, [r1, #26]
	}
}
 80227b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80227b4:	20001078 	.word	0x20001078
 80227b8:	20001088 	.word	0x20001088
 80227bc:	20001084 	.word	0x20001084
 80227c0:	20001080 	.word	0x20001080
 80227c4:	20001090 	.word	0x20001090
 80227c8:	2000107c 	.word	0x2000107c
 80227cc:	2000108c 	.word	0x2000108c
 80227d0:	20010ae2 	.word	0x20010ae2
 80227d4:	20001074 	.word	0x20001074
	...

080227e0 <spi_sw_init>:
	if (!m_init_done) {
 80227e0:	4b02      	ldr	r3, [pc, #8]	; (80227ec <spi_sw_init+0xc>)
 80227e2:	781b      	ldrb	r3, [r3, #0]
 80227e4:	b103      	cbz	r3, 80227e8 <spi_sw_init+0x8>
}
 80227e6:	4770      	bx	lr
 80227e8:	f7ff bfaa 	b.w	8022740 <spi_sw_init.part.0>
 80227ec:	20010ae2 	.word	0x20010ae2

080227f0 <spi_sw_stop>:

void spi_sw_stop(void) {
	palSetPadMode(m_port_miso, m_pin_miso, PAL_MODE_INPUT);
 80227f0:	4a14      	ldr	r2, [pc, #80]	; (8022844 <spi_sw_stop+0x54>)
 80227f2:	4b15      	ldr	r3, [pc, #84]	; (8022848 <spi_sw_stop+0x58>)
 80227f4:	6811      	ldr	r1, [r2, #0]
 80227f6:	6818      	ldr	r0, [r3, #0]
void spi_sw_stop(void) {
 80227f8:	b510      	push	{r4, lr}
	palSetPadMode(m_port_miso, m_pin_miso, PAL_MODE_INPUT);
 80227fa:	2401      	movs	r4, #1
 80227fc:	fa04 f101 	lsl.w	r1, r4, r1
 8022800:	2200      	movs	r2, #0
 8022802:	f7ed fb2d 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(m_port_csn, m_pin_csn, PAL_MODE_INPUT);
 8022806:	4a11      	ldr	r2, [pc, #68]	; (802284c <spi_sw_stop+0x5c>)
 8022808:	4b11      	ldr	r3, [pc, #68]	; (8022850 <spi_sw_stop+0x60>)
 802280a:	6811      	ldr	r1, [r2, #0]
 802280c:	6818      	ldr	r0, [r3, #0]
 802280e:	fa04 f101 	lsl.w	r1, r4, r1
 8022812:	2200      	movs	r2, #0
 8022814:	f7ed fb24 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(m_port_sck, m_pin_sck, PAL_MODE_INPUT);
 8022818:	4a0e      	ldr	r2, [pc, #56]	; (8022854 <spi_sw_stop+0x64>)
 802281a:	4b0f      	ldr	r3, [pc, #60]	; (8022858 <spi_sw_stop+0x68>)
 802281c:	6811      	ldr	r1, [r2, #0]
 802281e:	6818      	ldr	r0, [r3, #0]
 8022820:	fa04 f101 	lsl.w	r1, r4, r1
 8022824:	2200      	movs	r2, #0
 8022826:	f7ed fb1b 	bl	800fe60 <_pal_lld_setgroupmode>
	palSetPadMode(m_port_mosi, m_pin_mosi, PAL_MODE_INPUT);
 802282a:	4a0c      	ldr	r2, [pc, #48]	; (802285c <spi_sw_stop+0x6c>)
 802282c:	4b0c      	ldr	r3, [pc, #48]	; (8022860 <spi_sw_stop+0x70>)
 802282e:	6811      	ldr	r1, [r2, #0]
 8022830:	6818      	ldr	r0, [r3, #0]
 8022832:	2200      	movs	r2, #0
 8022834:	fa04 f101 	lsl.w	r1, r4, r1
 8022838:	f7ed fb12 	bl	800fe60 <_pal_lld_setgroupmode>
	m_init_done = false;
 802283c:	4b09      	ldr	r3, [pc, #36]	; (8022864 <spi_sw_stop+0x74>)
 802283e:	2200      	movs	r2, #0
 8022840:	701a      	strb	r2, [r3, #0]
}
 8022842:	bd10      	pop	{r4, pc}
 8022844:	20001078 	.word	0x20001078
 8022848:	20001088 	.word	0x20001088
 802284c:	20001074 	.word	0x20001074
 8022850:	20001084 	.word	0x20001084
 8022854:	20001080 	.word	0x20001080
 8022858:	20001090 	.word	0x20001090
 802285c:	2000107c 	.word	0x2000107c
 8022860:	2000108c 	.word	0x2000108c
 8022864:	20010ae2 	.word	0x20010ae2
	...

08022870 <spi_sw_transfer>:
	if (init_was_done) {
		spi_sw_init();
	}
}

void spi_sw_transfer(char *in_buf, const char *out_buf, int length) {
 8022870:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	palClearPad(m_port_sck, m_pin_sck);
 8022874:	f8df 9130 	ldr.w	r9, [pc, #304]	; 80229a8 <spi_sw_transfer+0x138>
 8022878:	4b49      	ldr	r3, [pc, #292]	; (80229a0 <spi_sw_transfer+0x130>)
 802287a:	f8d9 5000 	ldr.w	r5, [r9]
 802287e:	681c      	ldr	r4, [r3, #0]
 8022880:	2301      	movs	r3, #1
void spi_sw_transfer(char *in_buf, const char *out_buf, int length) {
 8022882:	b089      	sub	sp, #36	; 0x24
	palClearPad(m_port_sck, m_pin_sck);
 8022884:	40ab      	lsls	r3, r5
 8022886:	b29b      	uxth	r3, r3
	spi_sw_delay();
	palSetPad(m_port_csn, m_pin_csn);
}

static void spi_sw_delay(void) {
	for (volatile int i = 0;i < 5;i++) {
 8022888:	2500      	movs	r5, #0
	palClearPad(m_port_sck, m_pin_sck);
 802288a:	8363      	strh	r3, [r4, #26]
	for (volatile int i = 0;i < 5;i++) {
 802288c:	9505      	str	r5, [sp, #20]
 802288e:	9b05      	ldr	r3, [sp, #20]
 8022890:	2b04      	cmp	r3, #4
 8022892:	dc06      	bgt.n	80228a2 <spi_sw_transfer+0x32>
 8022894:	bf00      	nop
 8022896:	9b05      	ldr	r3, [sp, #20]
 8022898:	3301      	adds	r3, #1
 802289a:	9305      	str	r3, [sp, #20]
 802289c:	9b05      	ldr	r3, [sp, #20]
 802289e:	2b04      	cmp	r3, #4
 80228a0:	ddf8      	ble.n	8022894 <spi_sw_transfer+0x24>
	for (int i = 0;i < length;i++) {
 80228a2:	2a00      	cmp	r2, #0
 80228a4:	dd76      	ble.n	8022994 <spi_sw_transfer+0x124>
 80228a6:	e9cd 1001 	strd	r1, r0, [sp, #4]
 80228aa:	2300      	movs	r3, #0
 80228ac:	f8df b0fc 	ldr.w	fp, [pc, #252]	; 80229ac <spi_sw_transfer+0x13c>
 80228b0:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 80229b0 <spi_sw_transfer+0x140>
 80228b4:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 80229b4 <spi_sw_transfer+0x144>
 80228b8:	4f3a      	ldr	r7, [pc, #232]	; (80229a4 <spi_sw_transfer+0x134>)
 80228ba:	9203      	str	r2, [sp, #12]
 80228bc:	9300      	str	r3, [sp, #0]
		unsigned char send = out_buf ? out_buf[i] : 0;
 80228be:	9b01      	ldr	r3, [sp, #4]
 80228c0:	2b00      	cmp	r3, #0
 80228c2:	d06a      	beq.n	802299a <spi_sw_transfer+0x12a>
 80228c4:	9a00      	ldr	r2, [sp, #0]
 80228c6:	5c9d      	ldrb	r5, [r3, r2]
 80228c8:	2608      	movs	r6, #8
 80228ca:	2400      	movs	r4, #0
			palWritePad(m_port_mosi, m_pin_mosi, send >> 7);
 80228cc:	f8db 1000 	ldr.w	r1, [fp]
 80228d0:	f8da 2000 	ldr.w	r2, [sl]
 80228d4:	09eb      	lsrs	r3, r5, #7
 80228d6:	f101 0010 	add.w	r0, r1, #16
 80228da:	fa03 f101 	lsl.w	r1, r3, r1
 80228de:	f083 0301 	eor.w	r3, r3, #1
 80228e2:	4083      	lsls	r3, r0
 80228e4:	430b      	orrs	r3, r1
 80228e6:	6193      	str	r3, [r2, #24]
	for (volatile int i = 0;i < 5;i++) {
 80228e8:	2300      	movs	r3, #0
 80228ea:	9306      	str	r3, [sp, #24]
 80228ec:	9b06      	ldr	r3, [sp, #24]
			send <<= 1;
 80228ee:	006d      	lsls	r5, r5, #1
	for (volatile int i = 0;i < 5;i++) {
 80228f0:	2b04      	cmp	r3, #4
			send <<= 1;
 80228f2:	b2ed      	uxtb	r5, r5
	for (volatile int i = 0;i < 5;i++) {
 80228f4:	dc06      	bgt.n	8022904 <spi_sw_transfer+0x94>
 80228f6:	bf00      	nop
 80228f8:	9b06      	ldr	r3, [sp, #24]
 80228fa:	3301      	adds	r3, #1
 80228fc:	9306      	str	r3, [sp, #24]
 80228fe:	9b06      	ldr	r3, [sp, #24]
 8022900:	2b04      	cmp	r3, #4
 8022902:	ddf8      	ble.n	80228f6 <spi_sw_transfer+0x86>
			r1 = palReadPad(m_port_miso, m_pin_miso);
 8022904:	f8d8 2000 	ldr.w	r2, [r8]
 8022908:	683b      	ldr	r3, [r7, #0]
 802290a:	6910      	ldr	r0, [r2, #16]
 802290c:	40d8      	lsrs	r0, r3
 802290e:	f000 0001 	and.w	r0, r0, #1
 8022912:	bf00      	nop
			r2 = palReadPad(m_port_miso, m_pin_miso);
 8022914:	f8d8 2000 	ldr.w	r2, [r8]
 8022918:	683b      	ldr	r3, [r7, #0]
 802291a:	6911      	ldr	r1, [r2, #16]
 802291c:	40d9      	lsrs	r1, r3
 802291e:	f001 0101 	and.w	r1, r1, #1
 8022922:	bf00      	nop
			r3 = palReadPad(m_port_miso, m_pin_miso);
 8022924:	f8d8 2000 	ldr.w	r2, [r8]
 8022928:	683b      	ldr	r3, [r7, #0]
 802292a:	6912      	ldr	r2, [r2, #16]
 802292c:	40da      	lsrs	r2, r3
			recieve <<= 1;
 802292e:	0064      	lsls	r4, r4, #1
			if (utils_middle_of_3_int(r1, r2, r3)) {
 8022930:	f002 0201 	and.w	r2, r2, #1
			recieve <<= 1;
 8022934:	b2e4      	uxtb	r4, r4
			if (utils_middle_of_3_int(r1, r2, r3)) {
 8022936:	f7f3 f9b3 	bl	8015ca0 <utils_middle_of_3_int>
 802293a:	b108      	cbz	r0, 8022940 <spi_sw_transfer+0xd0>
				recieve |= 1;
 802293c:	f044 0401 	orr.w	r4, r4, #1
			palSetPad(m_port_sck, m_pin_sck);
 8022940:	f8d9 3000 	ldr.w	r3, [r9]
 8022944:	4a16      	ldr	r2, [pc, #88]	; (80229a0 <spi_sw_transfer+0x130>)
 8022946:	2101      	movs	r1, #1
 8022948:	fa01 f303 	lsl.w	r3, r1, r3
 802294c:	6812      	ldr	r2, [r2, #0]
	for (volatile int i = 0;i < 5;i++) {
 802294e:	2100      	movs	r1, #0
			palSetPad(m_port_sck, m_pin_sck);
 8022950:	b29b      	uxth	r3, r3
 8022952:	8313      	strh	r3, [r2, #24]
	for (volatile int i = 0;i < 5;i++) {
 8022954:	9107      	str	r1, [sp, #28]
 8022956:	9907      	ldr	r1, [sp, #28]
 8022958:	2904      	cmp	r1, #4
 802295a:	dc0e      	bgt.n	802297a <spi_sw_transfer+0x10a>
 802295c:	bf00      	nop
 802295e:	9b07      	ldr	r3, [sp, #28]
 8022960:	3301      	adds	r3, #1
 8022962:	9307      	str	r3, [sp, #28]
 8022964:	9b07      	ldr	r3, [sp, #28]
 8022966:	2b04      	cmp	r3, #4
 8022968:	ddf8      	ble.n	802295c <spi_sw_transfer+0xec>
 802296a:	f8d9 3000 	ldr.w	r3, [r9]
 802296e:	4a0c      	ldr	r2, [pc, #48]	; (80229a0 <spi_sw_transfer+0x130>)
 8022970:	2101      	movs	r1, #1
 8022972:	fa01 f303 	lsl.w	r3, r1, r3
 8022976:	6812      	ldr	r2, [r2, #0]
 8022978:	b29b      	uxth	r3, r3
		for (int bit=0;bit < 8;bit++) {
 802297a:	3e01      	subs	r6, #1
			palClearPad(m_port_sck, m_pin_sck);
 802297c:	8353      	strh	r3, [r2, #26]
		for (int bit=0;bit < 8;bit++) {
 802297e:	d1a5      	bne.n	80228cc <spi_sw_transfer+0x5c>
		if (in_buf) {
 8022980:	9b02      	ldr	r3, [sp, #8]
 8022982:	b10b      	cbz	r3, 8022988 <spi_sw_transfer+0x118>
			in_buf[i] = recieve;
 8022984:	9a00      	ldr	r2, [sp, #0]
 8022986:	549c      	strb	r4, [r3, r2]
	for (int i = 0;i < length;i++) {
 8022988:	9b00      	ldr	r3, [sp, #0]
 802298a:	9a03      	ldr	r2, [sp, #12]
 802298c:	3301      	adds	r3, #1
 802298e:	429a      	cmp	r2, r3
 8022990:	9300      	str	r3, [sp, #0]
 8022992:	d194      	bne.n	80228be <spi_sw_transfer+0x4e>
}
 8022994:	b009      	add	sp, #36	; 0x24
 8022996:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		unsigned char send = out_buf ? out_buf[i] : 0;
 802299a:	9d01      	ldr	r5, [sp, #4]
 802299c:	e794      	b.n	80228c8 <spi_sw_transfer+0x58>
 802299e:	bf00      	nop
 80229a0:	20001090 	.word	0x20001090
 80229a4:	20001078 	.word	0x20001078
 80229a8:	20001080 	.word	0x20001080
 80229ac:	2000107c 	.word	0x2000107c
 80229b0:	2000108c 	.word	0x2000108c
 80229b4:	20001088 	.word	0x20001088
	...

080229c0 <spi_sw_begin>:
	palClearPad(m_port_csn, m_pin_csn);
 80229c0:	4a0b      	ldr	r2, [pc, #44]	; (80229f0 <spi_sw_begin+0x30>)
 80229c2:	4b0c      	ldr	r3, [pc, #48]	; (80229f4 <spi_sw_begin+0x34>)
 80229c4:	6812      	ldr	r2, [r2, #0]
 80229c6:	6819      	ldr	r1, [r3, #0]
 80229c8:	2301      	movs	r3, #1
void spi_sw_begin(void) {
 80229ca:	b082      	sub	sp, #8
	palClearPad(m_port_csn, m_pin_csn);
 80229cc:	4093      	lsls	r3, r2
 80229ce:	b29b      	uxth	r3, r3
	for (volatile int i = 0;i < 5;i++) {
 80229d0:	2200      	movs	r2, #0
	palClearPad(m_port_csn, m_pin_csn);
 80229d2:	834b      	strh	r3, [r1, #26]
	for (volatile int i = 0;i < 5;i++) {
 80229d4:	9201      	str	r2, [sp, #4]
 80229d6:	9b01      	ldr	r3, [sp, #4]
 80229d8:	2b04      	cmp	r3, #4
 80229da:	dc06      	bgt.n	80229ea <spi_sw_begin+0x2a>
 80229dc:	bf00      	nop
 80229de:	9b01      	ldr	r3, [sp, #4]
 80229e0:	3301      	adds	r3, #1
 80229e2:	9301      	str	r3, [sp, #4]
 80229e4:	9b01      	ldr	r3, [sp, #4]
 80229e6:	2b04      	cmp	r3, #4
 80229e8:	ddf8      	ble.n	80229dc <spi_sw_begin+0x1c>
}
 80229ea:	b002      	add	sp, #8
 80229ec:	4770      	bx	lr
 80229ee:	bf00      	nop
 80229f0:	20001074 	.word	0x20001074
 80229f4:	20001084 	.word	0x20001084
	...

08022a00 <spi_sw_end>:
void spi_sw_end(void) {
 8022a00:	b082      	sub	sp, #8
	for (volatile int i = 0;i < 5;i++) {
 8022a02:	2300      	movs	r3, #0
 8022a04:	9301      	str	r3, [sp, #4]
 8022a06:	9b01      	ldr	r3, [sp, #4]
 8022a08:	2b04      	cmp	r3, #4
 8022a0a:	dc06      	bgt.n	8022a1a <spi_sw_end+0x1a>
 8022a0c:	bf00      	nop
 8022a0e:	9b01      	ldr	r3, [sp, #4]
 8022a10:	3301      	adds	r3, #1
 8022a12:	9301      	str	r3, [sp, #4]
 8022a14:	9b01      	ldr	r3, [sp, #4]
 8022a16:	2b04      	cmp	r3, #4
 8022a18:	ddf8      	ble.n	8022a0c <spi_sw_end+0xc>
	palSetPad(m_port_csn, m_pin_csn);
 8022a1a:	4a05      	ldr	r2, [pc, #20]	; (8022a30 <spi_sw_end+0x30>)
 8022a1c:	4b05      	ldr	r3, [pc, #20]	; (8022a34 <spi_sw_end+0x34>)
 8022a1e:	6811      	ldr	r1, [r2, #0]
 8022a20:	681a      	ldr	r2, [r3, #0]
 8022a22:	2301      	movs	r3, #1
 8022a24:	408b      	lsls	r3, r1
 8022a26:	b29b      	uxth	r3, r3
 8022a28:	8313      	strh	r3, [r2, #24]
}
 8022a2a:	b002      	add	sp, #8
 8022a2c:	4770      	bx	lr
 8022a2e:	bf00      	nop
 8022a30:	20001074 	.word	0x20001074
 8022a34:	20001084 	.word	0x20001084
	...

08022a40 <rf_init>:
#include "rf.h"
#include "spi_sw.h"
#include "ch.h"

void rf_init(void) {
	spi_sw_init();
 8022a40:	f7ff bece 	b.w	80227e0 <spi_sw_init>
	...

08022a50 <rf_stop>:
}

void rf_stop(void) {
	spi_sw_stop();
 8022a50:	f7ff bece 	b.w	80227f0 <spi_sw_stop>
	...

08022a60 <rf_write_tx_payload>:

void rf_set_tx_addr(const char *address, int addr_len) {
	rf_write_reg(NRF_REG_TX_ADDR, address, addr_len);
}

void rf_write_tx_payload(const char *data, int length) {
 8022a60:	b570      	push	{r4, r5, r6, lr}
 8022a62:	b082      	sub	sp, #8
	char cmd = NRF_CMD_WRITE_TX_PAYLOAD;
 8022a64:	ac02      	add	r4, sp, #8
 8022a66:	23a0      	movs	r3, #160	; 0xa0
 8022a68:	f804 3d01 	strb.w	r3, [r4, #-1]!
void rf_write_tx_payload(const char *data, int length) {
 8022a6c:	4605      	mov	r5, r0
 8022a6e:	460e      	mov	r6, r1
	spi_sw_begin();
 8022a70:	f7ff ffa6 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022a74:	4621      	mov	r1, r4
 8022a76:	2201      	movs	r2, #1
 8022a78:	2000      	movs	r0, #0
 8022a7a:	f7ff fef9 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(0, data, length);
 8022a7e:	4632      	mov	r2, r6
 8022a80:	4629      	mov	r1, r5
 8022a82:	2000      	movs	r0, #0
 8022a84:	f7ff fef4 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022a88:	f7ff ffba 	bl	8022a00 <spi_sw_end>

}
 8022a8c:	b002      	add	sp, #8
 8022a8e:	bd70      	pop	{r4, r5, r6, pc}

08022a90 <rf_write_tx_payload_no_ack>:

// Write payload for transmission without requesting acknowledge
void rf_write_tx_payload_no_ack(const char *data, int length) {
 8022a90:	b570      	push	{r4, r5, r6, lr}
 8022a92:	b082      	sub	sp, #8
	char cmd = NRF_CMD_WRITE_TX_PAYLOAD_NO_ACK;
 8022a94:	ac02      	add	r4, sp, #8
 8022a96:	23b0      	movs	r3, #176	; 0xb0
 8022a98:	f804 3d01 	strb.w	r3, [r4, #-1]!
void rf_write_tx_payload_no_ack(const char *data, int length) {
 8022a9c:	4605      	mov	r5, r0
 8022a9e:	460e      	mov	r6, r1
	spi_sw_begin();
 8022aa0:	f7ff ff8e 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022aa4:	4621      	mov	r1, r4
 8022aa6:	2201      	movs	r2, #1
 8022aa8:	2000      	movs	r0, #0
 8022aaa:	f7ff fee1 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(0, data, length);
 8022aae:	4632      	mov	r2, r6
 8022ab0:	4629      	mov	r1, r5
 8022ab2:	2000      	movs	r0, #0
 8022ab4:	f7ff fedc 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022ab8:	f7ff ffa2 	bl	8022a00 <spi_sw_end>

}
 8022abc:	b002      	add	sp, #8
 8022abe:	bd70      	pop	{r4, r5, r6, pc}

08022ac0 <rf_read_rx_payload>:
	spi_sw_end();

}

// Read recieved payload
void rf_read_rx_payload(char *data, int length) {
 8022ac0:	b570      	push	{r4, r5, r6, lr}
 8022ac2:	b082      	sub	sp, #8
	char cmd = NRF_CMD_READ_RX_PAYLOAD;
 8022ac4:	ac02      	add	r4, sp, #8
 8022ac6:	2361      	movs	r3, #97	; 0x61
 8022ac8:	f804 3d01 	strb.w	r3, [r4, #-1]!
void rf_read_rx_payload(char *data, int length) {
 8022acc:	4605      	mov	r5, r0
 8022ace:	460e      	mov	r6, r1
	spi_sw_begin();
 8022ad0:	f7ff ff76 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022ad4:	4621      	mov	r1, r4
 8022ad6:	2201      	movs	r2, #1
 8022ad8:	2000      	movs	r0, #0
 8022ada:	f7ff fec9 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(data, 0, length);
 8022ade:	4632      	mov	r2, r6
 8022ae0:	4628      	mov	r0, r5
 8022ae2:	2100      	movs	r1, #0
 8022ae4:	f7ff fec4 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022ae8:	f7ff ff8a 	bl	8022a00 <spi_sw_end>

}
 8022aec:	b002      	add	sp, #8
 8022aee:	bd70      	pop	{r4, r5, r6, pc}

08022af0 <rf_flush_tx>:
		tmp |= (features);
		rf_write_reg_byte(NRF_REG_FEATURE, tmp);	//Update if we need
	}
}

void rf_flush_tx(void) {
 8022af0:	b510      	push	{r4, lr}
 8022af2:	b082      	sub	sp, #8
	char cmd = NRF_CMD_FLUSH_TX;
 8022af4:	ac02      	add	r4, sp, #8
 8022af6:	23e1      	movs	r3, #225	; 0xe1
 8022af8:	f804 3d01 	strb.w	r3, [r4, #-1]!
	spi_sw_begin();
 8022afc:	f7ff ff60 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022b00:	4621      	mov	r1, r4
 8022b02:	2201      	movs	r2, #1
 8022b04:	2000      	movs	r0, #0
 8022b06:	f7ff feb3 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022b0a:	f7ff ff79 	bl	8022a00 <spi_sw_end>
}
 8022b0e:	b002      	add	sp, #8
 8022b10:	bd10      	pop	{r4, pc}
 8022b12:	bf00      	nop
	...

08022b20 <rf_flush_rx>:

void rf_flush_rx(void) {
 8022b20:	b510      	push	{r4, lr}
 8022b22:	b082      	sub	sp, #8
	char cmd = NRF_CMD_FLUSH_RX;
 8022b24:	ac02      	add	r4, sp, #8
 8022b26:	23e2      	movs	r3, #226	; 0xe2
 8022b28:	f804 3d01 	strb.w	r3, [r4, #-1]!
	spi_sw_begin();
 8022b2c:	f7ff ff48 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022b30:	4621      	mov	r1, r4
 8022b32:	2201      	movs	r2, #1
 8022b34:	2000      	movs	r0, #0
 8022b36:	f7ff fe9b 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022b3a:	f7ff ff61 	bl	8022a00 <spi_sw_end>
}
 8022b3e:	b002      	add	sp, #8
 8022b40:	bd10      	pop	{r4, pc}
 8022b42:	bf00      	nop
	...

08022b50 <rf_flush_all>:

void rf_flush_all(void) {
 8022b50:	b508      	push	{r3, lr}
	rf_flush_rx();
 8022b52:	f7ff ffe5 	bl	8022b20 <rf_flush_rx>
	rf_flush_tx();
}
 8022b56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	rf_flush_tx();
 8022b5a:	f7ff bfc9 	b.w	8022af0 <rf_flush_tx>
 8022b5e:	bf00      	nop

08022b60 <rf_get_payload_width>:

void rf_clear_maxrt_irq(void) {
	rf_write_reg_byte(NRF_REG_STATUS, NRF_STATUS_MAX_RT);
}

int rf_get_payload_width(void) {
 8022b60:	b510      	push	{r4, lr}
 8022b62:	b082      	sub	sp, #8
	char w;
	char cmd = NRF_CMD_READ_RX_PAYLOAD_WIDTH;
 8022b64:	ac02      	add	r4, sp, #8
 8022b66:	2360      	movs	r3, #96	; 0x60
 8022b68:	f804 3d01 	strb.w	r3, [r4, #-1]!
	spi_sw_begin();
 8022b6c:	f7ff ff28 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022b70:	4621      	mov	r1, r4
 8022b72:	2201      	movs	r2, #1
 8022b74:	2000      	movs	r0, #0
 8022b76:	f7ff fe7b 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(&w, 0, 1);
 8022b7a:	f10d 0006 	add.w	r0, sp, #6
 8022b7e:	2201      	movs	r2, #1
 8022b80:	2100      	movs	r1, #0
 8022b82:	f7ff fe75 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022b86:	f7ff ff3b 	bl	8022a00 <spi_sw_end>
	return w;
}
 8022b8a:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8022b8e:	b002      	add	sp, #8
 8022b90:	bd10      	pop	{r4, pc}
 8022b92:	bf00      	nop
	...

08022ba0 <rf_status>:

int rf_status(void) {
 8022ba0:	b510      	push	{r4, lr}
 8022ba2:	b082      	sub	sp, #8
	char w = NRF_CMD_NOP;
 8022ba4:	ac02      	add	r4, sp, #8
 8022ba6:	23ff      	movs	r3, #255	; 0xff
 8022ba8:	f804 3d01 	strb.w	r3, [r4, #-1]!
	spi_sw_begin();
 8022bac:	f7ff ff08 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(&w, &w, 1);
 8022bb0:	4620      	mov	r0, r4
 8022bb2:	4621      	mov	r1, r4
 8022bb4:	2201      	movs	r2, #1
 8022bb6:	f7ff fe5b 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022bba:	f7ff ff21 	bl	8022a00 <spi_sw_end>
	return w;
}
 8022bbe:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8022bc2:	b002      	add	sp, #8
 8022bc4:	bd10      	pop	{r4, pc}
 8022bc6:	bf00      	nop
	...

08022bd0 <rf_write_reg>:

int rf_rx_power_detect(void) {
	return rf_read_reg_byte(NRF_REG_RPD) >> 1;
}

void rf_write_reg(int reg, const char *data, int len) {
 8022bd0:	b570      	push	{r4, r5, r6, lr}
 8022bd2:	b082      	sub	sp, #8
	char cmd = NRF_CMD_WRITE_REGISTER | reg;
 8022bd4:	ac02      	add	r4, sp, #8
 8022bd6:	f040 0020 	orr.w	r0, r0, #32
 8022bda:	f804 0d01 	strb.w	r0, [r4, #-1]!
void rf_write_reg(int reg, const char *data, int len) {
 8022bde:	460d      	mov	r5, r1
 8022be0:	4616      	mov	r6, r2

	spi_sw_begin();
 8022be2:	f7ff feed 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022be6:	4621      	mov	r1, r4
 8022be8:	2201      	movs	r2, #1
 8022bea:	2000      	movs	r0, #0
 8022bec:	f7ff fe40 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(0, data, len);
 8022bf0:	4632      	mov	r2, r6
 8022bf2:	4629      	mov	r1, r5
 8022bf4:	2000      	movs	r0, #0
 8022bf6:	f7ff fe3b 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022bfa:	f7ff ff01 	bl	8022a00 <spi_sw_end>
}
 8022bfe:	b002      	add	sp, #8
 8022c00:	bd70      	pop	{r4, r5, r6, pc}
 8022c02:	bf00      	nop
	...

08022c10 <rf_set_rx_addr>:
	rf_write_reg(NRF_REG_RX_ADDR_P0 + pipe, address, addr_len);
 8022c10:	300a      	adds	r0, #10
 8022c12:	f7ff bfdd 	b.w	8022bd0 <rf_write_reg>
 8022c16:	bf00      	nop
	...

08022c20 <rf_set_tx_addr>:
	rf_write_reg(NRF_REG_TX_ADDR, address, addr_len);
 8022c20:	460a      	mov	r2, r1
 8022c22:	4601      	mov	r1, r0
 8022c24:	2010      	movs	r0, #16
 8022c26:	f7ff bfd3 	b.w	8022bd0 <rf_write_reg>
 8022c2a:	bf00      	nop
 8022c2c:	0000      	movs	r0, r0
	...

08022c30 <rf_set_address_width>:
void rf_set_address_width(NRF_AW aw) {
 8022c30:	b500      	push	{lr}
 8022c32:	b083      	sub	sp, #12
 8022c34:	a902      	add	r1, sp, #8
	rf_write_reg_byte(NRF_REG_SETUP_AW, (char)aw + 1);
 8022c36:	3001      	adds	r0, #1
 8022c38:	f801 0d01 	strb.w	r0, [r1, #-1]!

void rf_write_reg_byte(int reg, char data) {
	rf_write_reg(reg, &data, 1);
 8022c3c:	2201      	movs	r2, #1
 8022c3e:	2003      	movs	r0, #3
 8022c40:	f7ff ffc6 	bl	8022bd0 <rf_write_reg>
}
 8022c44:	b003      	add	sp, #12
 8022c46:	f85d fb04 	ldr.w	pc, [sp], #4
 8022c4a:	bf00      	nop
 8022c4c:	0000      	movs	r0, r0
	...

08022c50 <rf_set_frequency>:
void rf_set_frequency(int freq) {
 8022c50:	b500      	push	{lr}
 8022c52:	b083      	sub	sp, #12
 8022c54:	a902      	add	r1, sp, #8
	rf_write_reg_byte(NRF_REG_RF_CH, (freq - 2400) & 0x7F);
 8022c56:	3860      	subs	r0, #96	; 0x60
 8022c58:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8022c5c:	f801 0d01 	strb.w	r0, [r1, #-1]!
	rf_write_reg(reg, &data, 1);
 8022c60:	2201      	movs	r2, #1
 8022c62:	2005      	movs	r0, #5
 8022c64:	f7ff ffb4 	bl	8022bd0 <rf_write_reg>
}
 8022c68:	b003      	add	sp, #12
 8022c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8022c6e:	bf00      	nop

08022c70 <rf_clear_irq>:
void rf_clear_irq(void) {
 8022c70:	b500      	push	{lr}
 8022c72:	b083      	sub	sp, #12
 8022c74:	a902      	add	r1, sp, #8
 8022c76:	2370      	movs	r3, #112	; 0x70
 8022c78:	f801 3d01 	strb.w	r3, [r1, #-1]!
	rf_write_reg(reg, &data, 1);
 8022c7c:	2201      	movs	r2, #1
 8022c7e:	2007      	movs	r0, #7
 8022c80:	f7ff ffa6 	bl	8022bd0 <rf_write_reg>
}
 8022c84:	b003      	add	sp, #12
 8022c86:	f85d fb04 	ldr.w	pc, [sp], #4
 8022c8a:	bf00      	nop
 8022c8c:	0000      	movs	r0, r0
	...

08022c90 <rf_clear_rx_irq>:
void rf_clear_rx_irq(void) {
 8022c90:	b500      	push	{lr}
 8022c92:	b083      	sub	sp, #12
 8022c94:	a902      	add	r1, sp, #8
 8022c96:	2340      	movs	r3, #64	; 0x40
 8022c98:	f801 3d01 	strb.w	r3, [r1, #-1]!
	rf_write_reg(reg, &data, 1);
 8022c9c:	2201      	movs	r2, #1
 8022c9e:	2007      	movs	r0, #7
 8022ca0:	f7ff ff96 	bl	8022bd0 <rf_write_reg>
}
 8022ca4:	b003      	add	sp, #12
 8022ca6:	f85d fb04 	ldr.w	pc, [sp], #4
 8022caa:	bf00      	nop
 8022cac:	0000      	movs	r0, r0
	...

08022cb0 <rf_clear_maxrt_irq>:
void rf_clear_maxrt_irq(void) {
 8022cb0:	b500      	push	{lr}
 8022cb2:	b083      	sub	sp, #12
 8022cb4:	a902      	add	r1, sp, #8
 8022cb6:	2310      	movs	r3, #16
 8022cb8:	f801 3d01 	strb.w	r3, [r1, #-1]!
	rf_write_reg(reg, &data, 1);
 8022cbc:	2201      	movs	r2, #1
 8022cbe:	2007      	movs	r0, #7
 8022cc0:	f7ff ff86 	bl	8022bd0 <rf_write_reg>
}
 8022cc4:	b003      	add	sp, #12
 8022cc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8022cca:	bf00      	nop
 8022ccc:	0000      	movs	r0, r0
	...

08022cd0 <rf_write_reg_byte>:
void rf_write_reg_byte(int reg, char data) {
 8022cd0:	b500      	push	{lr}
 8022cd2:	b083      	sub	sp, #12
 8022cd4:	ab02      	add	r3, sp, #8
	rf_write_reg(reg, &data, 1);
 8022cd6:	2201      	movs	r2, #1
void rf_write_reg_byte(int reg, char data) {
 8022cd8:	f803 1d01 	strb.w	r1, [r3, #-1]!
	rf_write_reg(reg, &data, 1);
 8022cdc:	4619      	mov	r1, r3
 8022cde:	f7ff ff77 	bl	8022bd0 <rf_write_reg>
}
 8022ce2:	b003      	add	sp, #12
 8022ce4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08022cf0 <rf_read_reg>:

void rf_read_reg(int reg, char *data, int len) {
 8022cf0:	b570      	push	{r4, r5, r6, lr}
 8022cf2:	b082      	sub	sp, #8
	char cmd = NRF_CMD_READ_REGISTER | reg;
 8022cf4:	ac02      	add	r4, sp, #8
void rf_read_reg(int reg, char *data, int len) {
 8022cf6:	460d      	mov	r5, r1
	char cmd = NRF_CMD_READ_REGISTER | reg;
 8022cf8:	f804 0d01 	strb.w	r0, [r4, #-1]!
void rf_read_reg(int reg, char *data, int len) {
 8022cfc:	4616      	mov	r6, r2

	spi_sw_begin();
 8022cfe:	f7ff fe5f 	bl	80229c0 <spi_sw_begin>
	spi_sw_transfer(0, &cmd, 1);
 8022d02:	4621      	mov	r1, r4
 8022d04:	2201      	movs	r2, #1
 8022d06:	2000      	movs	r0, #0
 8022d08:	f7ff fdb2 	bl	8022870 <spi_sw_transfer>
	spi_sw_transfer(data, 0, len);
 8022d0c:	4632      	mov	r2, r6
 8022d0e:	4628      	mov	r0, r5
 8022d10:	2100      	movs	r1, #0
 8022d12:	f7ff fdad 	bl	8022870 <spi_sw_transfer>
	spi_sw_end();
 8022d16:	f7ff fe73 	bl	8022a00 <spi_sw_end>
}
 8022d1a:	b002      	add	sp, #8
 8022d1c:	bd70      	pop	{r4, r5, r6, pc}
 8022d1e:	bf00      	nop

08022d20 <rf_set_speed>:
void rf_set_speed(NRF_SPEED speed) {
 8022d20:	b510      	push	{r4, lr}
 8022d22:	b082      	sub	sp, #8

char rf_read_reg_byte(int reg) {
	char result;
	rf_read_reg(reg, &result, 1);
 8022d24:	2201      	movs	r2, #1
void rf_set_speed(NRF_SPEED speed) {
 8022d26:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022d28:	f10d 0107 	add.w	r1, sp, #7
 8022d2c:	2006      	movs	r0, #6
 8022d2e:	f7ff ffdf 	bl	8022cf0 <rf_read_reg>
	return result;
 8022d32:	f89d 2007 	ldrb.w	r2, [sp, #7]
	reg_new &= ~(NRF_RF_SETUP_RF_DR_LOW | NRF_RF_SETUP_RF_DR_HIGH);
 8022d36:	f002 03d7 	and.w	r3, r2, #215	; 0xd7
	switch (speed) {
 8022d3a:	b184      	cbz	r4, 8022d5e <rf_set_speed+0x3e>
 8022d3c:	2c02      	cmp	r4, #2
 8022d3e:	d00b      	beq.n	8022d58 <rf_set_speed+0x38>
	if (reg_old != reg_new) {
 8022d40:	4293      	cmp	r3, r2
 8022d42:	d007      	beq.n	8022d54 <rf_set_speed+0x34>
	rf_write_reg(reg, &data, 1);
 8022d44:	f10d 0107 	add.w	r1, sp, #7
 8022d48:	2201      	movs	r2, #1
 8022d4a:	2006      	movs	r0, #6
 8022d4c:	f88d 3007 	strb.w	r3, [sp, #7]
 8022d50:	f7ff ff3e 	bl	8022bd0 <rf_write_reg>
}
 8022d54:	b002      	add	sp, #8
 8022d56:	bd10      	pop	{r4, pc}
		reg_new |= NRF_RF_SETUP_RF_DR_HIGH;
 8022d58:	f043 0308 	orr.w	r3, r3, #8
		break;
 8022d5c:	e7f0      	b.n	8022d40 <rf_set_speed+0x20>
		reg_new |= NRF_RF_SETUP_RF_DR_LOW;
 8022d5e:	f043 0320 	orr.w	r3, r3, #32
		break;
 8022d62:	e7ed      	b.n	8022d40 <rf_set_speed+0x20>
	...

08022d70 <rf_set_power>:
void rf_set_power(NRF_POWER power) {
 8022d70:	b510      	push	{r4, lr}
 8022d72:	b082      	sub	sp, #8
 8022d74:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022d76:	2201      	movs	r2, #1
 8022d78:	f10d 0107 	add.w	r1, sp, #7
 8022d7c:	2006      	movs	r0, #6
 8022d7e:	f7ff ffb7 	bl	8022cf0 <rf_read_reg>
	return result;
 8022d82:	f89d 2007 	ldrb.w	r2, [sp, #7]
	reg_new &= ~(NRF_RF_SETUP_RF_PWR | 1);
 8022d86:	f022 0307 	bic.w	r3, r2, #7
	reg_new |= (char)power << 1;
 8022d8a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
 8022d8e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	if (power == NRF_POWER_0DBM) {
 8022d92:	2c03      	cmp	r4, #3
		reg_new |= 1;
 8022d94:	bf08      	it	eq
 8022d96:	f043 0301 	orreq.w	r3, r3, #1
	if (reg_old != reg_new) {
 8022d9a:	4293      	cmp	r3, r2
 8022d9c:	d007      	beq.n	8022dae <rf_set_power+0x3e>
	rf_write_reg(reg, &data, 1);
 8022d9e:	f10d 0107 	add.w	r1, sp, #7
 8022da2:	2201      	movs	r2, #1
 8022da4:	2006      	movs	r0, #6
 8022da6:	f88d 3007 	strb.w	r3, [sp, #7]
 8022daa:	f7ff ff11 	bl	8022bd0 <rf_write_reg>
}
 8022dae:	b002      	add	sp, #8
 8022db0:	bd10      	pop	{r4, pc}
 8022db2:	bf00      	nop
	...

08022dc0 <rf_set_crc_type>:
void rf_set_crc_type(NRF_CRC crc_type) {
 8022dc0:	b510      	push	{r4, lr}
 8022dc2:	b082      	sub	sp, #8
 8022dc4:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022dc6:	2201      	movs	r2, #1
 8022dc8:	f10d 0107 	add.w	r1, sp, #7
 8022dcc:	2000      	movs	r0, #0
 8022dce:	f7ff ff8f 	bl	8022cf0 <rf_read_reg>
	return result;
 8022dd2:	f89d 2007 	ldrb.w	r2, [sp, #7]
	switch (crc_type) {
 8022dd6:	2c01      	cmp	r4, #1
	reg_new &= ~(NRF_CONFIG_CRCO | NRF_CONFIG_EN_CRC);
 8022dd8:	f002 03f3 	and.w	r3, r2, #243	; 0xf3
	switch (crc_type) {
 8022ddc:	d010      	beq.n	8022e00 <rf_set_crc_type+0x40>
 8022dde:	2c02      	cmp	r4, #2
 8022de0:	d00b      	beq.n	8022dfa <rf_set_crc_type+0x3a>
	if (reg_old != reg_new) {
 8022de2:	4293      	cmp	r3, r2
 8022de4:	d007      	beq.n	8022df6 <rf_set_crc_type+0x36>
	rf_write_reg(reg, &data, 1);
 8022de6:	f10d 0107 	add.w	r1, sp, #7
 8022dea:	2201      	movs	r2, #1
 8022dec:	2000      	movs	r0, #0
 8022dee:	f88d 3007 	strb.w	r3, [sp, #7]
 8022df2:	f7ff feed 	bl	8022bd0 <rf_write_reg>
}
 8022df6:	b002      	add	sp, #8
 8022df8:	bd10      	pop	{r4, pc}
		reg_new |= NRF_CONFIG_EN_CRC | NRF_CONFIG_CRCO;
 8022dfa:	f043 030c 	orr.w	r3, r3, #12
		break;
 8022dfe:	e7f0      	b.n	8022de2 <rf_set_crc_type+0x22>
		reg_new |= NRF_CONFIG_EN_CRC;
 8022e00:	f043 0308 	orr.w	r3, r3, #8
		break;
 8022e04:	e7ed      	b.n	8022de2 <rf_set_crc_type+0x22>
 8022e06:	bf00      	nop
	...

08022e10 <rf_set_retr_retries>:
void rf_set_retr_retries(int retries) {
 8022e10:	b510      	push	{r4, lr}
 8022e12:	b082      	sub	sp, #8
 8022e14:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022e16:	f10d 0107 	add.w	r1, sp, #7
 8022e1a:	2201      	movs	r2, #1
 8022e1c:	2004      	movs	r0, #4
 8022e1e:	f7ff ff67 	bl	8022cf0 <rf_read_reg>
	return result;
 8022e22:	f89d 2007 	ldrb.w	r2, [sp, #7]
	reg_new |= (char)retries & 0xF;
 8022e26:	f004 030f 	and.w	r3, r4, #15
	reg_new &= ~NRF_SETUP_RETR_ARC;
 8022e2a:	f022 010f 	bic.w	r1, r2, #15
	reg_new |= (char)retries & 0xF;
 8022e2e:	430b      	orrs	r3, r1
	if (reg_old != reg_new) {
 8022e30:	4293      	cmp	r3, r2
 8022e32:	d007      	beq.n	8022e44 <rf_set_retr_retries+0x34>
	rf_write_reg(reg, &data, 1);
 8022e34:	f10d 0107 	add.w	r1, sp, #7
 8022e38:	2201      	movs	r2, #1
 8022e3a:	2004      	movs	r0, #4
 8022e3c:	f88d 3007 	strb.w	r3, [sp, #7]
 8022e40:	f7ff fec6 	bl	8022bd0 <rf_write_reg>
}
 8022e44:	b002      	add	sp, #8
 8022e46:	bd10      	pop	{r4, pc}
	...

08022e50 <rf_set_retr_delay>:
void rf_set_retr_delay(NRF_RETR_DELAY delay) {
 8022e50:	b510      	push	{r4, lr}
 8022e52:	b082      	sub	sp, #8
 8022e54:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022e56:	2201      	movs	r2, #1
 8022e58:	f10d 0107 	add.w	r1, sp, #7
 8022e5c:	2004      	movs	r0, #4
 8022e5e:	f7ff ff47 	bl	8022cf0 <rf_read_reg>
	return result;
 8022e62:	f89d 2007 	ldrb.w	r2, [sp, #7]
	reg_new &= ~NRF_SETUP_RETR_ARD;
 8022e66:	f002 030f 	and.w	r3, r2, #15
	reg_new |= ((char)delay & 0xF) << 4;
 8022e6a:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8022e6e:	b2db      	uxtb	r3, r3
	if (reg_old != reg_new) {
 8022e70:	4293      	cmp	r3, r2
 8022e72:	d007      	beq.n	8022e84 <rf_set_retr_delay+0x34>
	rf_write_reg(reg, &data, 1);
 8022e74:	f10d 0107 	add.w	r1, sp, #7
 8022e78:	2201      	movs	r2, #1
 8022e7a:	2004      	movs	r0, #4
 8022e7c:	f88d 3007 	strb.w	r3, [sp, #7]
 8022e80:	f7ff fea6 	bl	8022bd0 <rf_write_reg>
}
 8022e84:	b002      	add	sp, #8
 8022e86:	bd10      	pop	{r4, pc}
	...

08022e90 <rf_power_up>:
void rf_power_up(void) {
 8022e90:	b500      	push	{lr}
 8022e92:	b083      	sub	sp, #12
	rf_read_reg(reg, &result, 1);
 8022e94:	2000      	movs	r0, #0
 8022e96:	f10d 0107 	add.w	r1, sp, #7
 8022e9a:	2201      	movs	r2, #1
 8022e9c:	f7ff ff28 	bl	8022cf0 <rf_read_reg>
	return result;
 8022ea0:	f89d 3007 	ldrb.w	r3, [sp, #7]
	if ((tmp & (NRF_CONFIG_PWR_UP)) != (NRF_CONFIG_PWR_UP)) {
 8022ea4:	f013 0002 	ands.w	r0, r3, #2
 8022ea8:	d108      	bne.n	8022ebc <rf_power_up+0x2c>
 8022eaa:	f043 0302 	orr.w	r3, r3, #2
	rf_write_reg(reg, &data, 1);
 8022eae:	f10d 0107 	add.w	r1, sp, #7
 8022eb2:	2201      	movs	r2, #1
 8022eb4:	f88d 3007 	strb.w	r3, [sp, #7]
 8022eb8:	f7ff fe8a 	bl	8022bd0 <rf_write_reg>
}
 8022ebc:	b003      	add	sp, #12
 8022ebe:	f85d fb04 	ldr.w	pc, [sp], #4
 8022ec2:	bf00      	nop
	...

08022ed0 <rf_power_down>:
void rf_power_down(void) {
 8022ed0:	b500      	push	{lr}
 8022ed2:	b083      	sub	sp, #12
	rf_read_reg(reg, &result, 1);
 8022ed4:	2201      	movs	r2, #1
 8022ed6:	f10d 0107 	add.w	r1, sp, #7
 8022eda:	2000      	movs	r0, #0
 8022edc:	f7ff ff08 	bl	8022cf0 <rf_read_reg>
	return result;
 8022ee0:	f89d 3007 	ldrb.w	r3, [sp, #7]
	if (tmp & (NRF_CONFIG_PWR_UP)) {
 8022ee4:	079a      	lsls	r2, r3, #30
 8022ee6:	d509      	bpl.n	8022efc <rf_power_down+0x2c>
		tmp &= ~(NRF_CONFIG_PWR_UP);
 8022ee8:	f023 0302 	bic.w	r3, r3, #2
	rf_write_reg(reg, &data, 1);
 8022eec:	f10d 0107 	add.w	r1, sp, #7
 8022ef0:	2201      	movs	r2, #1
 8022ef2:	2000      	movs	r0, #0
		rf_write_reg_byte(NRF_REG_CONFIG, tmp);	//Update if we need
 8022ef4:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 8022ef8:	f7ff fe6a 	bl	8022bd0 <rf_write_reg>
}
 8022efc:	b003      	add	sp, #12
 8022efe:	f85d fb04 	ldr.w	pc, [sp], #4
 8022f02:	bf00      	nop
	...

08022f10 <rf_mode_tx>:
void rf_mode_tx(void) {
 8022f10:	b500      	push	{lr}
 8022f12:	b083      	sub	sp, #12
	rf_read_reg(reg, &result, 1);
 8022f14:	2201      	movs	r2, #1
 8022f16:	f10d 0107 	add.w	r1, sp, #7
 8022f1a:	2000      	movs	r0, #0
 8022f1c:	f7ff fee8 	bl	8022cf0 <rf_read_reg>
	return result;
 8022f20:	f89d 3007 	ldrb.w	r3, [sp, #7]
	if (tmp & (NRF_CONFIG_PRIM_RX)) {
 8022f24:	07da      	lsls	r2, r3, #31
 8022f26:	d509      	bpl.n	8022f3c <rf_mode_tx+0x2c>
		tmp &= ~(NRF_CONFIG_PRIM_RX);
 8022f28:	f023 0301 	bic.w	r3, r3, #1
	rf_write_reg(reg, &data, 1);
 8022f2c:	f10d 0107 	add.w	r1, sp, #7
 8022f30:	2201      	movs	r2, #1
 8022f32:	2000      	movs	r0, #0
		rf_write_reg_byte(NRF_REG_CONFIG, tmp);	//Update if we need
 8022f34:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 8022f38:	f7ff fe4a 	bl	8022bd0 <rf_write_reg>
}
 8022f3c:	b003      	add	sp, #12
 8022f3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8022f42:	bf00      	nop
	...

08022f50 <rf_mode_rx>:
void rf_mode_rx(void) {
 8022f50:	b500      	push	{lr}
 8022f52:	b083      	sub	sp, #12
	rf_read_reg(reg, &result, 1);
 8022f54:	2000      	movs	r0, #0
 8022f56:	f10d 0107 	add.w	r1, sp, #7
 8022f5a:	2201      	movs	r2, #1
 8022f5c:	f7ff fec8 	bl	8022cf0 <rf_read_reg>
	return result;
 8022f60:	f89d 3007 	ldrb.w	r3, [sp, #7]
	if ((tmp & (NRF_CONFIG_PRIM_RX)) != (NRF_CONFIG_PRIM_RX)) {
 8022f64:	f013 0001 	ands.w	r0, r3, #1
 8022f68:	d108      	bne.n	8022f7c <rf_mode_rx+0x2c>
 8022f6a:	f043 0301 	orr.w	r3, r3, #1
	rf_write_reg(reg, &data, 1);
 8022f6e:	f10d 0107 	add.w	r1, sp, #7
 8022f72:	2201      	movs	r2, #1
 8022f74:	f88d 3007 	strb.w	r3, [sp, #7]
 8022f78:	f7ff fe2a 	bl	8022bd0 <rf_write_reg>
}
 8022f7c:	b003      	add	sp, #12
 8022f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8022f82:	bf00      	nop
	...

08022f90 <rf_enable_pipe_autoack>:
void rf_enable_pipe_autoack(int pipes) {
 8022f90:	b510      	push	{r4, lr}
	rf_read_reg(reg, &result, 1);
 8022f92:	2201      	movs	r2, #1
void rf_enable_pipe_autoack(int pipes) {
 8022f94:	b082      	sub	sp, #8
 8022f96:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022f98:	f10d 0107 	add.w	r1, sp, #7
 8022f9c:	4610      	mov	r0, r2
 8022f9e:	f7ff fea7 	bl	8022cf0 <rf_read_reg>
	return result;
 8022fa2:	f89d 0007 	ldrb.w	r0, [sp, #7]
	if ((tmp & (pipes)) != (pipes)) {
 8022fa6:	ea34 0300 	bics.w	r3, r4, r0
 8022faa:	d009      	beq.n	8022fc0 <rf_enable_pipe_autoack+0x30>
	rf_write_reg(reg, &data, 1);
 8022fac:	2201      	movs	r2, #1
		tmp |= (pipes);
 8022fae:	ea40 0304 	orr.w	r3, r0, r4
	rf_write_reg(reg, &data, 1);
 8022fb2:	f10d 0107 	add.w	r1, sp, #7
 8022fb6:	4610      	mov	r0, r2
		rf_write_reg_byte(NRF_REG_EN_AA, tmp);	//Update if we need
 8022fb8:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 8022fbc:	f7ff fe08 	bl	8022bd0 <rf_write_reg>
}
 8022fc0:	b002      	add	sp, #8
 8022fc2:	bd10      	pop	{r4, pc}
	...

08022fd0 <rf_enable_pipe_address>:
void rf_enable_pipe_address(int pipes) {
 8022fd0:	b510      	push	{r4, lr}
 8022fd2:	b082      	sub	sp, #8
 8022fd4:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8022fd6:	f10d 0107 	add.w	r1, sp, #7
 8022fda:	2002      	movs	r0, #2
 8022fdc:	2201      	movs	r2, #1
 8022fde:	f7ff fe87 	bl	8022cf0 <rf_read_reg>
	return result;
 8022fe2:	f89d 0007 	ldrb.w	r0, [sp, #7]
	if ((tmp & (pipes)) != (pipes)) {
 8022fe6:	ea34 0300 	bics.w	r3, r4, r0
 8022fea:	d009      	beq.n	8023000 <rf_enable_pipe_address+0x30>
		tmp |= (pipes);
 8022fec:	ea40 0304 	orr.w	r3, r0, r4
	rf_write_reg(reg, &data, 1);
 8022ff0:	f10d 0107 	add.w	r1, sp, #7
 8022ff4:	2201      	movs	r2, #1
 8022ff6:	2002      	movs	r0, #2
		rf_write_reg_byte(NRF_REG_EN_RXADDR, tmp);	//Update if we need
 8022ff8:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 8022ffc:	f7ff fde8 	bl	8022bd0 <rf_write_reg>
}
 8023000:	b002      	add	sp, #8
 8023002:	bd10      	pop	{r4, pc}
	...

08023010 <rf_enable_pipe_dlp>:
void rf_enable_pipe_dlp(int pipes) {
 8023010:	b510      	push	{r4, lr}
 8023012:	b082      	sub	sp, #8
 8023014:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8023016:	f10d 0107 	add.w	r1, sp, #7
 802301a:	201c      	movs	r0, #28
 802301c:	2201      	movs	r2, #1
 802301e:	f7ff fe67 	bl	8022cf0 <rf_read_reg>
	return result;
 8023022:	f89d 0007 	ldrb.w	r0, [sp, #7]
	if ((tmp & (pipes)) != (pipes)) {
 8023026:	ea34 0300 	bics.w	r3, r4, r0
 802302a:	d009      	beq.n	8023040 <rf_enable_pipe_dlp+0x30>
		tmp |= (pipes);
 802302c:	ea40 0304 	orr.w	r3, r0, r4
	rf_write_reg(reg, &data, 1);
 8023030:	f10d 0107 	add.w	r1, sp, #7
 8023034:	2201      	movs	r2, #1
 8023036:	201c      	movs	r0, #28
		rf_write_reg_byte(NRF_REG_DYNPD, tmp);	//Update if we need
 8023038:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 802303c:	f7ff fdc8 	bl	8022bd0 <rf_write_reg>
}
 8023040:	b002      	add	sp, #8
 8023042:	bd10      	pop	{r4, pc}
	...

08023050 <rf_enable_features>:
void rf_enable_features(int features) {
 8023050:	b510      	push	{r4, lr}
 8023052:	b082      	sub	sp, #8
 8023054:	4604      	mov	r4, r0
	rf_read_reg(reg, &result, 1);
 8023056:	f10d 0107 	add.w	r1, sp, #7
 802305a:	201d      	movs	r0, #29
 802305c:	2201      	movs	r2, #1
 802305e:	f7ff fe47 	bl	8022cf0 <rf_read_reg>
	return result;
 8023062:	f89d 0007 	ldrb.w	r0, [sp, #7]
	if ((tmp & (features)) != (features)) {
 8023066:	ea34 0300 	bics.w	r3, r4, r0
 802306a:	d009      	beq.n	8023080 <rf_enable_features+0x30>
		tmp |= (features);
 802306c:	ea40 0304 	orr.w	r3, r0, r4
	rf_write_reg(reg, &data, 1);
 8023070:	f10d 0107 	add.w	r1, sp, #7
 8023074:	2201      	movs	r2, #1
 8023076:	201d      	movs	r0, #29
		rf_write_reg_byte(NRF_REG_FEATURE, tmp);	//Update if we need
 8023078:	f88d 3007 	strb.w	r3, [sp, #7]
	rf_write_reg(reg, &data, 1);
 802307c:	f7ff fda8 	bl	8022bd0 <rf_write_reg>
}
 8023080:	b002      	add	sp, #8
 8023082:	bd10      	pop	{r4, pc}
	...

08023090 <rfhelp_init>:
 * @return
 * true: Writing an address and reading it back worked.
 * false: Writing an address and reading it failed. This means that something
 * is wrong with the SPI communication.
 */
bool rfhelp_init(void) {
 8023090:	b570      	push	{r4, r5, r6, lr}
	chMtxObjectInit(&rf_mutex);
 8023092:	482a      	ldr	r0, [pc, #168]	; (802313c <rfhelp_init+0xac>)
	rf_init();

//	address_length = rf_get_address_width();
	address_length = 3; // We assume length 3
 8023094:	4e2a      	ldr	r6, [pc, #168]	; (8023140 <rfhelp_init+0xb0>)
bool rfhelp_init(void) {
 8023096:	b084      	sub	sp, #16
	address_length = 3; // We assume length 3
 8023098:	2403      	movs	r4, #3
	chMtxObjectInit(&rf_mutex);
 802309a:	f7ea fdd9 	bl	800dc50 <chMtxObjectInit>
	rf_init();
 802309e:	f7ff fccf 	bl	8022a40 <rf_init>
		address_length = 3;
	}

	// Try a read and write to see if the SPI communication works
	char addr_old[3];
	rf_read_reg(NRF_REG_TX_ADDR, addr_old, 3);
 80230a2:	4622      	mov	r2, r4
 80230a4:	a901      	add	r1, sp, #4
 80230a6:	2010      	movs	r0, #16
	address_length = 3; // We assume length 3
 80230a8:	6034      	str	r4, [r6, #0]
	rf_read_reg(NRF_REG_TX_ADDR, addr_old, 3);
 80230aa:	f7ff fe21 	bl	8022cf0 <rf_read_reg>
	char addr_test[3] = {0x12, 0x41, 0xF3};
 80230ae:	4b25      	ldr	r3, [pc, #148]	; (8023144 <rfhelp_init+0xb4>)
 80230b0:	681b      	ldr	r3, [r3, #0]
 80230b2:	f8ad 3008 	strh.w	r3, [sp, #8]
	rf_write_reg(NRF_REG_TX_ADDR, addr_test, 3);
 80230b6:	4622      	mov	r2, r4
	char addr_test[3] = {0x12, 0x41, 0xF3};
 80230b8:	0c1b      	lsrs	r3, r3, #16
	rf_write_reg(NRF_REG_TX_ADDR, addr_test, 3);
 80230ba:	a902      	add	r1, sp, #8
 80230bc:	2010      	movs	r0, #16
	char addr_test[3] = {0x12, 0x41, 0xF3};
 80230be:	f88d 300a 	strb.w	r3, [sp, #10]
	rf_write_reg(NRF_REG_TX_ADDR, addr_test, 3);
 80230c2:	f7ff fd85 	bl	8022bd0 <rf_write_reg>
	char addr_test_read[3];
	rf_read_reg(NRF_REG_TX_ADDR, addr_test_read, 3);
 80230c6:	4622      	mov	r2, r4
 80230c8:	a903      	add	r1, sp, #12
 80230ca:	2010      	movs	r0, #16
 80230cc:	f7ff fe10 	bl	8022cf0 <rf_read_reg>
	rf_write_reg(NRF_REG_TX_ADDR, addr_old, 3);
 80230d0:	4622      	mov	r2, r4
 80230d2:	a901      	add	r1, sp, #4
 80230d4:	2010      	movs	r0, #16
 80230d6:	f7ff fd7b 	bl	8022bd0 <rf_write_reg>

	if (memcmp(addr_test, addr_test_read, 3) != 0) {
 80230da:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 80230de:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80230e2:	429a      	cmp	r2, r3
 80230e4:	d004      	beq.n	80230f0 <rfhelp_init+0x60>
		rf_stop();
 80230e6:	f7ff fcb3 	bl	8022a50 <rf_stop>
		return false;
 80230ea:	2000      	movs	r0, #0
	// that nrf_conf is already set when rfhelp_restart is called.

	init_done = true;

	return true;
}
 80230ec:	b004      	add	sp, #16
 80230ee:	bd70      	pop	{r4, r5, r6, pc}
	if (memcmp(addr_test, addr_test_read, 3) != 0) {
 80230f0:	f89d 200a 	ldrb.w	r2, [sp, #10]
 80230f4:	f89d 300e 	ldrb.w	r3, [sp, #14]
 80230f8:	429a      	cmp	r2, r3
 80230fa:	d1f4      	bne.n	80230e6 <rfhelp_init+0x56>
 80230fc:	4d12      	ldr	r5, [pc, #72]	; (8023148 <rfhelp_init+0xb8>)
 80230fe:	240a      	movs	r4, #10
		rf_read_reg(NRF_REG_RX_ADDR_P0 + i, rx_addr[i], address_length);
 8023100:	4629      	mov	r1, r5
 8023102:	4620      	mov	r0, r4
 8023104:	6832      	ldr	r2, [r6, #0]
 8023106:	3401      	adds	r4, #1
 8023108:	f7ff fdf2 	bl	8022cf0 <rf_read_reg>
	for (int i = 0;i < 6;i++) {
 802310c:	2c10      	cmp	r4, #16
 802310e:	f105 0505 	add.w	r5, r5, #5
 8023112:	d1f5      	bne.n	8023100 <rfhelp_init+0x70>
	rf_read_reg(NRF_REG_TX_ADDR, tx_addr, address_length);
 8023114:	4620      	mov	r0, r4
 8023116:	6832      	ldr	r2, [r6, #0]
 8023118:	490c      	ldr	r1, [pc, #48]	; (802314c <rfhelp_init+0xbc>)
 802311a:	f7ff fde9 	bl	8022cf0 <rf_read_reg>
	tx_pipe0_addr_eq = memcmp(rx_addr[0], tx_addr, address_length) == 0;
 802311e:	6832      	ldr	r2, [r6, #0]
 8023120:	490a      	ldr	r1, [pc, #40]	; (802314c <rfhelp_init+0xbc>)
 8023122:	4809      	ldr	r0, [pc, #36]	; (8023148 <rfhelp_init+0xb8>)
 8023124:	f003 fd44 	bl	8026bb0 <memcmp>
 8023128:	4909      	ldr	r1, [pc, #36]	; (8023150 <rfhelp_init+0xc0>)
	init_done = true;
 802312a:	4a0a      	ldr	r2, [pc, #40]	; (8023154 <rfhelp_init+0xc4>)
	tx_pipe0_addr_eq = memcmp(rx_addr[0], tx_addr, address_length) == 0;
 802312c:	fab0 f380 	clz	r3, r0
 8023130:	095b      	lsrs	r3, r3, #5
	init_done = true;
 8023132:	2001      	movs	r0, #1
	tx_pipe0_addr_eq = memcmp(rx_addr[0], tx_addr, address_length) == 0;
 8023134:	700b      	strb	r3, [r1, #0]
	init_done = true;
 8023136:	7010      	strb	r0, [r2, #0]
}
 8023138:	b004      	add	sp, #16
 802313a:	bd70      	pop	{r4, r5, r6, pc}
 802313c:	20010af8 	.word	0x20010af8
 8023140:	20010ae4 	.word	0x20010ae4
 8023144:	0802d920 	.word	0x0802d920
 8023148:	20010b08 	.word	0x20010b08
 802314c:	20010b28 	.word	0x20010b28
 8023150:	20010b2d 	.word	0x20010b2d
 8023154:	20010ae8 	.word	0x20010ae8
	...

08023160 <rfhelp_stop>:

void rfhelp_stop(void) {
 8023160:	b508      	push	{r3, lr}
	rf_stop();
 8023162:	f7ff fc75 	bl	8022a50 <rf_stop>
	init_done = false;
 8023166:	4b02      	ldr	r3, [pc, #8]	; (8023170 <rfhelp_stop+0x10>)
 8023168:	2200      	movs	r2, #0
 802316a:	701a      	strb	r2, [r3, #0]
}
 802316c:	bd08      	pop	{r3, pc}
 802316e:	bf00      	nop
 8023170:	20010ae8 	.word	0x20010ae8
	...

08023180 <rfhelp_restart>:
}

/**
 * Re-init the rf chip
 */
void rfhelp_restart(void) {
 8023180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	chMtxLock(&rf_mutex);
 8023182:	4e2b      	ldr	r6, [pc, #172]	; (8023230 <rfhelp_restart+0xb0>)
	// TODO: make this file consistent with multiple
	// rx_addr and tx_addr, and the rest in general.
	rf_write_reg_byte(NRF_REG_EN_RXADDR, 0);
	rf_write_reg_byte(NRF_REG_DYNPD, 0);

	rf_set_crc_type(nrf_conf.crc_type);
 8023184:	4c2b      	ldr	r4, [pc, #172]	; (8023234 <rfhelp_restart+0xb4>)
	rf_enable_pipe_autoack(NRF_MASK_PIPE0);
	rf_enable_pipe_address(NRF_MASK_PIPE0);
	rf_enable_pipe_dlp(NRF_MASK_PIPE0);

	memcpy(tx_addr, nrf_conf.address, 3);
	memcpy(rx_addr[0], nrf_conf.address, 3);
 8023186:	4d2c      	ldr	r5, [pc, #176]	; (8023238 <rfhelp_restart+0xb8>)
	tx_pipe0_addr_eq = true;

	rf_set_tx_addr(tx_addr, address_length);
 8023188:	4f2c      	ldr	r7, [pc, #176]	; (802323c <rfhelp_restart+0xbc>)
	chMtxLock(&rf_mutex);
 802318a:	4630      	mov	r0, r6
 802318c:	f7ea fdd0 	bl	800dd30 <chMtxLock>
	rf_power_down();
 8023190:	f7ff fe9e 	bl	8022ed0 <rf_power_down>
	rf_write_reg_byte(NRF_REG_EN_RXADDR, 0);
 8023194:	2100      	movs	r1, #0
 8023196:	2002      	movs	r0, #2
 8023198:	f7ff fd9a 	bl	8022cd0 <rf_write_reg_byte>
	rf_write_reg_byte(NRF_REG_DYNPD, 0);
 802319c:	2100      	movs	r1, #0
 802319e:	201c      	movs	r0, #28
 80231a0:	f7ff fd96 	bl	8022cd0 <rf_write_reg_byte>
	rf_set_crc_type(nrf_conf.crc_type);
 80231a4:	78a0      	ldrb	r0, [r4, #2]
 80231a6:	f7ff fe0b 	bl	8022dc0 <rf_set_crc_type>
	rf_set_retr_retries(nrf_conf.retries);
 80231aa:	7920      	ldrb	r0, [r4, #4]
 80231ac:	f7ff fe30 	bl	8022e10 <rf_set_retr_retries>
	rf_set_retr_delay(nrf_conf.retry_delay);
 80231b0:	78e0      	ldrb	r0, [r4, #3]
 80231b2:	f7ff fe4d 	bl	8022e50 <rf_set_retr_delay>
	rf_set_power(nrf_conf.power);
 80231b6:	7860      	ldrb	r0, [r4, #1]
 80231b8:	f7ff fdda 	bl	8022d70 <rf_set_power>
	rf_set_speed(nrf_conf.speed);
 80231bc:	7820      	ldrb	r0, [r4, #0]
 80231be:	f7ff fdaf 	bl	8022d20 <rf_set_speed>
	rf_set_address_width(NRF_AW_3); // Always use 3 byte address
 80231c2:	2000      	movs	r0, #0
 80231c4:	f7ff fd34 	bl	8022c30 <rf_set_address_width>
	rf_set_frequency(2400 + (unsigned int)nrf_conf.channel);
 80231c8:	7960      	ldrb	r0, [r4, #5]
 80231ca:	f500 6016 	add.w	r0, r0, #2400	; 0x960
 80231ce:	f7ff fd3f 	bl	8022c50 <rf_set_frequency>
	rf_enable_features(NRF_FEATURE_DPL | NRF_FEATURE_DYN_ACK);
 80231d2:	2005      	movs	r0, #5
 80231d4:	f7ff ff3c 	bl	8023050 <rf_enable_features>
	rf_enable_pipe_autoack(NRF_MASK_PIPE0);
 80231d8:	2001      	movs	r0, #1
 80231da:	f7ff fed9 	bl	8022f90 <rf_enable_pipe_autoack>
	rf_enable_pipe_address(NRF_MASK_PIPE0);
 80231de:	2001      	movs	r0, #1
 80231e0:	f7ff fef6 	bl	8022fd0 <rf_enable_pipe_address>
	rf_enable_pipe_dlp(NRF_MASK_PIPE0);
 80231e4:	2001      	movs	r0, #1
 80231e6:	f7ff ff13 	bl	8023010 <rf_enable_pipe_dlp>
	memcpy(tx_addr, nrf_conf.address, 3);
 80231ea:	f834 3f06 	ldrh.w	r3, [r4, #6]!
 80231ee:	4814      	ldr	r0, [pc, #80]	; (8023240 <rfhelp_restart+0xc0>)
	tx_pipe0_addr_eq = true;
 80231f0:	f8df c050 	ldr.w	ip, [pc, #80]	; 8023244 <rfhelp_restart+0xc4>
	memcpy(tx_addr, nrf_conf.address, 3);
 80231f4:	78a2      	ldrb	r2, [r4, #2]
 80231f6:	8003      	strh	r3, [r0, #0]
	rf_set_tx_addr(tx_addr, address_length);
 80231f8:	6839      	ldr	r1, [r7, #0]
	memcpy(tx_addr, nrf_conf.address, 3);
 80231fa:	7082      	strb	r2, [r0, #2]
	memcpy(rx_addr[0], nrf_conf.address, 3);
 80231fc:	70aa      	strb	r2, [r5, #2]
	tx_pipe0_addr_eq = true;
 80231fe:	2201      	movs	r2, #1
	memcpy(rx_addr[0], nrf_conf.address, 3);
 8023200:	802b      	strh	r3, [r5, #0]
	tx_pipe0_addr_eq = true;
 8023202:	f88c 2000 	strb.w	r2, [ip]
	rf_set_tx_addr(tx_addr, address_length);
 8023206:	f7ff fd0b 	bl	8022c20 <rf_set_tx_addr>
	rf_set_rx_addr(0, rx_addr[0], address_length);
 802320a:	683a      	ldr	r2, [r7, #0]
 802320c:	4629      	mov	r1, r5
 802320e:	2000      	movs	r0, #0
 8023210:	f7ff fcfe 	bl	8022c10 <rf_set_rx_addr>

	rf_power_up();
 8023214:	f7ff fe3c 	bl	8022e90 <rf_power_up>
	rf_mode_rx();
 8023218:	f7ff fe9a 	bl	8022f50 <rf_mode_rx>
	rf_flush_all();
 802321c:	f7ff fc98 	bl	8022b50 <rf_flush_all>
	rf_clear_irq();
 8023220:	f7ff fd26 	bl	8022c70 <rf_clear_irq>

	chMtxUnlock(&rf_mutex);
 8023224:	4630      	mov	r0, r6
}
 8023226:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	chMtxUnlock(&rf_mutex);
 802322a:	f7ea bd91 	b.w	800dd50 <chMtxUnlock>
 802322e:	bf00      	nop
 8023230:	20010af8 	.word	0x20010af8
 8023234:	20010aec 	.word	0x20010aec
 8023238:	20010b08 	.word	0x20010b08
 802323c:	20010ae4 	.word	0x20010ae4
 8023240:	20010b28 	.word	0x20010b28
 8023244:	20010b2d 	.word	0x20010b2d
	...

08023250 <rfhelp_update_conf>:
void rfhelp_update_conf(nrf_config *conf) {
 8023250:	4602      	mov	r2, r0
	nrf_conf = *conf;
 8023252:	4b07      	ldr	r3, [pc, #28]	; (8023270 <rfhelp_update_conf+0x20>)
 8023254:	6851      	ldr	r1, [r2, #4]
 8023256:	6800      	ldr	r0, [r0, #0]
void rfhelp_update_conf(nrf_config *conf) {
 8023258:	b430      	push	{r4, r5}
	if (init_done) {
 802325a:	4d06      	ldr	r5, [pc, #24]	; (8023274 <rfhelp_update_conf+0x24>)
	nrf_conf = *conf;
 802325c:	8914      	ldrh	r4, [r2, #8]
	if (init_done) {
 802325e:	782a      	ldrb	r2, [r5, #0]
	nrf_conf = *conf;
 8023260:	c303      	stmia	r3!, {r0, r1}
 8023262:	801c      	strh	r4, [r3, #0]
	if (init_done) {
 8023264:	b90a      	cbnz	r2, 802326a <rfhelp_update_conf+0x1a>
}
 8023266:	bc30      	pop	{r4, r5}
 8023268:	4770      	bx	lr
 802326a:	bc30      	pop	{r4, r5}
		rfhelp_restart();
 802326c:	f7ff bf88 	b.w	8023180 <rfhelp_restart>
 8023270:	20010aec 	.word	0x20010aec
 8023274:	20010ae8 	.word	0x20010ae8
	...

08023280 <rfhelp_send_data>:
 * @return
 * 0: Send OK.
 * -1: Max RT.
 * -2: Timeout
 */
int rfhelp_send_data(char *data, int len, bool ack) {
 8023280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	rf_mode_tx();
	rf_clear_irq();
	rf_flush_all();

	// Pipe0-address and tx-address must be equal for ack to work.
	if (!tx_pipe0_addr_eq && ack) {
 8023282:	4e25      	ldr	r6, [pc, #148]	; (8023318 <rfhelp_send_data+0x98>)
int rfhelp_send_data(char *data, int len, bool ack) {
 8023284:	4604      	mov	r4, r0
	chMtxLock(&rf_mutex);
 8023286:	4825      	ldr	r0, [pc, #148]	; (802331c <rfhelp_send_data+0x9c>)
int rfhelp_send_data(char *data, int len, bool ack) {
 8023288:	460d      	mov	r5, r1
 802328a:	4617      	mov	r7, r2
	chMtxLock(&rf_mutex);
 802328c:	f7ea fd50 	bl	800dd30 <chMtxLock>
	rf_mode_tx();
 8023290:	f7ff fe3e 	bl	8022f10 <rf_mode_tx>
	rf_clear_irq();
 8023294:	f7ff fcec 	bl	8022c70 <rf_clear_irq>
	rf_flush_all();
 8023298:	f7ff fc5a 	bl	8022b50 <rf_flush_all>
	if (!tx_pipe0_addr_eq && ack) {
 802329c:	7830      	ldrb	r0, [r6, #0]
 802329e:	bb10      	cbnz	r0, 80232e6 <rfhelp_send_data+0x66>
 80232a0:	bb6f      	cbnz	r7, 80232fe <rfhelp_send_data+0x7e>
	}

	if (ack) {
		rf_write_tx_payload(data, len);
	} else {
		rf_write_tx_payload_no_ack(data, len);
 80232a2:	4629      	mov	r1, r5
 80232a4:	4620      	mov	r0, r4
 80232a6:	f7ff fbf3 	bl	8022a90 <rf_write_tx_payload_no_ack>
int rfhelp_send_data(char *data, int len, bool ack) {
 80232aa:	253c      	movs	r5, #60	; 0x3c
 80232ac:	e003      	b.n	80232b6 <rfhelp_send_data+0x36>
		timeout--;

		if (NRF_STATUS_GET_TX_DS(s)) {
			retval = 0;
			break;
		} else if (NRF_STATUS_GET_MAX_RT(s)) {
 80232ae:	06e3      	lsls	r3, r4, #27
 80232b0:	d420      	bmi.n	80232f4 <rfhelp_send_data+0x74>
			rf_clear_maxrt_irq();
			retval = -1;
			break;
		} else if (timeout == 0) {
 80232b2:	3d01      	subs	r5, #1
 80232b4:	d02d      	beq.n	8023312 <rfhelp_send_data+0x92>
		int s = rf_status();
 80232b6:	f7ff fc73 	bl	8022ba0 <rf_status>
 80232ba:	4604      	mov	r4, r0
		chThdSleepMilliseconds(1);
 80232bc:	200a      	movs	r0, #10
 80232be:	f7ea fb8f 	bl	800d9e0 <chThdSleep>
		if (NRF_STATUS_GET_TX_DS(s)) {
 80232c2:	06a2      	lsls	r2, r4, #26
 80232c4:	d5f3      	bpl.n	80232ae <rfhelp_send_data+0x2e>
			retval = 0;
 80232c6:	2400      	movs	r4, #0
			break;
		}
	}

	// Restore pipe0 address
	if (!tx_pipe0_addr_eq && ack) {
 80232c8:	7830      	ldrb	r0, [r6, #0]
 80232ca:	b928      	cbnz	r0, 80232d8 <rfhelp_send_data+0x58>
 80232cc:	b127      	cbz	r7, 80232d8 <rfhelp_send_data+0x58>
		rf_set_rx_addr(0, rx_addr[0], address_length);
 80232ce:	4b14      	ldr	r3, [pc, #80]	; (8023320 <rfhelp_send_data+0xa0>)
 80232d0:	4914      	ldr	r1, [pc, #80]	; (8023324 <rfhelp_send_data+0xa4>)
 80232d2:	681a      	ldr	r2, [r3, #0]
 80232d4:	f7ff fc9c 	bl	8022c10 <rf_set_rx_addr>
	}

	rf_mode_rx();
 80232d8:	f7ff fe3a 	bl	8022f50 <rf_mode_rx>

	chMtxUnlock(&rf_mutex);
 80232dc:	480f      	ldr	r0, [pc, #60]	; (802331c <rfhelp_send_data+0x9c>)
 80232de:	f7ea fd37 	bl	800dd50 <chMtxUnlock>

	return retval;
}
 80232e2:	4620      	mov	r0, r4
 80232e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (ack) {
 80232e6:	2f00      	cmp	r7, #0
 80232e8:	d0db      	beq.n	80232a2 <rfhelp_send_data+0x22>
		rf_write_tx_payload(data, len);
 80232ea:	4629      	mov	r1, r5
 80232ec:	4620      	mov	r0, r4
 80232ee:	f7ff fbb7 	bl	8022a60 <rf_write_tx_payload>
 80232f2:	e7da      	b.n	80232aa <rfhelp_send_data+0x2a>
			rf_clear_maxrt_irq();
 80232f4:	f7ff fcdc 	bl	8022cb0 <rf_clear_maxrt_irq>
			retval = -1;
 80232f8:	f04f 34ff 	mov.w	r4, #4294967295
			break;
 80232fc:	e7e4      	b.n	80232c8 <rfhelp_send_data+0x48>
		rf_set_rx_addr(0, tx_addr, address_length);
 80232fe:	4b08      	ldr	r3, [pc, #32]	; (8023320 <rfhelp_send_data+0xa0>)
 8023300:	4909      	ldr	r1, [pc, #36]	; (8023328 <rfhelp_send_data+0xa8>)
 8023302:	681a      	ldr	r2, [r3, #0]
 8023304:	f7ff fc84 	bl	8022c10 <rf_set_rx_addr>
		rf_write_tx_payload(data, len);
 8023308:	4629      	mov	r1, r5
 802330a:	4620      	mov	r0, r4
 802330c:	f7ff fba8 	bl	8022a60 <rf_write_tx_payload>
 8023310:	e7cb      	b.n	80232aa <rfhelp_send_data+0x2a>
			retval = -2;
 8023312:	f06f 0401 	mvn.w	r4, #1
 8023316:	e7d7      	b.n	80232c8 <rfhelp_send_data+0x48>
 8023318:	20010b2d 	.word	0x20010b2d
 802331c:	20010af8 	.word	0x20010af8
 8023320:	20010ae4 	.word	0x20010ae4
 8023324:	20010b08 	.word	0x20010b08
 8023328:	20010b28 	.word	0x20010b28
 802332c:	00000000 	.word	0x00000000

08023330 <rfhelp_send_data_crc>:
 * @return
 * 0: Send OK.
 * -1: Max RT.
 * -2: Timeout
 */
int rfhelp_send_data_crc(char *data, int len) {
 8023330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char buffer[len + 2];
 8023332:	f101 0309 	add.w	r3, r1, #9
 8023336:	f023 0307 	bic.w	r3, r3, #7
int rfhelp_send_data_crc(char *data, int len) {
 802333a:	af00      	add	r7, sp, #0
	char buffer[len + 2];
 802333c:	ebad 0d03 	sub.w	sp, sp, r3
int rfhelp_send_data_crc(char *data, int len) {
 8023340:	460c      	mov	r4, r1
 8023342:	4606      	mov	r6, r0
	unsigned short crc = crc16((unsigned char*)data, len);
 8023344:	f7ee fe14 	bl	8011f70 <crc16>

	memcpy(buffer, data, len);
 8023348:	4622      	mov	r2, r4
	unsigned short crc = crc16((unsigned char*)data, len);
 802334a:	4605      	mov	r5, r0
	memcpy(buffer, data, len);
 802334c:	4631      	mov	r1, r6
 802334e:	4668      	mov	r0, sp
 8023350:	f7e9 fbe6 	bl	800cb20 <memcpy>
	buffer[len] = (char)(crc >> 8);
	buffer[len + 1] = (char)(crc & 0xFF);
 8023354:	eb0d 0304 	add.w	r3, sp, r4

	return rfhelp_send_data(buffer, len + 2, nrf_conf.send_crc_ack);
 8023358:	4a05      	ldr	r2, [pc, #20]	; (8023370 <rfhelp_send_data_crc+0x40>)
	buffer[len] = (char)(crc >> 8);
 802335a:	0a28      	lsrs	r0, r5, #8
 802335c:	f80d 0004 	strb.w	r0, [sp, r4]
	char buffer[len + 2];
 8023360:	1ca1      	adds	r1, r4, #2
	return rfhelp_send_data(buffer, len + 2, nrf_conf.send_crc_ack);
 8023362:	7a52      	ldrb	r2, [r2, #9]
	buffer[len + 1] = (char)(crc & 0xFF);
 8023364:	705d      	strb	r5, [r3, #1]
	return rfhelp_send_data(buffer, len + 2, nrf_conf.send_crc_ack);
 8023366:	4668      	mov	r0, sp
 8023368:	f7ff ff8a 	bl	8023280 <rfhelp_send_data>
}
 802336c:	46bd      	mov	sp, r7
 802336e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023370:	20010aec 	.word	0x20010aec
	...

08023380 <rfhelp_read_rx_data>:
 * 1: Read OK, more data to read.
 * 0: Read OK
 * -1: No RX data
 * -2: Wrong length read. Something is likely wrong.
 */
int rfhelp_read_rx_data(char *data, int *len, int *pipe) {
 8023380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023382:	4607      	mov	r7, r0
	int retval = -1;

	chMtxLock(&rf_mutex);
 8023384:	4816      	ldr	r0, [pc, #88]	; (80233e0 <rfhelp_read_rx_data+0x60>)
int rfhelp_read_rx_data(char *data, int *len, int *pipe) {
 8023386:	460c      	mov	r4, r1
 8023388:	4616      	mov	r6, r2
	chMtxLock(&rf_mutex);
 802338a:	f7ea fcd1 	bl	800dd30 <chMtxLock>

	int s = rf_status();
 802338e:	f7ff fc07 	bl	8022ba0 <rf_status>
	int pipe_n = NRF_STATUS_GET_RX_P_NO(s);
 8023392:	f3c0 0542 	ubfx	r5, r0, #1, #3

	if (pipe_n != 7) {
 8023396:	2d07      	cmp	r5, #7
 8023398:	d01e      	beq.n	80233d8 <rfhelp_read_rx_data+0x58>
		*len = rf_get_payload_width();
 802339a:	f7ff fbe1 	bl	8022b60 <rf_get_payload_width>
 802339e:	6020      	str	r0, [r4, #0]
		if (pipe) {
 80233a0:	b10e      	cbz	r6, 80233a6 <rfhelp_read_rx_data+0x26>
			*pipe = pipe_n;
 80233a2:	6035      	str	r5, [r6, #0]
 80233a4:	6820      	ldr	r0, [r4, #0]
		}
		if (*len <= 32 && *len >= 0) {
 80233a6:	2820      	cmp	r0, #32
 80233a8:	d811      	bhi.n	80233ce <rfhelp_read_rx_data+0x4e>
			rf_read_rx_payload(data, *len);
 80233aa:	4601      	mov	r1, r0
 80233ac:	4638      	mov	r0, r7
 80233ae:	f7ff fb87 	bl	8022ac0 <rf_read_rx_payload>
			rf_clear_rx_irq();
 80233b2:	f7ff fc6d 	bl	8022c90 <rf_clear_rx_irq>
//			rf_flush_rx();

			s = rf_status();
 80233b6:	f7ff fbf3 	bl	8022ba0 <rf_status>
			if (NRF_STATUS_GET_RX_P_NO(s) == 7) {
 80233ba:	f3c0 0042 	ubfx	r0, r0, #1, #3
 80233be:	1fc4      	subs	r4, r0, #7
 80233c0:	bf18      	it	ne
 80233c2:	2401      	movne	r4, #1
			*len = 0;
			retval = -2;
		}
	}

	chMtxUnlock(&rf_mutex);
 80233c4:	4806      	ldr	r0, [pc, #24]	; (80233e0 <rfhelp_read_rx_data+0x60>)
 80233c6:	f7ea fcc3 	bl	800dd50 <chMtxUnlock>

	return retval;
}
 80233ca:	4620      	mov	r0, r4
 80233cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			*len = 0;
 80233ce:	2300      	movs	r3, #0
 80233d0:	6023      	str	r3, [r4, #0]
			retval = -2;
 80233d2:	f06f 0401 	mvn.w	r4, #1
 80233d6:	e7f5      	b.n	80233c4 <rfhelp_read_rx_data+0x44>
	int retval = -1;
 80233d8:	f04f 34ff 	mov.w	r4, #4294967295
 80233dc:	e7f2      	b.n	80233c4 <rfhelp_read_rx_data+0x44>
 80233de:	bf00      	nop
 80233e0:	20010af8 	.word	0x20010af8
	...

080233f0 <rfhelp_read_rx_data_crc>:
 * 0: Read OK
 * -1: No RX data
 * -2: Wrong length read. Something is likely wrong.
 * -3: Data read, but CRC does not match.
 */
int rfhelp_read_rx_data_crc(char *data, int *len, int *pipe) {
 80233f0:	b570      	push	{r4, r5, r6, lr}
 80233f2:	4605      	mov	r5, r0
 80233f4:	460c      	mov	r4, r1
	int res = rfhelp_read_rx_data(data, len, pipe);
 80233f6:	f7ff ffc3 	bl	8023380 <rfhelp_read_rx_data>

	if (res >= 0 && *len > 2) {
 80233fa:	1e06      	subs	r6, r0, #0
 80233fc:	db1a      	blt.n	8023434 <rfhelp_read_rx_data_crc+0x44>
 80233fe:	6823      	ldr	r3, [r4, #0]
 8023400:	2b02      	cmp	r3, #2
 8023402:	f1a3 0102 	sub.w	r1, r3, #2
 8023406:	dc02      	bgt.n	802340e <rfhelp_read_rx_data_crc+0x1e>
		if (crc	!= ((unsigned short) data[*len - 2] << 8 | (unsigned short) data[*len - 1])) {
			res = -3;
		}
	}

	*len -= 2;
 8023408:	6021      	str	r1, [r4, #0]

	return res;
}
 802340a:	4630      	mov	r0, r6
 802340c:	bd70      	pop	{r4, r5, r6, pc}
		unsigned short crc = crc16((unsigned char*)data, *len - 2);
 802340e:	4628      	mov	r0, r5
 8023410:	f7ee fdae 	bl	8011f70 <crc16>
		if (crc	!= ((unsigned short) data[*len - 2] << 8 | (unsigned short) data[*len - 1])) {
 8023414:	6821      	ldr	r1, [r4, #0]
 8023416:	440d      	add	r5, r1
 8023418:	3902      	subs	r1, #2
 802341a:	f815 2c02 	ldrb.w	r2, [r5, #-2]
 802341e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
	*len -= 2;
 8023422:	6021      	str	r1, [r4, #0]
		if (crc	!= ((unsigned short) data[*len - 2] << 8 | (unsigned short) data[*len - 1])) {
 8023424:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8023428:	4298      	cmp	r0, r3
			res = -3;
 802342a:	bf18      	it	ne
 802342c:	f06f 0602 	mvnne.w	r6, #2
}
 8023430:	4630      	mov	r0, r6
 8023432:	bd70      	pop	{r4, r5, r6, pc}
 8023434:	6821      	ldr	r1, [r4, #0]
 8023436:	3902      	subs	r1, #2
	*len -= 2;
 8023438:	6021      	str	r1, [r4, #0]
}
 802343a:	4630      	mov	r0, r6
 802343c:	bd70      	pop	{r4, r5, r6, pc}
 802343e:	bf00      	nop

08023440 <rfhelp_power_up>:
	chMtxLock(&rf_mutex);
	rf_power_down();
	chMtxUnlock(&rf_mutex);
}

void rfhelp_power_up(void) {
 8023440:	b510      	push	{r4, lr}
	chMtxLock(&rf_mutex);
 8023442:	4c05      	ldr	r4, [pc, #20]	; (8023458 <rfhelp_power_up+0x18>)
 8023444:	4620      	mov	r0, r4
 8023446:	f7ea fc73 	bl	800dd30 <chMtxLock>
	rf_power_up();
 802344a:	f7ff fd21 	bl	8022e90 <rf_power_up>
	chMtxUnlock(&rf_mutex);
 802344e:	4620      	mov	r0, r4
}
 8023450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	chMtxUnlock(&rf_mutex);
 8023454:	f7ea bc7c 	b.w	800dd50 <chMtxUnlock>
 8023458:	20010af8 	.word	0x20010af8
 802345c:	00000000 	.word	0x00000000

08023460 <tx_thread>:
 8023460:	4b1c      	ldr	r3, [pc, #112]	; (80234d4 <tx_thread+0x74>)
 8023462:	491d      	ldr	r1, [pc, #116]	; (80234d8 <tx_thread+0x78>)
 8023464:	699a      	ldr	r2, [r3, #24]
	}

	return res;
}

static THD_FUNCTION(tx_thread, arg) {
 8023466:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)arg;

	chRegSetThreadName("Nrf TX");
	tx_running = true;
 802346a:	4f1c      	ldr	r7, [pc, #112]	; (80234dc <tx_thread+0x7c>)

	for(;;) {
		if (tx_stop) {
 802346c:	4d1c      	ldr	r5, [pc, #112]	; (80234e0 <tx_thread+0x80>)
 802346e:	6191      	str	r1, [r2, #24]
	tx_running = true;
 8023470:	2301      	movs	r3, #1
 8023472:	703b      	strb	r3, [r7, #0]
		if (tx_stop) {
 8023474:	782b      	ldrb	r3, [r5, #0]
static THD_FUNCTION(tx_thread, arg) {
 8023476:	b083      	sub	sp, #12
		if (tx_stop) {
 8023478:	bb33      	cbnz	r3, 80234c8 <tx_thread+0x68>
 802347a:	4c1a      	ldr	r4, [pc, #104]	; (80234e4 <tx_thread+0x84>)
			return;
		}

		nosend_cnt++;

		if (nosend_cnt >= ALIVE_INTERVAL && !pairing_active) {
 802347c:	4e1a      	ldr	r6, [pc, #104]	; (80234e8 <tx_thread+0x88>)
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 802347e:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80234ec <tx_thread+0x8c>
			uint8_t pl[2];
			int32_t index = 0;
			pl[index++] = MOTE_PACKET_ALIVE;
 8023482:	f04f 0802 	mov.w	r8, #2
 8023486:	e004      	b.n	8023492 <tx_thread+0x32>
			rf_tx_wrapper((char*)pl, index);
			nosend_cnt = 0;
		}

		chThdSleepMilliseconds(1);
 8023488:	200a      	movs	r0, #10
 802348a:	f7ea faa9 	bl	800d9e0 <chThdSleep>
		if (tx_stop) {
 802348e:	782b      	ldrb	r3, [r5, #0]
 8023490:	b9d3      	cbnz	r3, 80234c8 <tx_thread+0x68>
		nosend_cnt++;
 8023492:	6823      	ldr	r3, [r4, #0]
 8023494:	3301      	adds	r3, #1
		if (nosend_cnt >= ALIVE_INTERVAL && !pairing_active) {
 8023496:	2b31      	cmp	r3, #49	; 0x31
		nosend_cnt++;
 8023498:	6023      	str	r3, [r4, #0]
		if (nosend_cnt >= ALIVE_INTERVAL && !pairing_active) {
 802349a:	ddf5      	ble.n	8023488 <tx_thread+0x28>
 802349c:	7833      	ldrb	r3, [r6, #0]
 802349e:	2b00      	cmp	r3, #0
 80234a0:	d1f2      	bne.n	8023488 <tx_thread+0x28>
			pl[index++] = MOTE_PACKET_ALIVE;
 80234a2:	a802      	add	r0, sp, #8
	int res = rfhelp_send_data_crc(data, len);
 80234a4:	2101      	movs	r1, #1
			pl[index++] = MOTE_PACKET_ALIVE;
 80234a6:	f800 8d04 	strb.w	r8, [r0, #-4]!
	int res = rfhelp_send_data_crc(data, len);
 80234aa:	f7ff ff41 	bl	8023330 <rfhelp_send_data_crc>
	if (res == 0) {
 80234ae:	b918      	cbnz	r0, 80234b8 <tx_thread+0x58>
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 80234b0:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80234b4:	f8c9 3000 	str.w	r3, [r9]
			nosend_cnt = 0;
 80234b8:	2300      	movs	r3, #0
		chThdSleepMilliseconds(1);
 80234ba:	200a      	movs	r0, #10
			nosend_cnt = 0;
 80234bc:	6023      	str	r3, [r4, #0]
		chThdSleepMilliseconds(1);
 80234be:	f7ea fa8f 	bl	800d9e0 <chThdSleep>
		if (tx_stop) {
 80234c2:	782b      	ldrb	r3, [r5, #0]
 80234c4:	2b00      	cmp	r3, #0
 80234c6:	d0e4      	beq.n	8023492 <tx_thread+0x32>
			tx_running = false;
 80234c8:	2300      	movs	r3, #0
 80234ca:	703b      	strb	r3, [r7, #0]
	}

}
 80234cc:	b003      	add	sp, #12
 80234ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80234d2:	bf00      	nop
 80234d4:	20001a48 	.word	0x20001a48
 80234d8:	0802f6b0 	.word	0x0802f6b0
 80234dc:	200118f0 	.word	0x200118f0
 80234e0:	20001095 	.word	0x20001095
 80234e4:	20010b3c 	.word	0x20010b3c
 80234e8:	20010b48 	.word	0x20010b48
 80234ec:	20010b44 	.word	0x20010b44

080234f0 <rx_thread>:

static THD_FUNCTION(rx_thread, arg) {
 80234f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)arg;

	chRegSetThreadName("Nrf RX");
	rx_running = true;
 80234f4:	48aa      	ldr	r0, [pc, #680]	; (80237a0 <rx_thread+0x2b0>)
 80234f6:	4fab      	ldr	r7, [pc, #684]	; (80237a4 <rx_thread+0x2b4>)
 80234f8:	49ab      	ldr	r1, [pc, #684]	; (80237a8 <rx_thread+0x2b8>)
 80234fa:	69ba      	ldr	r2, [r7, #24]
 80234fc:	2301      	movs	r3, #1
static THD_FUNCTION(rx_thread, arg) {
 80234fe:	ed2d 8b02 	vpush	{d8}
	rx_running = true;
 8023502:	7003      	strb	r3, [r0, #0]

	for(;;) {
		if (rx_stop) {
 8023504:	4ba9      	ldr	r3, [pc, #676]	; (80237ac <rx_thread+0x2bc>)
 8023506:	6191      	str	r1, [r2, #24]
 8023508:	781b      	ldrb	r3, [r3, #0]
static THD_FUNCTION(rx_thread, arg) {
 802350a:	b0c1      	sub	sp, #260	; 0x104
		if (rx_stop) {
 802350c:	2b00      	cmp	r3, #0
 802350e:	f040 811e 	bne.w	802374e <rx_thread+0x25e>
 8023512:	4da7      	ldr	r5, [pc, #668]	; (80237b0 <rx_thread+0x2c0>)
 8023514:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 80237c4 <rx_thread+0x2d4>
 8023518:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 80237c8 <rx_thread+0x2d8>
					appconf.app_nrf_conf.retries = 3;
					appconf.app_nrf_conf.retry_delay = NRF_RETR_DELAY_1000US;
					appconf.app_nrf_conf.send_crc_ack = true;
					appconf.app_nrf_conf.speed = NRF_SPEED_250K;

					pairing_active = false;
 802351c:	f8df b2ac 	ldr.w	fp, [pc, #684]	; 80237cc <rx_thread+0x2dc>

					from_nrf = true;
 8023520:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 80237d0 <rx_thread+0x2e0>
					mstate.vbat = (float)buffer_get_int16(buf, &ind) / 1000.0;
 8023524:	ed9f 8aa3 	vldr	s16, [pc, #652]	; 80237b4 <rx_thread+0x2c4>
			int res = rfhelp_read_rx_data_crc((char*)buf, &len, &pipe);
 8023528:	aa04      	add	r2, sp, #16
 802352a:	a903      	add	r1, sp, #12
 802352c:	a806      	add	r0, sp, #24
 802352e:	f7ff ff5f 	bl	80233f0 <rfhelp_read_rx_data_crc>
			int32_t ind = 0;
 8023532:	2300      	movs	r3, #0
			if (res >= 0) {
 8023534:	1e04      	subs	r4, r0, #0
			int32_t ind = 0;
 8023536:	9305      	str	r3, [sp, #20]
			if (res >= 0) {
 8023538:	f2c0 80ed 	blt.w	8023716 <rx_thread+0x226>
				MOTE_PACKET packet = buf[0];
 802353c:	f89d 3018 	ldrb.w	r3, [sp, #24]
				nrf_restart_rx_time = NRF_RESTART_TIMEOUT;
 8023540:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
				switch (packet) {
 8023544:	3b01      	subs	r3, #1
				nrf_restart_rx_time = NRF_RESTART_TIMEOUT;
 8023546:	602a      	str	r2, [r5, #0]
				switch (packet) {
 8023548:	2b06      	cmp	r3, #6
 802354a:	d834      	bhi.n	80235b6 <rx_thread+0xc6>
 802354c:	e8df f003 	tbb	[pc, r3]
 8023550:	85953304 	.word	0x85953304
 8023554:	3a4d      	.short	0x3a4d
 8023556:	a0          	.byte	0xa0
 8023557:	00          	.byte	0x00
					buttons = buf[ind++];
 8023558:	f89d 301b 	ldrb.w	r3, [sp, #27]
					mstate.js_x = buf[ind++];
 802355c:	4e96      	ldr	r6, [pc, #600]	; (80237b8 <rx_thread+0x2c8>)
 802355e:	f89d 2019 	ldrb.w	r2, [sp, #25]
 8023562:	7032      	strb	r2, [r6, #0]
					mstate.bt_c = buttons & (1 << 0);
 8023564:	f003 0101 	and.w	r1, r3, #1
					mstate.js_y = buf[ind++];
 8023568:	f89d 201a 	ldrb.w	r2, [sp, #26]
					mstate.bt_c = buttons & (1 << 0);
 802356c:	70b1      	strb	r1, [r6, #2]
					mstate.bt_z = buttons & (1 << 1);
 802356e:	f3c3 0140 	ubfx	r1, r3, #1, #1
					mstate.js_y = buf[ind++];
 8023572:	7072      	strb	r2, [r6, #1]
					mstate.bt_push = buttons & (1 << 2);
 8023574:	f3c3 0380 	ubfx	r3, r3, #2, #1
					buttons = buf[ind++];
 8023578:	2204      	movs	r2, #4
					mstate.bt_z = buttons & (1 << 1);
 802357a:	70f1      	strb	r1, [r6, #3]
					mstate.vbat = (float)buffer_get_int16(buf, &ind) / 1000.0;
 802357c:	a806      	add	r0, sp, #24
 802357e:	a905      	add	r1, sp, #20
					mstate.bt_push = buttons & (1 << 2);
 8023580:	7133      	strb	r3, [r6, #4]
					buttons = buf[ind++];
 8023582:	9205      	str	r2, [sp, #20]
					mstate.vbat = (float)buffer_get_int16(buf, &ind) / 1000.0;
 8023584:	f7ee fb94 	bl	8011cb0 <buffer_get_int16>
 8023588:	ee07 0a90 	vmov	s15, r0
 802358c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
					cdata.js_x = 255 - mstate.js_x;
 8023590:	7833      	ldrb	r3, [r6, #0]
					cdata.js_y = mstate.js_y;
 8023592:	7872      	ldrb	r2, [r6, #1]
 8023594:	920f      	str	r2, [sp, #60]	; 0x3c
					mstate.vbat = (float)buffer_get_int16(buf, &ind) / 1000.0;
 8023596:	eec7 7a08 	vdiv.f32	s15, s14, s16
					cdata.js_x = 255 - mstate.js_x;
 802359a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
					cdata.bt_c = mstate.bt_c;
 802359e:	78b1      	ldrb	r1, [r6, #2]
					cdata.bt_z = mstate.bt_z;
 80235a0:	78f2      	ldrb	r2, [r6, #3]
					cdata.js_x = 255 - mstate.js_x;
 80235a2:	930e      	str	r3, [sp, #56]	; 0x38
					app_nunchuk_update_output(&cdata);
 80235a4:	a80e      	add	r0, sp, #56	; 0x38
					cdata.bt_c = mstate.bt_c;
 80235a6:	f88d 104c 	strb.w	r1, [sp, #76]	; 0x4c
					cdata.bt_z = mstate.bt_z;
 80235aa:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
					mstate.vbat = (float)buffer_get_int16(buf, &ind) / 1000.0;
 80235ae:	edc6 7a02 	vstr	s15, [r6, #8]
					app_nunchuk_update_output(&cdata);
 80235b2:	f7fe ff95 	bl	80224e0 <app_nunchuk_update_output>
					break;
				}
			}

			// Stop when there is no more data to read.
			if (res <= 0) {
 80235b6:	2c00      	cmp	r4, #0
 80235b8:	f000 80ad 	beq.w	8023716 <rx_thread+0x226>
				break;
			} else {
				// Sleep a bit to prevent locking the other threads.
				chThdSleepMilliseconds(1);
 80235bc:	200a      	movs	r0, #10
 80235be:	f7ea fa0f 	bl	800d9e0 <chThdSleep>
		for(;;) {
 80235c2:	e7b1      	b.n	8023528 <rx_thread+0x38>
					chThdSleepMilliseconds(2);
 80235c4:	2014      	movs	r0, #20
 80235c6:	f7ea fa0b 	bl	800d9e0 <chThdSleep>
					commands_set_send_func(nrf_driver_send_buffer);
 80235ca:	487c      	ldr	r0, [pc, #496]	; (80237bc <rx_thread+0x2cc>)
 80235cc:	f7f5 f828 	bl	8018620 <commands_set_send_func>
					commands_process_packet(buf + 1, len - 1);
 80235d0:	9903      	ldr	r1, [sp, #12]
					from_nrf = true;
 80235d2:	2301      	movs	r3, #1
					commands_process_packet(buf + 1, len - 1);
 80235d4:	3901      	subs	r1, #1
 80235d6:	f10d 0019 	add.w	r0, sp, #25
					from_nrf = true;
 80235da:	f888 3000 	strb.w	r3, [r8]
					commands_process_packet(buf + 1, len - 1);
 80235de:	f7f5 f9e7 	bl	80189b0 <commands_process_packet>
					from_nrf = false;
 80235e2:	2300      	movs	r3, #0
 80235e4:	f888 3000 	strb.w	r3, [r8]
					break;
 80235e8:	e7e5      	b.n	80235b6 <rx_thread+0xc6>
					int rxbuf_len = (unsigned int)buf[ind++] << 8;
 80235ea:	f89d 2019 	ldrb.w	r2, [sp, #25]
					rxbuf_len |= (unsigned int)buf[ind++];
 80235ee:	f89d 301a 	ldrb.w	r3, [sp, #26]
 80235f2:	ea43 2602 	orr.w	r6, r3, r2, lsl #8
					if (rxbuf_len > RX_BUFFER_SIZE) {
 80235f6:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
					rxbuf_len |= (unsigned int)buf[ind++];
 80235fa:	f04f 0203 	mov.w	r2, #3
 80235fe:	9205      	str	r2, [sp, #20]
					if (rxbuf_len > RX_BUFFER_SIZE) {
 8023600:	d8d9      	bhi.n	80235b6 <rx_thread+0xc6>
					memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 8023602:	9a03      	ldr	r2, [sp, #12]
					uint8_t crc_high = buf[ind++];
 8023604:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8023608:	9300      	str	r3, [sp, #0]
					memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 802360a:	3a05      	subs	r2, #5
 802360c:	4b6c      	ldr	r3, [pc, #432]	; (80237c0 <rx_thread+0x2d0>)
					uint8_t crc_low = buf[ind++];
 802360e:	f89d 101c 	ldrb.w	r1, [sp, #28]
 8023612:	9101      	str	r1, [sp, #4]
					memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 8023614:	1ab0      	subs	r0, r6, r2
 8023616:	4418      	add	r0, r3
 8023618:	f10d 011d 	add.w	r1, sp, #29
					uint8_t crc_low = buf[ind++];
 802361c:	2305      	movs	r3, #5
 802361e:	9305      	str	r3, [sp, #20]
					memcpy(rx_buffer + rxbuf_len - (len - ind), buf + ind, len - ind);
 8023620:	f7e9 fa7e 	bl	800cb20 <memcpy>
					if (crc16(rx_buffer, rxbuf_len)
 8023624:	4631      	mov	r1, r6
 8023626:	4866      	ldr	r0, [pc, #408]	; (80237c0 <rx_thread+0x2d0>)
 8023628:	f7ee fca2 	bl	8011f70 <crc16>
									| (unsigned short) crc_low)) {
 802362c:	e9dd 3100 	ldrd	r3, r1, [sp]
 8023630:	ea41 2203 	orr.w	r2, r1, r3, lsl #8
					if (crc16(rx_buffer, rxbuf_len)
 8023634:	4290      	cmp	r0, r2
 8023636:	d1be      	bne.n	80235b6 <rx_thread+0xc6>
						chThdSleepMilliseconds(2);
 8023638:	2014      	movs	r0, #20
 802363a:	f7ea f9d1 	bl	800d9e0 <chThdSleep>
						commands_set_send_func(nrf_driver_send_buffer);
 802363e:	485f      	ldr	r0, [pc, #380]	; (80237bc <rx_thread+0x2cc>)
 8023640:	f7f4 ffee 	bl	8018620 <commands_set_send_func>
						from_nrf = true;
 8023644:	2301      	movs	r3, #1
						commands_process_packet(rx_buffer, rxbuf_len);
 8023646:	4631      	mov	r1, r6
 8023648:	485d      	ldr	r0, [pc, #372]	; (80237c0 <rx_thread+0x2d0>)
						from_nrf = true;
 802364a:	f888 3000 	strb.w	r3, [r8]
						commands_process_packet(rx_buffer, rxbuf_len);
 802364e:	f7f5 f9af 	bl	80189b0 <commands_process_packet>
						from_nrf = false;
 8023652:	2300      	movs	r3, #0
 8023654:	f888 3000 	strb.w	r3, [r8]
 8023658:	e7ad      	b.n	80235b6 <rx_thread+0xc6>
 802365a:	f8bd 3019 	ldrh.w	r3, [sp, #25]
 802365e:	ba5b      	rev16	r3, r3
 8023660:	b29b      	uxth	r3, r3
					if (rxbuf_ind < RX_BUFFER_SIZE) {
 8023662:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8023666:	d2a6      	bcs.n	80235b6 <rx_thread+0xc6>
						memcpy(rx_buffer + rxbuf_ind, buf + 3, len - 3);
 8023668:	9a03      	ldr	r2, [sp, #12]
 802366a:	4855      	ldr	r0, [pc, #340]	; (80237c0 <rx_thread+0x2d0>)
 802366c:	3a03      	subs	r2, #3
 802366e:	4418      	add	r0, r3
 8023670:	f10d 011b 	add.w	r1, sp, #27
 8023674:	f7e9 fa54 	bl	800cb20 <memcpy>
 8023678:	e79d      	b.n	80235b6 <rx_thread+0xc6>
					memcpy(rx_buffer + buf[1], buf + 2, len - 2);
 802367a:	f89d 3019 	ldrb.w	r3, [sp, #25]
 802367e:	9a03      	ldr	r2, [sp, #12]
 8023680:	484f      	ldr	r0, [pc, #316]	; (80237c0 <rx_thread+0x2d0>)
 8023682:	3a02      	subs	r2, #2
 8023684:	4418      	add	r0, r3
 8023686:	f10d 011a 	add.w	r1, sp, #26
 802368a:	f7e9 fa49 	bl	800cb20 <memcpy>
					break;
 802368e:	e792      	b.n	80235b6 <rx_thread+0xc6>
					ind = 1;
 8023690:	2601      	movs	r6, #1
 8023692:	9605      	str	r6, [sp, #20]
					app_configuration appconf = *app_get_configuration();
 8023694:	f7fc ff84 	bl	80205a0 <app_get_configuration>
 8023698:	22c8      	movs	r2, #200	; 0xc8
 802369a:	4601      	mov	r1, r0
 802369c:	a80e      	add	r0, sp, #56	; 0x38
 802369e:	f7e9 fa3f 	bl	800cb20 <memcpy>
					appconf.app_nrf_conf.address[0] = buf[ind++];
 80236a2:	9b05      	ldr	r3, [sp, #20]
					appconf.app_nrf_conf.crc_type = NRF_CRC_1B;
 80236a4:	f88d 60f6 	strb.w	r6, [sp, #246]	; 0xf6
					appconf.app_nrf_conf.address[0] = buf[ind++];
 80236a8:	aa40      	add	r2, sp, #256	; 0x100
 80236aa:	441a      	add	r2, r3
					appconf.app_nrf_conf.channel = buf[ind++];
 80236ac:	3304      	adds	r3, #4
					appconf.app_nrf_conf.address[0] = buf[ind++];
 80236ae:	f812 ece8 	ldrb.w	lr, [r2, #-232]
					appconf.app_nrf_conf.address[1] = buf[ind++];
 80236b2:	f812 cce7 	ldrb.w	ip, [r2, #-231]
					appconf.app_nrf_conf.address[2] = buf[ind++];
 80236b6:	f812 1ce6 	ldrb.w	r1, [r2, #-230]
					appconf.app_nrf_conf.send_crc_ack = true;
 80236ba:	f88d 60fd 	strb.w	r6, [sp, #253]	; 0xfd
					appconf.app_nrf_conf.channel = buf[ind++];
 80236be:	f812 2ce5 	ldrb.w	r2, [r2, #-229]
					from_nrf = true;
 80236c2:	f888 6000 	strb.w	r6, [r8]
					appconf.app_nrf_conf.channel = buf[ind++];
 80236c6:	9305      	str	r3, [sp, #20]
					appconf.app_nrf_conf.speed = NRF_SPEED_250K;
 80236c8:	2600      	movs	r6, #0
					appconf.app_nrf_conf.retries = 3;
 80236ca:	2303      	movs	r3, #3
					conf_general_store_app_configuration(&appconf);
 80236cc:	a80e      	add	r0, sp, #56	; 0x38
					appconf.app_nrf_conf.address[0] = buf[ind++];
 80236ce:	f88d e0fa 	strb.w	lr, [sp, #250]	; 0xfa
					appconf.app_nrf_conf.address[1] = buf[ind++];
 80236d2:	f88d c0fb 	strb.w	ip, [sp, #251]	; 0xfb
					appconf.app_nrf_conf.channel = buf[ind++];
 80236d6:	f88d 20f9 	strb.w	r2, [sp, #249]	; 0xf9
					appconf.app_nrf_conf.retries = 3;
 80236da:	f88d 30f8 	strb.w	r3, [sp, #248]	; 0xf8
					appconf.app_nrf_conf.retry_delay = NRF_RETR_DELAY_1000US;
 80236de:	f88d 30f7 	strb.w	r3, [sp, #247]	; 0xf7
					appconf.app_nrf_conf.address[2] = buf[ind++];
 80236e2:	f88d 10fc 	strb.w	r1, [sp, #252]	; 0xfc
					appconf.app_nrf_conf.speed = NRF_SPEED_250K;
 80236e6:	f88d 60f4 	strb.w	r6, [sp, #244]	; 0xf4
					pairing_active = false;
 80236ea:	f88b 6000 	strb.w	r6, [fp]
					conf_general_store_app_configuration(&appconf);
 80236ee:	f7f4 f987 	bl	8017a00 <conf_general_store_app_configuration>
					app_set_configuration(&appconf);
 80236f2:	a80e      	add	r0, sp, #56	; 0x38
 80236f4:	f7fc ff5c 	bl	80205b0 <app_set_configuration>
					commands_send_appconf(COMM_GET_APPCONF, &appconf);
 80236f8:	a90e      	add	r1, sp, #56	; 0x38
 80236fa:	2011      	movs	r0, #17
 80236fc:	f7f4 fff0 	bl	80186e0 <commands_send_appconf>
					data[0] = COMM_NRF_START_PAIRING;
 8023700:	a840      	add	r0, sp, #256	; 0x100
 8023702:	f240 1325 	movw	r3, #293	; 0x125
 8023706:	f820 3df8 	strh.w	r3, [r0, #-248]!
					commands_send_packet(data, 2);
 802370a:	2102      	movs	r1, #2
 802370c:	f7f4 ff90 	bl	8018630 <commands_send_packet>
					from_nrf = false;
 8023710:	f888 6000 	strb.w	r6, [r8]
				} break;
 8023714:	e74f      	b.n	80235b6 <rx_thread+0xc6>
 8023716:	6abb      	ldr	r3, [r7, #40]	; 0x28
			}
		}

		if (chVTGetSystemTimeX() > pairing_time_end && pairing_active) {
 8023718:	f8d9 2000 	ldr.w	r2, [r9]
 802371c:	429a      	cmp	r2, r3
 802371e:	d202      	bcs.n	8023726 <rx_thread+0x236>
 8023720:	f89b 3000 	ldrb.w	r3, [fp]
 8023724:	bb2b      	cbnz	r3, 8023772 <rx_thread+0x282>
			data[0] = COMM_NRF_START_PAIRING;
			data[1] = NRF_PAIR_FAIL;
			commands_send_packet(data, 2);
		}

		chThdSleepMilliseconds(5);
 8023726:	2032      	movs	r0, #50	; 0x32
 8023728:	f7ea f95a 	bl	800d9e0 <chThdSleep>

		// Restart the nrf if nothing has been received for a while
		if (nrf_restart_rx_time > 0 && nrf_restart_tx_time > 0) {
 802372c:	682b      	ldr	r3, [r5, #0]
 802372e:	2b00      	cmp	r3, #0
 8023730:	dd15      	ble.n	802375e <rx_thread+0x26e>
 8023732:	f8da 2000 	ldr.w	r2, [sl]
 8023736:	2a00      	cmp	r2, #0
 8023738:	dd11      	ble.n	802375e <rx_thread+0x26e>
			nrf_restart_rx_time -= 5;
 802373a:	3b05      	subs	r3, #5
			nrf_restart_tx_time -= 5;
 802373c:	3a05      	subs	r2, #5
			nrf_restart_rx_time -= 5;
 802373e:	602b      	str	r3, [r5, #0]
			nrf_restart_tx_time -= 5;
 8023740:	f8ca 2000 	str.w	r2, [sl]
		if (rx_stop) {
 8023744:	4b19      	ldr	r3, [pc, #100]	; (80237ac <rx_thread+0x2bc>)
 8023746:	781b      	ldrb	r3, [r3, #0]
 8023748:	2b00      	cmp	r3, #0
 802374a:	f43f aeed 	beq.w	8023528 <rx_thread+0x38>
			rx_running = false;
 802374e:	4a14      	ldr	r2, [pc, #80]	; (80237a0 <rx_thread+0x2b0>)
 8023750:	2300      	movs	r3, #0
 8023752:	7013      	strb	r3, [r2, #0]
			rfhelp_restart();
			nrf_restart_rx_time = NRF_RESTART_TIMEOUT;
			nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
		}
	}
}
 8023754:	b041      	add	sp, #260	; 0x104
 8023756:	ecbd 8b02 	vpop	{d8}
 802375a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			rfhelp_power_up();
 802375e:	f7ff fe6f 	bl	8023440 <rfhelp_power_up>
			rfhelp_restart();
 8023762:	f7ff fd0d 	bl	8023180 <rfhelp_restart>
			nrf_restart_rx_time = NRF_RESTART_TIMEOUT;
 8023766:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 802376a:	602b      	str	r3, [r5, #0]
			nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 802376c:	f8ca 3000 	str.w	r3, [sl]
 8023770:	e7e8      	b.n	8023744 <rx_thread+0x254>
			pairing_active = false;
 8023772:	2300      	movs	r3, #0
 8023774:	f88b 3000 	strb.w	r3, [fp]
			nrf_config conf = app_get_configuration()->app_nrf_conf;
 8023778:	f7fc ff12 	bl	80205a0 <app_get_configuration>
 802377c:	30bc      	adds	r0, #188	; 0xbc
 802377e:	c807      	ldmia	r0, {r0, r1, r2}
 8023780:	ab0e      	add	r3, sp, #56	; 0x38
 8023782:	c303      	stmia	r3!, {r0, r1}
			rfhelp_update_conf(&conf);
 8023784:	a80e      	add	r0, sp, #56	; 0x38
			nrf_config conf = app_get_configuration()->app_nrf_conf;
 8023786:	801a      	strh	r2, [r3, #0]
			rfhelp_update_conf(&conf);
 8023788:	f7ff fd62 	bl	8023250 <rfhelp_update_conf>
			data[0] = COMM_NRF_START_PAIRING;
 802378c:	a840      	add	r0, sp, #256	; 0x100
 802378e:	f240 2325 	movw	r3, #549	; 0x225
 8023792:	f820 3dec 	strh.w	r3, [r0, #-236]!
			commands_send_packet(data, 2);
 8023796:	2102      	movs	r1, #2
 8023798:	f7f4 ff4a 	bl	8018630 <commands_send_packet>
 802379c:	e7c3      	b.n	8023726 <rx_thread+0x236>
 802379e:	bf00      	nop
 80237a0:	20010f50 	.word	0x20010f50
 80237a4:	20001a48 	.word	0x20001a48
 80237a8:	0802f6a0 	.word	0x0802f6a0
 80237ac:	20001094 	.word	0x20001094
 80237b0:	20010b40 	.word	0x20010b40
 80237b4:	447a0000 	.word	0x447a0000
 80237b8:	20010b30 	.word	0x20010b30
 80237bc:	080237e1 	.word	0x080237e1
 80237c0:	20010b50 	.word	0x20010b50
 80237c4:	20010b4c 	.word	0x20010b4c
 80237c8:	20010b44 	.word	0x20010b44
 80237cc:	20010b48 	.word	0x20010b48
 80237d0:	20010b2e 	.word	0x20010b2e
	...

080237e0 <nrf_driver_send_buffer>:

void nrf_driver_send_buffer(unsigned char *data, unsigned int len) {
 80237e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t send_buffer[MAX_PL_LEN];

	if (len <= (MAX_PL_LEN - 1)) {
 80237e4:	2918      	cmp	r1, #24
void nrf_driver_send_buffer(unsigned char *data, unsigned int len) {
 80237e6:	b08b      	sub	sp, #44	; 0x2c
 80237e8:	4688      	mov	r8, r1
 80237ea:	4606      	mov	r6, r0
	if (len <= (MAX_PL_LEN - 1)) {
 80237ec:	d96d      	bls.n	80238ca <nrf_driver_send_buffer+0xea>
		ind += len;
		rf_tx_wrapper((char*)send_buffer, ind);
		nosend_cnt = 0;
	} else {
		unsigned int end_a = 0;
		unsigned int len2 = len - (MAX_PL_LEN - 5);
 80237ee:	f1a1 0514 	sub.w	r5, r1, #20
 80237f2:	4f69      	ldr	r7, [pc, #420]	; (8023998 <nrf_driver_send_buffer+0x1b8>)
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 80237f4:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 802399c <nrf_driver_send_buffer+0x1bc>
		unsigned int end_a = 0;
 80237f8:	2100      	movs	r1, #0
			}

			end_a = i + (MAX_PL_LEN - 2);

			uint8_t send_len = (MAX_PL_LEN - 2);
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 80237fa:	f04f 0903 	mov.w	r9, #3
 80237fe:	e002      	b.n	8023806 <nrf_driver_send_buffer+0x26>
			if (i > 255) {
 8023800:	f5b4 7f8a 	cmp.w	r4, #276	; 0x114
 8023804:	d07b      	beq.n	80238fe <nrf_driver_send_buffer+0x11e>
			end_a = i + (MAX_PL_LEN - 2);
 8023806:	f101 0417 	add.w	r4, r1, #23
 802380a:	b2e3      	uxtb	r3, r4
			send_buffer[1] = i;
 802380c:	f1a3 0217 	sub.w	r2, r3, #23

			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 8023810:	42a5      	cmp	r5, r4
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER;
 8023812:	f88d 900c 	strb.w	r9, [sp, #12]
 8023816:	4431      	add	r1, r6
			send_buffer[1] = i;
 8023818:	f88d 200d 	strb.w	r2, [sp, #13]
			if ((i + (MAX_PL_LEN - 2)) <= len2) {
 802381c:	f0c0 80ae 	bcc.w	802397c <nrf_driver_send_buffer+0x19c>
				memcpy(send_buffer + 2, data + i, send_len);
 8023820:	680b      	ldr	r3, [r1, #0]
 8023822:	684a      	ldr	r2, [r1, #4]
 8023824:	f8cd 300e 	str.w	r3, [sp, #14]
 8023828:	f8cd 2012 	str.w	r2, [sp, #18]
 802382c:	688b      	ldr	r3, [r1, #8]
 802382e:	68ca      	ldr	r2, [r1, #12]
 8023830:	8a88      	ldrh	r0, [r1, #20]
 8023832:	f8cd 3016 	str.w	r3, [sp, #22]
 8023836:	f8cd 201a 	str.w	r2, [sp, #26]
 802383a:	690b      	ldr	r3, [r1, #16]
 802383c:	7d8a      	ldrb	r2, [r1, #22]
 802383e:	f8cd 301e 	str.w	r3, [sp, #30]
 8023842:	f8ad 0022 	strh.w	r0, [sp, #34]	; 0x22
 8023846:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
 802384a:	2119      	movs	r1, #25
	int res = rfhelp_send_data_crc(data, len);
 802384c:	a803      	add	r0, sp, #12
 802384e:	f7ff fd6f 	bl	8023330 <rfhelp_send_data_crc>
				send_len = len2 - i;
				memcpy(send_buffer + 2, data + i, send_len);
			}

			rf_tx_wrapper((char*)send_buffer, send_len + 2);
			nosend_cnt = 0;
 8023852:	2300      	movs	r3, #0
 8023854:	4621      	mov	r1, r4
	if (res == 0) {
 8023856:	b918      	cbnz	r0, 8023860 <nrf_driver_send_buffer+0x80>
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 8023858:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 802385c:	f8ca 2000 	str.w	r2, [sl]
		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
 8023860:	42a5      	cmp	r5, r4
			nosend_cnt = 0;
 8023862:	603b      	str	r3, [r7, #0]
		for (unsigned int i = 0;i < len2;i += (MAX_PL_LEN - 2)) {
 8023864:	d8cc      	bhi.n	8023800 <nrf_driver_send_buffer+0x20>
			rf_tx_wrapper((char*)send_buffer, send_len + 3);
			nosend_cnt = 0;
		}

		uint32_t ind = 0;
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8023866:	2205      	movs	r2, #5
		send_buffer[ind++] = len >> 8;
 8023868:	ea4f 2318 	mov.w	r3, r8, lsr #8
		send_buffer[ind++] = len & 0xFF;
		unsigned short crc = crc16(data, len);
 802386c:	4641      	mov	r1, r8
 802386e:	4630      	mov	r0, r6
		send_buffer[ind++] = (uint8_t)(crc >> 8);
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
		memcpy(send_buffer + 5, data + len2, len - len2);
 8023870:	4435      	add	r5, r6
		send_buffer[ind++] = MOTE_PACKET_PROCESS_RX_BUFFER;
 8023872:	f88d 200c 	strb.w	r2, [sp, #12]
		send_buffer[ind++] = len >> 8;
 8023876:	f88d 300d 	strb.w	r3, [sp, #13]
		send_buffer[ind++] = len & 0xFF;
 802387a:	f88d 800e 	strb.w	r8, [sp, #14]
		unsigned short crc = crc16(data, len);
 802387e:	f7ee fb77 	bl	8011f70 <crc16>
		memcpy(send_buffer + 5, data + len2, len - len2);
 8023882:	682b      	ldr	r3, [r5, #0]
 8023884:	6869      	ldr	r1, [r5, #4]
 8023886:	f8cd 3011 	str.w	r3, [sp, #17]
		unsigned short crc = crc16(data, len);
 802388a:	4602      	mov	r2, r0
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 802388c:	0a03      	lsrs	r3, r0, #8
		send_buffer[ind++] = (uint8_t)(crc & 0xFF);
 802388e:	f88d 2010 	strb.w	r2, [sp, #16]
		memcpy(send_buffer + 5, data + len2, len - len2);
 8023892:	68ac      	ldr	r4, [r5, #8]
		send_buffer[ind++] = (uint8_t)(crc >> 8);
 8023894:	f88d 300f 	strb.w	r3, [sp, #15]
		memcpy(send_buffer + 5, data + len2, len - len2);
 8023898:	68ea      	ldr	r2, [r5, #12]
 802389a:	692b      	ldr	r3, [r5, #16]
 802389c:	f8cd 1015 	str.w	r1, [sp, #21]
	int res = rfhelp_send_data_crc(data, len);
 80238a0:	a803      	add	r0, sp, #12
 80238a2:	2119      	movs	r1, #25
		memcpy(send_buffer + 5, data + len2, len - len2);
 80238a4:	f8cd 4019 	str.w	r4, [sp, #25]
 80238a8:	f8cd 201d 	str.w	r2, [sp, #29]
 80238ac:	f8cd 3021 	str.w	r3, [sp, #33]	; 0x21
	int res = rfhelp_send_data_crc(data, len);
 80238b0:	f7ff fd3e 	bl	8023330 <rfhelp_send_data_crc>
	if (res == 0) {
 80238b4:	b120      	cbz	r0, 80238c0 <nrf_driver_send_buffer+0xe0>
		ind += len - len2;

		rf_tx_wrapper((char*)send_buffer, ind);
		nosend_cnt = 0;
 80238b6:	2300      	movs	r3, #0
 80238b8:	603b      	str	r3, [r7, #0]
	}
}
 80238ba:	b00b      	add	sp, #44	; 0x2c
 80238bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 80238c0:	4b36      	ldr	r3, [pc, #216]	; (802399c <nrf_driver_send_buffer+0x1bc>)
 80238c2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80238c6:	601a      	str	r2, [r3, #0]
 80238c8:	e7f5      	b.n	80238b6 <nrf_driver_send_buffer+0xd6>
		send_buffer[ind++] = MOTE_PACKET_PROCESS_SHORT_BUFFER;
 80238ca:	ac0a      	add	r4, sp, #40	; 0x28
 80238cc:	2306      	movs	r3, #6
 80238ce:	f804 3d1c 	strb.w	r3, [r4, #-28]!
		memcpy(send_buffer + ind, data, len);
 80238d2:	4601      	mov	r1, r0
 80238d4:	4642      	mov	r2, r8
 80238d6:	f10d 000d 	add.w	r0, sp, #13
 80238da:	f7e9 f921 	bl	800cb20 <memcpy>
	int res = rfhelp_send_data_crc(data, len);
 80238de:	4620      	mov	r0, r4
 80238e0:	f108 0101 	add.w	r1, r8, #1
 80238e4:	f7ff fd24 	bl	8023330 <rfhelp_send_data_crc>
	if (res == 0) {
 80238e8:	b918      	cbnz	r0, 80238f2 <nrf_driver_send_buffer+0x112>
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 80238ea:	4b2c      	ldr	r3, [pc, #176]	; (802399c <nrf_driver_send_buffer+0x1bc>)
 80238ec:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80238f0:	601a      	str	r2, [r3, #0]
		nosend_cnt = 0;
 80238f2:	4b29      	ldr	r3, [pc, #164]	; (8023998 <nrf_driver_send_buffer+0x1b8>)
 80238f4:	2200      	movs	r2, #0
 80238f6:	601a      	str	r2, [r3, #0]
}
 80238f8:	b00b      	add	sp, #44	; 0x2c
 80238fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80238fe:	f1a6 0b16 	sub.w	fp, r6, #22
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 8023902:	f04f 0a04 	mov.w	sl, #4
 8023906:	f105 0916 	add.w	r9, r5, #22
 802390a:	9601      	str	r6, [sp, #4]
 802390c:	e01e      	b.n	802394c <nrf_driver_send_buffer+0x16c>
				memcpy(send_buffer + 3, data + i, send_len);
 802390e:	680b      	ldr	r3, [r1, #0]
 8023910:	684a      	ldr	r2, [r1, #4]
 8023912:	f8cd 300f 	str.w	r3, [sp, #15]
 8023916:	688b      	ldr	r3, [r1, #8]
 8023918:	68c8      	ldr	r0, [r1, #12]
 802391a:	f8cd 2013 	str.w	r2, [sp, #19]
 802391e:	f8cd 3017 	str.w	r3, [sp, #23]
 8023922:	8a8a      	ldrh	r2, [r1, #20]
 8023924:	690b      	ldr	r3, [r1, #16]
 8023926:	f8cd 001b 	str.w	r0, [sp, #27]
 802392a:	f8cd 301f 	str.w	r3, [sp, #31]
 802392e:	f8ad 2023 	strh.w	r2, [sp, #35]	; 0x23
 8023932:	2119      	movs	r1, #25
	int res = rfhelp_send_data_crc(data, len);
 8023934:	a803      	add	r0, sp, #12
 8023936:	f7ff fcfb 	bl	8023330 <rfhelp_send_data_crc>
			nosend_cnt = 0;
 802393a:	2300      	movs	r3, #0
	if (res == 0) {
 802393c:	b918      	cbnz	r0, 8023946 <nrf_driver_send_buffer+0x166>
		nrf_restart_tx_time = NRF_RESTART_TIMEOUT;
 802393e:	4917      	ldr	r1, [pc, #92]	; (802399c <nrf_driver_send_buffer+0x1bc>)
 8023940:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8023944:	600a      	str	r2, [r1, #0]
		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
 8023946:	42a5      	cmp	r5, r4
			nosend_cnt = 0;
 8023948:	603b      	str	r3, [r7, #0]
		for (unsigned int i = end_a;i < len2;i += (MAX_PL_LEN - 3)) {
 802394a:	d915      	bls.n	8023978 <nrf_driver_send_buffer+0x198>
			send_buffer[1] = i >> 8;
 802394c:	0a23      	lsrs	r3, r4, #8
			send_buffer[2] = i & 0xFF;
 802394e:	f88d 400e 	strb.w	r4, [sp, #14]
			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 8023952:	3416      	adds	r4, #22
 8023954:	42a5      	cmp	r5, r4
			send_buffer[1] = i >> 8;
 8023956:	f88d 300d 	strb.w	r3, [sp, #13]
			send_buffer[0] = MOTE_PACKET_FILL_RX_BUFFER_LONG;
 802395a:	f88d a00c 	strb.w	sl, [sp, #12]
 802395e:	eb0b 0104 	add.w	r1, fp, r4
 8023962:	eba9 0304 	sub.w	r3, r9, r4
			if ((i + (MAX_PL_LEN - 3)) <= len2) {
 8023966:	d2d2      	bcs.n	802390e <nrf_driver_send_buffer+0x12e>
 8023968:	b2de      	uxtb	r6, r3
				memcpy(send_buffer + 3, data + i, send_len);
 802396a:	4632      	mov	r2, r6
 802396c:	f10d 000f 	add.w	r0, sp, #15
 8023970:	f7e9 f8d6 	bl	800cb20 <memcpy>
 8023974:	1cf1      	adds	r1, r6, #3
 8023976:	e7dd      	b.n	8023934 <nrf_driver_send_buffer+0x154>
 8023978:	9e01      	ldr	r6, [sp, #4]
 802397a:	e774      	b.n	8023866 <nrf_driver_send_buffer+0x86>
 802397c:	f1c3 0b17 	rsb	fp, r3, #23
 8023980:	44ab      	add	fp, r5
 8023982:	fa5f fb8b 	uxtb.w	fp, fp
				memcpy(send_buffer + 2, data + i, send_len);
 8023986:	465a      	mov	r2, fp
 8023988:	f10d 000e 	add.w	r0, sp, #14
 802398c:	f7e9 f8c8 	bl	800cb20 <memcpy>
 8023990:	f10b 0102 	add.w	r1, fp, #2
 8023994:	e75a      	b.n	802384c <nrf_driver_send_buffer+0x6c>
 8023996:	bf00      	nop
 8023998:	20010b3c 	.word	0x20010b3c
 802399c:	20010b44 	.word	0x20010b44

080239a0 <nrf_driver_stop.part.1>:
	tx_stop = true;
 80239a0:	490d      	ldr	r1, [pc, #52]	; (80239d8 <nrf_driver_stop.part.1+0x38>)
	rx_stop = true;
 80239a2:	4a0e      	ldr	r2, [pc, #56]	; (80239dc <nrf_driver_stop.part.1+0x3c>)
void nrf_driver_stop(void) {
 80239a4:	b538      	push	{r3, r4, r5, lr}
	tx_stop = true;
 80239a6:	2301      	movs	r3, #1
	if (rx_running || tx_running) {
 80239a8:	4c0d      	ldr	r4, [pc, #52]	; (80239e0 <nrf_driver_stop.part.1+0x40>)
	tx_stop = true;
 80239aa:	700b      	strb	r3, [r1, #0]
	rx_stop = true;
 80239ac:	7013      	strb	r3, [r2, #0]
	if (rx_running || tx_running) {
 80239ae:	7823      	ldrb	r3, [r4, #0]
 80239b0:	4d0c      	ldr	r5, [pc, #48]	; (80239e4 <nrf_driver_stop.part.1+0x44>)
 80239b2:	b90b      	cbnz	r3, 80239b8 <nrf_driver_stop.part.1+0x18>
 80239b4:	782b      	ldrb	r3, [r5, #0]
 80239b6:	b133      	cbz	r3, 80239c6 <nrf_driver_stop.part.1+0x26>
		rfhelp_stop();
 80239b8:	f7ff fbd2 	bl	8023160 <rfhelp_stop>
	while (rx_running || tx_running) {
 80239bc:	7823      	ldrb	r3, [r4, #0]
		chThdSleepMilliseconds(1);
 80239be:	200a      	movs	r0, #10
	while (rx_running || tx_running) {
 80239c0:	b12b      	cbz	r3, 80239ce <nrf_driver_stop.part.1+0x2e>
		chThdSleepMilliseconds(1);
 80239c2:	f7ea f80d 	bl	800d9e0 <chThdSleep>
	while (rx_running || tx_running) {
 80239c6:	7823      	ldrb	r3, [r4, #0]
		chThdSleepMilliseconds(1);
 80239c8:	200a      	movs	r0, #10
	while (rx_running || tx_running) {
 80239ca:	2b00      	cmp	r3, #0
 80239cc:	d1f9      	bne.n	80239c2 <nrf_driver_stop.part.1+0x22>
 80239ce:	782b      	ldrb	r3, [r5, #0]
 80239d0:	2b00      	cmp	r3, #0
 80239d2:	d1f6      	bne.n	80239c2 <nrf_driver_stop.part.1+0x22>
}
 80239d4:	bd38      	pop	{r3, r4, r5, pc}
 80239d6:	bf00      	nop
 80239d8:	20001095 	.word	0x20001095
 80239dc:	20001094 	.word	0x20001094
 80239e0:	20010f50 	.word	0x20010f50
 80239e4:	200118f0 	.word	0x200118f0
	...

080239f0 <nrf_driver_init>:
bool nrf_driver_init(void) {
 80239f0:	b570      	push	{r4, r5, r6, lr}
	if (from_nrf) {
 80239f2:	4a1f      	ldr	r2, [pc, #124]	; (8023a70 <nrf_driver_init+0x80>)
 80239f4:	7813      	ldrb	r3, [r2, #0]
bool nrf_driver_init(void) {
 80239f6:	b082      	sub	sp, #8
	if (from_nrf) {
 80239f8:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 80239fc:	b933      	cbnz	r3, 8023a0c <nrf_driver_init+0x1c>
	if (from_nrf) {
 80239fe:	7813      	ldrb	r3, [r2, #0]
 8023a00:	2b00      	cmp	r3, #0
 8023a02:	d02d      	beq.n	8023a60 <nrf_driver_init+0x70>
	if (!rfhelp_init()) {
 8023a04:	f7ff fb44 	bl	8023090 <rfhelp_init>
 8023a08:	4604      	mov	r4, r0
 8023a0a:	b910      	cbnz	r0, 8023a12 <nrf_driver_init+0x22>
}
 8023a0c:	4620      	mov	r0, r4
 8023a0e:	b002      	add	sp, #8
 8023a10:	bd70      	pop	{r4, r5, r6, pc}
	rx_stop = false;
 8023a12:	4818      	ldr	r0, [pc, #96]	; (8023a74 <nrf_driver_init+0x84>)
	nosend_cnt = 0;
 8023a14:	4e18      	ldr	r6, [pc, #96]	; (8023a78 <nrf_driver_init+0x88>)
	nrf_restart_rx_time = 0;
 8023a16:	4b19      	ldr	r3, [pc, #100]	; (8023a7c <nrf_driver_init+0x8c>)
	nrf_restart_tx_time = 0;
 8023a18:	4a19      	ldr	r2, [pc, #100]	; (8023a80 <nrf_driver_init+0x90>)
	pairing_time_end = 0;
 8023a1a:	491a      	ldr	r1, [pc, #104]	; (8023a84 <nrf_driver_init+0x94>)
	nosend_cnt = 0;
 8023a1c:	2500      	movs	r5, #0
	chThdCreateStatic(rx_thread_wa, sizeof(rx_thread_wa), NORMALPRIO - 1, rx_thread, NULL);
 8023a1e:	9500      	str	r5, [sp, #0]
	rx_stop = false;
 8023a20:	7005      	strb	r5, [r0, #0]
	nosend_cnt = 0;
 8023a22:	6035      	str	r5, [r6, #0]
	pairing_active = false;
 8023a24:	4818      	ldr	r0, [pc, #96]	; (8023a88 <nrf_driver_init+0x98>)
	tx_stop = false;
 8023a26:	4e19      	ldr	r6, [pc, #100]	; (8023a8c <nrf_driver_init+0x9c>)
	nrf_restart_rx_time = 0;
 8023a28:	601d      	str	r5, [r3, #0]
	nrf_restart_tx_time = 0;
 8023a2a:	6015      	str	r5, [r2, #0]
	pairing_time_end = 0;
 8023a2c:	600d      	str	r5, [r1, #0]
	pairing_active = false;
 8023a2e:	7005      	strb	r5, [r0, #0]
	chThdCreateStatic(rx_thread_wa, sizeof(rx_thread_wa), NORMALPRIO - 1, rx_thread, NULL);
 8023a30:	4b17      	ldr	r3, [pc, #92]	; (8023a90 <nrf_driver_init+0xa0>)
	tx_stop = false;
 8023a32:	7035      	strb	r5, [r6, #0]
	chThdCreateStatic(rx_thread_wa, sizeof(rx_thread_wa), NORMALPRIO - 1, rx_thread, NULL);
 8023a34:	223f      	movs	r2, #63	; 0x3f
 8023a36:	f640 1198 	movw	r1, #2456	; 0x998
 8023a3a:	4816      	ldr	r0, [pc, #88]	; (8023a94 <nrf_driver_init+0xa4>)
 8023a3c:	f7e9 ff98 	bl	800d970 <chThdCreateStatic>
	chThdCreateStatic(tx_thread_wa, sizeof(tx_thread_wa), NORMALPRIO - 1, tx_thread, NULL);
 8023a40:	9500      	str	r5, [sp, #0]
 8023a42:	4b15      	ldr	r3, [pc, #84]	; (8023a98 <nrf_driver_init+0xa8>)
 8023a44:	4815      	ldr	r0, [pc, #84]	; (8023a9c <nrf_driver_init+0xac>)
 8023a46:	223f      	movs	r2, #63	; 0x3f
 8023a48:	f44f 7166 	mov.w	r1, #920	; 0x398
 8023a4c:	f7e9 ff90 	bl	800d970 <chThdCreateStatic>
	rx_running = true;
 8023a50:	4913      	ldr	r1, [pc, #76]	; (8023aa0 <nrf_driver_init+0xb0>)
	tx_running = true;
 8023a52:	4a14      	ldr	r2, [pc, #80]	; (8023aa4 <nrf_driver_init+0xb4>)
	rx_running = true;
 8023a54:	2301      	movs	r3, #1
}
 8023a56:	4620      	mov	r0, r4
	rx_running = true;
 8023a58:	700b      	strb	r3, [r1, #0]
	tx_running = true;
 8023a5a:	7013      	strb	r3, [r2, #0]
}
 8023a5c:	b002      	add	sp, #8
 8023a5e:	bd70      	pop	{r4, r5, r6, pc}
 8023a60:	f7ff ff9e 	bl	80239a0 <nrf_driver_stop.part.1>
	if (!rfhelp_init()) {
 8023a64:	f7ff fb14 	bl	8023090 <rfhelp_init>
 8023a68:	4604      	mov	r4, r0
 8023a6a:	2800      	cmp	r0, #0
 8023a6c:	d0ce      	beq.n	8023a0c <nrf_driver_init+0x1c>
 8023a6e:	e7d0      	b.n	8023a12 <nrf_driver_init+0x22>
 8023a70:	20010b2e 	.word	0x20010b2e
 8023a74:	20001094 	.word	0x20001094
 8023a78:	20010b3c 	.word	0x20010b3c
 8023a7c:	20010b40 	.word	0x20010b40
 8023a80:	20010b44 	.word	0x20010b44
 8023a84:	20010b4c 	.word	0x20010b4c
 8023a88:	20010b48 	.word	0x20010b48
 8023a8c:	20001095 	.word	0x20001095
 8023a90:	080234f1 	.word	0x080234f1
 8023a94:	20010f58 	.word	0x20010f58
 8023a98:	08023461 	.word	0x08023461
 8023a9c:	200118f8 	.word	0x200118f8
 8023aa0:	20010f50 	.word	0x20010f50
 8023aa4:	200118f0 	.word	0x200118f0
	...

08023ab0 <nrf_driver_stop>:
	if (from_nrf) {
 8023ab0:	4b02      	ldr	r3, [pc, #8]	; (8023abc <nrf_driver_stop+0xc>)
 8023ab2:	781b      	ldrb	r3, [r3, #0]
 8023ab4:	b90b      	cbnz	r3, 8023aba <nrf_driver_stop+0xa>
 8023ab6:	f7ff bf73 	b.w	80239a0 <nrf_driver_stop.part.1>
}
 8023aba:	4770      	bx	lr
 8023abc:	20010b2e 	.word	0x20010b2e

08023ac0 <nrf_driver_start_pairing>:
	if (!rx_running) {
 8023ac0:	4b1a      	ldr	r3, [pc, #104]	; (8023b2c <nrf_driver_start_pairing+0x6c>)
 8023ac2:	781b      	ldrb	r3, [r3, #0]
 8023ac4:	b1ab      	cbz	r3, 8023af2 <nrf_driver_start_pairing+0x32>
void nrf_driver_start_pairing(int ms) {
 8023ac6:	b530      	push	{r4, r5, lr}
	pairing_time_end = chVTGetSystemTimeX() + MS2ST(ms);
 8023ac8:	f242 7310 	movw	r3, #10000	; 0x2710
 8023acc:	4a18      	ldr	r2, [pc, #96]	; (8023b30 <nrf_driver_start_pairing+0x70>)
 8023ace:	4c19      	ldr	r4, [pc, #100]	; (8023b34 <nrf_driver_start_pairing+0x74>)
	if (!pairing_active) {
 8023ad0:	4919      	ldr	r1, [pc, #100]	; (8023b38 <nrf_driver_start_pairing+0x78>)
 8023ad2:	6a92      	ldr	r2, [r2, #40]	; 0x28
	pairing_time_end = chVTGetSystemTimeX() + MS2ST(ms);
 8023ad4:	4d19      	ldr	r5, [pc, #100]	; (8023b3c <nrf_driver_start_pairing+0x7c>)
 8023ad6:	fb03 f000 	mul.w	r0, r3, r0
 8023ada:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 8023ade:	fba4 3000 	umull	r3, r0, r4, r0
	if (!pairing_active) {
 8023ae2:	780c      	ldrb	r4, [r1, #0]
	pairing_time_end = chVTGetSystemTimeX() + MS2ST(ms);
 8023ae4:	eb02 1090 	add.w	r0, r2, r0, lsr #6
void nrf_driver_start_pairing(int ms) {
 8023ae8:	b085      	sub	sp, #20
	pairing_time_end = chVTGetSystemTimeX() + MS2ST(ms);
 8023aea:	6028      	str	r0, [r5, #0]
	if (!pairing_active) {
 8023aec:	b114      	cbz	r4, 8023af4 <nrf_driver_start_pairing+0x34>
}
 8023aee:	b005      	add	sp, #20
 8023af0:	bd30      	pop	{r4, r5, pc}
 8023af2:	4770      	bx	lr
		pairing_active = true;
 8023af4:	2501      	movs	r5, #1
 8023af6:	700d      	strb	r5, [r1, #0]
		nrf_config conf = app_get_configuration()->app_nrf_conf;
 8023af8:	f7fc fd52 	bl	80205a0 <app_get_configuration>
 8023afc:	30bc      	adds	r0, #188	; 0xbc
 8023afe:	c807      	ldmia	r0, {r0, r1, r2}
		conf.speed = NRF_SPEED_250K;
 8023b00:	aa04      	add	r2, sp, #16
		nrf_config conf = app_get_configuration()->app_nrf_conf;
 8023b02:	ab01      	add	r3, sp, #4
 8023b04:	c303      	stmia	r3!, {r0, r1}
		conf.speed = NRF_SPEED_250K;
 8023b06:	f802 4d0c 	strb.w	r4, [r2, #-12]!
		conf.retries = 3;
 8023b0a:	490d      	ldr	r1, [pc, #52]	; (8023b40 <nrf_driver_start_pairing+0x80>)
		conf.send_crc_ack = true;
 8023b0c:	f88d 500d 	strb.w	r5, [sp, #13]
		conf.retry_delay = NRF_RETR_DELAY_1000US;
 8023b10:	2303      	movs	r3, #3
		rfhelp_update_conf(&conf);
 8023b12:	4610      	mov	r0, r2
		conf.crc_type = NRF_CRC_1B;
 8023b14:	f88d 5006 	strb.w	r5, [sp, #6]
		conf.address[1] = 0xC5;
 8023b18:	f88d 400c 	strb.w	r4, [sp, #12]
		conf.retries = 3;
 8023b1c:	9102      	str	r1, [sp, #8]
		conf.retry_delay = NRF_RETR_DELAY_1000US;
 8023b1e:	f88d 3007 	strb.w	r3, [sp, #7]
		rfhelp_update_conf(&conf);
 8023b22:	f7ff fb95 	bl	8023250 <rfhelp_update_conf>
}
 8023b26:	b005      	add	sp, #20
 8023b28:	bd30      	pop	{r4, r5, pc}
 8023b2a:	bf00      	nop
 8023b2c:	20010f50 	.word	0x20010f50
 8023b30:	20001a48 	.word	0x20001a48
 8023b34:	10624dd3 	.word	0x10624dd3
 8023b38:	20010b48 	.word	0x20010b48
 8023b3c:	20010b4c 	.word	0x20010b4c
 8023b40:	c5c67c03 	.word	0xc5c67c03
	...

08023b50 <ADC_DeInit>:
 8023b50:	b508      	push	{r3, lr}
 8023b52:	2101      	movs	r1, #1
 8023b54:	f44f 7080 	mov.w	r0, #256	; 0x100
 8023b58:	f000 fb9a 	bl	8024290 <RCC_APB2PeriphResetCmd>
 8023b5c:	2100      	movs	r1, #0
 8023b5e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8023b62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8023b66:	f000 bb93 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 8023b6a:	bf00      	nop
 8023b6c:	0000      	movs	r0, r0
	...

08023b70 <ADC_Init>:
 8023b70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023b72:	6844      	ldr	r4, [r0, #4]
 8023b74:	680a      	ldr	r2, [r1, #0]
 8023b76:	790e      	ldrb	r6, [r1, #4]
 8023b78:	f8d1 e010 	ldr.w	lr, [r1, #16]
 8023b7c:	68cd      	ldr	r5, [r1, #12]
 8023b7e:	4b0f      	ldr	r3, [pc, #60]	; (8023bbc <ADC_Init+0x4c>)
 8023b80:	f024 7440 	bic.w	r4, r4, #50331648	; 0x3000000
 8023b84:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 8023b88:	4322      	orrs	r2, r4
 8023b8a:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
 8023b8e:	6042      	str	r2, [r0, #4]
 8023b90:	6887      	ldr	r7, [r0, #8]
 8023b92:	688a      	ldr	r2, [r1, #8]
 8023b94:	794e      	ldrb	r6, [r1, #5]
 8023b96:	ea4e 0405 	orr.w	r4, lr, r5
 8023b9a:	4322      	orrs	r2, r4
 8023b9c:	403b      	ands	r3, r7
 8023b9e:	4313      	orrs	r3, r2
 8023ba0:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
 8023ba4:	6083      	str	r3, [r0, #8]
 8023ba6:	7d0a      	ldrb	r2, [r1, #20]
 8023ba8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8023baa:	3a01      	subs	r2, #1
 8023bac:	b2d2      	uxtb	r2, r2
 8023bae:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8023bb2:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 8023bb6:	62c3      	str	r3, [r0, #44]	; 0x2c
 8023bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023bba:	bf00      	nop
 8023bbc:	c0fff7fd 	.word	0xc0fff7fd

08023bc0 <ADC_CommonInit>:
 8023bc0:	b470      	push	{r4, r5, r6}
 8023bc2:	6842      	ldr	r2, [r0, #4]
 8023bc4:	6806      	ldr	r6, [r0, #0]
 8023bc6:	4d06      	ldr	r5, [pc, #24]	; (8023be0 <ADC_CommonInit+0x20>)
 8023bc8:	6884      	ldr	r4, [r0, #8]
 8023bca:	68c1      	ldr	r1, [r0, #12]
 8023bcc:	4b05      	ldr	r3, [pc, #20]	; (8023be4 <ADC_CommonInit+0x24>)
 8023bce:	6868      	ldr	r0, [r5, #4]
 8023bd0:	4332      	orrs	r2, r6
 8023bd2:	4322      	orrs	r2, r4
 8023bd4:	430a      	orrs	r2, r1
 8023bd6:	4003      	ands	r3, r0
 8023bd8:	4313      	orrs	r3, r2
 8023bda:	606b      	str	r3, [r5, #4]
 8023bdc:	bc70      	pop	{r4, r5, r6}
 8023bde:	4770      	bx	lr
 8023be0:	40012300 	.word	0x40012300
 8023be4:	fffc30e0 	.word	0xfffc30e0
	...

08023bf0 <ADC_Cmd>:
 8023bf0:	6883      	ldr	r3, [r0, #8]
 8023bf2:	b919      	cbnz	r1, 8023bfc <ADC_Cmd+0xc>
 8023bf4:	f023 0301 	bic.w	r3, r3, #1
 8023bf8:	6083      	str	r3, [r0, #8]
 8023bfa:	4770      	bx	lr
 8023bfc:	f043 0301 	orr.w	r3, r3, #1
 8023c00:	6083      	str	r3, [r0, #8]
 8023c02:	4770      	bx	lr
	...

08023c10 <ADC_TempSensorVrefintCmd>:
 8023c10:	4a05      	ldr	r2, [pc, #20]	; (8023c28 <ADC_TempSensorVrefintCmd+0x18>)
 8023c12:	6853      	ldr	r3, [r2, #4]
 8023c14:	b918      	cbnz	r0, 8023c1e <ADC_TempSensorVrefintCmd+0xe>
 8023c16:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8023c1a:	6053      	str	r3, [r2, #4]
 8023c1c:	4770      	bx	lr
 8023c1e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023c22:	6053      	str	r3, [r2, #4]
 8023c24:	4770      	bx	lr
 8023c26:	bf00      	nop
 8023c28:	40012300 	.word	0x40012300
 8023c2c:	00000000 	.word	0x00000000

08023c30 <ADC_RegularChannelConfig>:
 8023c30:	2909      	cmp	r1, #9
 8023c32:	b470      	push	{r4, r5, r6}
 8023c34:	d91d      	bls.n	8023c72 <ADC_RegularChannelConfig+0x42>
 8023c36:	f1a1 060a 	sub.w	r6, r1, #10
 8023c3a:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8023c3e:	68c5      	ldr	r5, [r0, #12]
 8023c40:	2407      	movs	r4, #7
 8023c42:	40b4      	lsls	r4, r6
 8023c44:	40b3      	lsls	r3, r6
 8023c46:	ea25 0404 	bic.w	r4, r5, r4
 8023c4a:	4323      	orrs	r3, r4
 8023c4c:	2a06      	cmp	r2, #6
 8023c4e:	60c3      	str	r3, [r0, #12]
 8023c50:	d91b      	bls.n	8023c8a <ADC_RegularChannelConfig+0x5a>
 8023c52:	2a0c      	cmp	r2, #12
 8023c54:	d927      	bls.n	8023ca6 <ADC_RegularChannelConfig+0x76>
 8023c56:	3a0d      	subs	r2, #13
 8023c58:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8023c5c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8023c5e:	241f      	movs	r4, #31
 8023c60:	4094      	lsls	r4, r2
 8023c62:	fa01 f202 	lsl.w	r2, r1, r2
 8023c66:	ea23 0104 	bic.w	r1, r3, r4
 8023c6a:	430a      	orrs	r2, r1
 8023c6c:	62c2      	str	r2, [r0, #44]	; 0x2c
 8023c6e:	bc70      	pop	{r4, r5, r6}
 8023c70:	4770      	bx	lr
 8023c72:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 8023c76:	6905      	ldr	r5, [r0, #16]
 8023c78:	2407      	movs	r4, #7
 8023c7a:	40b4      	lsls	r4, r6
 8023c7c:	40b3      	lsls	r3, r6
 8023c7e:	ea25 0404 	bic.w	r4, r5, r4
 8023c82:	4323      	orrs	r3, r4
 8023c84:	2a06      	cmp	r2, #6
 8023c86:	6103      	str	r3, [r0, #16]
 8023c88:	d8e3      	bhi.n	8023c52 <ADC_RegularChannelConfig+0x22>
 8023c8a:	3a01      	subs	r2, #1
 8023c8c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8023c90:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8023c92:	241f      	movs	r4, #31
 8023c94:	4094      	lsls	r4, r2
 8023c96:	fa01 f202 	lsl.w	r2, r1, r2
 8023c9a:	ea23 0104 	bic.w	r1, r3, r4
 8023c9e:	430a      	orrs	r2, r1
 8023ca0:	6342      	str	r2, [r0, #52]	; 0x34
 8023ca2:	bc70      	pop	{r4, r5, r6}
 8023ca4:	4770      	bx	lr
 8023ca6:	3a07      	subs	r2, #7
 8023ca8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8023cac:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8023cae:	241f      	movs	r4, #31
 8023cb0:	4094      	lsls	r4, r2
 8023cb2:	fa01 f202 	lsl.w	r2, r1, r2
 8023cb6:	ea23 0104 	bic.w	r1, r3, r4
 8023cba:	430a      	orrs	r2, r1
 8023cbc:	6302      	str	r2, [r0, #48]	; 0x30
 8023cbe:	bc70      	pop	{r4, r5, r6}
 8023cc0:	4770      	bx	lr
 8023cc2:	bf00      	nop
	...

08023cd0 <ADC_MultiModeDMARequestAfterLastTransferCmd>:
 8023cd0:	4a05      	ldr	r2, [pc, #20]	; (8023ce8 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x18>)
 8023cd2:	6853      	ldr	r3, [r2, #4]
 8023cd4:	b918      	cbnz	r0, 8023cde <ADC_MultiModeDMARequestAfterLastTransferCmd+0xe>
 8023cd6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8023cda:	6053      	str	r3, [r2, #4]
 8023cdc:	4770      	bx	lr
 8023cde:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8023ce2:	6053      	str	r3, [r2, #4]
 8023ce4:	4770      	bx	lr
 8023ce6:	bf00      	nop
 8023ce8:	40012300 	.word	0x40012300
 8023cec:	00000000 	.word	0x00000000

08023cf0 <ADC_InjectedChannelConfig>:
 8023cf0:	2909      	cmp	r1, #9
 8023cf2:	b470      	push	{r4, r5, r6}
 8023cf4:	d81b      	bhi.n	8023d2e <ADC_InjectedChannelConfig+0x3e>
 8023cf6:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 8023cfa:	6905      	ldr	r5, [r0, #16]
 8023cfc:	2407      	movs	r4, #7
 8023cfe:	40b4      	lsls	r4, r6
 8023d00:	40b3      	lsls	r3, r6
 8023d02:	ea25 0404 	bic.w	r4, r5, r4
 8023d06:	4323      	orrs	r3, r4
 8023d08:	6103      	str	r3, [r0, #16]
 8023d0a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8023d0c:	3202      	adds	r2, #2
 8023d0e:	f3c3 5401 	ubfx	r4, r3, #20, #2
 8023d12:	1b12      	subs	r2, r2, r4
 8023d14:	b2d2      	uxtb	r2, r2
 8023d16:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8023d1a:	241f      	movs	r4, #31
 8023d1c:	4094      	lsls	r4, r2
 8023d1e:	ea23 0304 	bic.w	r3, r3, r4
 8023d22:	fa01 f202 	lsl.w	r2, r1, r2
 8023d26:	4313      	orrs	r3, r2
 8023d28:	6383      	str	r3, [r0, #56]	; 0x38
 8023d2a:	bc70      	pop	{r4, r5, r6}
 8023d2c:	4770      	bx	lr
 8023d2e:	f1a1 060a 	sub.w	r6, r1, #10
 8023d32:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8023d36:	68c5      	ldr	r5, [r0, #12]
 8023d38:	2407      	movs	r4, #7
 8023d3a:	40b4      	lsls	r4, r6
 8023d3c:	40b3      	lsls	r3, r6
 8023d3e:	ea25 0404 	bic.w	r4, r5, r4
 8023d42:	4323      	orrs	r3, r4
 8023d44:	60c3      	str	r3, [r0, #12]
 8023d46:	e7e0      	b.n	8023d0a <ADC_InjectedChannelConfig+0x1a>
	...

08023d50 <ADC_InjectedSequencerLengthConfig>:
 8023d50:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8023d52:	3901      	subs	r1, #1
 8023d54:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8023d58:	ea43 5101 	orr.w	r1, r3, r1, lsl #20
 8023d5c:	6381      	str	r1, [r0, #56]	; 0x38
 8023d5e:	4770      	bx	lr

08023d60 <ADC_ExternalTrigInjectedConvConfig>:
 8023d60:	6883      	ldr	r3, [r0, #8]
 8023d62:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8023d66:	4319      	orrs	r1, r3
 8023d68:	6081      	str	r1, [r0, #8]
 8023d6a:	4770      	bx	lr
 8023d6c:	0000      	movs	r0, r0
	...

08023d70 <ADC_ExternalTrigInjectedConvEdgeConfig>:
 8023d70:	6883      	ldr	r3, [r0, #8]
 8023d72:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8023d76:	4319      	orrs	r1, r3
 8023d78:	6081      	str	r1, [r0, #8]
 8023d7a:	4770      	bx	lr
 8023d7c:	0000      	movs	r0, r0
	...

08023d80 <ADC_GetInjectedConversionValue>:
 8023d80:	b082      	sub	sp, #8
 8023d82:	2300      	movs	r3, #0
 8023d84:	9301      	str	r3, [sp, #4]
 8023d86:	9001      	str	r0, [sp, #4]
 8023d88:	9b01      	ldr	r3, [sp, #4]
 8023d8a:	3328      	adds	r3, #40	; 0x28
 8023d8c:	4419      	add	r1, r3
 8023d8e:	9101      	str	r1, [sp, #4]
 8023d90:	9b01      	ldr	r3, [sp, #4]
 8023d92:	6818      	ldr	r0, [r3, #0]
 8023d94:	b280      	uxth	r0, r0
 8023d96:	b002      	add	sp, #8
 8023d98:	4770      	bx	lr
 8023d9a:	bf00      	nop
 8023d9c:	0000      	movs	r0, r0
	...

08023da0 <ADC_ITConfig>:
 8023da0:	b2c9      	uxtb	r1, r1
 8023da2:	2301      	movs	r3, #1
 8023da4:	408b      	lsls	r3, r1
 8023da6:	6841      	ldr	r1, [r0, #4]
 8023da8:	b91a      	cbnz	r2, 8023db2 <ADC_ITConfig+0x12>
 8023daa:	ea21 0303 	bic.w	r3, r1, r3
 8023dae:	6043      	str	r3, [r0, #4]
 8023db0:	4770      	bx	lr
 8023db2:	430b      	orrs	r3, r1
 8023db4:	6043      	str	r3, [r0, #4]
 8023db6:	4770      	bx	lr
	...

08023dc0 <ADC_ClearITPendingBit>:
 8023dc0:	ea6f 2111 	mvn.w	r1, r1, lsr #8
 8023dc4:	6001      	str	r1, [r0, #0]
 8023dc6:	4770      	bx	lr
	...

08023dd0 <DMA_DeInit>:
 8023dd0:	6802      	ldr	r2, [r0, #0]
 8023dd2:	4937      	ldr	r1, [pc, #220]	; (8023eb0 <DMA_DeInit+0xe0>)
 8023dd4:	2300      	movs	r3, #0
 8023dd6:	b410      	push	{r4}
 8023dd8:	f022 0201 	bic.w	r2, r2, #1
 8023ddc:	2421      	movs	r4, #33	; 0x21
 8023dde:	4288      	cmp	r0, r1
 8023de0:	6002      	str	r2, [r0, #0]
 8023de2:	6003      	str	r3, [r0, #0]
 8023de4:	6043      	str	r3, [r0, #4]
 8023de6:	6083      	str	r3, [r0, #8]
 8023de8:	60c3      	str	r3, [r0, #12]
 8023dea:	6103      	str	r3, [r0, #16]
 8023dec:	6144      	str	r4, [r0, #20]
 8023dee:	d04d      	beq.n	8023e8c <DMA_DeInit+0xbc>
 8023df0:	4b30      	ldr	r3, [pc, #192]	; (8023eb4 <DMA_DeInit+0xe4>)
 8023df2:	4298      	cmp	r0, r3
 8023df4:	d035      	beq.n	8023e62 <DMA_DeInit+0x92>
 8023df6:	4b30      	ldr	r3, [pc, #192]	; (8023eb8 <DMA_DeInit+0xe8>)
 8023df8:	4298      	cmp	r0, r3
 8023dfa:	d039      	beq.n	8023e70 <DMA_DeInit+0xa0>
 8023dfc:	4b2f      	ldr	r3, [pc, #188]	; (8023ebc <DMA_DeInit+0xec>)
 8023dfe:	4298      	cmp	r0, r3
 8023e00:	d03d      	beq.n	8023e7e <DMA_DeInit+0xae>
 8023e02:	4b2f      	ldr	r3, [pc, #188]	; (8023ec0 <DMA_DeInit+0xf0>)
 8023e04:	4298      	cmp	r0, r3
 8023e06:	d047      	beq.n	8023e98 <DMA_DeInit+0xc8>
 8023e08:	4b2e      	ldr	r3, [pc, #184]	; (8023ec4 <DMA_DeInit+0xf4>)
 8023e0a:	4298      	cmp	r0, r3
 8023e0c:	d048      	beq.n	8023ea0 <DMA_DeInit+0xd0>
 8023e0e:	4b2e      	ldr	r3, [pc, #184]	; (8023ec8 <DMA_DeInit+0xf8>)
 8023e10:	4298      	cmp	r0, r3
 8023e12:	d01d      	beq.n	8023e50 <DMA_DeInit+0x80>
 8023e14:	4b2d      	ldr	r3, [pc, #180]	; (8023ecc <DMA_DeInit+0xfc>)
 8023e16:	4298      	cmp	r0, r3
 8023e18:	d01e      	beq.n	8023e58 <DMA_DeInit+0x88>
 8023e1a:	4b2d      	ldr	r3, [pc, #180]	; (8023ed0 <DMA_DeInit+0x100>)
 8023e1c:	4298      	cmp	r0, r3
 8023e1e:	d043      	beq.n	8023ea8 <DMA_DeInit+0xd8>
 8023e20:	4b2c      	ldr	r3, [pc, #176]	; (8023ed4 <DMA_DeInit+0x104>)
 8023e22:	4298      	cmp	r0, r3
 8023e24:	d01d      	beq.n	8023e62 <DMA_DeInit+0x92>
 8023e26:	4b2c      	ldr	r3, [pc, #176]	; (8023ed8 <DMA_DeInit+0x108>)
 8023e28:	4298      	cmp	r0, r3
 8023e2a:	d021      	beq.n	8023e70 <DMA_DeInit+0xa0>
 8023e2c:	4b2b      	ldr	r3, [pc, #172]	; (8023edc <DMA_DeInit+0x10c>)
 8023e2e:	4298      	cmp	r0, r3
 8023e30:	d025      	beq.n	8023e7e <DMA_DeInit+0xae>
 8023e32:	4b2b      	ldr	r3, [pc, #172]	; (8023ee0 <DMA_DeInit+0x110>)
 8023e34:	4298      	cmp	r0, r3
 8023e36:	d02f      	beq.n	8023e98 <DMA_DeInit+0xc8>
 8023e38:	4b2a      	ldr	r3, [pc, #168]	; (8023ee4 <DMA_DeInit+0x114>)
 8023e3a:	4298      	cmp	r0, r3
 8023e3c:	d030      	beq.n	8023ea0 <DMA_DeInit+0xd0>
 8023e3e:	4b2a      	ldr	r3, [pc, #168]	; (8023ee8 <DMA_DeInit+0x118>)
 8023e40:	4298      	cmp	r0, r3
 8023e42:	d005      	beq.n	8023e50 <DMA_DeInit+0x80>
 8023e44:	4b29      	ldr	r3, [pc, #164]	; (8023eec <DMA_DeInit+0x11c>)
 8023e46:	4298      	cmp	r0, r3
 8023e48:	d006      	beq.n	8023e58 <DMA_DeInit+0x88>
 8023e4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023e4e:	4770      	bx	lr
 8023e50:	4a27      	ldr	r2, [pc, #156]	; (8023ef0 <DMA_DeInit+0x120>)
 8023e52:	f843 2c94 	str.w	r2, [r3, #-148]
 8023e56:	e7f8      	b.n	8023e4a <DMA_DeInit+0x7a>
 8023e58:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8023e5c:	f843 2cac 	str.w	r2, [r3, #-172]
 8023e60:	e7f3      	b.n	8023e4a <DMA_DeInit+0x7a>
 8023e62:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8023e66:	f843 2c20 	str.w	r2, [r3, #-32]
 8023e6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023e6e:	4770      	bx	lr
 8023e70:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8023e74:	f843 2c38 	str.w	r2, [r3, #-56]
 8023e78:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023e7c:	4770      	bx	lr
 8023e7e:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8023e82:	f843 2c50 	str.w	r2, [r3, #-80]
 8023e86:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023e8a:	4770      	bx	lr
 8023e8c:	4b19      	ldr	r3, [pc, #100]	; (8023ef4 <DMA_DeInit+0x124>)
 8023e8e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023e92:	223d      	movs	r2, #61	; 0x3d
 8023e94:	609a      	str	r2, [r3, #8]
 8023e96:	4770      	bx	lr
 8023e98:	4a17      	ldr	r2, [pc, #92]	; (8023ef8 <DMA_DeInit+0x128>)
 8023e9a:	f843 2c64 	str.w	r2, [r3, #-100]
 8023e9e:	e7d4      	b.n	8023e4a <DMA_DeInit+0x7a>
 8023ea0:	4a16      	ldr	r2, [pc, #88]	; (8023efc <DMA_DeInit+0x12c>)
 8023ea2:	f843 2c7c 	str.w	r2, [r3, #-124]
 8023ea6:	e7d0      	b.n	8023e4a <DMA_DeInit+0x7a>
 8023ea8:	223d      	movs	r2, #61	; 0x3d
 8023eaa:	f843 2c08 	str.w	r2, [r3, #-8]
 8023eae:	e7cc      	b.n	8023e4a <DMA_DeInit+0x7a>
 8023eb0:	40026010 	.word	0x40026010
 8023eb4:	40026028 	.word	0x40026028
 8023eb8:	40026040 	.word	0x40026040
 8023ebc:	40026058 	.word	0x40026058
 8023ec0:	40026070 	.word	0x40026070
 8023ec4:	40026088 	.word	0x40026088
 8023ec8:	400260a0 	.word	0x400260a0
 8023ecc:	400260b8 	.word	0x400260b8
 8023ed0:	40026410 	.word	0x40026410
 8023ed4:	40026428 	.word	0x40026428
 8023ed8:	40026440 	.word	0x40026440
 8023edc:	40026458 	.word	0x40026458
 8023ee0:	40026470 	.word	0x40026470
 8023ee4:	40026488 	.word	0x40026488
 8023ee8:	400264a0 	.word	0x400264a0
 8023eec:	400264b8 	.word	0x400264b8
 8023ef0:	203d0000 	.word	0x203d0000
 8023ef4:	40026000 	.word	0x40026000
 8023ef8:	2000003d 	.word	0x2000003d
 8023efc:	20000f40 	.word	0x20000f40

08023f00 <DMA_Init>:
 8023f00:	f101 0218 	add.w	r2, r1, #24
 8023f04:	b4f0      	push	{r4, r5, r6, r7}
 8023f06:	ca8c      	ldmia	r2, {r2, r3, r7}
 8023f08:	68cd      	ldr	r5, [r1, #12]
 8023f0a:	680e      	ldr	r6, [r1, #0]
 8023f0c:	694c      	ldr	r4, [r1, #20]
 8023f0e:	432e      	orrs	r6, r5
 8023f10:	4326      	orrs	r6, r4
 8023f12:	4316      	orrs	r6, r2
 8023f14:	431e      	orrs	r6, r3
 8023f16:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8023f18:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8023f1a:	6b4d      	ldr	r5, [r1, #52]	; 0x34
 8023f1c:	6b8c      	ldr	r4, [r1, #56]	; 0x38
 8023f1e:	433e      	orrs	r6, r7
 8023f20:	4316      	orrs	r6, r2
 8023f22:	431e      	orrs	r6, r3
 8023f24:	4a0b      	ldr	r2, [pc, #44]	; (8023f54 <DMA_Init+0x54>)
 8023f26:	6803      	ldr	r3, [r0, #0]
 8023f28:	6acf      	ldr	r7, [r1, #44]	; 0x2c
 8023f2a:	4335      	orrs	r5, r6
 8023f2c:	432c      	orrs	r4, r5
 8023f2e:	401a      	ands	r2, r3
 8023f30:	4322      	orrs	r2, r4
 8023f32:	6002      	str	r2, [r0, #0]
 8023f34:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8023f36:	6942      	ldr	r2, [r0, #20]
 8023f38:	690d      	ldr	r5, [r1, #16]
 8023f3a:	684c      	ldr	r4, [r1, #4]
 8023f3c:	6889      	ldr	r1, [r1, #8]
 8023f3e:	433b      	orrs	r3, r7
 8023f40:	f022 0207 	bic.w	r2, r2, #7
 8023f44:	4313      	orrs	r3, r2
 8023f46:	6143      	str	r3, [r0, #20]
 8023f48:	6045      	str	r5, [r0, #4]
 8023f4a:	6084      	str	r4, [r0, #8]
 8023f4c:	60c1      	str	r1, [r0, #12]
 8023f4e:	bcf0      	pop	{r4, r5, r6, r7}
 8023f50:	4770      	bx	lr
 8023f52:	bf00      	nop
 8023f54:	f01c803f 	.word	0xf01c803f
	...

08023f60 <DMA_Cmd>:
 8023f60:	6803      	ldr	r3, [r0, #0]
 8023f62:	b919      	cbnz	r1, 8023f6c <DMA_Cmd+0xc>
 8023f64:	f023 0301 	bic.w	r3, r3, #1
 8023f68:	6003      	str	r3, [r0, #0]
 8023f6a:	4770      	bx	lr
 8023f6c:	f043 0301 	orr.w	r3, r3, #1
 8023f70:	6003      	str	r3, [r0, #0]
 8023f72:	4770      	bx	lr
	...

08023f80 <DMA_ITConfig>:
 8023f80:	060b      	lsls	r3, r1, #24
 8023f82:	d50c      	bpl.n	8023f9e <DMA_ITConfig+0x1e>
 8023f84:	6943      	ldr	r3, [r0, #20]
 8023f86:	b1aa      	cbz	r2, 8023fb4 <DMA_ITConfig+0x34>
 8023f88:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8023f8c:	2980      	cmp	r1, #128	; 0x80
 8023f8e:	6143      	str	r3, [r0, #20]
 8023f90:	d00f      	beq.n	8023fb2 <DMA_ITConfig+0x32>
 8023f92:	6803      	ldr	r3, [r0, #0]
 8023f94:	f001 011e 	and.w	r1, r1, #30
 8023f98:	4319      	orrs	r1, r3
 8023f9a:	6001      	str	r1, [r0, #0]
 8023f9c:	4770      	bx	lr
 8023f9e:	2980      	cmp	r1, #128	; 0x80
 8023fa0:	d007      	beq.n	8023fb2 <DMA_ITConfig+0x32>
 8023fa2:	2a00      	cmp	r2, #0
 8023fa4:	d1f5      	bne.n	8023f92 <DMA_ITConfig+0x12>
 8023fa6:	6803      	ldr	r3, [r0, #0]
 8023fa8:	f001 011e 	and.w	r1, r1, #30
 8023fac:	ea23 0101 	bic.w	r1, r3, r1
 8023fb0:	6001      	str	r1, [r0, #0]
 8023fb2:	4770      	bx	lr
 8023fb4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8023fb8:	2980      	cmp	r1, #128	; 0x80
 8023fba:	6143      	str	r3, [r0, #20]
 8023fbc:	d1f3      	bne.n	8023fa6 <DMA_ITConfig+0x26>
 8023fbe:	4770      	bx	lr

08023fc0 <EXTI_Init>:
 8023fc0:	7983      	ldrb	r3, [r0, #6]
 8023fc2:	b333      	cbz	r3, 8024012 <EXTI_Init+0x52>
 8023fc4:	4b1c      	ldr	r3, [pc, #112]	; (8024038 <EXTI_Init+0x78>)
 8023fc6:	7902      	ldrb	r2, [r0, #4]
 8023fc8:	7941      	ldrb	r1, [r0, #5]
 8023fca:	b4f0      	push	{r4, r5, r6, r7}
 8023fcc:	6807      	ldr	r7, [r0, #0]
 8023fce:	681e      	ldr	r6, [r3, #0]
 8023fd0:	43fc      	mvns	r4, r7
 8023fd2:	4026      	ands	r6, r4
 8023fd4:	601e      	str	r6, [r3, #0]
 8023fd6:	685d      	ldr	r5, [r3, #4]
 8023fd8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8023fdc:	4025      	ands	r5, r4
 8023fde:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 8023fe2:	605d      	str	r5, [r3, #4]
 8023fe4:	6814      	ldr	r4, [r2, #0]
 8023fe6:	433c      	orrs	r4, r7
 8023fe8:	6014      	str	r4, [r2, #0]
 8023fea:	6804      	ldr	r4, [r0, #0]
 8023fec:	6898      	ldr	r0, [r3, #8]
 8023fee:	43e5      	mvns	r5, r4
 8023ff0:	4028      	ands	r0, r5
 8023ff2:	6098      	str	r0, [r3, #8]
 8023ff4:	68da      	ldr	r2, [r3, #12]
 8023ff6:	2910      	cmp	r1, #16
 8023ff8:	ea02 0205 	and.w	r2, r2, r5
 8023ffc:	60da      	str	r2, [r3, #12]
 8023ffe:	d013      	beq.n	8024028 <EXTI_Init+0x68>
 8024000:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 8024004:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 8024008:	681a      	ldr	r2, [r3, #0]
 802400a:	4314      	orrs	r4, r2
 802400c:	601c      	str	r4, [r3, #0]
 802400e:	bcf0      	pop	{r4, r5, r6, r7}
 8024010:	4770      	bx	lr
 8024012:	7903      	ldrb	r3, [r0, #4]
 8024014:	6801      	ldr	r1, [r0, #0]
 8024016:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 802401a:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 802401e:	681a      	ldr	r2, [r3, #0]
 8024020:	ea22 0201 	bic.w	r2, r2, r1
 8024024:	601a      	str	r2, [r3, #0]
 8024026:	4770      	bx	lr
 8024028:	689a      	ldr	r2, [r3, #8]
 802402a:	4322      	orrs	r2, r4
 802402c:	609a      	str	r2, [r3, #8]
 802402e:	68da      	ldr	r2, [r3, #12]
 8024030:	4314      	orrs	r4, r2
 8024032:	60dc      	str	r4, [r3, #12]
 8024034:	bcf0      	pop	{r4, r5, r6, r7}
 8024036:	4770      	bx	lr
 8024038:	40013c00 	.word	0x40013c00
 802403c:	00000000 	.word	0x00000000

08024040 <EXTI_GetITStatus>:
 8024040:	4b03      	ldr	r3, [pc, #12]	; (8024050 <EXTI_GetITStatus+0x10>)
 8024042:	695b      	ldr	r3, [r3, #20]
 8024044:	4203      	tst	r3, r0
 8024046:	bf14      	ite	ne
 8024048:	2001      	movne	r0, #1
 802404a:	2000      	moveq	r0, #0
 802404c:	4770      	bx	lr
 802404e:	bf00      	nop
 8024050:	40013c00 	.word	0x40013c00
	...

08024060 <EXTI_ClearITPendingBit>:
 8024060:	4b01      	ldr	r3, [pc, #4]	; (8024068 <EXTI_ClearITPendingBit+0x8>)
 8024062:	6158      	str	r0, [r3, #20]
 8024064:	4770      	bx	lr
 8024066:	bf00      	nop
 8024068:	40013c00 	.word	0x40013c00
 802406c:	00000000 	.word	0x00000000

08024070 <FLASH_Unlock>:
 8024070:	4b04      	ldr	r3, [pc, #16]	; (8024084 <FLASH_Unlock+0x14>)
 8024072:	691a      	ldr	r2, [r3, #16]
 8024074:	2a00      	cmp	r2, #0
 8024076:	da03      	bge.n	8024080 <FLASH_Unlock+0x10>
 8024078:	4903      	ldr	r1, [pc, #12]	; (8024088 <FLASH_Unlock+0x18>)
 802407a:	4a04      	ldr	r2, [pc, #16]	; (802408c <FLASH_Unlock+0x1c>)
 802407c:	6059      	str	r1, [r3, #4]
 802407e:	605a      	str	r2, [r3, #4]
 8024080:	4770      	bx	lr
 8024082:	bf00      	nop
 8024084:	40023c00 	.word	0x40023c00
 8024088:	45670123 	.word	0x45670123
 802408c:	cdef89ab 	.word	0xcdef89ab

08024090 <FLASH_ClearFlag>:
 8024090:	4b01      	ldr	r3, [pc, #4]	; (8024098 <FLASH_ClearFlag+0x8>)
 8024092:	60d8      	str	r0, [r3, #12]
 8024094:	4770      	bx	lr
 8024096:	bf00      	nop
 8024098:	40023c00 	.word	0x40023c00
 802409c:	00000000 	.word	0x00000000

080240a0 <FLASH_GetStatus>:
 80240a0:	4b0e      	ldr	r3, [pc, #56]	; (80240dc <FLASH_GetStatus+0x3c>)
 80240a2:	68da      	ldr	r2, [r3, #12]
 80240a4:	03d2      	lsls	r2, r2, #15
 80240a6:	d409      	bmi.n	80240bc <FLASH_GetStatus+0x1c>
 80240a8:	68da      	ldr	r2, [r3, #12]
 80240aa:	06d1      	lsls	r1, r2, #27
 80240ac:	d501      	bpl.n	80240b2 <FLASH_GetStatus+0x12>
 80240ae:	2006      	movs	r0, #6
 80240b0:	4770      	bx	lr
 80240b2:	68da      	ldr	r2, [r3, #12]
 80240b4:	05d2      	lsls	r2, r2, #23
 80240b6:	d503      	bpl.n	80240c0 <FLASH_GetStatus+0x20>
 80240b8:	2002      	movs	r0, #2
 80240ba:	4770      	bx	lr
 80240bc:	2001      	movs	r0, #1
 80240be:	4770      	bx	lr
 80240c0:	68da      	ldr	r2, [r3, #12]
 80240c2:	f012 0fe0 	tst.w	r2, #224	; 0xe0
 80240c6:	d001      	beq.n	80240cc <FLASH_GetStatus+0x2c>
 80240c8:	2007      	movs	r0, #7
 80240ca:	4770      	bx	lr
 80240cc:	68db      	ldr	r3, [r3, #12]
 80240ce:	f013 0f02 	tst.w	r3, #2
 80240d2:	bf14      	ite	ne
 80240d4:	2008      	movne	r0, #8
 80240d6:	2009      	moveq	r0, #9
 80240d8:	4770      	bx	lr
 80240da:	bf00      	nop
 80240dc:	40023c00 	.word	0x40023c00

080240e0 <FLASH_WaitForLastOperation>:
 80240e0:	b500      	push	{lr}
 80240e2:	b083      	sub	sp, #12
 80240e4:	2309      	movs	r3, #9
 80240e6:	f88d 3007 	strb.w	r3, [sp, #7]
 80240ea:	f7ff ffd9 	bl	80240a0 <FLASH_GetStatus>
 80240ee:	f88d 0007 	strb.w	r0, [sp, #7]
 80240f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80240f6:	2b01      	cmp	r3, #1
 80240f8:	d0f7      	beq.n	80240ea <FLASH_WaitForLastOperation+0xa>
 80240fa:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80240fe:	b2c0      	uxtb	r0, r0
 8024100:	b003      	add	sp, #12
 8024102:	f85d fb04 	ldr.w	pc, [sp], #4
 8024106:	bf00      	nop
	...

08024110 <FLASH_EraseSector>:
 8024110:	b570      	push	{r4, r5, r6, lr}
 8024112:	4606      	mov	r6, r0
 8024114:	b359      	cbz	r1, 802416e <FLASH_EraseSector+0x5e>
 8024116:	2901      	cmp	r1, #1
 8024118:	d02f      	beq.n	802417a <FLASH_EraseSector+0x6a>
 802411a:	2902      	cmp	r1, #2
 802411c:	bf0c      	ite	eq
 802411e:	f44f 7400 	moveq.w	r4, #512	; 0x200
 8024122:	f44f 7440 	movne.w	r4, #768	; 0x300
 8024126:	f7ff ffdb 	bl	80240e0 <FLASH_WaitForLastOperation>
 802412a:	2809      	cmp	r0, #9
 802412c:	d124      	bne.n	8024178 <FLASH_EraseSector+0x68>
 802412e:	4d14      	ldr	r5, [pc, #80]	; (8024180 <FLASH_EraseSector+0x70>)
 8024130:	692b      	ldr	r3, [r5, #16]
 8024132:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8024136:	612b      	str	r3, [r5, #16]
 8024138:	6929      	ldr	r1, [r5, #16]
 802413a:	4321      	orrs	r1, r4
 802413c:	6129      	str	r1, [r5, #16]
 802413e:	692b      	ldr	r3, [r5, #16]
 8024140:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8024144:	612b      	str	r3, [r5, #16]
 8024146:	692b      	ldr	r3, [r5, #16]
 8024148:	f043 0302 	orr.w	r3, r3, #2
 802414c:	431e      	orrs	r6, r3
 802414e:	612e      	str	r6, [r5, #16]
 8024150:	692b      	ldr	r3, [r5, #16]
 8024152:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8024156:	612b      	str	r3, [r5, #16]
 8024158:	f7ff ffc2 	bl	80240e0 <FLASH_WaitForLastOperation>
 802415c:	692b      	ldr	r3, [r5, #16]
 802415e:	f023 0302 	bic.w	r3, r3, #2
 8024162:	612b      	str	r3, [r5, #16]
 8024164:	692b      	ldr	r3, [r5, #16]
 8024166:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 802416a:	612b      	str	r3, [r5, #16]
 802416c:	bd70      	pop	{r4, r5, r6, pc}
 802416e:	460c      	mov	r4, r1
 8024170:	f7ff ffb6 	bl	80240e0 <FLASH_WaitForLastOperation>
 8024174:	2809      	cmp	r0, #9
 8024176:	d0da      	beq.n	802412e <FLASH_EraseSector+0x1e>
 8024178:	bd70      	pop	{r4, r5, r6, pc}
 802417a:	f44f 7480 	mov.w	r4, #256	; 0x100
 802417e:	e7f7      	b.n	8024170 <FLASH_EraseSector+0x60>
 8024180:	40023c00 	.word	0x40023c00
	...

08024190 <FLASH_ProgramHalfWord>:
 8024190:	b570      	push	{r4, r5, r6, lr}
 8024192:	4605      	mov	r5, r0
 8024194:	460e      	mov	r6, r1
 8024196:	f7ff ffa3 	bl	80240e0 <FLASH_WaitForLastOperation>
 802419a:	2809      	cmp	r0, #9
 802419c:	d000      	beq.n	80241a0 <FLASH_ProgramHalfWord+0x10>
 802419e:	bd70      	pop	{r4, r5, r6, pc}
 80241a0:	4c0a      	ldr	r4, [pc, #40]	; (80241cc <FLASH_ProgramHalfWord+0x3c>)
 80241a2:	6923      	ldr	r3, [r4, #16]
 80241a4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80241a8:	6123      	str	r3, [r4, #16]
 80241aa:	6923      	ldr	r3, [r4, #16]
 80241ac:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80241b0:	6123      	str	r3, [r4, #16]
 80241b2:	6923      	ldr	r3, [r4, #16]
 80241b4:	f043 0301 	orr.w	r3, r3, #1
 80241b8:	6123      	str	r3, [r4, #16]
 80241ba:	802e      	strh	r6, [r5, #0]
 80241bc:	f7ff ff90 	bl	80240e0 <FLASH_WaitForLastOperation>
 80241c0:	6923      	ldr	r3, [r4, #16]
 80241c2:	f023 0301 	bic.w	r3, r3, #1
 80241c6:	6123      	str	r3, [r4, #16]
 80241c8:	bd70      	pop	{r4, r5, r6, pc}
 80241ca:	bf00      	nop
 80241cc:	40023c00 	.word	0x40023c00

080241d0 <FLASH_ProgramByte>:
 80241d0:	b570      	push	{r4, r5, r6, lr}
 80241d2:	4605      	mov	r5, r0
 80241d4:	460e      	mov	r6, r1
 80241d6:	f7ff ff83 	bl	80240e0 <FLASH_WaitForLastOperation>
 80241da:	2809      	cmp	r0, #9
 80241dc:	d000      	beq.n	80241e0 <FLASH_ProgramByte+0x10>
 80241de:	bd70      	pop	{r4, r5, r6, pc}
 80241e0:	4c09      	ldr	r4, [pc, #36]	; (8024208 <FLASH_ProgramByte+0x38>)
 80241e2:	6923      	ldr	r3, [r4, #16]
 80241e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80241e8:	6123      	str	r3, [r4, #16]
 80241ea:	6923      	ldr	r3, [r4, #16]
 80241ec:	6123      	str	r3, [r4, #16]
 80241ee:	6923      	ldr	r3, [r4, #16]
 80241f0:	f043 0301 	orr.w	r3, r3, #1
 80241f4:	6123      	str	r3, [r4, #16]
 80241f6:	702e      	strb	r6, [r5, #0]
 80241f8:	f7ff ff72 	bl	80240e0 <FLASH_WaitForLastOperation>
 80241fc:	6923      	ldr	r3, [r4, #16]
 80241fe:	f023 0301 	bic.w	r3, r3, #1
 8024202:	6123      	str	r3, [r4, #16]
 8024204:	bd70      	pop	{r4, r5, r6, pc}
 8024206:	bf00      	nop
 8024208:	40023c00 	.word	0x40023c00
 802420c:	00000000 	.word	0x00000000

08024210 <RCC_AHB1PeriphClockCmd>:
 8024210:	b929      	cbnz	r1, 802421e <RCC_AHB1PeriphClockCmd+0xe>
 8024212:	4a05      	ldr	r2, [pc, #20]	; (8024228 <RCC_AHB1PeriphClockCmd+0x18>)
 8024214:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8024216:	ea23 0000 	bic.w	r0, r3, r0
 802421a:	6310      	str	r0, [r2, #48]	; 0x30
 802421c:	4770      	bx	lr
 802421e:	4b02      	ldr	r3, [pc, #8]	; (8024228 <RCC_AHB1PeriphClockCmd+0x18>)
 8024220:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8024222:	4310      	orrs	r0, r2
 8024224:	6318      	str	r0, [r3, #48]	; 0x30
 8024226:	4770      	bx	lr
 8024228:	40023800 	.word	0x40023800
 802422c:	00000000 	.word	0x00000000

08024230 <RCC_APB1PeriphClockCmd>:
 8024230:	b929      	cbnz	r1, 802423e <RCC_APB1PeriphClockCmd+0xe>
 8024232:	4a05      	ldr	r2, [pc, #20]	; (8024248 <RCC_APB1PeriphClockCmd+0x18>)
 8024234:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8024236:	ea23 0000 	bic.w	r0, r3, r0
 802423a:	6410      	str	r0, [r2, #64]	; 0x40
 802423c:	4770      	bx	lr
 802423e:	4b02      	ldr	r3, [pc, #8]	; (8024248 <RCC_APB1PeriphClockCmd+0x18>)
 8024240:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8024242:	4310      	orrs	r0, r2
 8024244:	6418      	str	r0, [r3, #64]	; 0x40
 8024246:	4770      	bx	lr
 8024248:	40023800 	.word	0x40023800
 802424c:	00000000 	.word	0x00000000

08024250 <RCC_APB2PeriphClockCmd>:
 8024250:	b929      	cbnz	r1, 802425e <RCC_APB2PeriphClockCmd+0xe>
 8024252:	4a05      	ldr	r2, [pc, #20]	; (8024268 <RCC_APB2PeriphClockCmd+0x18>)
 8024254:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8024256:	ea23 0000 	bic.w	r0, r3, r0
 802425a:	6450      	str	r0, [r2, #68]	; 0x44
 802425c:	4770      	bx	lr
 802425e:	4b02      	ldr	r3, [pc, #8]	; (8024268 <RCC_APB2PeriphClockCmd+0x18>)
 8024260:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8024262:	4310      	orrs	r0, r2
 8024264:	6458      	str	r0, [r3, #68]	; 0x44
 8024266:	4770      	bx	lr
 8024268:	40023800 	.word	0x40023800
 802426c:	00000000 	.word	0x00000000

08024270 <RCC_APB1PeriphResetCmd>:
 8024270:	b929      	cbnz	r1, 802427e <RCC_APB1PeriphResetCmd+0xe>
 8024272:	4a05      	ldr	r2, [pc, #20]	; (8024288 <RCC_APB1PeriphResetCmd+0x18>)
 8024274:	6a13      	ldr	r3, [r2, #32]
 8024276:	ea23 0000 	bic.w	r0, r3, r0
 802427a:	6210      	str	r0, [r2, #32]
 802427c:	4770      	bx	lr
 802427e:	4b02      	ldr	r3, [pc, #8]	; (8024288 <RCC_APB1PeriphResetCmd+0x18>)
 8024280:	6a1a      	ldr	r2, [r3, #32]
 8024282:	4310      	orrs	r0, r2
 8024284:	6218      	str	r0, [r3, #32]
 8024286:	4770      	bx	lr
 8024288:	40023800 	.word	0x40023800
 802428c:	00000000 	.word	0x00000000

08024290 <RCC_APB2PeriphResetCmd>:
 8024290:	b929      	cbnz	r1, 802429e <RCC_APB2PeriphResetCmd+0xe>
 8024292:	4a05      	ldr	r2, [pc, #20]	; (80242a8 <RCC_APB2PeriphResetCmd+0x18>)
 8024294:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8024296:	ea23 0000 	bic.w	r0, r3, r0
 802429a:	6250      	str	r0, [r2, #36]	; 0x24
 802429c:	4770      	bx	lr
 802429e:	4b02      	ldr	r3, [pc, #8]	; (80242a8 <RCC_APB2PeriphResetCmd+0x18>)
 80242a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80242a2:	4310      	orrs	r0, r2
 80242a4:	6258      	str	r0, [r3, #36]	; 0x24
 80242a6:	4770      	bx	lr
 80242a8:	40023800 	.word	0x40023800
 80242ac:	00000000 	.word	0x00000000

080242b0 <SYSCFG_EXTILineConfig>:
 80242b0:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 80242b4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80242b8:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
 80242bc:	f001 0103 	and.w	r1, r1, #3
 80242c0:	b410      	push	{r4}
 80242c2:	0089      	lsls	r1, r1, #2
 80242c4:	689c      	ldr	r4, [r3, #8]
 80242c6:	220f      	movs	r2, #15
 80242c8:	408a      	lsls	r2, r1
 80242ca:	ea24 0202 	bic.w	r2, r4, r2
 80242ce:	609a      	str	r2, [r3, #8]
 80242d0:	689a      	ldr	r2, [r3, #8]
 80242d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80242d6:	4088      	lsls	r0, r1
 80242d8:	4310      	orrs	r0, r2
 80242da:	6098      	str	r0, [r3, #8]
 80242dc:	4770      	bx	lr
 80242de:	bf00      	nop

080242e0 <TIM_DeInit>:
 80242e0:	b508      	push	{r3, lr}
 80242e2:	4b60      	ldr	r3, [pc, #384]	; (8024464 <TIM_DeInit+0x184>)
 80242e4:	4298      	cmp	r0, r3
 80242e6:	d035      	beq.n	8024354 <TIM_DeInit+0x74>
 80242e8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80242ec:	d03c      	beq.n	8024368 <TIM_DeInit+0x88>
 80242ee:	4b5e      	ldr	r3, [pc, #376]	; (8024468 <TIM_DeInit+0x188>)
 80242f0:	4298      	cmp	r0, r3
 80242f2:	d043      	beq.n	802437c <TIM_DeInit+0x9c>
 80242f4:	4b5d      	ldr	r3, [pc, #372]	; (802446c <TIM_DeInit+0x18c>)
 80242f6:	4298      	cmp	r0, r3
 80242f8:	d04a      	beq.n	8024390 <TIM_DeInit+0xb0>
 80242fa:	4b5d      	ldr	r3, [pc, #372]	; (8024470 <TIM_DeInit+0x190>)
 80242fc:	4298      	cmp	r0, r3
 80242fe:	d051      	beq.n	80243a4 <TIM_DeInit+0xc4>
 8024300:	4b5c      	ldr	r3, [pc, #368]	; (8024474 <TIM_DeInit+0x194>)
 8024302:	4298      	cmp	r0, r3
 8024304:	d058      	beq.n	80243b8 <TIM_DeInit+0xd8>
 8024306:	4b5c      	ldr	r3, [pc, #368]	; (8024478 <TIM_DeInit+0x198>)
 8024308:	4298      	cmp	r0, r3
 802430a:	d05f      	beq.n	80243cc <TIM_DeInit+0xec>
 802430c:	4b5b      	ldr	r3, [pc, #364]	; (802447c <TIM_DeInit+0x19c>)
 802430e:	4298      	cmp	r0, r3
 8024310:	d066      	beq.n	80243e0 <TIM_DeInit+0x100>
 8024312:	4b5b      	ldr	r3, [pc, #364]	; (8024480 <TIM_DeInit+0x1a0>)
 8024314:	4298      	cmp	r0, r3
 8024316:	d06d      	beq.n	80243f4 <TIM_DeInit+0x114>
 8024318:	4b5a      	ldr	r3, [pc, #360]	; (8024484 <TIM_DeInit+0x1a4>)
 802431a:	4298      	cmp	r0, r3
 802431c:	d076      	beq.n	802440c <TIM_DeInit+0x12c>
 802431e:	4b5a      	ldr	r3, [pc, #360]	; (8024488 <TIM_DeInit+0x1a8>)
 8024320:	4298      	cmp	r0, r3
 8024322:	d07f      	beq.n	8024424 <TIM_DeInit+0x144>
 8024324:	4b59      	ldr	r3, [pc, #356]	; (802448c <TIM_DeInit+0x1ac>)
 8024326:	4298      	cmp	r0, r3
 8024328:	f000 8088 	beq.w	802443c <TIM_DeInit+0x15c>
 802432c:	4b58      	ldr	r3, [pc, #352]	; (8024490 <TIM_DeInit+0x1b0>)
 802432e:	4298      	cmp	r0, r3
 8024330:	f000 808e 	beq.w	8024450 <TIM_DeInit+0x170>
 8024334:	4b57      	ldr	r3, [pc, #348]	; (8024494 <TIM_DeInit+0x1b4>)
 8024336:	4298      	cmp	r0, r3
 8024338:	d000      	beq.n	802433c <TIM_DeInit+0x5c>
 802433a:	bd08      	pop	{r3, pc}
 802433c:	2101      	movs	r1, #1
 802433e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8024342:	f7ff ff95 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024346:	2100      	movs	r1, #0
 8024348:	f44f 7080 	mov.w	r0, #256	; 0x100
 802434c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024350:	f7ff bf8e 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 8024354:	2101      	movs	r1, #1
 8024356:	4608      	mov	r0, r1
 8024358:	f7ff ff9a 	bl	8024290 <RCC_APB2PeriphResetCmd>
 802435c:	2100      	movs	r1, #0
 802435e:	2001      	movs	r0, #1
 8024360:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024364:	f7ff bf94 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 8024368:	2101      	movs	r1, #1
 802436a:	4608      	mov	r0, r1
 802436c:	f7ff ff80 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024370:	2100      	movs	r1, #0
 8024372:	2001      	movs	r0, #1
 8024374:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024378:	f7ff bf7a 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 802437c:	2101      	movs	r1, #1
 802437e:	2002      	movs	r0, #2
 8024380:	f7ff ff76 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024384:	2100      	movs	r1, #0
 8024386:	2002      	movs	r0, #2
 8024388:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802438c:	f7ff bf70 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 8024390:	2101      	movs	r1, #1
 8024392:	2004      	movs	r0, #4
 8024394:	f7ff ff6c 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024398:	2100      	movs	r1, #0
 802439a:	2004      	movs	r0, #4
 802439c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80243a0:	f7ff bf66 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 80243a4:	2101      	movs	r1, #1
 80243a6:	2008      	movs	r0, #8
 80243a8:	f7ff ff62 	bl	8024270 <RCC_APB1PeriphResetCmd>
 80243ac:	2100      	movs	r1, #0
 80243ae:	2008      	movs	r0, #8
 80243b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80243b4:	f7ff bf5c 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 80243b8:	2101      	movs	r1, #1
 80243ba:	2010      	movs	r0, #16
 80243bc:	f7ff ff58 	bl	8024270 <RCC_APB1PeriphResetCmd>
 80243c0:	2100      	movs	r1, #0
 80243c2:	2010      	movs	r0, #16
 80243c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80243c8:	f7ff bf52 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 80243cc:	2101      	movs	r1, #1
 80243ce:	2020      	movs	r0, #32
 80243d0:	f7ff ff4e 	bl	8024270 <RCC_APB1PeriphResetCmd>
 80243d4:	2100      	movs	r1, #0
 80243d6:	2020      	movs	r0, #32
 80243d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80243dc:	f7ff bf48 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 80243e0:	2101      	movs	r1, #1
 80243e2:	2002      	movs	r0, #2
 80243e4:	f7ff ff54 	bl	8024290 <RCC_APB2PeriphResetCmd>
 80243e8:	2100      	movs	r1, #0
 80243ea:	2002      	movs	r0, #2
 80243ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80243f0:	f7ff bf4e 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 80243f4:	2101      	movs	r1, #1
 80243f6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80243fa:	f7ff ff49 	bl	8024290 <RCC_APB2PeriphResetCmd>
 80243fe:	2100      	movs	r1, #0
 8024400:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8024404:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024408:	f7ff bf42 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 802440c:	2101      	movs	r1, #1
 802440e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8024412:	f7ff ff3d 	bl	8024290 <RCC_APB2PeriphResetCmd>
 8024416:	2100      	movs	r1, #0
 8024418:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 802441c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024420:	f7ff bf36 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 8024424:	2101      	movs	r1, #1
 8024426:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 802442a:	f7ff ff31 	bl	8024290 <RCC_APB2PeriphResetCmd>
 802442e:	2100      	movs	r1, #0
 8024430:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8024434:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024438:	f7ff bf2a 	b.w	8024290 <RCC_APB2PeriphResetCmd>
 802443c:	2101      	movs	r1, #1
 802443e:	2040      	movs	r0, #64	; 0x40
 8024440:	f7ff ff16 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024444:	2100      	movs	r1, #0
 8024446:	2040      	movs	r0, #64	; 0x40
 8024448:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802444c:	f7ff bf10 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 8024450:	2101      	movs	r1, #1
 8024452:	2080      	movs	r0, #128	; 0x80
 8024454:	f7ff ff0c 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024458:	2100      	movs	r1, #0
 802445a:	2080      	movs	r0, #128	; 0x80
 802445c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024460:	f7ff bf06 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 8024464:	40010000 	.word	0x40010000
 8024468:	40000400 	.word	0x40000400
 802446c:	40000800 	.word	0x40000800
 8024470:	40000c00 	.word	0x40000c00
 8024474:	40001000 	.word	0x40001000
 8024478:	40001400 	.word	0x40001400
 802447c:	40010400 	.word	0x40010400
 8024480:	40014000 	.word	0x40014000
 8024484:	40014400 	.word	0x40014400
 8024488:	40014800 	.word	0x40014800
 802448c:	40001800 	.word	0x40001800
 8024490:	40001c00 	.word	0x40001c00
 8024494:	40002000 	.word	0x40002000
	...

080244a0 <TIM_TimeBaseInit>:
 80244a0:	4a22      	ldr	r2, [pc, #136]	; (802452c <TIM_TimeBaseInit+0x8c>)
 80244a2:	6803      	ldr	r3, [r0, #0]
 80244a4:	4290      	cmp	r0, r2
 80244a6:	b29b      	uxth	r3, r3
 80244a8:	d012      	beq.n	80244d0 <TIM_TimeBaseInit+0x30>
 80244aa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80244ae:	4290      	cmp	r0, r2
 80244b0:	d00e      	beq.n	80244d0 <TIM_TimeBaseInit+0x30>
 80244b2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80244b6:	d00b      	beq.n	80244d0 <TIM_TimeBaseInit+0x30>
 80244b8:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 80244bc:	4290      	cmp	r0, r2
 80244be:	d007      	beq.n	80244d0 <TIM_TimeBaseInit+0x30>
 80244c0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80244c4:	4290      	cmp	r0, r2
 80244c6:	d003      	beq.n	80244d0 <TIM_TimeBaseInit+0x30>
 80244c8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80244cc:	4290      	cmp	r0, r2
 80244ce:	d103      	bne.n	80244d8 <TIM_TimeBaseInit+0x38>
 80244d0:	884a      	ldrh	r2, [r1, #2]
 80244d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80244d6:	4313      	orrs	r3, r2
 80244d8:	4a15      	ldr	r2, [pc, #84]	; (8024530 <TIM_TimeBaseInit+0x90>)
 80244da:	4290      	cmp	r0, r2
 80244dc:	d01e      	beq.n	802451c <TIM_TimeBaseInit+0x7c>
 80244de:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80244e2:	4290      	cmp	r0, r2
 80244e4:	d01a      	beq.n	802451c <TIM_TimeBaseInit+0x7c>
 80244e6:	890a      	ldrh	r2, [r1, #8]
 80244e8:	b470      	push	{r4, r5, r6}
 80244ea:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80244ee:	4c0f      	ldr	r4, [pc, #60]	; (802452c <TIM_TimeBaseInit+0x8c>)
 80244f0:	684e      	ldr	r6, [r1, #4]
 80244f2:	880d      	ldrh	r5, [r1, #0]
 80244f4:	b29b      	uxth	r3, r3
 80244f6:	4313      	orrs	r3, r2
 80244f8:	42a0      	cmp	r0, r4
 80244fa:	6003      	str	r3, [r0, #0]
 80244fc:	62c6      	str	r6, [r0, #44]	; 0x2c
 80244fe:	6285      	str	r5, [r0, #40]	; 0x28
 8024500:	d006      	beq.n	8024510 <TIM_TimeBaseInit+0x70>
 8024502:	4b0c      	ldr	r3, [pc, #48]	; (8024534 <TIM_TimeBaseInit+0x94>)
 8024504:	4298      	cmp	r0, r3
 8024506:	d003      	beq.n	8024510 <TIM_TimeBaseInit+0x70>
 8024508:	2301      	movs	r3, #1
 802450a:	6143      	str	r3, [r0, #20]
 802450c:	bc70      	pop	{r4, r5, r6}
 802450e:	4770      	bx	lr
 8024510:	7a8b      	ldrb	r3, [r1, #10]
 8024512:	6303      	str	r3, [r0, #48]	; 0x30
 8024514:	2301      	movs	r3, #1
 8024516:	6143      	str	r3, [r0, #20]
 8024518:	bc70      	pop	{r4, r5, r6}
 802451a:	4770      	bx	lr
 802451c:	6003      	str	r3, [r0, #0]
 802451e:	684a      	ldr	r2, [r1, #4]
 8024520:	880b      	ldrh	r3, [r1, #0]
 8024522:	62c2      	str	r2, [r0, #44]	; 0x2c
 8024524:	6283      	str	r3, [r0, #40]	; 0x28
 8024526:	2301      	movs	r3, #1
 8024528:	6143      	str	r3, [r0, #20]
 802452a:	4770      	bx	lr
 802452c:	40010000 	.word	0x40010000
 8024530:	40001000 	.word	0x40001000
 8024534:	40010400 	.word	0x40010400
	...

08024540 <TIM_SetAutoreload>:
 8024540:	62c1      	str	r1, [r0, #44]	; 0x2c
 8024542:	4770      	bx	lr
	...

08024550 <TIM_ARRPreloadConfig>:
 8024550:	b929      	cbnz	r1, 802455e <TIM_ARRPreloadConfig+0xe>
 8024552:	6802      	ldr	r2, [r0, #0]
 8024554:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8024558:	4013      	ands	r3, r2
 802455a:	6003      	str	r3, [r0, #0]
 802455c:	4770      	bx	lr
 802455e:	6803      	ldr	r3, [r0, #0]
 8024560:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8024564:	6003      	str	r3, [r0, #0]
 8024566:	4770      	bx	lr
	...

08024570 <TIM_Cmd>:
 8024570:	b929      	cbnz	r1, 802457e <TIM_Cmd+0xe>
 8024572:	6802      	ldr	r2, [r0, #0]
 8024574:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8024578:	4013      	ands	r3, r2
 802457a:	6003      	str	r3, [r0, #0]
 802457c:	4770      	bx	lr
 802457e:	6803      	ldr	r3, [r0, #0]
 8024580:	f043 0301 	orr.w	r3, r3, #1
 8024584:	6003      	str	r3, [r0, #0]
 8024586:	4770      	bx	lr
	...

08024590 <TIM_OC1Init>:
 8024590:	6a02      	ldr	r2, [r0, #32]
 8024592:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8024596:	4013      	ands	r3, r2
 8024598:	6203      	str	r3, [r0, #32]
 802459a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802459c:	884a      	ldrh	r2, [r1, #2]
 802459e:	6a05      	ldr	r5, [r0, #32]
 80245a0:	898b      	ldrh	r3, [r1, #12]
 80245a2:	6844      	ldr	r4, [r0, #4]
 80245a4:	4f15      	ldr	r7, [pc, #84]	; (80245fc <TIM_OC1Init+0x6c>)
 80245a6:	f8d0 e018 	ldr.w	lr, [r0, #24]
 80245aa:	f64f 76fd 	movw	r6, #65533	; 0xfffd
 80245ae:	402e      	ands	r6, r5
 80245b0:	4313      	orrs	r3, r2
 80245b2:	4333      	orrs	r3, r6
 80245b4:	f64f 758c 	movw	r5, #65420	; 0xff8c
 80245b8:	880e      	ldrh	r6, [r1, #0]
 80245ba:	ea0e 0505 	and.w	r5, lr, r5
 80245be:	42b8      	cmp	r0, r7
 80245c0:	b2a2      	uxth	r2, r4
 80245c2:	b29b      	uxth	r3, r3
 80245c4:	ea45 0406 	orr.w	r4, r5, r6
 80245c8:	d008      	beq.n	80245dc <TIM_OC1Init+0x4c>
 80245ca:	4d0d      	ldr	r5, [pc, #52]	; (8024600 <TIM_OC1Init+0x70>)
 80245cc:	42a8      	cmp	r0, r5
 80245ce:	d005      	beq.n	80245dc <TIM_OC1Init+0x4c>
 80245d0:	6889      	ldr	r1, [r1, #8]
 80245d2:	6042      	str	r2, [r0, #4]
 80245d4:	6184      	str	r4, [r0, #24]
 80245d6:	6341      	str	r1, [r0, #52]	; 0x34
 80245d8:	6203      	str	r3, [r0, #32]
 80245da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80245dc:	89ce      	ldrh	r6, [r1, #14]
 80245de:	8a0f      	ldrh	r7, [r1, #16]
 80245e0:	8a4d      	ldrh	r5, [r1, #18]
 80245e2:	f023 0308 	bic.w	r3, r3, #8
 80245e6:	4333      	orrs	r3, r6
 80245e8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80245ec:	888e      	ldrh	r6, [r1, #4]
 80245ee:	433d      	orrs	r5, r7
 80245f0:	f023 0304 	bic.w	r3, r3, #4
 80245f4:	432a      	orrs	r2, r5
 80245f6:	4333      	orrs	r3, r6
 80245f8:	b292      	uxth	r2, r2
 80245fa:	e7e9      	b.n	80245d0 <TIM_OC1Init+0x40>
 80245fc:	40010000 	.word	0x40010000
 8024600:	40010400 	.word	0x40010400
	...

08024610 <TIM_OC2Init>:
 8024610:	6a02      	ldr	r2, [r0, #32]
 8024612:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8024616:	4013      	ands	r3, r2
 8024618:	b5f0      	push	{r4, r5, r6, r7, lr}
 802461a:	6203      	str	r3, [r0, #32]
 802461c:	884a      	ldrh	r2, [r1, #2]
 802461e:	898c      	ldrh	r4, [r1, #12]
 8024620:	f8d0 e020 	ldr.w	lr, [r0, #32]
 8024624:	6846      	ldr	r6, [r0, #4]
 8024626:	6987      	ldr	r7, [r0, #24]
 8024628:	4d18      	ldr	r5, [pc, #96]	; (802468c <TIM_OC2Init+0x7c>)
 802462a:	4314      	orrs	r4, r2
 802462c:	f648 42ff 	movw	r2, #36095	; 0x8cff
 8024630:	403a      	ands	r2, r7
 8024632:	f64f 73df 	movw	r3, #65503	; 0xffdf
 8024636:	880f      	ldrh	r7, [r1, #0]
 8024638:	ea0e 0303 	and.w	r3, lr, r3
 802463c:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8024640:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8024644:	42a8      	cmp	r0, r5
 8024646:	b29b      	uxth	r3, r3
 8024648:	b2b4      	uxth	r4, r6
 802464a:	b292      	uxth	r2, r2
 802464c:	d009      	beq.n	8024662 <TIM_OC2Init+0x52>
 802464e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8024652:	42a8      	cmp	r0, r5
 8024654:	d005      	beq.n	8024662 <TIM_OC2Init+0x52>
 8024656:	6889      	ldr	r1, [r1, #8]
 8024658:	6044      	str	r4, [r0, #4]
 802465a:	6182      	str	r2, [r0, #24]
 802465c:	6381      	str	r1, [r0, #56]	; 0x38
 802465e:	6203      	str	r3, [r0, #32]
 8024660:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024662:	89cd      	ldrh	r5, [r1, #14]
 8024664:	8a0f      	ldrh	r7, [r1, #16]
 8024666:	8a4e      	ldrh	r6, [r1, #18]
 8024668:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802466c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
 8024670:	f64f 75bf 	movw	r5, #65471	; 0xffbf
 8024674:	401d      	ands	r5, r3
 8024676:	888b      	ldrh	r3, [r1, #4]
 8024678:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 802467c:	433e      	orrs	r6, r7
 802467e:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
 8024682:	ea44 0486 	orr.w	r4, r4, r6, lsl #2
 8024686:	b29b      	uxth	r3, r3
 8024688:	b2a4      	uxth	r4, r4
 802468a:	e7e4      	b.n	8024656 <TIM_OC2Init+0x46>
 802468c:	40010000 	.word	0x40010000

08024690 <TIM_OC3Init>:
 8024690:	6a02      	ldr	r2, [r0, #32]
 8024692:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8024696:	4013      	ands	r3, r2
 8024698:	6203      	str	r3, [r0, #32]
 802469a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802469c:	884a      	ldrh	r2, [r1, #2]
 802469e:	f8d0 e020 	ldr.w	lr, [r0, #32]
 80246a2:	898c      	ldrh	r4, [r1, #12]
 80246a4:	6845      	ldr	r5, [r0, #4]
 80246a6:	4e1a      	ldr	r6, [pc, #104]	; (8024710 <TIM_OC3Init+0x80>)
 80246a8:	69c7      	ldr	r7, [r0, #28]
 80246aa:	f64f 53ff 	movw	r3, #65023	; 0xfdff
 80246ae:	4314      	orrs	r4, r2
 80246b0:	ea0e 0303 	and.w	r3, lr, r3
 80246b4:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80246b8:	f64f 728c 	movw	r2, #65420	; 0xff8c
 80246bc:	880c      	ldrh	r4, [r1, #0]
 80246be:	403a      	ands	r2, r7
 80246c0:	42b0      	cmp	r0, r6
 80246c2:	b29b      	uxth	r3, r3
 80246c4:	b2ad      	uxth	r5, r5
 80246c6:	ea42 0204 	orr.w	r2, r2, r4
 80246ca:	d009      	beq.n	80246e0 <TIM_OC3Init+0x50>
 80246cc:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80246d0:	42b0      	cmp	r0, r6
 80246d2:	d005      	beq.n	80246e0 <TIM_OC3Init+0x50>
 80246d4:	6889      	ldr	r1, [r1, #8]
 80246d6:	6045      	str	r5, [r0, #4]
 80246d8:	61c2      	str	r2, [r0, #28]
 80246da:	63c1      	str	r1, [r0, #60]	; 0x3c
 80246dc:	6203      	str	r3, [r0, #32]
 80246de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80246e0:	89ce      	ldrh	r6, [r1, #14]
 80246e2:	8a0c      	ldrh	r4, [r1, #16]
 80246e4:	f8b1 e012 	ldrh.w	lr, [r1, #18]
 80246e8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80246ec:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 80246f0:	f64f 36ff 	movw	r6, #64511	; 0xfbff
 80246f4:	401e      	ands	r6, r3
 80246f6:	888b      	ldrh	r3, [r1, #4]
 80246f8:	f425 5740 	bic.w	r7, r5, #12288	; 0x3000
 80246fc:	ea44 050e 	orr.w	r5, r4, lr
 8024700:	ea46 2303 	orr.w	r3, r6, r3, lsl #8
 8024704:	ea47 1505 	orr.w	r5, r7, r5, lsl #4
 8024708:	b29b      	uxth	r3, r3
 802470a:	b2ad      	uxth	r5, r5
 802470c:	e7e2      	b.n	80246d4 <TIM_OC3Init+0x44>
 802470e:	bf00      	nop
 8024710:	40010000 	.word	0x40010000
	...

08024720 <TIM_OC4Init>:
 8024720:	6a02      	ldr	r2, [r0, #32]
 8024722:	f64e 73ff 	movw	r3, #61439	; 0xefff
 8024726:	4013      	ands	r3, r2
 8024728:	b5f0      	push	{r4, r5, r6, r7, lr}
 802472a:	6203      	str	r3, [r0, #32]
 802472c:	884a      	ldrh	r2, [r1, #2]
 802472e:	898d      	ldrh	r5, [r1, #12]
 8024730:	f8d0 e020 	ldr.w	lr, [r0, #32]
 8024734:	6844      	ldr	r4, [r0, #4]
 8024736:	69c7      	ldr	r7, [r0, #28]
 8024738:	4e11      	ldr	r6, [pc, #68]	; (8024780 <TIM_OC4Init+0x60>)
 802473a:	4315      	orrs	r5, r2
 802473c:	f648 42ff 	movw	r2, #36095	; 0x8cff
 8024740:	403a      	ands	r2, r7
 8024742:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 8024746:	880f      	ldrh	r7, [r1, #0]
 8024748:	ea0e 0303 	and.w	r3, lr, r3
 802474c:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
 8024750:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8024754:	42b0      	cmp	r0, r6
 8024756:	b29b      	uxth	r3, r3
 8024758:	b2a4      	uxth	r4, r4
 802475a:	b292      	uxth	r2, r2
 802475c:	d008      	beq.n	8024770 <TIM_OC4Init+0x50>
 802475e:	4d09      	ldr	r5, [pc, #36]	; (8024784 <TIM_OC4Init+0x64>)
 8024760:	42a8      	cmp	r0, r5
 8024762:	d005      	beq.n	8024770 <TIM_OC4Init+0x50>
 8024764:	6889      	ldr	r1, [r1, #8]
 8024766:	6044      	str	r4, [r0, #4]
 8024768:	61c2      	str	r2, [r0, #28]
 802476a:	6401      	str	r1, [r0, #64]	; 0x40
 802476c:	6203      	str	r3, [r0, #32]
 802476e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024770:	8a0d      	ldrh	r5, [r1, #16]
 8024772:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
 8024776:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 802477a:	b2a4      	uxth	r4, r4
 802477c:	e7f2      	b.n	8024764 <TIM_OC4Init+0x44>
 802477e:	bf00      	nop
 8024780:	40010000 	.word	0x40010000
 8024784:	40010400 	.word	0x40010400
	...

08024790 <TIM_SelectOCxM>:
 8024790:	2301      	movs	r3, #1
 8024792:	408b      	lsls	r3, r1
 8024794:	b410      	push	{r4}
 8024796:	43db      	mvns	r3, r3
 8024798:	6a04      	ldr	r4, [r0, #32]
 802479a:	b29b      	uxth	r3, r3
 802479c:	4023      	ands	r3, r4
 802479e:	f021 0408 	bic.w	r4, r1, #8
 80247a2:	6203      	str	r3, [r0, #32]
 80247a4:	3018      	adds	r0, #24
 80247a6:	b17c      	cbz	r4, 80247c8 <TIM_SelectOCxM+0x38>
 80247a8:	3904      	subs	r1, #4
 80247aa:	f3c1 014e 	ubfx	r1, r1, #1, #15
 80247ae:	f648 73ff 	movw	r3, #36863	; 0x8fff
 80247b2:	580c      	ldr	r4, [r1, r0]
 80247b4:	4023      	ands	r3, r4
 80247b6:	500b      	str	r3, [r1, r0]
 80247b8:	0212      	lsls	r2, r2, #8
 80247ba:	580b      	ldr	r3, [r1, r0]
 80247bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80247c0:	b292      	uxth	r2, r2
 80247c2:	431a      	orrs	r2, r3
 80247c4:	500a      	str	r2, [r1, r0]
 80247c6:	4770      	bx	lr
 80247c8:	0849      	lsrs	r1, r1, #1
 80247ca:	f64f 738f 	movw	r3, #65423	; 0xff8f
 80247ce:	580c      	ldr	r4, [r1, r0]
 80247d0:	4023      	ands	r3, r4
 80247d2:	500b      	str	r3, [r1, r0]
 80247d4:	580b      	ldr	r3, [r1, r0]
 80247d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80247da:	431a      	orrs	r2, r3
 80247dc:	500a      	str	r2, [r1, r0]
 80247de:	4770      	bx	lr

080247e0 <TIM_OC1PreloadConfig>:
 80247e0:	6982      	ldr	r2, [r0, #24]
 80247e2:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 80247e6:	4013      	ands	r3, r2
 80247e8:	4319      	orrs	r1, r3
 80247ea:	6181      	str	r1, [r0, #24]
 80247ec:	4770      	bx	lr
 80247ee:	bf00      	nop

080247f0 <TIM_OC2PreloadConfig>:
 80247f0:	6982      	ldr	r2, [r0, #24]
 80247f2:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
 80247f6:	4013      	ands	r3, r2
 80247f8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80247fc:	b289      	uxth	r1, r1
 80247fe:	6181      	str	r1, [r0, #24]
 8024800:	4770      	bx	lr
 8024802:	bf00      	nop
	...

08024810 <TIM_OC3PreloadConfig>:
 8024810:	69c2      	ldr	r2, [r0, #28]
 8024812:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 8024816:	4013      	ands	r3, r2
 8024818:	4319      	orrs	r1, r3
 802481a:	61c1      	str	r1, [r0, #28]
 802481c:	4770      	bx	lr
 802481e:	bf00      	nop

08024820 <TIM_OC4PreloadConfig>:
 8024820:	69c2      	ldr	r2, [r0, #28]
 8024822:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
 8024826:	4013      	ands	r3, r2
 8024828:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 802482c:	b289      	uxth	r1, r1
 802482e:	61c1      	str	r1, [r0, #28]
 8024830:	4770      	bx	lr
 8024832:	bf00      	nop
	...

08024840 <TIM_CCxCmd>:
 8024840:	2301      	movs	r3, #1
 8024842:	408b      	lsls	r3, r1
 8024844:	b410      	push	{r4}
 8024846:	43db      	mvns	r3, r3
 8024848:	6a04      	ldr	r4, [r0, #32]
 802484a:	b29b      	uxth	r3, r3
 802484c:	4023      	ands	r3, r4
 802484e:	6203      	str	r3, [r0, #32]
 8024850:	408a      	lsls	r2, r1
 8024852:	6a01      	ldr	r1, [r0, #32]
 8024854:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024858:	b292      	uxth	r2, r2
 802485a:	430a      	orrs	r2, r1
 802485c:	6202      	str	r2, [r0, #32]
 802485e:	4770      	bx	lr

08024860 <TIM_CCxNCmd>:
 8024860:	2304      	movs	r3, #4
 8024862:	408b      	lsls	r3, r1
 8024864:	b410      	push	{r4}
 8024866:	43db      	mvns	r3, r3
 8024868:	6a04      	ldr	r4, [r0, #32]
 802486a:	b29b      	uxth	r3, r3
 802486c:	4023      	ands	r3, r4
 802486e:	6203      	str	r3, [r0, #32]
 8024870:	408a      	lsls	r2, r1
 8024872:	6a01      	ldr	r1, [r0, #32]
 8024874:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024878:	b292      	uxth	r2, r2
 802487a:	430a      	orrs	r2, r1
 802487c:	6202      	str	r2, [r0, #32]
 802487e:	4770      	bx	lr

08024880 <TIM_BDTRConfig>:
 8024880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024882:	884b      	ldrh	r3, [r1, #2]
 8024884:	f8b1 e000 	ldrh.w	lr, [r1]
 8024888:	888f      	ldrh	r7, [r1, #4]
 802488a:	88ce      	ldrh	r6, [r1, #6]
 802488c:	890d      	ldrh	r5, [r1, #8]
 802488e:	894c      	ldrh	r4, [r1, #10]
 8024890:	898a      	ldrh	r2, [r1, #12]
 8024892:	ea4e 0303 	orr.w	r3, lr, r3
 8024896:	433b      	orrs	r3, r7
 8024898:	4333      	orrs	r3, r6
 802489a:	432b      	orrs	r3, r5
 802489c:	4323      	orrs	r3, r4
 802489e:	4313      	orrs	r3, r2
 80248a0:	b29b      	uxth	r3, r3
 80248a2:	6443      	str	r3, [r0, #68]	; 0x44
 80248a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80248a6:	bf00      	nop
	...

080248b0 <TIM_CtrlPWMOutputs>:
 80248b0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80248b2:	b919      	cbnz	r1, 80248bc <TIM_CtrlPWMOutputs+0xc>
 80248b4:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80248b8:	6443      	str	r3, [r0, #68]	; 0x44
 80248ba:	4770      	bx	lr
 80248bc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80248c0:	6443      	str	r3, [r0, #68]	; 0x44
 80248c2:	4770      	bx	lr
	...

080248d0 <TIM_CCPreloadControl>:
 80248d0:	b929      	cbnz	r1, 80248de <TIM_CCPreloadControl+0xe>
 80248d2:	6842      	ldr	r2, [r0, #4]
 80248d4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80248d8:	4013      	ands	r3, r2
 80248da:	6043      	str	r3, [r0, #4]
 80248dc:	4770      	bx	lr
 80248de:	6843      	ldr	r3, [r0, #4]
 80248e0:	f043 0301 	orr.w	r3, r3, #1
 80248e4:	6043      	str	r3, [r0, #4]
 80248e6:	4770      	bx	lr
	...

080248f0 <TIM_GenerateEvent>:
 80248f0:	6141      	str	r1, [r0, #20]
 80248f2:	4770      	bx	lr
	...

08024900 <TIM_GetITStatus>:
 8024900:	6903      	ldr	r3, [r0, #16]
 8024902:	68c2      	ldr	r2, [r0, #12]
 8024904:	ea11 0003 	ands.w	r0, r1, r3
 8024908:	d003      	beq.n	8024912 <TIM_GetITStatus+0x12>
 802490a:	4211      	tst	r1, r2
 802490c:	bf14      	ite	ne
 802490e:	2001      	movne	r0, #1
 8024910:	2000      	moveq	r0, #0
 8024912:	4770      	bx	lr
	...

08024920 <TIM_ClearITPendingBit>:
 8024920:	43c9      	mvns	r1, r1
 8024922:	b289      	uxth	r1, r1
 8024924:	6101      	str	r1, [r0, #16]
 8024926:	4770      	bx	lr
	...

08024930 <TIM_DMACmd>:
 8024930:	b92a      	cbnz	r2, 802493e <TIM_DMACmd+0xe>
 8024932:	68c3      	ldr	r3, [r0, #12]
 8024934:	43c9      	mvns	r1, r1
 8024936:	b289      	uxth	r1, r1
 8024938:	4019      	ands	r1, r3
 802493a:	60c1      	str	r1, [r0, #12]
 802493c:	4770      	bx	lr
 802493e:	68c3      	ldr	r3, [r0, #12]
 8024940:	4319      	orrs	r1, r3
 8024942:	60c1      	str	r1, [r0, #12]
 8024944:	4770      	bx	lr
 8024946:	bf00      	nop
	...

08024950 <TIM_ITConfig>:
 8024950:	f7ff bfee 	b.w	8024930 <TIM_DMACmd>
	...

08024960 <TIM_SelectInputTrigger>:
 8024960:	6882      	ldr	r2, [r0, #8]
 8024962:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8024966:	4013      	ands	r3, r2
 8024968:	4319      	orrs	r1, r3
 802496a:	6081      	str	r1, [r0, #8]
 802496c:	4770      	bx	lr
 802496e:	bf00      	nop

08024970 <TIM_SelectOutputTrigger>:
 8024970:	6842      	ldr	r2, [r0, #4]
 8024972:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8024976:	4013      	ands	r3, r2
 8024978:	6043      	str	r3, [r0, #4]
 802497a:	6843      	ldr	r3, [r0, #4]
 802497c:	4319      	orrs	r1, r3
 802497e:	6041      	str	r1, [r0, #4]
 8024980:	4770      	bx	lr
 8024982:	bf00      	nop
	...

08024990 <TIM_SelectSlaveMode>:
 8024990:	6882      	ldr	r2, [r0, #8]
 8024992:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 8024996:	4013      	ands	r3, r2
 8024998:	6083      	str	r3, [r0, #8]
 802499a:	6883      	ldr	r3, [r0, #8]
 802499c:	4319      	orrs	r1, r3
 802499e:	6081      	str	r1, [r0, #8]
 80249a0:	4770      	bx	lr
 80249a2:	bf00      	nop
	...

080249b0 <TIM_SelectMasterSlaveMode>:
 80249b0:	6882      	ldr	r2, [r0, #8]
 80249b2:	f64f 737f 	movw	r3, #65407	; 0xff7f
 80249b6:	4013      	ands	r3, r2
 80249b8:	6083      	str	r3, [r0, #8]
 80249ba:	6883      	ldr	r3, [r0, #8]
 80249bc:	4319      	orrs	r1, r3
 80249be:	6081      	str	r1, [r0, #8]
 80249c0:	4770      	bx	lr
 80249c2:	bf00      	nop
	...

080249d0 <TIM_EncoderInterfaceConfig>:
 80249d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80249d2:	6887      	ldr	r7, [r0, #8]
 80249d4:	f8d0 e018 	ldr.w	lr, [r0, #24]
 80249d8:	6a04      	ldr	r4, [r0, #32]
 80249da:	b2a4      	uxth	r4, r4
 80249dc:	f64f 45fc 	movw	r5, #64764	; 0xfcfc
 80249e0:	f024 0422 	bic.w	r4, r4, #34	; 0x22
 80249e4:	4322      	orrs	r2, r4
 80249e6:	f64f 76f8 	movw	r6, #65528	; 0xfff8
 80249ea:	ea0e 0505 	and.w	r5, lr, r5
 80249ee:	403e      	ands	r6, r7
 80249f0:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 80249f4:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 80249f8:	4331      	orrs	r1, r6
 80249fa:	b29a      	uxth	r2, r3
 80249fc:	f045 0501 	orr.w	r5, r5, #1
 8024a00:	6081      	str	r1, [r0, #8]
 8024a02:	6185      	str	r5, [r0, #24]
 8024a04:	6202      	str	r2, [r0, #32]
 8024a06:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08024a10 <WWDG_DeInit>:
 8024a10:	b508      	push	{r3, lr}
 8024a12:	2101      	movs	r1, #1
 8024a14:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8024a18:	f7ff fc2a 	bl	8024270 <RCC_APB1PeriphResetCmd>
 8024a1c:	2100      	movs	r1, #0
 8024a1e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8024a22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8024a26:	f7ff bc23 	b.w	8024270 <RCC_APB1PeriphResetCmd>
 8024a2a:	bf00      	nop
 8024a2c:	0000      	movs	r0, r0
	...

08024a30 <WWDG_SetPrescaler>:
 8024a30:	4a03      	ldr	r2, [pc, #12]	; (8024a40 <WWDG_SetPrescaler+0x10>)
 8024a32:	6853      	ldr	r3, [r2, #4]
 8024a34:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
 8024a38:	4318      	orrs	r0, r3
 8024a3a:	6050      	str	r0, [r2, #4]
 8024a3c:	4770      	bx	lr
 8024a3e:	bf00      	nop
 8024a40:	40002c00 	.word	0x40002c00
	...

08024a50 <WWDG_SetWindowValue>:
 8024a50:	b082      	sub	sp, #8
 8024a52:	4a08      	ldr	r2, [pc, #32]	; (8024a74 <WWDG_SetWindowValue+0x24>)
 8024a54:	2300      	movs	r3, #0
 8024a56:	9301      	str	r3, [sp, #4]
 8024a58:	6853      	ldr	r3, [r2, #4]
 8024a5a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8024a5e:	9301      	str	r3, [sp, #4]
 8024a60:	9b01      	ldr	r3, [sp, #4]
 8024a62:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8024a66:	4303      	orrs	r3, r0
 8024a68:	9301      	str	r3, [sp, #4]
 8024a6a:	9b01      	ldr	r3, [sp, #4]
 8024a6c:	6053      	str	r3, [r2, #4]
 8024a6e:	b002      	add	sp, #8
 8024a70:	4770      	bx	lr
 8024a72:	bf00      	nop
 8024a74:	40002c00 	.word	0x40002c00
	...

08024a80 <WWDG_SetCounter>:
 8024a80:	4b02      	ldr	r3, [pc, #8]	; (8024a8c <WWDG_SetCounter+0xc>)
 8024a82:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8024a86:	6018      	str	r0, [r3, #0]
 8024a88:	4770      	bx	lr
 8024a8a:	bf00      	nop
 8024a8c:	40002c00 	.word	0x40002c00

08024a90 <WWDG_Enable>:
 8024a90:	4b02      	ldr	r3, [pc, #8]	; (8024a9c <WWDG_Enable+0xc>)
 8024a92:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8024a96:	6018      	str	r0, [r3, #0]
 8024a98:	4770      	bx	lr
 8024a9a:	bf00      	nop
 8024a9c:	40002c00 	.word	0x40002c00

08024aa0 <cosf>:
 8024aa0:	b500      	push	{lr}
 8024aa2:	ee10 3a10 	vmov	r3, s0
 8024aa6:	4a20      	ldr	r2, [pc, #128]	; (8024b28 <cosf+0x88>)
 8024aa8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8024aac:	4293      	cmp	r3, r2
 8024aae:	b083      	sub	sp, #12
 8024ab0:	dd19      	ble.n	8024ae6 <cosf+0x46>
 8024ab2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024ab6:	db04      	blt.n	8024ac2 <cosf+0x22>
 8024ab8:	ee30 0a40 	vsub.f32	s0, s0, s0
 8024abc:	b003      	add	sp, #12
 8024abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8024ac2:	4668      	mov	r0, sp
 8024ac4:	f001 f9ac 	bl	8025e20 <__ieee754_rem_pio2f>
 8024ac8:	f000 0003 	and.w	r0, r0, #3
 8024acc:	2801      	cmp	r0, #1
 8024ace:	d011      	beq.n	8024af4 <cosf+0x54>
 8024ad0:	2802      	cmp	r0, #2
 8024ad2:	d01f      	beq.n	8024b14 <cosf+0x74>
 8024ad4:	b1b8      	cbz	r0, 8024b06 <cosf+0x66>
 8024ad6:	2001      	movs	r0, #1
 8024ad8:	eddd 0a01 	vldr	s1, [sp, #4]
 8024adc:	ed9d 0a00 	vldr	s0, [sp]
 8024ae0:	f001 fea6 	bl	8026830 <__kernel_sinf>
 8024ae4:	e7ea      	b.n	8024abc <cosf+0x1c>
 8024ae6:	eddf 0a11 	vldr	s1, [pc, #68]	; 8024b2c <cosf+0x8c>
 8024aea:	f001 faf1 	bl	80260d0 <__kernel_cosf>
 8024aee:	b003      	add	sp, #12
 8024af0:	f85d fb04 	ldr.w	pc, [sp], #4
 8024af4:	eddd 0a01 	vldr	s1, [sp, #4]
 8024af8:	ed9d 0a00 	vldr	s0, [sp]
 8024afc:	f001 fe98 	bl	8026830 <__kernel_sinf>
 8024b00:	eeb1 0a40 	vneg.f32	s0, s0
 8024b04:	e7da      	b.n	8024abc <cosf+0x1c>
 8024b06:	eddd 0a01 	vldr	s1, [sp, #4]
 8024b0a:	ed9d 0a00 	vldr	s0, [sp]
 8024b0e:	f001 fadf 	bl	80260d0 <__kernel_cosf>
 8024b12:	e7d3      	b.n	8024abc <cosf+0x1c>
 8024b14:	eddd 0a01 	vldr	s1, [sp, #4]
 8024b18:	ed9d 0a00 	vldr	s0, [sp]
 8024b1c:	f001 fad8 	bl	80260d0 <__kernel_cosf>
 8024b20:	eeb1 0a40 	vneg.f32	s0, s0
 8024b24:	e7ca      	b.n	8024abc <cosf+0x1c>
 8024b26:	bf00      	nop
 8024b28:	3f490fd8 	.word	0x3f490fd8
 8024b2c:	00000000 	.word	0x00000000

08024b30 <expf>:
 8024b30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024b34:	ee10 0a10 	vmov	r0, s0
 8024b38:	b085      	sub	sp, #20
 8024b3a:	ee10 4a10 	vmov	r4, s0
 8024b3e:	f7e7 fc63 	bl	800c408 <__aeabi_f2d>
 8024b42:	f3c4 520a 	ubfx	r2, r4, #20, #11
 8024b46:	460f      	mov	r7, r1
 8024b48:	f240 412a 	movw	r1, #1066	; 0x42a
 8024b4c:	428a      	cmp	r2, r1
 8024b4e:	4606      	mov	r6, r0
 8024b50:	d861      	bhi.n	8024c16 <expf+0xe6>
 8024b52:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8024c98 <expf+0x168>
 8024b56:	4630      	mov	r0, r6
 8024b58:	e9d8 234a 	ldrd	r2, r3, [r8, #296]	; 0x128
 8024b5c:	4639      	mov	r1, r7
 8024b5e:	f7e7 fcaf 	bl	800c4c0 <__aeabi_dmul>
 8024b62:	e9d8 ab48 	ldrd	sl, fp, [r8, #288]	; 0x120
 8024b66:	4606      	mov	r6, r0
 8024b68:	460f      	mov	r7, r1
 8024b6a:	4602      	mov	r2, r0
 8024b6c:	460b      	mov	r3, r1
 8024b6e:	4650      	mov	r0, sl
 8024b70:	4659      	mov	r1, fp
 8024b72:	f7e7 faeb 	bl	800c14c <__adddf3>
 8024b76:	4652      	mov	r2, sl
 8024b78:	465b      	mov	r3, fp
 8024b7a:	4604      	mov	r4, r0
 8024b7c:	460d      	mov	r5, r1
 8024b7e:	f7e7 fae3 	bl	800c148 <__aeabi_dsub>
 8024b82:	4602      	mov	r2, r0
 8024b84:	460b      	mov	r3, r1
 8024b86:	4630      	mov	r0, r6
 8024b88:	4639      	mov	r1, r7
 8024b8a:	f7e7 fadd 	bl	800c148 <__aeabi_dsub>
 8024b8e:	f004 021f 	and.w	r2, r4, #31
 8024b92:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8024b96:	eb08 05c2 	add.w	r5, r8, r2, lsl #3
 8024b9a:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024b9e:	e9d8 2350 	ldrd	r2, r3, [r8, #320]	; 0x140
 8024ba2:	4606      	mov	r6, r0
 8024ba4:	460f      	mov	r7, r1
 8024ba6:	e9cd 4500 	strd	r4, r5, [sp]
 8024baa:	f7e7 fc89 	bl	800c4c0 <__aeabi_dmul>
 8024bae:	2200      	movs	r2, #0
 8024bb0:	4b34      	ldr	r3, [pc, #208]	; (8024c84 <expf+0x154>)
 8024bb2:	f7e7 facb 	bl	800c14c <__adddf3>
 8024bb6:	e9d8 234c 	ldrd	r2, r3, [r8, #304]	; 0x130
 8024bba:	4682      	mov	sl, r0
 8024bbc:	468b      	mov	fp, r1
 8024bbe:	4630      	mov	r0, r6
 8024bc0:	4639      	mov	r1, r7
 8024bc2:	f7e7 fc7d 	bl	800c4c0 <__aeabi_dmul>
 8024bc6:	e9d8 234e 	ldrd	r2, r3, [r8, #312]	; 0x138
 8024bca:	f7e7 fabf 	bl	800c14c <__adddf3>
 8024bce:	4632      	mov	r2, r6
 8024bd0:	4680      	mov	r8, r0
 8024bd2:	4689      	mov	r9, r1
 8024bd4:	463b      	mov	r3, r7
 8024bd6:	4630      	mov	r0, r6
 8024bd8:	4639      	mov	r1, r7
 8024bda:	f7e7 fc71 	bl	800c4c0 <__aeabi_dmul>
 8024bde:	4602      	mov	r2, r0
 8024be0:	460b      	mov	r3, r1
 8024be2:	4640      	mov	r0, r8
 8024be4:	4649      	mov	r1, r9
 8024be6:	f7e7 fc6b 	bl	800c4c0 <__aeabi_dmul>
 8024bea:	9c02      	ldr	r4, [sp, #8]
 8024bec:	4652      	mov	r2, sl
 8024bee:	465b      	mov	r3, fp
 8024bf0:	f7e7 faac 	bl	800c14c <__adddf3>
 8024bf4:	03e3      	lsls	r3, r4, #15
 8024bf6:	e9dd 4500 	ldrd	r4, r5, [sp]
 8024bfa:	2200      	movs	r2, #0
 8024bfc:	18a4      	adds	r4, r4, r2
 8024bfe:	415d      	adcs	r5, r3
 8024c00:	4622      	mov	r2, r4
 8024c02:	462b      	mov	r3, r5
 8024c04:	f7e7 fc5c 	bl	800c4c0 <__aeabi_dmul>
 8024c08:	f7e7 ff3a 	bl	800ca80 <__aeabi_d2f>
 8024c0c:	ee00 0a10 	vmov	s0, r0
 8024c10:	b005      	add	sp, #20
 8024c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024c16:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 8024c1a:	d024      	beq.n	8024c66 <expf+0x136>
 8024c1c:	f5b2 6fff 	cmp.w	r2, #2040	; 0x7f8
 8024c20:	d21c      	bcs.n	8024c5c <expf+0x12c>
 8024c22:	eddf 7a19 	vldr	s15, [pc, #100]	; 8024c88 <expf+0x158>
 8024c26:	ee07 4a10 	vmov	s14, r4
 8024c2a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8024c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c32:	dc1b      	bgt.n	8024c6c <expf+0x13c>
 8024c34:	eddf 7a15 	vldr	s15, [pc, #84]	; 8024c8c <expf+0x15c>
 8024c38:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8024c3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c40:	d41a      	bmi.n	8024c78 <expf+0x148>
 8024c42:	eddf 7a13 	vldr	s15, [pc, #76]	; 8024c90 <expf+0x160>
 8024c46:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8024c4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c4e:	d580      	bpl.n	8024b52 <expf+0x22>
 8024c50:	2000      	movs	r0, #0
 8024c52:	b005      	add	sp, #20
 8024c54:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024c58:	f001 be5a 	b.w	8026910 <__math_may_uflowf>
 8024c5c:	ee07 4a90 	vmov	s15, r4
 8024c60:	ee37 0aa7 	vadd.f32	s0, s15, s15
 8024c64:	e7d4      	b.n	8024c10 <expf+0xe0>
 8024c66:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8024c94 <expf+0x164>
 8024c6a:	e7d1      	b.n	8024c10 <expf+0xe0>
 8024c6c:	2000      	movs	r0, #0
 8024c6e:	b005      	add	sp, #20
 8024c70:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024c74:	f001 be54 	b.w	8026920 <__math_oflowf>
 8024c78:	2000      	movs	r0, #0
 8024c7a:	b005      	add	sp, #20
 8024c7c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024c80:	f001 be3e 	b.w	8026900 <__math_uflowf>
 8024c84:	3ff00000 	.word	0x3ff00000
 8024c88:	42b17217 	.word	0x42b17217
 8024c8c:	c2cff1b4 	.word	0xc2cff1b4
 8024c90:	c2ce8ecf 	.word	0xc2ce8ecf
 8024c94:	00000000 	.word	0x00000000
 8024c98:	0802f6c0 	.word	0x0802f6c0
 8024c9c:	00000000 	.word	0x00000000

08024ca0 <floorf>:
 8024ca0:	ee10 2a10 	vmov	r2, s0
 8024ca4:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 8024ca8:	0dcb      	lsrs	r3, r1, #23
 8024caa:	3b7f      	subs	r3, #127	; 0x7f
 8024cac:	2b16      	cmp	r3, #22
 8024cae:	dc1c      	bgt.n	8024cea <floorf+0x4a>
 8024cb0:	2b00      	cmp	r3, #0
 8024cb2:	ee10 0a10 	vmov	r0, s0
 8024cb6:	db1e      	blt.n	8024cf6 <floorf+0x56>
 8024cb8:	4919      	ldr	r1, [pc, #100]	; (8024d20 <floorf+0x80>)
 8024cba:	4119      	asrs	r1, r3
 8024cbc:	420a      	tst	r2, r1
 8024cbe:	d027      	beq.n	8024d10 <floorf+0x70>
 8024cc0:	eddf 7a18 	vldr	s15, [pc, #96]	; 8024d24 <floorf+0x84>
 8024cc4:	ee70 7a27 	vadd.f32	s15, s0, s15
 8024cc8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024ccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cd0:	dd1e      	ble.n	8024d10 <floorf+0x70>
 8024cd2:	2a00      	cmp	r2, #0
 8024cd4:	da04      	bge.n	8024ce0 <floorf+0x40>
 8024cd6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8024cda:	fa42 f303 	asr.w	r3, r2, r3
 8024cde:	4418      	add	r0, r3
 8024ce0:	ea20 0301 	bic.w	r3, r0, r1
 8024ce4:	ee00 3a10 	vmov	s0, r3
 8024ce8:	4770      	bx	lr
 8024cea:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8024cee:	d30f      	bcc.n	8024d10 <floorf+0x70>
 8024cf0:	ee30 0a00 	vadd.f32	s0, s0, s0
 8024cf4:	4770      	bx	lr
 8024cf6:	eddf 7a0b 	vldr	s15, [pc, #44]	; 8024d24 <floorf+0x84>
 8024cfa:	ee70 7a27 	vadd.f32	s15, s0, s15
 8024cfe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024d02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024d06:	dd03      	ble.n	8024d10 <floorf+0x70>
 8024d08:	2a00      	cmp	r2, #0
 8024d0a:	db02      	blt.n	8024d12 <floorf+0x72>
 8024d0c:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8024d28 <floorf+0x88>
 8024d10:	4770      	bx	lr
 8024d12:	2900      	cmp	r1, #0
 8024d14:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8024d18:	bf18      	it	ne
 8024d1a:	eeb0 0a67 	vmovne.f32	s0, s15
 8024d1e:	4770      	bx	lr
 8024d20:	007fffff 	.word	0x007fffff
 8024d24:	7149f2ca 	.word	0x7149f2ca
	...

08024d30 <frexpf>:
 8024d30:	ee10 1a10 	vmov	r1, s0
 8024d34:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8024d38:	b410      	push	{r4}
 8024d3a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024d3e:	f04f 0400 	mov.w	r4, #0
 8024d42:	6004      	str	r4, [r0, #0]
 8024d44:	da17      	bge.n	8024d76 <frexpf+0x46>
 8024d46:	b1b3      	cbz	r3, 8024d76 <frexpf+0x46>
 8024d48:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8024d4c:	ee10 2a10 	vmov	r2, s0
 8024d50:	da09      	bge.n	8024d66 <frexpf+0x36>
 8024d52:	eddf 7a0b 	vldr	s15, [pc, #44]	; 8024d80 <frexpf+0x50>
 8024d56:	ee60 7a27 	vmul.f32	s15, s0, s15
 8024d5a:	f06f 0418 	mvn.w	r4, #24
 8024d5e:	ee17 2a90 	vmov	r2, s15
 8024d62:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8024d66:	15db      	asrs	r3, r3, #23
 8024d68:	3b7e      	subs	r3, #126	; 0x7e
 8024d6a:	4423      	add	r3, r4
 8024d6c:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8024d70:	6003      	str	r3, [r0, #0]
 8024d72:	f042 517c 	orr.w	r1, r2, #1056964608	; 0x3f000000
 8024d76:	ee00 1a10 	vmov	s0, r1
 8024d7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024d7e:	4770      	bx	lr
 8024d80:	4c000000 	.word	0x4c000000
	...

08024d90 <ldexpf>:
 8024d90:	b510      	push	{r4, lr}
 8024d92:	ed2d 8b02 	vpush	{d8}
 8024d96:	4604      	mov	r4, r0
 8024d98:	eeb0 8a40 	vmov.f32	s16, s0
 8024d9c:	f001 fef0 	bl	8026b80 <finitef>
 8024da0:	b120      	cbz	r0, 8024dac <ldexpf+0x1c>
 8024da2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8024da6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024daa:	d104      	bne.n	8024db6 <ldexpf+0x26>
 8024dac:	eeb0 0a48 	vmov.f32	s0, s16
 8024db0:	ecbd 8b02 	vpop	{d8}
 8024db4:	bd10      	pop	{r4, pc}
 8024db6:	eeb0 0a48 	vmov.f32	s0, s16
 8024dba:	4620      	mov	r0, r4
 8024dbc:	f000 fab8 	bl	8025330 <scalbnf>
 8024dc0:	eeb0 8a40 	vmov.f32	s16, s0
 8024dc4:	f001 fedc 	bl	8026b80 <finitef>
 8024dc8:	b120      	cbz	r0, 8024dd4 <ldexpf+0x44>
 8024dca:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8024dce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024dd2:	d1eb      	bne.n	8024dac <ldexpf+0x1c>
 8024dd4:	f001 fee4 	bl	8026ba0 <__errno>
 8024dd8:	eeb0 0a48 	vmov.f32	s0, s16
 8024ddc:	ecbd 8b02 	vpop	{d8}
 8024de0:	2322      	movs	r3, #34	; 0x22
 8024de2:	6003      	str	r3, [r0, #0]
 8024de4:	bd10      	pop	{r4, pc}
 8024de6:	bf00      	nop
	...

08024df0 <logf>:
 8024df0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024df4:	b082      	sub	sp, #8
 8024df6:	ed8d 0a00 	vstr	s0, [sp]
 8024dfa:	9b00      	ldr	r3, [sp, #0]
 8024dfc:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8024e00:	d058      	beq.n	8024eb4 <logf+0xc4>
 8024e02:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
 8024e06:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8024e0a:	d258      	bcs.n	8024ebe <logf+0xce>
 8024e0c:	f103 4540 	add.w	r5, r3, #3221225472	; 0xc0000000
 8024e10:	f505 054d 	add.w	r5, r5, #13434880	; 0xcd0000
 8024e14:	4c3c      	ldr	r4, [pc, #240]	; (8024f08 <logf+0x118>)
 8024e16:	0de8      	lsrs	r0, r5, #23
 8024e18:	05c0      	lsls	r0, r0, #23
 8024e1a:	f3c5 4ac3 	ubfx	sl, r5, #19, #4
 8024e1e:	1a18      	subs	r0, r3, r0
 8024e20:	eb04 1a0a 	add.w	sl, r4, sl, lsl #4
 8024e24:	f7e7 faf0 	bl	800c408 <__aeabi_f2d>
 8024e28:	e9da 2300 	ldrd	r2, r3, [sl]
 8024e2c:	f7e7 fb48 	bl	800c4c0 <__aeabi_dmul>
 8024e30:	2200      	movs	r2, #0
 8024e32:	4b36      	ldr	r3, [pc, #216]	; (8024f0c <logf+0x11c>)
 8024e34:	f7e7 f988 	bl	800c148 <__aeabi_dsub>
 8024e38:	4602      	mov	r2, r0
 8024e3a:	460b      	mov	r3, r1
 8024e3c:	4606      	mov	r6, r0
 8024e3e:	460f      	mov	r7, r1
 8024e40:	f7e7 fb3e 	bl	800c4c0 <__aeabi_dmul>
 8024e44:	e9d4 2344 	ldrd	r2, r3, [r4, #272]	; 0x110
 8024e48:	4680      	mov	r8, r0
 8024e4a:	4689      	mov	r9, r1
 8024e4c:	4630      	mov	r0, r6
 8024e4e:	4639      	mov	r1, r7
 8024e50:	f7e7 fb36 	bl	800c4c0 <__aeabi_dmul>
 8024e54:	e9d4 2346 	ldrd	r2, r3, [r4, #280]	; 0x118
 8024e58:	f7e7 f978 	bl	800c14c <__adddf3>
 8024e5c:	e9d4 2342 	ldrd	r2, r3, [r4, #264]	; 0x108
 8024e60:	e9cd 0100 	strd	r0, r1, [sp]
 8024e64:	4640      	mov	r0, r8
 8024e66:	4649      	mov	r1, r9
 8024e68:	f7e7 fb2a 	bl	800c4c0 <__aeabi_dmul>
 8024e6c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8024e70:	f7e7 f96c 	bl	800c14c <__adddf3>
 8024e74:	4642      	mov	r2, r8
 8024e76:	464b      	mov	r3, r9
 8024e78:	f7e7 fb22 	bl	800c4c0 <__aeabi_dmul>
 8024e7c:	4680      	mov	r8, r0
 8024e7e:	15e8      	asrs	r0, r5, #23
 8024e80:	4689      	mov	r9, r1
 8024e82:	f7e7 faaf 	bl	800c3e4 <__aeabi_i2d>
 8024e86:	e9d4 2340 	ldrd	r2, r3, [r4, #256]	; 0x100
 8024e8a:	f7e7 fb19 	bl	800c4c0 <__aeabi_dmul>
 8024e8e:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 8024e92:	f7e7 f95b 	bl	800c14c <__adddf3>
 8024e96:	4632      	mov	r2, r6
 8024e98:	463b      	mov	r3, r7
 8024e9a:	f7e7 f957 	bl	800c14c <__adddf3>
 8024e9e:	4642      	mov	r2, r8
 8024ea0:	464b      	mov	r3, r9
 8024ea2:	f7e7 f953 	bl	800c14c <__adddf3>
 8024ea6:	f7e7 fdeb 	bl	800ca80 <__aeabi_d2f>
 8024eaa:	ee00 0a10 	vmov	s0, r0
 8024eae:	b002      	add	sp, #8
 8024eb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8024eb4:	ed9f 0a16 	vldr	s0, [pc, #88]	; 8024f10 <logf+0x120>
 8024eb8:	b002      	add	sp, #8
 8024eba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8024ebe:	005a      	lsls	r2, r3, #1
 8024ec0:	d015      	beq.n	8024eee <logf+0xfe>
 8024ec2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024ec6:	d00f      	beq.n	8024ee8 <logf+0xf8>
 8024ec8:	2b00      	cmp	r3, #0
 8024eca:	db16      	blt.n	8024efa <logf+0x10a>
 8024ecc:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
 8024ed0:	d213      	bcs.n	8024efa <logf+0x10a>
 8024ed2:	eddf 7a10 	vldr	s15, [pc, #64]	; 8024f14 <logf+0x124>
 8024ed6:	ed9d 7a00 	vldr	s14, [sp]
 8024eda:	ee67 7a27 	vmul.f32	s15, s14, s15
 8024ede:	ee17 3a90 	vmov	r3, s15
 8024ee2:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
 8024ee6:	e791      	b.n	8024e0c <logf+0x1c>
 8024ee8:	ed9d 0a00 	vldr	s0, [sp]
 8024eec:	e7df      	b.n	8024eae <logf+0xbe>
 8024eee:	2001      	movs	r0, #1
 8024ef0:	b002      	add	sp, #8
 8024ef2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024ef6:	f001 bd1b 	b.w	8026930 <__math_divzerof>
 8024efa:	ed9d 0a00 	vldr	s0, [sp]
 8024efe:	b002      	add	sp, #8
 8024f00:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024f04:	f001 bd2c 	b.w	8026960 <__math_invalidf>
 8024f08:	0802f810 	.word	0x0802f810
 8024f0c:	3ff00000 	.word	0x3ff00000
 8024f10:	00000000 	.word	0x00000000
 8024f14:	4b000000 	.word	0x4b000000
	...

08024f20 <powf>:
 8024f20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024f24:	b087      	sub	sp, #28
 8024f26:	ed8d 0a00 	vstr	s0, [sp]
 8024f2a:	9800      	ldr	r0, [sp, #0]
 8024f2c:	ee10 5a90 	vmov	r5, s1
 8024f30:	f5a0 0100 	sub.w	r1, r0, #8388608	; 0x800000
 8024f34:	006b      	lsls	r3, r5, #1
 8024f36:	f1b1 4ffe 	cmp.w	r1, #2130706432	; 0x7f000000
 8024f3a:	ee10 ba90 	vmov	fp, s1
 8024f3e:	f103 32ff 	add.w	r2, r3, #4294967295
 8024f42:	49c9      	ldr	r1, [pc, #804]	; (8025268 <powf+0x348>)
 8024f44:	f080 80dc 	bcs.w	8025100 <powf+0x1e0>
 8024f48:	428a      	cmp	r2, r1
 8024f4a:	f200 813e 	bhi.w	80251ca <powf+0x2aa>
 8024f4e:	2300      	movs	r3, #0
 8024f50:	9303      	str	r3, [sp, #12]
 8024f52:	f100 4640 	add.w	r6, r0, #3221225472	; 0xc0000000
 8024f56:	f506 064d 	add.w	r6, r6, #13434880	; 0xcd0000
 8024f5a:	4cc4      	ldr	r4, [pc, #784]	; (802526c <powf+0x34c>)
 8024f5c:	0df7      	lsrs	r7, r6, #23
 8024f5e:	05ff      	lsls	r7, r7, #23
 8024f60:	f3c6 46c3 	ubfx	r6, r6, #19, #4
 8024f64:	eb04 1606 	add.w	r6, r4, r6, lsl #4
 8024f68:	1bc0      	subs	r0, r0, r7
 8024f6a:	f7e7 fa4d 	bl	800c408 <__aeabi_f2d>
 8024f6e:	e9d6 2300 	ldrd	r2, r3, [r6]
 8024f72:	f7e7 faa5 	bl	800c4c0 <__aeabi_dmul>
 8024f76:	2200      	movs	r2, #0
 8024f78:	4bbd      	ldr	r3, [pc, #756]	; (8025270 <powf+0x350>)
 8024f7a:	f7e7 f8e5 	bl	800c148 <__aeabi_dsub>
 8024f7e:	4602      	mov	r2, r0
 8024f80:	460b      	mov	r3, r1
 8024f82:	4680      	mov	r8, r0
 8024f84:	4689      	mov	r9, r1
 8024f86:	f7e7 fa9b 	bl	800c4c0 <__aeabi_dmul>
 8024f8a:	4682      	mov	sl, r0
 8024f8c:	15f8      	asrs	r0, r7, #23
 8024f8e:	468b      	mov	fp, r1
 8024f90:	f7e7 fa28 	bl	800c3e4 <__aeabi_i2d>
 8024f94:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8024f98:	f7e7 f8d8 	bl	800c14c <__adddf3>
 8024f9c:	e9d4 2348 	ldrd	r2, r3, [r4, #288]	; 0x120
 8024fa0:	4606      	mov	r6, r0
 8024fa2:	460f      	mov	r7, r1
 8024fa4:	4640      	mov	r0, r8
 8024fa6:	4649      	mov	r1, r9
 8024fa8:	f7e7 fa8a 	bl	800c4c0 <__aeabi_dmul>
 8024fac:	4602      	mov	r2, r0
 8024fae:	460b      	mov	r3, r1
 8024fb0:	4630      	mov	r0, r6
 8024fb2:	4639      	mov	r1, r7
 8024fb4:	f7e7 f8ca 	bl	800c14c <__adddf3>
 8024fb8:	e9d4 2340 	ldrd	r2, r3, [r4, #256]	; 0x100
 8024fbc:	e9cd 0100 	strd	r0, r1, [sp]
 8024fc0:	4640      	mov	r0, r8
 8024fc2:	4649      	mov	r1, r9
 8024fc4:	f7e7 fa7c 	bl	800c4c0 <__aeabi_dmul>
 8024fc8:	e9d4 2342 	ldrd	r2, r3, [r4, #264]	; 0x108
 8024fcc:	f7e7 f8be 	bl	800c14c <__adddf3>
 8024fd0:	4652      	mov	r2, sl
 8024fd2:	4606      	mov	r6, r0
 8024fd4:	460f      	mov	r7, r1
 8024fd6:	465b      	mov	r3, fp
 8024fd8:	4650      	mov	r0, sl
 8024fda:	4659      	mov	r1, fp
 8024fdc:	f7e7 fa70 	bl	800c4c0 <__aeabi_dmul>
 8024fe0:	4602      	mov	r2, r0
 8024fe2:	460b      	mov	r3, r1
 8024fe4:	4630      	mov	r0, r6
 8024fe6:	4639      	mov	r1, r7
 8024fe8:	f7e7 fa6a 	bl	800c4c0 <__aeabi_dmul>
 8024fec:	e9d4 2344 	ldrd	r2, r3, [r4, #272]	; 0x110
 8024ff0:	4606      	mov	r6, r0
 8024ff2:	460f      	mov	r7, r1
 8024ff4:	4640      	mov	r0, r8
 8024ff6:	4649      	mov	r1, r9
 8024ff8:	f7e7 fa62 	bl	800c4c0 <__aeabi_dmul>
 8024ffc:	e9d4 2346 	ldrd	r2, r3, [r4, #280]	; 0x118
 8025000:	f7e7 f8a4 	bl	800c14c <__adddf3>
 8025004:	4652      	mov	r2, sl
 8025006:	465b      	mov	r3, fp
 8025008:	f7e7 fa5a 	bl	800c4c0 <__aeabi_dmul>
 802500c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8025010:	f7e7 f89c 	bl	800c14c <__adddf3>
 8025014:	4632      	mov	r2, r6
 8025016:	463b      	mov	r3, r7
 8025018:	f7e7 f898 	bl	800c14c <__adddf3>
 802501c:	4606      	mov	r6, r0
 802501e:	4628      	mov	r0, r5
 8025020:	460f      	mov	r7, r1
 8025022:	f7e7 f9f1 	bl	800c408 <__aeabi_f2d>
 8025026:	4602      	mov	r2, r0
 8025028:	460b      	mov	r3, r1
 802502a:	4630      	mov	r0, r6
 802502c:	4639      	mov	r1, r7
 802502e:	f7e7 fa47 	bl	800c4c0 <__aeabi_dmul>
 8025032:	2500      	movs	r5, #0
 8025034:	0bca      	lsrs	r2, r1, #15
 8025036:	2300      	movs	r3, #0
 8025038:	b292      	uxth	r2, r2
 802503a:	f248 04be 	movw	r4, #32958	; 0x80be
 802503e:	429d      	cmp	r5, r3
 8025040:	bf08      	it	eq
 8025042:	4294      	cmpeq	r4, r2
 8025044:	4606      	mov	r6, r0
 8025046:	460f      	mov	r7, r1
 8025048:	d375      	bcc.n	8025136 <powf+0x216>
 802504a:	f8df a234 	ldr.w	sl, [pc, #564]	; 8025280 <powf+0x360>
 802504e:	e9da 8940 	ldrd	r8, r9, [sl, #256]	; 0x100
 8025052:	4630      	mov	r0, r6
 8025054:	4642      	mov	r2, r8
 8025056:	464b      	mov	r3, r9
 8025058:	4639      	mov	r1, r7
 802505a:	f7e7 f877 	bl	800c14c <__adddf3>
 802505e:	4642      	mov	r2, r8
 8025060:	464b      	mov	r3, r9
 8025062:	4604      	mov	r4, r0
 8025064:	f7e7 f870 	bl	800c148 <__aeabi_dsub>
 8025068:	4602      	mov	r2, r0
 802506a:	460b      	mov	r3, r1
 802506c:	4630      	mov	r0, r6
 802506e:	4639      	mov	r1, r7
 8025070:	f7e7 f86a 	bl	800c148 <__aeabi_dsub>
 8025074:	f004 021f 	and.w	r2, r4, #31
 8025078:	eb0a 0cc2 	add.w	ip, sl, r2, lsl #3
 802507c:	e9dc 8900 	ldrd	r8, r9, [ip]
 8025080:	e9da 2346 	ldrd	r2, r3, [sl, #280]	; 0x118
 8025084:	4606      	mov	r6, r0
 8025086:	460f      	mov	r7, r1
 8025088:	e9cd 8900 	strd	r8, r9, [sp]
 802508c:	f7e7 fa18 	bl	800c4c0 <__aeabi_dmul>
 8025090:	2200      	movs	r2, #0
 8025092:	4b77      	ldr	r3, [pc, #476]	; (8025270 <powf+0x350>)
 8025094:	f7e7 f85a 	bl	800c14c <__adddf3>
 8025098:	e9da 2342 	ldrd	r2, r3, [sl, #264]	; 0x108
 802509c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80250a0:	4630      	mov	r0, r6
 80250a2:	4639      	mov	r1, r7
 80250a4:	f7e7 fa0c 	bl	800c4c0 <__aeabi_dmul>
 80250a8:	e9da 2344 	ldrd	r2, r3, [sl, #272]	; 0x110
 80250ac:	f7e7 f84e 	bl	800c14c <__adddf3>
 80250b0:	4632      	mov	r2, r6
 80250b2:	4680      	mov	r8, r0
 80250b4:	4689      	mov	r9, r1
 80250b6:	463b      	mov	r3, r7
 80250b8:	4630      	mov	r0, r6
 80250ba:	4639      	mov	r1, r7
 80250bc:	f7e7 fa00 	bl	800c4c0 <__aeabi_dmul>
 80250c0:	4602      	mov	r2, r0
 80250c2:	460b      	mov	r3, r1
 80250c4:	4640      	mov	r0, r8
 80250c6:	4649      	mov	r1, r9
 80250c8:	f7e7 f9fa 	bl	800c4c0 <__aeabi_dmul>
 80250cc:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80250d0:	f7e7 f83c 	bl	800c14c <__adddf3>
 80250d4:	9b03      	ldr	r3, [sp, #12]
 80250d6:	e9dd 8900 	ldrd	r8, r9, [sp]
 80250da:	18e4      	adds	r4, r4, r3
 80250dc:	2200      	movs	r2, #0
 80250de:	eb18 0802 	adds.w	r8, r8, r2
 80250e2:	ea4f 33c4 	mov.w	r3, r4, lsl #15
 80250e6:	eb49 0903 	adc.w	r9, r9, r3
 80250ea:	4642      	mov	r2, r8
 80250ec:	464b      	mov	r3, r9
 80250ee:	f7e7 f9e7 	bl	800c4c0 <__aeabi_dmul>
 80250f2:	f7e7 fcc5 	bl	800ca80 <__aeabi_d2f>
 80250f6:	ee00 0a10 	vmov	s0, r0
 80250fa:	b007      	add	sp, #28
 80250fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025100:	428a      	cmp	r2, r1
 8025102:	d862      	bhi.n	80251ca <powf+0x2aa>
 8025104:	0043      	lsls	r3, r0, #1
 8025106:	1e5a      	subs	r2, r3, #1
 8025108:	428a      	cmp	r2, r1
 802510a:	d868      	bhi.n	80251de <powf+0x2be>
 802510c:	2800      	cmp	r0, #0
 802510e:	db30      	blt.n	8025172 <powf+0x252>
 8025110:	2300      	movs	r3, #0
 8025112:	9303      	str	r3, [sp, #12]
 8025114:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8025118:	f4bf af1b 	bcs.w	8024f52 <powf+0x32>
 802511c:	eddf 7a55 	vldr	s15, [pc, #340]	; 8025274 <powf+0x354>
 8025120:	ed9d 7a00 	vldr	s14, [sp]
 8025124:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025128:	ee17 0a90 	vmov	r0, s15
 802512c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8025130:	f1a0 6038 	sub.w	r0, r0, #192937984	; 0xb800000
 8025134:	e70d      	b.n	8024f52 <powf+0x32>
 8025136:	a348      	add	r3, pc, #288	; (adr r3, 8025258 <powf+0x338>)
 8025138:	e9d3 2300 	ldrd	r2, r3, [r3]
 802513c:	f7e7 fc56 	bl	800c9ec <__aeabi_dcmpgt>
 8025140:	2800      	cmp	r0, #0
 8025142:	d139      	bne.n	80251b8 <powf+0x298>
 8025144:	2200      	movs	r2, #0
 8025146:	4b4c      	ldr	r3, [pc, #304]	; (8025278 <powf+0x358>)
 8025148:	4630      	mov	r0, r6
 802514a:	4639      	mov	r1, r7
 802514c:	f7e7 fc3a 	bl	800c9c4 <__aeabi_dcmple>
 8025150:	bb28      	cbnz	r0, 802519e <powf+0x27e>
 8025152:	a343      	add	r3, pc, #268	; (adr r3, 8025260 <powf+0x340>)
 8025154:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025158:	4630      	mov	r0, r6
 802515a:	4639      	mov	r1, r7
 802515c:	f7e7 fc28 	bl	800c9b0 <__aeabi_dcmplt>
 8025160:	2800      	cmp	r0, #0
 8025162:	f43f af72 	beq.w	802504a <powf+0x12a>
 8025166:	9803      	ldr	r0, [sp, #12]
 8025168:	b007      	add	sp, #28
 802516a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802516e:	f001 bbcf 	b.w	8026910 <__math_may_uflowf>
 8025172:	f3c5 53c7 	ubfx	r3, r5, #23, #8
 8025176:	2b7e      	cmp	r3, #126	; 0x7e
 8025178:	dd17      	ble.n	80251aa <powf+0x28a>
 802517a:	2b96      	cmp	r3, #150	; 0x96
 802517c:	dc22      	bgt.n	80251c4 <powf+0x2a4>
 802517e:	2201      	movs	r2, #1
 8025180:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 8025184:	fa02 f303 	lsl.w	r3, r2, r3
 8025188:	1e5a      	subs	r2, r3, #1
 802518a:	422a      	tst	r2, r5
 802518c:	d10d      	bne.n	80251aa <powf+0x28a>
 802518e:	402b      	ands	r3, r5
 8025190:	bf18      	it	ne
 8025192:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 8025196:	9303      	str	r3, [sp, #12]
 8025198:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802519c:	e7ba      	b.n	8025114 <powf+0x1f4>
 802519e:	9803      	ldr	r0, [sp, #12]
 80251a0:	b007      	add	sp, #28
 80251a2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80251a6:	f001 bbab 	b.w	8026900 <__math_uflowf>
 80251aa:	ed9d 0a00 	vldr	s0, [sp]
 80251ae:	b007      	add	sp, #28
 80251b0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80251b4:	f001 bbd4 	b.w	8026960 <__math_invalidf>
 80251b8:	9803      	ldr	r0, [sp, #12]
 80251ba:	b007      	add	sp, #28
 80251bc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80251c0:	f001 bbae 	b.w	8026920 <__math_oflowf>
 80251c4:	2300      	movs	r3, #0
 80251c6:	9303      	str	r3, [sp, #12]
 80251c8:	e7e6      	b.n	8025198 <powf+0x278>
 80251ca:	bb3b      	cbnz	r3, 802521c <powf+0x2fc>
 80251cc:	f480 0380 	eor.w	r3, r0, #4194304	; 0x400000
 80251d0:	005b      	lsls	r3, r3, #1
 80251d2:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
 80251d6:	d81a      	bhi.n	802520e <powf+0x2ee>
 80251d8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80251dc:	e78d      	b.n	80250fa <powf+0x1da>
 80251de:	eddd 7a00 	vldr	s15, [sp]
 80251e2:	2800      	cmp	r0, #0
 80251e4:	ee27 0aa7 	vmul.f32	s0, s15, s15
 80251e8:	db55      	blt.n	8025296 <powf+0x376>
 80251ea:	2000      	movs	r0, #0
 80251ec:	2b00      	cmp	r3, #0
 80251ee:	d149      	bne.n	8025284 <powf+0x364>
 80251f0:	f1bb 0f00 	cmp.w	fp, #0
 80251f4:	da81      	bge.n	80250fa <powf+0x1da>
 80251f6:	b007      	add	sp, #28
 80251f8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80251fc:	f001 bb98 	b.w	8026930 <__math_divzerof>
 8025200:	f48b 0b80 	eor.w	fp, fp, #4194304	; 0x400000
 8025204:	ea4f 034b 	mov.w	r3, fp, lsl #1
 8025208:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
 802520c:	d9e4      	bls.n	80251d8 <powf+0x2b8>
 802520e:	eddd 7a00 	vldr	s15, [sp]
 8025212:	ee07 5a10 	vmov	s14, r5
 8025216:	ee37 0a87 	vadd.f32	s0, s15, s14
 802521a:	e76e      	b.n	80250fa <powf+0x1da>
 802521c:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 8025220:	d0ee      	beq.n	8025200 <powf+0x2e0>
 8025222:	0040      	lsls	r0, r0, #1
 8025224:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
 8025228:	d8f1      	bhi.n	802520e <powf+0x2ee>
 802522a:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 802522e:	d1ee      	bne.n	802520e <powf+0x2ee>
 8025230:	f1b0 4ffe 	cmp.w	r0, #2130706432	; 0x7f000000
 8025234:	d0d0      	beq.n	80251d8 <powf+0x2b8>
 8025236:	f1b0 4ffe 	cmp.w	r0, #2130706432	; 0x7f000000
 802523a:	ea6f 0b0b 	mvn.w	fp, fp
 802523e:	bf34      	ite	cc
 8025240:	2000      	movcc	r0, #0
 8025242:	2001      	movcs	r0, #1
 8025244:	ea4f 7bdb 	mov.w	fp, fp, lsr #31
 8025248:	4558      	cmp	r0, fp
 802524a:	d038      	beq.n	80252be <powf+0x39e>
 802524c:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 802527c <powf+0x35c>
 8025250:	e753      	b.n	80250fa <powf+0x1da>
 8025252:	bf00      	nop
 8025254:	f3af 8000 	nop.w
 8025258:	ffd1d571 	.word	0xffd1d571
 802525c:	405fffff 	.word	0x405fffff
 8025260:	00000000 	.word	0x00000000
 8025264:	c062a000 	.word	0xc062a000
 8025268:	fefffffe 	.word	0xfefffffe
 802526c:	0802f930 	.word	0x0802f930
 8025270:	3ff00000 	.word	0x3ff00000
 8025274:	4b000000 	.word	0x4b000000
 8025278:	c062c000 	.word	0xc062c000
 802527c:	00000000 	.word	0x00000000
 8025280:	0802f6c0 	.word	0x0802f6c0
 8025284:	f1bb 0f00 	cmp.w	fp, #0
 8025288:	f6bf af37 	bge.w	80250fa <powf+0x1da>
 802528c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025290:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8025294:	e731      	b.n	80250fa <powf+0x1da>
 8025296:	f3c5 52c7 	ubfx	r2, r5, #23, #8
 802529a:	f1a2 017f 	sub.w	r1, r2, #127	; 0x7f
 802529e:	2917      	cmp	r1, #23
 80252a0:	d8a3      	bhi.n	80251ea <powf+0x2ca>
 80252a2:	f1c2 0096 	rsb	r0, r2, #150	; 0x96
 80252a6:	2201      	movs	r2, #1
 80252a8:	fa02 f000 	lsl.w	r0, r2, r0
 80252ac:	1e41      	subs	r1, r0, #1
 80252ae:	4229      	tst	r1, r5
 80252b0:	d19b      	bne.n	80251ea <powf+0x2ca>
 80252b2:	4028      	ands	r0, r5
 80252b4:	d09a      	beq.n	80251ec <powf+0x2cc>
 80252b6:	eeb1 0a40 	vneg.f32	s0, s0
 80252ba:	4610      	mov	r0, r2
 80252bc:	e796      	b.n	80251ec <powf+0x2cc>
 80252be:	ee07 5a90 	vmov	s15, r5
 80252c2:	ee27 0aa7 	vmul.f32	s0, s15, s15
 80252c6:	e718      	b.n	80250fa <powf+0x1da>
	...

080252d0 <roundf>:
 80252d0:	b082      	sub	sp, #8
 80252d2:	ed8d 0a01 	vstr	s0, [sp, #4]
 80252d6:	9901      	ldr	r1, [sp, #4]
 80252d8:	f3c1 53c7 	ubfx	r3, r1, #23, #8
 80252dc:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
 80252e0:	2a16      	cmp	r2, #22
 80252e2:	dc0c      	bgt.n	80252fe <roundf+0x2e>
 80252e4:	2a00      	cmp	r2, #0
 80252e6:	db10      	blt.n	802530a <roundf+0x3a>
 80252e8:	4810      	ldr	r0, [pc, #64]	; (802532c <roundf+0x5c>)
 80252ea:	4110      	asrs	r0, r2
 80252ec:	4201      	tst	r1, r0
 80252ee:	d008      	beq.n	8025302 <roundf+0x32>
 80252f0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80252f4:	4113      	asrs	r3, r2
 80252f6:	440b      	add	r3, r1
 80252f8:	ea23 0300 	bic.w	r3, r3, r0
 80252fc:	e00b      	b.n	8025316 <roundf+0x46>
 80252fe:	2a80      	cmp	r2, #128	; 0x80
 8025300:	d00d      	beq.n	802531e <roundf+0x4e>
 8025302:	ed9d 0a01 	vldr	s0, [sp, #4]
 8025306:	b002      	add	sp, #8
 8025308:	4770      	bx	lr
 802530a:	3201      	adds	r2, #1
 802530c:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
 8025310:	d101      	bne.n	8025316 <roundf+0x46>
 8025312:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 8025316:	ee00 3a10 	vmov	s0, r3
 802531a:	b002      	add	sp, #8
 802531c:	4770      	bx	lr
 802531e:	eddd 7a01 	vldr	s15, [sp, #4]
 8025322:	ee37 0aa7 	vadd.f32	s0, s15, s15
 8025326:	b002      	add	sp, #8
 8025328:	4770      	bx	lr
 802532a:	bf00      	nop
 802532c:	007fffff 	.word	0x007fffff

08025330 <scalbnf>:
 8025330:	b508      	push	{r3, lr}
 8025332:	ee10 3a10 	vmov	r3, s0
 8025336:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802533a:	ed2d 8b02 	vpush	{d8}
 802533e:	d011      	beq.n	8025364 <scalbnf+0x34>
 8025340:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8025344:	d211      	bcs.n	802536a <scalbnf+0x3a>
 8025346:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802534a:	d313      	bcc.n	8025374 <scalbnf+0x44>
 802534c:	0dd2      	lsrs	r2, r2, #23
 802534e:	4402      	add	r2, r0
 8025350:	2afe      	cmp	r2, #254	; 0xfe
 8025352:	dc1c      	bgt.n	802538e <scalbnf+0x5e>
 8025354:	2a00      	cmp	r2, #0
 8025356:	dd2a      	ble.n	80253ae <scalbnf+0x7e>
 8025358:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802535c:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8025360:	ee00 3a10 	vmov	s0, r3
 8025364:	ecbd 8b02 	vpop	{d8}
 8025368:	bd08      	pop	{r3, pc}
 802536a:	ecbd 8b02 	vpop	{d8}
 802536e:	ee30 0a00 	vadd.f32	s0, s0, s0
 8025372:	bd08      	pop	{r3, pc}
 8025374:	4b1d      	ldr	r3, [pc, #116]	; (80253ec <scalbnf+0xbc>)
 8025376:	eddf 7a1e 	vldr	s15, [pc, #120]	; 80253f0 <scalbnf+0xc0>
 802537a:	4298      	cmp	r0, r3
 802537c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025380:	db10      	blt.n	80253a4 <scalbnf+0x74>
 8025382:	ee10 3a10 	vmov	r3, s0
 8025386:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802538a:	3a19      	subs	r2, #25
 802538c:	e7df      	b.n	802534e <scalbnf+0x1e>
 802538e:	ed9f 8a19 	vldr	s16, [pc, #100]	; 80253f4 <scalbnf+0xc4>
 8025392:	eef0 0a40 	vmov.f32	s1, s0
 8025396:	eeb0 0a48 	vmov.f32	s0, s16
 802539a:	f001 fbd9 	bl	8026b50 <copysignf>
 802539e:	ee20 0a08 	vmul.f32	s0, s0, s16
 80253a2:	e7df      	b.n	8025364 <scalbnf+0x34>
 80253a4:	eddf 0a14 	vldr	s1, [pc, #80]	; 80253f8 <scalbnf+0xc8>
 80253a8:	ee20 0a20 	vmul.f32	s0, s0, s1
 80253ac:	e7da      	b.n	8025364 <scalbnf+0x34>
 80253ae:	f112 0f16 	cmn.w	r2, #22
 80253b2:	da0e      	bge.n	80253d2 <scalbnf+0xa2>
 80253b4:	f24c 3350 	movw	r3, #50000	; 0xc350
 80253b8:	4298      	cmp	r0, r3
 80253ba:	dce8      	bgt.n	802538e <scalbnf+0x5e>
 80253bc:	ed9f 8a0e 	vldr	s16, [pc, #56]	; 80253f8 <scalbnf+0xc8>
 80253c0:	eef0 0a40 	vmov.f32	s1, s0
 80253c4:	eeb0 0a48 	vmov.f32	s0, s16
 80253c8:	f001 fbc2 	bl	8026b50 <copysignf>
 80253cc:	ee20 0a08 	vmul.f32	s0, s0, s16
 80253d0:	e7c8      	b.n	8025364 <scalbnf+0x34>
 80253d2:	3219      	adds	r2, #25
 80253d4:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80253d8:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 80253dc:	eddf 7a07 	vldr	s15, [pc, #28]	; 80253fc <scalbnf+0xcc>
 80253e0:	ee00 3a10 	vmov	s0, r3
 80253e4:	ee20 0a27 	vmul.f32	s0, s0, s15
 80253e8:	e7bc      	b.n	8025364 <scalbnf+0x34>
 80253ea:	bf00      	nop
 80253ec:	ffff3cb0 	.word	0xffff3cb0
 80253f0:	4c000000 	.word	0x4c000000
 80253f4:	7149f2ca 	.word	0x7149f2ca
 80253f8:	0da24260 	.word	0x0da24260
 80253fc:	33000000 	.word	0x33000000

08025400 <sinf>:
 8025400:	b500      	push	{lr}
 8025402:	ee10 3a10 	vmov	r3, s0
 8025406:	4a21      	ldr	r2, [pc, #132]	; (802548c <sinf+0x8c>)
 8025408:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802540c:	4293      	cmp	r3, r2
 802540e:	b083      	sub	sp, #12
 8025410:	dd1a      	ble.n	8025448 <sinf+0x48>
 8025412:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8025416:	db04      	blt.n	8025422 <sinf+0x22>
 8025418:	ee30 0a40 	vsub.f32	s0, s0, s0
 802541c:	b003      	add	sp, #12
 802541e:	f85d fb04 	ldr.w	pc, [sp], #4
 8025422:	4668      	mov	r0, sp
 8025424:	f000 fcfc 	bl	8025e20 <__ieee754_rem_pio2f>
 8025428:	f000 0003 	and.w	r0, r0, #3
 802542c:	2801      	cmp	r0, #1
 802542e:	d013      	beq.n	8025458 <sinf+0x58>
 8025430:	2802      	cmp	r0, #2
 8025432:	d020      	beq.n	8025476 <sinf+0x76>
 8025434:	b1b8      	cbz	r0, 8025466 <sinf+0x66>
 8025436:	eddd 0a01 	vldr	s1, [sp, #4]
 802543a:	ed9d 0a00 	vldr	s0, [sp]
 802543e:	f000 fe47 	bl	80260d0 <__kernel_cosf>
 8025442:	eeb1 0a40 	vneg.f32	s0, s0
 8025446:	e7e9      	b.n	802541c <sinf+0x1c>
 8025448:	2000      	movs	r0, #0
 802544a:	eddf 0a11 	vldr	s1, [pc, #68]	; 8025490 <sinf+0x90>
 802544e:	f001 f9ef 	bl	8026830 <__kernel_sinf>
 8025452:	b003      	add	sp, #12
 8025454:	f85d fb04 	ldr.w	pc, [sp], #4
 8025458:	eddd 0a01 	vldr	s1, [sp, #4]
 802545c:	ed9d 0a00 	vldr	s0, [sp]
 8025460:	f000 fe36 	bl	80260d0 <__kernel_cosf>
 8025464:	e7da      	b.n	802541c <sinf+0x1c>
 8025466:	2001      	movs	r0, #1
 8025468:	eddd 0a01 	vldr	s1, [sp, #4]
 802546c:	ed9d 0a00 	vldr	s0, [sp]
 8025470:	f001 f9de 	bl	8026830 <__kernel_sinf>
 8025474:	e7d2      	b.n	802541c <sinf+0x1c>
 8025476:	2001      	movs	r0, #1
 8025478:	eddd 0a01 	vldr	s1, [sp, #4]
 802547c:	ed9d 0a00 	vldr	s0, [sp]
 8025480:	f001 f9d6 	bl	8026830 <__kernel_sinf>
 8025484:	eeb1 0a40 	vneg.f32	s0, s0
 8025488:	e7c8      	b.n	802541c <sinf+0x1c>
 802548a:	bf00      	nop
 802548c:	3f490fd8 	.word	0x3f490fd8
	...

080254a0 <sqrt>:
 80254a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80254a4:	ed2d 8b02 	vpush	{d8}
 80254a8:	b08b      	sub	sp, #44	; 0x2c
 80254aa:	ec55 4b10 	vmov	r4, r5, d0
 80254ae:	f000 f98f 	bl	80257d0 <__ieee754_sqrt>
 80254b2:	4b27      	ldr	r3, [pc, #156]	; (8025550 <sqrt+0xb0>)
 80254b4:	eeb0 8a40 	vmov.f32	s16, s0
 80254b8:	eef0 8a60 	vmov.f32	s17, s1
 80254bc:	f993 6000 	ldrsb.w	r6, [r3]
 80254c0:	1c73      	adds	r3, r6, #1
 80254c2:	d012      	beq.n	80254ea <sqrt+0x4a>
 80254c4:	4622      	mov	r2, r4
 80254c6:	462b      	mov	r3, r5
 80254c8:	4620      	mov	r0, r4
 80254ca:	4629      	mov	r1, r5
 80254cc:	f7e7 fa98 	bl	800ca00 <__aeabi_dcmpun>
 80254d0:	4607      	mov	r7, r0
 80254d2:	b950      	cbnz	r0, 80254ea <sqrt+0x4a>
 80254d4:	f04f 0800 	mov.w	r8, #0
 80254d8:	f04f 0900 	mov.w	r9, #0
 80254dc:	4620      	mov	r0, r4
 80254de:	4629      	mov	r1, r5
 80254e0:	4642      	mov	r2, r8
 80254e2:	464b      	mov	r3, r9
 80254e4:	f7e7 fa64 	bl	800c9b0 <__aeabi_dcmplt>
 80254e8:	b940      	cbnz	r0, 80254fc <sqrt+0x5c>
 80254ea:	eeb0 0a48 	vmov.f32	s0, s16
 80254ee:	eef0 0a68 	vmov.f32	s1, s17
 80254f2:	b00b      	add	sp, #44	; 0x2c
 80254f4:	ecbd 8b02 	vpop	{d8}
 80254f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80254fc:	2201      	movs	r2, #1
 80254fe:	4b15      	ldr	r3, [pc, #84]	; (8025554 <sqrt+0xb4>)
 8025500:	9708      	str	r7, [sp, #32]
 8025502:	9200      	str	r2, [sp, #0]
 8025504:	e9cd 4504 	strd	r4, r5, [sp, #16]
 8025508:	e9cd 4502 	strd	r4, r5, [sp, #8]
 802550c:	9301      	str	r3, [sp, #4]
 802550e:	b196      	cbz	r6, 8025536 <sqrt+0x96>
 8025510:	4642      	mov	r2, r8
 8025512:	464b      	mov	r3, r9
 8025514:	4640      	mov	r0, r8
 8025516:	4649      	mov	r1, r9
 8025518:	f7e7 f8fc 	bl	800c714 <__aeabi_ddiv>
 802551c:	2e02      	cmp	r6, #2
 802551e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8025522:	d10a      	bne.n	802553a <sqrt+0x9a>
 8025524:	f001 fb3c 	bl	8026ba0 <__errno>
 8025528:	2321      	movs	r3, #33	; 0x21
 802552a:	6003      	str	r3, [r0, #0]
 802552c:	9b08      	ldr	r3, [sp, #32]
 802552e:	b953      	cbnz	r3, 8025546 <sqrt+0xa6>
 8025530:	ed9d 8b06 	vldr	d8, [sp, #24]
 8025534:	e7d9      	b.n	80254ea <sqrt+0x4a>
 8025536:	e9cd 8906 	strd	r8, r9, [sp, #24]
 802553a:	4668      	mov	r0, sp
 802553c:	f001 fa20 	bl	8026980 <matherr>
 8025540:	2800      	cmp	r0, #0
 8025542:	d1f3      	bne.n	802552c <sqrt+0x8c>
 8025544:	e7ee      	b.n	8025524 <sqrt+0x84>
 8025546:	f001 fb2b 	bl	8026ba0 <__errno>
 802554a:	9b08      	ldr	r3, [sp, #32]
 802554c:	6003      	str	r3, [r0, #0]
 802554e:	e7ef      	b.n	8025530 <sqrt+0x90>
 8025550:	20001096 	.word	0x20001096
 8025554:	0802fa60 	.word	0x0802fa60
	...

08025560 <asinf>:
 8025560:	b510      	push	{r4, lr}
 8025562:	ed2d 8b02 	vpush	{d8}
 8025566:	4c28      	ldr	r4, [pc, #160]	; (8025608 <asinf+0xa8>)
 8025568:	b08a      	sub	sp, #40	; 0x28
 802556a:	eeb0 8a40 	vmov.f32	s16, s0
 802556e:	f000 f9ff 	bl	8025970 <__ieee754_asinf>
 8025572:	f994 3000 	ldrsb.w	r3, [r4]
 8025576:	3301      	adds	r3, #1
 8025578:	eef0 8a40 	vmov.f32	s17, s0
 802557c:	d034      	beq.n	80255e8 <asinf+0x88>
 802557e:	eeb4 8a48 	vcmp.f32	s16, s16
 8025582:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025586:	d62f      	bvs.n	80255e8 <asinf+0x88>
 8025588:	eeb0 0a48 	vmov.f32	s0, s16
 802558c:	f001 faf0 	bl	8026b70 <fabsf>
 8025590:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025594:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8025598:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802559c:	dd24      	ble.n	80255e8 <asinf+0x88>
 802559e:	2301      	movs	r3, #1
 80255a0:	4a1a      	ldr	r2, [pc, #104]	; (802560c <asinf+0xac>)
 80255a2:	9300      	str	r3, [sp, #0]
 80255a4:	ee18 0a10 	vmov	r0, s16
 80255a8:	2300      	movs	r3, #0
 80255aa:	9201      	str	r2, [sp, #4]
 80255ac:	9308      	str	r3, [sp, #32]
 80255ae:	f7e6 ff2b 	bl	800c408 <__aeabi_f2d>
 80255b2:	4602      	mov	r2, r0
 80255b4:	460b      	mov	r3, r1
 80255b6:	4816      	ldr	r0, [pc, #88]	; (8025610 <asinf+0xb0>)
 80255b8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80255bc:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80255c0:	f001 f9e6 	bl	8026990 <nan>
 80255c4:	f994 3000 	ldrsb.w	r3, [r4]
 80255c8:	2b02      	cmp	r3, #2
 80255ca:	ed8d 0b06 	vstr	d0, [sp, #24]
 80255ce:	d011      	beq.n	80255f4 <asinf+0x94>
 80255d0:	4668      	mov	r0, sp
 80255d2:	f001 f9d5 	bl	8026980 <matherr>
 80255d6:	b168      	cbz	r0, 80255f4 <asinf+0x94>
 80255d8:	9b08      	ldr	r3, [sp, #32]
 80255da:	b983      	cbnz	r3, 80255fe <asinf+0x9e>
 80255dc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80255e0:	f7e7 fa4e 	bl	800ca80 <__aeabi_d2f>
 80255e4:	ee08 0a90 	vmov	s17, r0
 80255e8:	eeb0 0a68 	vmov.f32	s0, s17
 80255ec:	b00a      	add	sp, #40	; 0x28
 80255ee:	ecbd 8b02 	vpop	{d8}
 80255f2:	bd10      	pop	{r4, pc}
 80255f4:	f001 fad4 	bl	8026ba0 <__errno>
 80255f8:	2321      	movs	r3, #33	; 0x21
 80255fa:	6003      	str	r3, [r0, #0]
 80255fc:	e7ec      	b.n	80255d8 <asinf+0x78>
 80255fe:	f001 facf 	bl	8026ba0 <__errno>
 8025602:	9b08      	ldr	r3, [sp, #32]
 8025604:	6003      	str	r3, [r0, #0]
 8025606:	e7e9      	b.n	80255dc <asinf+0x7c>
 8025608:	20001096 	.word	0x20001096
 802560c:	0802fa70 	.word	0x0802fa70
 8025610:	0802e8e0 	.word	0x0802e8e0
	...

08025620 <atan2f>:
 8025620:	f000 baa6 	b.w	8025b70 <__ieee754_atan2f>
	...

08025630 <fmodf>:
 8025630:	b5d0      	push	{r4, r6, r7, lr}
 8025632:	ed2d 8b02 	vpush	{d8}
 8025636:	b08a      	sub	sp, #40	; 0x28
 8025638:	eef0 8a40 	vmov.f32	s17, s0
 802563c:	eeb0 8a60 	vmov.f32	s16, s1
 8025640:	f000 fb56 	bl	8025cf0 <__ieee754_fmodf>
 8025644:	4b28      	ldr	r3, [pc, #160]	; (80256e8 <fmodf+0xb8>)
 8025646:	f993 4000 	ldrsb.w	r4, [r3]
 802564a:	1c63      	adds	r3, r4, #1
 802564c:	d039      	beq.n	80256c2 <fmodf+0x92>
 802564e:	eeb4 8a48 	vcmp.f32	s16, s16
 8025652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025656:	d634      	bvs.n	80256c2 <fmodf+0x92>
 8025658:	eef4 8a68 	vcmp.f32	s17, s17
 802565c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025660:	d62f      	bvs.n	80256c2 <fmodf+0x92>
 8025662:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8025666:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802566a:	d12a      	bne.n	80256c2 <fmodf+0x92>
 802566c:	2301      	movs	r3, #1
 802566e:	4a1f      	ldr	r2, [pc, #124]	; (80256ec <fmodf+0xbc>)
 8025670:	9300      	str	r3, [sp, #0]
 8025672:	ee18 0a90 	vmov	r0, s17
 8025676:	2300      	movs	r3, #0
 8025678:	9201      	str	r2, [sp, #4]
 802567a:	9308      	str	r3, [sp, #32]
 802567c:	f7e6 fec4 	bl	800c408 <__aeabi_f2d>
 8025680:	4606      	mov	r6, r0
 8025682:	460f      	mov	r7, r1
 8025684:	ee18 0a10 	vmov	r0, s16
 8025688:	e9cd 6702 	strd	r6, r7, [sp, #8]
 802568c:	f7e6 febc 	bl	800c408 <__aeabi_f2d>
 8025690:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8025694:	b1cc      	cbz	r4, 80256ca <fmodf+0x9a>
 8025696:	2200      	movs	r2, #0
 8025698:	2300      	movs	r3, #0
 802569a:	4610      	mov	r0, r2
 802569c:	4619      	mov	r1, r3
 802569e:	f7e7 f839 	bl	800c714 <__aeabi_ddiv>
 80256a2:	2c02      	cmp	r4, #2
 80256a4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80256a8:	d111      	bne.n	80256ce <fmodf+0x9e>
 80256aa:	f001 fa79 	bl	8026ba0 <__errno>
 80256ae:	2321      	movs	r3, #33	; 0x21
 80256b0:	6003      	str	r3, [r0, #0]
 80256b2:	9b08      	ldr	r3, [sp, #32]
 80256b4:	b99b      	cbnz	r3, 80256de <fmodf+0xae>
 80256b6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80256ba:	f7e7 f9e1 	bl	800ca80 <__aeabi_d2f>
 80256be:	ee00 0a10 	vmov	s0, r0
 80256c2:	b00a      	add	sp, #40	; 0x28
 80256c4:	ecbd 8b02 	vpop	{d8}
 80256c8:	bdd0      	pop	{r4, r6, r7, pc}
 80256ca:	e9cd 6706 	strd	r6, r7, [sp, #24]
 80256ce:	4668      	mov	r0, sp
 80256d0:	f001 f956 	bl	8026980 <matherr>
 80256d4:	2800      	cmp	r0, #0
 80256d6:	d0e8      	beq.n	80256aa <fmodf+0x7a>
 80256d8:	9b08      	ldr	r3, [sp, #32]
 80256da:	2b00      	cmp	r3, #0
 80256dc:	d0eb      	beq.n	80256b6 <fmodf+0x86>
 80256de:	f001 fa5f 	bl	8026ba0 <__errno>
 80256e2:	9b08      	ldr	r3, [sp, #32]
 80256e4:	6003      	str	r3, [r0, #0]
 80256e6:	e7e6      	b.n	80256b6 <fmodf+0x86>
 80256e8:	20001096 	.word	0x20001096
 80256ec:	0802fa80 	.word	0x0802fa80

080256f0 <sincosf>:
 80256f0:	b538      	push	{r3, r4, r5, lr}
 80256f2:	ed2d 8b02 	vpush	{d8}
 80256f6:	4605      	mov	r5, r0
 80256f8:	460c      	mov	r4, r1
 80256fa:	eeb0 8a40 	vmov.f32	s16, s0
 80256fe:	f7ff fe7f 	bl	8025400 <sinf>
 8025702:	ed85 0a00 	vstr	s0, [r5]
 8025706:	eeb0 0a48 	vmov.f32	s0, s16
 802570a:	f7ff f9c9 	bl	8024aa0 <cosf>
 802570e:	ecbd 8b02 	vpop	{d8}
 8025712:	ed84 0a00 	vstr	s0, [r4]
 8025716:	bd38      	pop	{r3, r4, r5, pc}
	...

08025720 <sqrtf>:
 8025720:	b510      	push	{r4, lr}
 8025722:	ed2d 8b02 	vpush	{d8}
 8025726:	b08a      	sub	sp, #40	; 0x28
 8025728:	eeb0 8a40 	vmov.f32	s16, s0
 802572c:	f000 fcc8 	bl	80260c0 <__ieee754_sqrtf>
 8025730:	4b24      	ldr	r3, [pc, #144]	; (80257c4 <sqrtf+0xa4>)
 8025732:	f993 4000 	ldrsb.w	r4, [r3]
 8025736:	1c63      	adds	r3, r4, #1
 8025738:	d009      	beq.n	802574e <sqrtf+0x2e>
 802573a:	eeb4 8a48 	vcmp.f32	s16, s16
 802573e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025742:	d604      	bvs.n	802574e <sqrtf+0x2e>
 8025744:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8025748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802574c:	d403      	bmi.n	8025756 <sqrtf+0x36>
 802574e:	b00a      	add	sp, #40	; 0x28
 8025750:	ecbd 8b02 	vpop	{d8}
 8025754:	bd10      	pop	{r4, pc}
 8025756:	2301      	movs	r3, #1
 8025758:	4a1b      	ldr	r2, [pc, #108]	; (80257c8 <sqrtf+0xa8>)
 802575a:	9300      	str	r3, [sp, #0]
 802575c:	ee18 0a10 	vmov	r0, s16
 8025760:	2300      	movs	r3, #0
 8025762:	9201      	str	r2, [sp, #4]
 8025764:	9308      	str	r3, [sp, #32]
 8025766:	f7e6 fe4f 	bl	800c408 <__aeabi_f2d>
 802576a:	2200      	movs	r2, #0
 802576c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8025770:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8025774:	2300      	movs	r3, #0
 8025776:	b1bc      	cbz	r4, 80257a8 <sqrtf+0x88>
 8025778:	4610      	mov	r0, r2
 802577a:	4619      	mov	r1, r3
 802577c:	f7e6 ffca 	bl	800c714 <__aeabi_ddiv>
 8025780:	2c02      	cmp	r4, #2
 8025782:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8025786:	d111      	bne.n	80257ac <sqrtf+0x8c>
 8025788:	f001 fa0a 	bl	8026ba0 <__errno>
 802578c:	2321      	movs	r3, #33	; 0x21
 802578e:	6003      	str	r3, [r0, #0]
 8025790:	9b08      	ldr	r3, [sp, #32]
 8025792:	b98b      	cbnz	r3, 80257b8 <sqrtf+0x98>
 8025794:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8025798:	f7e7 f972 	bl	800ca80 <__aeabi_d2f>
 802579c:	ee00 0a10 	vmov	s0, r0
 80257a0:	b00a      	add	sp, #40	; 0x28
 80257a2:	ecbd 8b02 	vpop	{d8}
 80257a6:	bd10      	pop	{r4, pc}
 80257a8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80257ac:	4668      	mov	r0, sp
 80257ae:	f001 f8e7 	bl	8026980 <matherr>
 80257b2:	2800      	cmp	r0, #0
 80257b4:	d1ec      	bne.n	8025790 <sqrtf+0x70>
 80257b6:	e7e7      	b.n	8025788 <sqrtf+0x68>
 80257b8:	f001 f9f2 	bl	8026ba0 <__errno>
 80257bc:	9b08      	ldr	r3, [sp, #32]
 80257be:	6003      	str	r3, [r0, #0]
 80257c0:	e7e8      	b.n	8025794 <sqrtf+0x74>
 80257c2:	bf00      	nop
 80257c4:	20001096 	.word	0x20001096
 80257c8:	0802fa90 	.word	0x0802fa90
 80257cc:	00000000 	.word	0x00000000

080257d0 <__ieee754_sqrt>:
 80257d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80257d4:	4a62      	ldr	r2, [pc, #392]	; (8025960 <__ieee754_sqrt+0x190>)
 80257d6:	ec57 6b10 	vmov	r6, r7, d0
 80257da:	43ba      	bics	r2, r7
 80257dc:	f000 8095 	beq.w	802590a <__ieee754_sqrt+0x13a>
 80257e0:	2f00      	cmp	r7, #0
 80257e2:	463b      	mov	r3, r7
 80257e4:	ee10 1a10 	vmov	r1, s0
 80257e8:	4634      	mov	r4, r6
 80257ea:	dd54      	ble.n	8025896 <__ieee754_sqrt+0xc6>
 80257ec:	153f      	asrs	r7, r7, #20
 80257ee:	f000 80af 	beq.w	8025950 <__ieee754_sqrt+0x180>
 80257f2:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80257f6:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 80257fa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80257fe:	0fe2      	lsrs	r2, r4, #31
 8025800:	07f9      	lsls	r1, r7, #31
 8025802:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8025806:	ea4f 0544 	mov.w	r5, r4, lsl #1
 802580a:	d503      	bpl.n	8025814 <__ieee754_sqrt+0x44>
 802580c:	0fed      	lsrs	r5, r5, #31
 802580e:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8025812:	00a5      	lsls	r5, r4, #2
 8025814:	2600      	movs	r6, #0
 8025816:	107f      	asrs	r7, r7, #1
 8025818:	46b4      	mov	ip, r6
 802581a:	2216      	movs	r2, #22
 802581c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8025820:	eb0c 0001 	add.w	r0, ip, r1
 8025824:	4298      	cmp	r0, r3
 8025826:	ea4f 74d5 	mov.w	r4, r5, lsr #31
 802582a:	ea4f 0545 	mov.w	r5, r5, lsl #1
 802582e:	dc03      	bgt.n	8025838 <__ieee754_sqrt+0x68>
 8025830:	1a1b      	subs	r3, r3, r0
 8025832:	eb00 0c01 	add.w	ip, r0, r1
 8025836:	440e      	add	r6, r1
 8025838:	3a01      	subs	r2, #1
 802583a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 802583e:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8025842:	d1ed      	bne.n	8025820 <__ieee754_sqrt+0x50>
 8025844:	4610      	mov	r0, r2
 8025846:	4696      	mov	lr, r2
 8025848:	2420      	movs	r4, #32
 802584a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 802584e:	e009      	b.n	8025864 <__ieee754_sqrt+0x94>
 8025850:	d052      	beq.n	80258f8 <__ieee754_sqrt+0x128>
 8025852:	005b      	lsls	r3, r3, #1
 8025854:	3c01      	subs	r4, #1
 8025856:	eb03 73d5 	add.w	r3, r3, r5, lsr #31
 802585a:	ea4f 0252 	mov.w	r2, r2, lsr #1
 802585e:	ea4f 0545 	mov.w	r5, r5, lsl #1
 8025862:	d036      	beq.n	80258d2 <__ieee754_sqrt+0x102>
 8025864:	4563      	cmp	r3, ip
 8025866:	eb02 010e 	add.w	r1, r2, lr
 802586a:	ddf1      	ble.n	8025850 <__ieee754_sqrt+0x80>
 802586c:	2900      	cmp	r1, #0
 802586e:	eb01 0e02 	add.w	lr, r1, r2
 8025872:	db0a      	blt.n	802588a <__ieee754_sqrt+0xba>
 8025874:	46e0      	mov	r8, ip
 8025876:	eba3 030c 	sub.w	r3, r3, ip
 802587a:	42a9      	cmp	r1, r5
 802587c:	bf88      	it	hi
 802587e:	f103 33ff 	addhi.w	r3, r3, #4294967295
 8025882:	1a6d      	subs	r5, r5, r1
 8025884:	4410      	add	r0, r2
 8025886:	46c4      	mov	ip, r8
 8025888:	e7e3      	b.n	8025852 <__ieee754_sqrt+0x82>
 802588a:	f1be 0f00 	cmp.w	lr, #0
 802588e:	dbf1      	blt.n	8025874 <__ieee754_sqrt+0xa4>
 8025890:	f10c 0801 	add.w	r8, ip, #1
 8025894:	e7ef      	b.n	8025876 <__ieee754_sqrt+0xa6>
 8025896:	f027 4200 	bic.w	r2, r7, #2147483648	; 0x80000000
 802589a:	4332      	orrs	r2, r6
 802589c:	d02a      	beq.n	80258f4 <__ieee754_sqrt+0x124>
 802589e:	2f00      	cmp	r7, #0
 80258a0:	d149      	bne.n	8025936 <__ieee754_sqrt+0x166>
 80258a2:	0aca      	lsrs	r2, r1, #11
 80258a4:	3b15      	subs	r3, #21
 80258a6:	0549      	lsls	r1, r1, #21
 80258a8:	2a00      	cmp	r2, #0
 80258aa:	d0fa      	beq.n	80258a2 <__ieee754_sqrt+0xd2>
 80258ac:	f412 1080 	ands.w	r0, r2, #1048576	; 0x100000
 80258b0:	d001      	beq.n	80258b6 <__ieee754_sqrt+0xe6>
 80258b2:	e050      	b.n	8025956 <__ieee754_sqrt+0x186>
 80258b4:	4620      	mov	r0, r4
 80258b6:	0052      	lsls	r2, r2, #1
 80258b8:	02d5      	lsls	r5, r2, #11
 80258ba:	f100 0401 	add.w	r4, r0, #1
 80258be:	d5f9      	bpl.n	80258b4 <__ieee754_sqrt+0xe4>
 80258c0:	f1c4 0520 	rsb	r5, r4, #32
 80258c4:	fa01 f404 	lsl.w	r4, r1, r4
 80258c8:	40e9      	lsrs	r1, r5
 80258ca:	1a1f      	subs	r7, r3, r0
 80258cc:	ea41 0302 	orr.w	r3, r1, r2
 80258d0:	e78f      	b.n	80257f2 <__ieee754_sqrt+0x22>
 80258d2:	432b      	orrs	r3, r5
 80258d4:	d129      	bne.n	802592a <__ieee754_sqrt+0x15a>
 80258d6:	0844      	lsrs	r4, r0, #1
 80258d8:	1071      	asrs	r1, r6, #1
 80258da:	07f3      	lsls	r3, r6, #31
 80258dc:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
 80258e0:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
 80258e4:	bf48      	it	mi
 80258e6:	f044 4400 	orrmi.w	r4, r4, #2147483648	; 0x80000000
 80258ea:	eb01 5307 	add.w	r3, r1, r7, lsl #20
 80258ee:	4622      	mov	r2, r4
 80258f0:	ec43 2b10 	vmov	d0, r2, r3
 80258f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80258f8:	42a9      	cmp	r1, r5
 80258fa:	d8aa      	bhi.n	8025852 <__ieee754_sqrt+0x82>
 80258fc:	2900      	cmp	r1, #0
 80258fe:	eb01 0e02 	add.w	lr, r1, r2
 8025902:	dbc2      	blt.n	802588a <__ieee754_sqrt+0xba>
 8025904:	4698      	mov	r8, r3
 8025906:	2300      	movs	r3, #0
 8025908:	e7bb      	b.n	8025882 <__ieee754_sqrt+0xb2>
 802590a:	ee10 2a10 	vmov	r2, s0
 802590e:	463b      	mov	r3, r7
 8025910:	ee10 0a10 	vmov	r0, s0
 8025914:	4639      	mov	r1, r7
 8025916:	f7e6 fdd3 	bl	800c4c0 <__aeabi_dmul>
 802591a:	4632      	mov	r2, r6
 802591c:	463b      	mov	r3, r7
 802591e:	f7e6 fc15 	bl	800c14c <__adddf3>
 8025922:	ec41 0b10 	vmov	d0, r0, r1
 8025926:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802592a:	1c42      	adds	r2, r0, #1
 802592c:	bf16      	itet	ne
 802592e:	1c42      	addne	r2, r0, #1
 8025930:	3601      	addeq	r6, #1
 8025932:	0854      	lsrne	r4, r2, #1
 8025934:	e7d0      	b.n	80258d8 <__ieee754_sqrt+0x108>
 8025936:	ee10 2a10 	vmov	r2, s0
 802593a:	4630      	mov	r0, r6
 802593c:	4639      	mov	r1, r7
 802593e:	f7e6 fc03 	bl	800c148 <__aeabi_dsub>
 8025942:	4602      	mov	r2, r0
 8025944:	460b      	mov	r3, r1
 8025946:	f7e6 fee5 	bl	800c714 <__aeabi_ddiv>
 802594a:	ec41 0b10 	vmov	d0, r0, r1
 802594e:	e7d1      	b.n	80258f4 <__ieee754_sqrt+0x124>
 8025950:	461a      	mov	r2, r3
 8025952:	463b      	mov	r3, r7
 8025954:	e7aa      	b.n	80258ac <__ieee754_sqrt+0xdc>
 8025956:	460c      	mov	r4, r1
 8025958:	2520      	movs	r5, #32
 802595a:	f04f 30ff 	mov.w	r0, #4294967295
 802595e:	e7b3      	b.n	80258c8 <__ieee754_sqrt+0xf8>
 8025960:	7ff00000 	.word	0x7ff00000
	...

08025970 <__ieee754_asinf>:
 8025970:	b538      	push	{r3, r4, r5, lr}
 8025972:	ee10 5a10 	vmov	r5, s0
 8025976:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 802597a:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802597e:	ed2d 8b04 	vpush	{d8-d9}
 8025982:	d068      	beq.n	8025a56 <__ieee754_asinf+0xe6>
 8025984:	dc60      	bgt.n	8025a48 <__ieee754_asinf+0xd8>
 8025986:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 802598a:	da0d      	bge.n	80259a8 <__ieee754_asinf+0x38>
 802598c:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 8025990:	da6e      	bge.n	8025a70 <__ieee754_asinf+0x100>
 8025992:	eddf 7a64 	vldr	s15, [pc, #400]	; 8025b24 <__ieee754_asinf+0x1b4>
 8025996:	ee70 7a27 	vadd.f32	s15, s0, s15
 802599a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802599e:	eef4 7ac7 	vcmpe.f32	s15, s14
 80259a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80259a6:	dc53      	bgt.n	8025a50 <__ieee754_asinf+0xe0>
 80259a8:	f001 f8e2 	bl	8026b70 <fabsf>
 80259ac:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80259b0:	ee37 0a40 	vsub.f32	s0, s14, s0
 80259b4:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 80259b8:	ee20 8a08 	vmul.f32	s16, s0, s16
 80259bc:	eddf 2a5a 	vldr	s5, [pc, #360]	; 8025b28 <__ieee754_asinf+0x1b8>
 80259c0:	eddf 3a5a 	vldr	s7, [pc, #360]	; 8025b2c <__ieee754_asinf+0x1bc>
 80259c4:	ed9f 3a5a 	vldr	s6, [pc, #360]	; 8025b30 <__ieee754_asinf+0x1c0>
 80259c8:	eddf 4a5a 	vldr	s9, [pc, #360]	; 8025b34 <__ieee754_asinf+0x1c4>
 80259cc:	ed9f 4a5a 	vldr	s8, [pc, #360]	; 8025b38 <__ieee754_asinf+0x1c8>
 80259d0:	eddf 5a5a 	vldr	s11, [pc, #360]	; 8025b3c <__ieee754_asinf+0x1cc>
 80259d4:	ed9f 5a5a 	vldr	s10, [pc, #360]	; 8025b40 <__ieee754_asinf+0x1d0>
 80259d8:	ed9f 6a5a 	vldr	s12, [pc, #360]	; 8025b44 <__ieee754_asinf+0x1d4>
 80259dc:	eddf 6a5a 	vldr	s13, [pc, #360]	; 8025b48 <__ieee754_asinf+0x1d8>
 80259e0:	eddf 7a5a 	vldr	s15, [pc, #360]	; 8025b4c <__ieee754_asinf+0x1dc>
 80259e4:	eee8 3a22 	vfma.f32	s7, s16, s5
 80259e8:	eea8 4a03 	vfma.f32	s8, s16, s6
 80259ec:	eee3 4a88 	vfma.f32	s9, s7, s16
 80259f0:	eea4 5a08 	vfma.f32	s10, s8, s16
 80259f4:	eee4 5a88 	vfma.f32	s11, s9, s16
 80259f8:	eee5 6a08 	vfma.f32	s13, s10, s16
 80259fc:	eea5 6a88 	vfma.f32	s12, s11, s16
 8025a00:	eea6 7a88 	vfma.f32	s14, s13, s16
 8025a04:	eee6 7a08 	vfma.f32	s15, s12, s16
 8025a08:	eeb0 0a48 	vmov.f32	s0, s16
 8025a0c:	eeb0 9a47 	vmov.f32	s18, s14
 8025a10:	ee67 8a88 	vmul.f32	s17, s15, s16
 8025a14:	f000 fb54 	bl	80260c0 <__ieee754_sqrtf>
 8025a18:	4b4d      	ldr	r3, [pc, #308]	; (8025b50 <__ieee754_asinf+0x1e0>)
 8025a1a:	429c      	cmp	r4, r3
 8025a1c:	dd5b      	ble.n	8025ad6 <__ieee754_asinf+0x166>
 8025a1e:	eec8 6a89 	vdiv.f32	s13, s17, s18
 8025a22:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 8025b54 <__ieee754_asinf+0x1e4>
 8025a26:	eddf 7a4c 	vldr	s15, [pc, #304]	; 8025b58 <__ieee754_asinf+0x1e8>
 8025a2a:	eea0 0a26 	vfma.f32	s0, s0, s13
 8025a2e:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8025a32:	eea0 7a26 	vfma.f32	s14, s0, s13
 8025a36:	ee37 0ac7 	vsub.f32	s0, s15, s14
 8025a3a:	ecbd 8b04 	vpop	{d8-d9}
 8025a3e:	2d00      	cmp	r5, #0
 8025a40:	bfd8      	it	le
 8025a42:	eeb1 0a40 	vnegle.f32	s0, s0
 8025a46:	bd38      	pop	{r3, r4, r5, pc}
 8025a48:	ee70 7a40 	vsub.f32	s15, s0, s0
 8025a4c:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 8025a50:	ecbd 8b04 	vpop	{d8-d9}
 8025a54:	bd38      	pop	{r3, r4, r5, pc}
 8025a56:	eddf 7a41 	vldr	s15, [pc, #260]	; 8025b5c <__ieee754_asinf+0x1ec>
 8025a5a:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 8025b58 <__ieee754_asinf+0x1e8>
 8025a5e:	ee60 7a27 	vmul.f32	s15, s0, s15
 8025a62:	ecbd 8b04 	vpop	{d8-d9}
 8025a66:	eee0 7a07 	vfma.f32	s15, s0, s14
 8025a6a:	eeb0 0a67 	vmov.f32	s0, s15
 8025a6e:	bd38      	pop	{r3, r4, r5, pc}
 8025a70:	ee60 7a00 	vmul.f32	s15, s0, s0
 8025a74:	eddf 2a2c 	vldr	s5, [pc, #176]	; 8025b28 <__ieee754_asinf+0x1b8>
 8025a78:	eddf 3a2c 	vldr	s7, [pc, #176]	; 8025b2c <__ieee754_asinf+0x1bc>
 8025a7c:	eddf 4a2d 	vldr	s9, [pc, #180]	; 8025b34 <__ieee754_asinf+0x1c4>
 8025a80:	ed9f 3a2b 	vldr	s6, [pc, #172]	; 8025b30 <__ieee754_asinf+0x1c0>
 8025a84:	ed9f 4a2c 	vldr	s8, [pc, #176]	; 8025b38 <__ieee754_asinf+0x1c8>
 8025a88:	eddf 6a2c 	vldr	s13, [pc, #176]	; 8025b3c <__ieee754_asinf+0x1cc>
 8025a8c:	ed9f 5a2c 	vldr	s10, [pc, #176]	; 8025b40 <__ieee754_asinf+0x1d0>
 8025a90:	eddf 5a2c 	vldr	s11, [pc, #176]	; 8025b44 <__ieee754_asinf+0x1d4>
 8025a94:	ed9f 6a2c 	vldr	s12, [pc, #176]	; 8025b48 <__ieee754_asinf+0x1d8>
 8025a98:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8025b4c <__ieee754_asinf+0x1dc>
 8025a9c:	eee7 3aa2 	vfma.f32	s7, s15, s5
 8025aa0:	ecbd 8b04 	vpop	{d8-d9}
 8025aa4:	eee3 4aa7 	vfma.f32	s9, s7, s15
 8025aa8:	eea7 4a83 	vfma.f32	s8, s15, s6
 8025aac:	eee4 6aa7 	vfma.f32	s13, s9, s15
 8025ab0:	eea4 5a27 	vfma.f32	s10, s8, s15
 8025ab4:	eee6 5aa7 	vfma.f32	s11, s13, s15
 8025ab8:	eea5 6a27 	vfma.f32	s12, s10, s15
 8025abc:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8025ac0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8025ac4:	eee6 6a27 	vfma.f32	s13, s12, s15
 8025ac8:	ee67 7a27 	vmul.f32	s15, s14, s15
 8025acc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8025ad0:	eea0 0a07 	vfma.f32	s0, s0, s14
 8025ad4:	bd38      	pop	{r3, r4, r5, pc}
 8025ad6:	ee10 3a10 	vmov	r3, s0
 8025ada:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8025ade:	f023 030f 	bic.w	r3, r3, #15
 8025ae2:	ee07 3a90 	vmov	s15, r3
 8025ae6:	eeb1 6a67 	vneg.f32	s12, s15
 8025aea:	eea6 8a27 	vfma.f32	s16, s12, s15
 8025aee:	ee77 7a80 	vadd.f32	s15, s15, s0
 8025af2:	eec8 5a89 	vdiv.f32	s11, s17, s18
 8025af6:	ee88 5a27 	vdiv.f32	s10, s16, s15
 8025afa:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8025b5c <__ieee754_asinf+0x1ec>
 8025afe:	eddf 7a18 	vldr	s15, [pc, #96]	; 8025b60 <__ieee754_asinf+0x1f0>
 8025b02:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 8025b06:	eea5 7a66 	vfms.f32	s14, s10, s13
 8025b0a:	ee30 0a00 	vadd.f32	s0, s0, s0
 8025b0e:	eeb0 5a67 	vmov.f32	s10, s15
 8025b12:	eea6 5a26 	vfma.f32	s10, s12, s13
 8025b16:	ee90 7a25 	vfnms.f32	s14, s0, s11
 8025b1a:	ee37 0a45 	vsub.f32	s0, s14, s10
 8025b1e:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8025b22:	e78a      	b.n	8025a3a <__ieee754_asinf+0xca>
 8025b24:	7149f2ca 	.word	0x7149f2ca
 8025b28:	3811ef08 	.word	0x3811ef08
 8025b2c:	3a4f7f04 	.word	0x3a4f7f04
 8025b30:	3d9dc62e 	.word	0x3d9dc62e
 8025b34:	bd241146 	.word	0xbd241146
 8025b38:	bf303361 	.word	0xbf303361
 8025b3c:	3e4e0aa8 	.word	0x3e4e0aa8
 8025b40:	4001572d 	.word	0x4001572d
 8025b44:	bea6b090 	.word	0xbea6b090
 8025b48:	c019d139 	.word	0xc019d139
 8025b4c:	3e2aaaab 	.word	0x3e2aaaab
 8025b50:	3f799999 	.word	0x3f799999
 8025b54:	333bbd2e 	.word	0x333bbd2e
 8025b58:	3fc90fdb 	.word	0x3fc90fdb
 8025b5c:	b33bbd2e 	.word	0xb33bbd2e
 8025b60:	3f490fdb 	.word	0x3f490fdb
	...

08025b70 <__ieee754_atan2f>:
 8025b70:	b510      	push	{r4, lr}
 8025b72:	b082      	sub	sp, #8
 8025b74:	edcd 0a01 	vstr	s1, [sp, #4]
 8025b78:	9b01      	ldr	r3, [sp, #4]
 8025b7a:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8025b7e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8025b82:	eef0 7a40 	vmov.f32	s15, s0
 8025b86:	dc18      	bgt.n	8025bba <__ieee754_atan2f+0x4a>
 8025b88:	ee10 0a10 	vmov	r0, s0
 8025b8c:	f020 4100 	bic.w	r1, r0, #2147483648	; 0x80000000
 8025b90:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8025b94:	dc11      	bgt.n	8025bba <__ieee754_atan2f+0x4a>
 8025b96:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8025b9a:	d03d      	beq.n	8025c18 <__ieee754_atan2f+0xa8>
 8025b9c:	179c      	asrs	r4, r3, #30
 8025b9e:	f004 0402 	and.w	r4, r4, #2
 8025ba2:	ea44 74d0 	orr.w	r4, r4, r0, lsr #31
 8025ba6:	b971      	cbnz	r1, 8025bc6 <__ieee754_atan2f+0x56>
 8025ba8:	2c02      	cmp	r4, #2
 8025baa:	d04a      	beq.n	8025c42 <__ieee754_atan2f+0xd2>
 8025bac:	ed9f 0a44 	vldr	s0, [pc, #272]	; 8025cc0 <__ieee754_atan2f+0x150>
 8025bb0:	2c03      	cmp	r4, #3
 8025bb2:	bf18      	it	ne
 8025bb4:	eeb0 0a67 	vmovne.f32	s0, s15
 8025bb8:	e003      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025bba:	ed9d 7a01 	vldr	s14, [sp, #4]
 8025bbe:	ee37 0a27 	vadd.f32	s0, s14, s15
 8025bc2:	b002      	add	sp, #8
 8025bc4:	bd10      	pop	{r4, pc}
 8025bc6:	b942      	cbnz	r2, 8025bda <__ieee754_atan2f+0x6a>
 8025bc8:	ed9f 0a3e 	vldr	s0, [pc, #248]	; 8025cc4 <__ieee754_atan2f+0x154>
 8025bcc:	eddf 7a3e 	vldr	s15, [pc, #248]	; 8025cc8 <__ieee754_atan2f+0x158>
 8025bd0:	2800      	cmp	r0, #0
 8025bd2:	bfb8      	it	lt
 8025bd4:	eeb0 0a67 	vmovlt.f32	s0, s15
 8025bd8:	e7f3      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025bda:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8025bde:	d020      	beq.n	8025c22 <__ieee754_atan2f+0xb2>
 8025be0:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8025be4:	d030      	beq.n	8025c48 <__ieee754_atan2f+0xd8>
 8025be6:	1a8a      	subs	r2, r1, r2
 8025be8:	15d2      	asrs	r2, r2, #23
 8025bea:	2a3c      	cmp	r2, #60	; 0x3c
 8025bec:	dc35      	bgt.n	8025c5a <__ieee754_atan2f+0xea>
 8025bee:	2b00      	cmp	r3, #0
 8025bf0:	da36      	bge.n	8025c60 <__ieee754_atan2f+0xf0>
 8025bf2:	323c      	adds	r2, #60	; 0x3c
 8025bf4:	da34      	bge.n	8025c60 <__ieee754_atan2f+0xf0>
 8025bf6:	ed9f 0a35 	vldr	s0, [pc, #212]	; 8025ccc <__ieee754_atan2f+0x15c>
 8025bfa:	2c01      	cmp	r4, #1
 8025bfc:	d042      	beq.n	8025c84 <__ieee754_atan2f+0x114>
 8025bfe:	2c02      	cmp	r4, #2
 8025c00:	d037      	beq.n	8025c72 <__ieee754_atan2f+0x102>
 8025c02:	2c00      	cmp	r4, #0
 8025c04:	d0dd      	beq.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c06:	eddf 7a32 	vldr	s15, [pc, #200]	; 8025cd0 <__ieee754_atan2f+0x160>
 8025c0a:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8025cd4 <__ieee754_atan2f+0x164>
 8025c0e:	ee70 7a27 	vadd.f32	s15, s0, s15
 8025c12:	ee37 0ac7 	vsub.f32	s0, s15, s14
 8025c16:	e7d4      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c18:	b002      	add	sp, #8
 8025c1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8025c1e:	f000 bebf 	b.w	80269a0 <atanf>
 8025c22:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8025c26:	d034      	beq.n	8025c92 <__ieee754_atan2f+0x122>
 8025c28:	2c02      	cmp	r4, #2
 8025c2a:	d00a      	beq.n	8025c42 <__ieee754_atan2f+0xd2>
 8025c2c:	2c03      	cmp	r4, #3
 8025c2e:	d03d      	beq.n	8025cac <__ieee754_atan2f+0x13c>
 8025c30:	eddf 7a29 	vldr	s15, [pc, #164]	; 8025cd8 <__ieee754_atan2f+0x168>
 8025c34:	ed9f 0a25 	vldr	s0, [pc, #148]	; 8025ccc <__ieee754_atan2f+0x15c>
 8025c38:	2c01      	cmp	r4, #1
 8025c3a:	bf08      	it	eq
 8025c3c:	eeb0 0a67 	vmoveq.f32	s0, s15
 8025c40:	e7bf      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c42:	ed9f 0a24 	vldr	s0, [pc, #144]	; 8025cd4 <__ieee754_atan2f+0x164>
 8025c46:	e7bc      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c48:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8025cc4 <__ieee754_atan2f+0x154>
 8025c4c:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 8025cc8 <__ieee754_atan2f+0x158>
 8025c50:	2800      	cmp	r0, #0
 8025c52:	bfa8      	it	ge
 8025c54:	eeb0 0a67 	vmovge.f32	s0, s15
 8025c58:	e7b3      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c5a:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 8025cc4 <__ieee754_atan2f+0x154>
 8025c5e:	e7cc      	b.n	8025bfa <__ieee754_atan2f+0x8a>
 8025c60:	ed9d 0a01 	vldr	s0, [sp, #4]
 8025c64:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8025c68:	f000 ff82 	bl	8026b70 <fabsf>
 8025c6c:	f000 fe98 	bl	80269a0 <atanf>
 8025c70:	e7c3      	b.n	8025bfa <__ieee754_atan2f+0x8a>
 8025c72:	eddf 7a17 	vldr	s15, [pc, #92]	; 8025cd0 <__ieee754_atan2f+0x160>
 8025c76:	ed9f 7a17 	vldr	s14, [pc, #92]	; 8025cd4 <__ieee754_atan2f+0x164>
 8025c7a:	ee70 7a27 	vadd.f32	s15, s0, s15
 8025c7e:	ee37 0a67 	vsub.f32	s0, s14, s15
 8025c82:	e79e      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c84:	ee10 3a10 	vmov	r3, s0
 8025c88:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8025c8c:	ee00 3a10 	vmov	s0, r3
 8025c90:	e797      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025c92:	2c02      	cmp	r4, #2
 8025c94:	d010      	beq.n	8025cb8 <__ieee754_atan2f+0x148>
 8025c96:	2c03      	cmp	r4, #3
 8025c98:	d00b      	beq.n	8025cb2 <__ieee754_atan2f+0x142>
 8025c9a:	eddf 7a10 	vldr	s15, [pc, #64]	; 8025cdc <__ieee754_atan2f+0x16c>
 8025c9e:	ed9f 0a10 	vldr	s0, [pc, #64]	; 8025ce0 <__ieee754_atan2f+0x170>
 8025ca2:	2c01      	cmp	r4, #1
 8025ca4:	bf08      	it	eq
 8025ca6:	eeb0 0a67 	vmoveq.f32	s0, s15
 8025caa:	e78a      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025cac:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8025cc0 <__ieee754_atan2f+0x150>
 8025cb0:	e787      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025cb2:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 8025ce4 <__ieee754_atan2f+0x174>
 8025cb6:	e784      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025cb8:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8025ce8 <__ieee754_atan2f+0x178>
 8025cbc:	e781      	b.n	8025bc2 <__ieee754_atan2f+0x52>
 8025cbe:	bf00      	nop
 8025cc0:	c0490fdb 	.word	0xc0490fdb
 8025cc4:	3fc90fdb 	.word	0x3fc90fdb
 8025cc8:	bfc90fdb 	.word	0xbfc90fdb
 8025ccc:	00000000 	.word	0x00000000
 8025cd0:	33bbbd2e 	.word	0x33bbbd2e
 8025cd4:	40490fdb 	.word	0x40490fdb
 8025cd8:	80000000 	.word	0x80000000
 8025cdc:	bf490fdb 	.word	0xbf490fdb
 8025ce0:	3f490fdb 	.word	0x3f490fdb
 8025ce4:	c016cbe4 	.word	0xc016cbe4
 8025ce8:	4016cbe4 	.word	0x4016cbe4
 8025cec:	00000000 	.word	0x00000000

08025cf0 <__ieee754_fmodf>:
 8025cf0:	ee10 3a90 	vmov	r3, s1
 8025cf4:	f033 4100 	bics.w	r1, r3, #2147483648	; 0x80000000
 8025cf8:	d03d      	beq.n	8025d76 <__ieee754_fmodf+0x86>
 8025cfa:	b4f0      	push	{r4, r5, r6, r7}
 8025cfc:	ee10 4a10 	vmov	r4, s0
 8025d00:	f024 4200 	bic.w	r2, r4, #2147483648	; 0x80000000
 8025d04:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8025d08:	da2f      	bge.n	8025d6a <__ieee754_fmodf+0x7a>
 8025d0a:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8025d0e:	dc2c      	bgt.n	8025d6a <__ieee754_fmodf+0x7a>
 8025d10:	428a      	cmp	r2, r1
 8025d12:	db2e      	blt.n	8025d72 <__ieee754_fmodf+0x82>
 8025d14:	f004 4600 	and.w	r6, r4, #2147483648	; 0x80000000
 8025d18:	d032      	beq.n	8025d80 <__ieee754_fmodf+0x90>
 8025d1a:	483e      	ldr	r0, [pc, #248]	; (8025e14 <__ieee754_fmodf+0x124>)
 8025d1c:	4282      	cmp	r2, r0
 8025d1e:	dd36      	ble.n	8025d8e <__ieee754_fmodf+0x9e>
 8025d20:	15d0      	asrs	r0, r2, #23
 8025d22:	387f      	subs	r0, #127	; 0x7f
 8025d24:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8025d28:	da5e      	bge.n	8025de8 <__ieee754_fmodf+0xf8>
 8025d2a:	020f      	lsls	r7, r1, #8
 8025d2c:	f06f 057d 	mvn.w	r5, #125	; 0x7d
 8025d30:	007f      	lsls	r7, r7, #1
 8025d32:	f105 35ff 	add.w	r5, r5, #4294967295
 8025d36:	d5fb      	bpl.n	8025d30 <__ieee754_fmodf+0x40>
 8025d38:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
 8025d3c:	db4f      	blt.n	8025dde <__ieee754_fmodf+0xee>
 8025d3e:	f3c4 0216 	ubfx	r2, r4, #0, #23
 8025d42:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8025d46:	f115 0f7e 	cmn.w	r5, #126	; 0x7e
 8025d4a:	db43      	blt.n	8025dd4 <__ieee754_fmodf+0xe4>
 8025d4c:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8025d50:	f443 0100 	orr.w	r1, r3, #8388608	; 0x800000
 8025d54:	1b40      	subs	r0, r0, r5
 8025d56:	e002      	b.n	8025d5e <__ieee754_fmodf+0x6e>
 8025d58:	d012      	beq.n	8025d80 <__ieee754_fmodf+0x90>
 8025d5a:	005a      	lsls	r2, r3, #1
 8025d5c:	3801      	subs	r0, #1
 8025d5e:	1a53      	subs	r3, r2, r1
 8025d60:	b1f8      	cbz	r0, 8025da2 <__ieee754_fmodf+0xb2>
 8025d62:	2b00      	cmp	r3, #0
 8025d64:	daf8      	bge.n	8025d58 <__ieee754_fmodf+0x68>
 8025d66:	0052      	lsls	r2, r2, #1
 8025d68:	e7f8      	b.n	8025d5c <__ieee754_fmodf+0x6c>
 8025d6a:	ee60 0a20 	vmul.f32	s1, s0, s1
 8025d6e:	ee80 0aa0 	vdiv.f32	s0, s1, s1
 8025d72:	bcf0      	pop	{r4, r5, r6, r7}
 8025d74:	4770      	bx	lr
 8025d76:	ee60 0a20 	vmul.f32	s1, s0, s1
 8025d7a:	ee80 0aa0 	vdiv.f32	s0, s1, s1
 8025d7e:	4770      	bx	lr
 8025d80:	4a25      	ldr	r2, [pc, #148]	; (8025e18 <__ieee754_fmodf+0x128>)
 8025d82:	0ff3      	lsrs	r3, r6, #31
 8025d84:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025d88:	ed93 0a00 	vldr	s0, [r3]
 8025d8c:	e7f1      	b.n	8025d72 <__ieee754_fmodf+0x82>
 8025d8e:	0215      	lsls	r5, r2, #8
 8025d90:	d036      	beq.n	8025e00 <__ieee754_fmodf+0x110>
 8025d92:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 8025d96:	006d      	lsls	r5, r5, #1
 8025d98:	2d00      	cmp	r5, #0
 8025d9a:	f100 30ff 	add.w	r0, r0, #4294967295
 8025d9e:	dcfa      	bgt.n	8025d96 <__ieee754_fmodf+0xa6>
 8025da0:	e7c0      	b.n	8025d24 <__ieee754_fmodf+0x34>
 8025da2:	ea33 0323 	bics.w	r3, r3, r3, asr #32
 8025da6:	bf28      	it	cs
 8025da8:	4613      	movcs	r3, r2
 8025daa:	2b00      	cmp	r3, #0
 8025dac:	d0e8      	beq.n	8025d80 <__ieee754_fmodf+0x90>
 8025dae:	4a19      	ldr	r2, [pc, #100]	; (8025e14 <__ieee754_fmodf+0x124>)
 8025db0:	4293      	cmp	r3, r2
 8025db2:	dc04      	bgt.n	8025dbe <__ieee754_fmodf+0xce>
 8025db4:	005b      	lsls	r3, r3, #1
 8025db6:	4293      	cmp	r3, r2
 8025db8:	f105 35ff 	add.w	r5, r5, #4294967295
 8025dbc:	ddfa      	ble.n	8025db4 <__ieee754_fmodf+0xc4>
 8025dbe:	f115 0f7e 	cmn.w	r5, #126	; 0x7e
 8025dc2:	da14      	bge.n	8025dee <__ieee754_fmodf+0xfe>
 8025dc4:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 8025dc8:	1b55      	subs	r5, r2, r5
 8025dca:	412b      	asrs	r3, r5
 8025dcc:	4333      	orrs	r3, r6
 8025dce:	ee00 3a10 	vmov	s0, r3
 8025dd2:	e7ce      	b.n	8025d72 <__ieee754_fmodf+0x82>
 8025dd4:	f06f 037d 	mvn.w	r3, #125	; 0x7d
 8025dd8:	1b5b      	subs	r3, r3, r5
 8025dda:	4099      	lsls	r1, r3
 8025ddc:	e7ba      	b.n	8025d54 <__ieee754_fmodf+0x64>
 8025dde:	f06f 047d 	mvn.w	r4, #125	; 0x7d
 8025de2:	1a24      	subs	r4, r4, r0
 8025de4:	40a2      	lsls	r2, r4
 8025de6:	e7ae      	b.n	8025d46 <__ieee754_fmodf+0x56>
 8025de8:	15cd      	asrs	r5, r1, #23
 8025dea:	3d7f      	subs	r5, #127	; 0x7f
 8025dec:	e7a4      	b.n	8025d38 <__ieee754_fmodf+0x48>
 8025dee:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8025df2:	4333      	orrs	r3, r6
 8025df4:	357f      	adds	r5, #127	; 0x7f
 8025df6:	ea43 53c5 	orr.w	r3, r3, r5, lsl #23
 8025dfa:	ee00 3a10 	vmov	s0, r3
 8025dfe:	e7b8      	b.n	8025d72 <__ieee754_fmodf+0x82>
 8025e00:	4281      	cmp	r1, r0
 8025e02:	dd04      	ble.n	8025e0e <__ieee754_fmodf+0x11e>
 8025e04:	15cd      	asrs	r5, r1, #23
 8025e06:	3d7f      	subs	r5, #127	; 0x7f
 8025e08:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 8025e0c:	e797      	b.n	8025d3e <__ieee754_fmodf+0x4e>
 8025e0e:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 8025e12:	e78a      	b.n	8025d2a <__ieee754_fmodf+0x3a>
 8025e14:	007fffff 	.word	0x007fffff
 8025e18:	0802faa0 	.word	0x0802faa0
 8025e1c:	00000000 	.word	0x00000000

08025e20 <__ieee754_rem_pio2f>:
 8025e20:	b570      	push	{r4, r5, r6, lr}
 8025e22:	ee10 3a10 	vmov	r3, s0
 8025e26:	4a96      	ldr	r2, [pc, #600]	; (8026080 <__ieee754_rem_pio2f+0x260>)
 8025e28:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 8025e2c:	4294      	cmp	r4, r2
 8025e2e:	b086      	sub	sp, #24
 8025e30:	4605      	mov	r5, r0
 8025e32:	dd69      	ble.n	8025f08 <__ieee754_rem_pio2f+0xe8>
 8025e34:	4a93      	ldr	r2, [pc, #588]	; (8026084 <__ieee754_rem_pio2f+0x264>)
 8025e36:	4294      	cmp	r4, r2
 8025e38:	ee10 6a10 	vmov	r6, s0
 8025e3c:	dc1a      	bgt.n	8025e74 <__ieee754_rem_pio2f+0x54>
 8025e3e:	2b00      	cmp	r3, #0
 8025e40:	f024 040f 	bic.w	r4, r4, #15
 8025e44:	eddf 7a90 	vldr	s15, [pc, #576]	; 8026088 <__ieee754_rem_pio2f+0x268>
 8025e48:	4a90      	ldr	r2, [pc, #576]	; (802608c <__ieee754_rem_pio2f+0x26c>)
 8025e4a:	dd64      	ble.n	8025f16 <__ieee754_rem_pio2f+0xf6>
 8025e4c:	4294      	cmp	r4, r2
 8025e4e:	ee70 7a67 	vsub.f32	s15, s0, s15
 8025e52:	f000 80cf 	beq.w	8025ff4 <__ieee754_rem_pio2f+0x1d4>
 8025e56:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 8026090 <__ieee754_rem_pio2f+0x270>
 8025e5a:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8025e5e:	2001      	movs	r0, #1
 8025e60:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8025e64:	edc5 6a00 	vstr	s13, [r5]
 8025e68:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025e6c:	edc5 7a01 	vstr	s15, [r5, #4]
 8025e70:	b006      	add	sp, #24
 8025e72:	bd70      	pop	{r4, r5, r6, pc}
 8025e74:	4a87      	ldr	r2, [pc, #540]	; (8026094 <__ieee754_rem_pio2f+0x274>)
 8025e76:	4294      	cmp	r4, r2
 8025e78:	dd61      	ble.n	8025f3e <__ieee754_rem_pio2f+0x11e>
 8025e7a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8025e7e:	f280 80b1 	bge.w	8025fe4 <__ieee754_rem_pio2f+0x1c4>
 8025e82:	15e2      	asrs	r2, r4, #23
 8025e84:	3a86      	subs	r2, #134	; 0x86
 8025e86:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 8025e8a:	ee07 3a90 	vmov	s15, r3
 8025e8e:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8025e92:	eddf 6a81 	vldr	s13, [pc, #516]	; 8026098 <__ieee754_rem_pio2f+0x278>
 8025e96:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8025e9a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025e9e:	ed8d 7a03 	vstr	s14, [sp, #12]
 8025ea2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8025ea6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8025eaa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8025eae:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025eb2:	ed8d 7a04 	vstr	s14, [sp, #16]
 8025eb6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8025eba:	eef5 7a40 	vcmp.f32	s15, #0.0
 8025ebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025ec2:	edcd 7a05 	vstr	s15, [sp, #20]
 8025ec6:	f040 80c7 	bne.w	8026058 <__ieee754_rem_pio2f+0x238>
 8025eca:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8025ece:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025ed2:	bf0c      	ite	eq
 8025ed4:	2301      	moveq	r3, #1
 8025ed6:	2302      	movne	r3, #2
 8025ed8:	4970      	ldr	r1, [pc, #448]	; (802609c <__ieee754_rem_pio2f+0x27c>)
 8025eda:	9101      	str	r1, [sp, #4]
 8025edc:	2102      	movs	r1, #2
 8025ede:	9100      	str	r1, [sp, #0]
 8025ee0:	a803      	add	r0, sp, #12
 8025ee2:	4629      	mov	r1, r5
 8025ee4:	f000 f97c 	bl	80261e0 <__kernel_rem_pio2f>
 8025ee8:	2e00      	cmp	r6, #0
 8025eea:	da12      	bge.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025eec:	ed95 7a00 	vldr	s14, [r5]
 8025ef0:	edd5 7a01 	vldr	s15, [r5, #4]
 8025ef4:	eeb1 7a47 	vneg.f32	s14, s14
 8025ef8:	eef1 7a67 	vneg.f32	s15, s15
 8025efc:	4240      	negs	r0, r0
 8025efe:	ed85 7a00 	vstr	s14, [r5]
 8025f02:	edc5 7a01 	vstr	s15, [r5, #4]
 8025f06:	e004      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025f08:	2200      	movs	r2, #0
 8025f0a:	ed85 0a00 	vstr	s0, [r5]
 8025f0e:	6042      	str	r2, [r0, #4]
 8025f10:	2000      	movs	r0, #0
 8025f12:	b006      	add	sp, #24
 8025f14:	bd70      	pop	{r4, r5, r6, pc}
 8025f16:	4294      	cmp	r4, r2
 8025f18:	ee70 7a27 	vadd.f32	s15, s0, s15
 8025f1c:	f000 8089 	beq.w	8026032 <__ieee754_rem_pio2f+0x212>
 8025f20:	ed9f 7a5b 	vldr	s14, [pc, #364]	; 8026090 <__ieee754_rem_pio2f+0x270>
 8025f24:	ee77 6a87 	vadd.f32	s13, s15, s14
 8025f28:	f04f 30ff 	mov.w	r0, #4294967295
 8025f2c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8025f30:	edc5 6a00 	vstr	s13, [r5]
 8025f34:	ee77 7a87 	vadd.f32	s15, s15, s14
 8025f38:	edc5 7a01 	vstr	s15, [r5, #4]
 8025f3c:	e7e9      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025f3e:	f000 fe17 	bl	8026b70 <fabsf>
 8025f42:	eddf 6a57 	vldr	s13, [pc, #348]	; 80260a0 <__ieee754_rem_pio2f+0x280>
 8025f46:	eddf 5a50 	vldr	s11, [pc, #320]	; 8026088 <__ieee754_rem_pio2f+0x268>
 8025f4a:	ed9f 7a51 	vldr	s14, [pc, #324]	; 8026090 <__ieee754_rem_pio2f+0x270>
 8025f4e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8025f52:	eee0 7a26 	vfma.f32	s15, s0, s13
 8025f56:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8025f5a:	ee17 0a90 	vmov	r0, s15
 8025f5e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8025f62:	281f      	cmp	r0, #31
 8025f64:	eeb1 6a66 	vneg.f32	s12, s13
 8025f68:	eea6 0a25 	vfma.f32	s0, s12, s11
 8025f6c:	ee66 7a87 	vmul.f32	s15, s13, s14
 8025f70:	dd52      	ble.n	8026018 <__ieee754_rem_pio2f+0x1f8>
 8025f72:	ee30 7a67 	vsub.f32	s14, s0, s15
 8025f76:	ee17 3a10 	vmov	r3, s14
 8025f7a:	15e4      	asrs	r4, r4, #23
 8025f7c:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8025f80:	1ae3      	subs	r3, r4, r3
 8025f82:	2b08      	cmp	r3, #8
 8025f84:	dd52      	ble.n	802602c <__ieee754_rem_pio2f+0x20c>
 8025f86:	eddf 7a47 	vldr	s15, [pc, #284]	; 80260a4 <__ieee754_rem_pio2f+0x284>
 8025f8a:	ed9f 7a47 	vldr	s14, [pc, #284]	; 80260a8 <__ieee754_rem_pio2f+0x288>
 8025f8e:	eef0 5a40 	vmov.f32	s11, s0
 8025f92:	eee6 5a27 	vfma.f32	s11, s12, s15
 8025f96:	ee30 0a65 	vsub.f32	s0, s0, s11
 8025f9a:	eea6 0a27 	vfma.f32	s0, s12, s15
 8025f9e:	eef0 7a40 	vmov.f32	s15, s0
 8025fa2:	eed6 7a87 	vfnms.f32	s15, s13, s14
 8025fa6:	ee35 7ae7 	vsub.f32	s14, s11, s15
 8025faa:	ee17 3a10 	vmov	r3, s14
 8025fae:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8025fb2:	1ae4      	subs	r4, r4, r3
 8025fb4:	2c19      	cmp	r4, #25
 8025fb6:	dc51      	bgt.n	802605c <__ieee754_rem_pio2f+0x23c>
 8025fb8:	ed85 7a00 	vstr	s14, [r5]
 8025fbc:	eeb0 0a65 	vmov.f32	s0, s11
 8025fc0:	ee30 0a47 	vsub.f32	s0, s0, s14
 8025fc4:	2e00      	cmp	r6, #0
 8025fc6:	ee30 0a67 	vsub.f32	s0, s0, s15
 8025fca:	ed85 0a01 	vstr	s0, [r5, #4]
 8025fce:	daa0      	bge.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025fd0:	eeb1 7a47 	vneg.f32	s14, s14
 8025fd4:	eeb1 0a40 	vneg.f32	s0, s0
 8025fd8:	ed85 7a00 	vstr	s14, [r5]
 8025fdc:	ed85 0a01 	vstr	s0, [r5, #4]
 8025fe0:	4240      	negs	r0, r0
 8025fe2:	e796      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025fe4:	ee70 7a40 	vsub.f32	s15, s0, s0
 8025fe8:	2000      	movs	r0, #0
 8025fea:	edc5 7a01 	vstr	s15, [r5, #4]
 8025fee:	edc5 7a00 	vstr	s15, [r5]
 8025ff2:	e78e      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8025ff4:	eddf 6a2b 	vldr	s13, [pc, #172]	; 80260a4 <__ieee754_rem_pio2f+0x284>
 8025ff8:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 80260a8 <__ieee754_rem_pio2f+0x288>
 8025ffc:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026000:	2001      	movs	r0, #1
 8026002:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8026006:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802600a:	edc5 6a00 	vstr	s13, [r5]
 802600e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026012:	edc5 7a01 	vstr	s15, [r5, #4]
 8026016:	e77c      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8026018:	1e42      	subs	r2, r0, #1
 802601a:	4b24      	ldr	r3, [pc, #144]	; (80260ac <__ieee754_rem_pio2f+0x28c>)
 802601c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8026020:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 8026024:	429a      	cmp	r2, r3
 8026026:	ee30 7a67 	vsub.f32	s14, s0, s15
 802602a:	d0a4      	beq.n	8025f76 <__ieee754_rem_pio2f+0x156>
 802602c:	ed85 7a00 	vstr	s14, [r5]
 8026030:	e7c6      	b.n	8025fc0 <__ieee754_rem_pio2f+0x1a0>
 8026032:	eddf 6a1c 	vldr	s13, [pc, #112]	; 80260a4 <__ieee754_rem_pio2f+0x284>
 8026036:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 80260a8 <__ieee754_rem_pio2f+0x288>
 802603a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802603e:	f04f 30ff 	mov.w	r0, #4294967295
 8026042:	ee77 6a87 	vadd.f32	s13, s15, s14
 8026046:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802604a:	edc5 6a00 	vstr	s13, [r5]
 802604e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026052:	edc5 7a01 	vstr	s15, [r5, #4]
 8026056:	e75c      	b.n	8025f12 <__ieee754_rem_pio2f+0xf2>
 8026058:	2303      	movs	r3, #3
 802605a:	e73d      	b.n	8025ed8 <__ieee754_rem_pio2f+0xb8>
 802605c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 80260b0 <__ieee754_rem_pio2f+0x290>
 8026060:	ed9f 5a14 	vldr	s10, [pc, #80]	; 80260b4 <__ieee754_rem_pio2f+0x294>
 8026064:	eeb0 0a65 	vmov.f32	s0, s11
 8026068:	eea6 0a07 	vfma.f32	s0, s12, s14
 802606c:	ee75 7ac0 	vsub.f32	s15, s11, s0
 8026070:	eee6 7a07 	vfma.f32	s15, s12, s14
 8026074:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8026078:	ee30 7a67 	vsub.f32	s14, s0, s15
 802607c:	e7d6      	b.n	802602c <__ieee754_rem_pio2f+0x20c>
 802607e:	bf00      	nop
 8026080:	3f490fd8 	.word	0x3f490fd8
 8026084:	4016cbe3 	.word	0x4016cbe3
 8026088:	3fc90f80 	.word	0x3fc90f80
 802608c:	3fc90fd0 	.word	0x3fc90fd0
 8026090:	37354443 	.word	0x37354443
 8026094:	43490f80 	.word	0x43490f80
 8026098:	43800000 	.word	0x43800000
 802609c:	0802fb30 	.word	0x0802fb30
 80260a0:	3f22f984 	.word	0x3f22f984
 80260a4:	37354400 	.word	0x37354400
 80260a8:	2e85a308 	.word	0x2e85a308
 80260ac:	0802fab0 	.word	0x0802fab0
 80260b0:	2e85a300 	.word	0x2e85a300
 80260b4:	248d3132 	.word	0x248d3132
	...

080260c0 <__ieee754_sqrtf>:
 80260c0:	eeb1 0ac0 	vsqrt.f32	s0, s0
 80260c4:	4770      	bx	lr
 80260c6:	bf00      	nop
	...

080260d0 <__kernel_cosf>:
 80260d0:	ee10 3a10 	vmov	r3, s0
 80260d4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80260d8:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80260dc:	da2c      	bge.n	8026138 <__kernel_cosf+0x68>
 80260de:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80260e2:	ee17 3a90 	vmov	r3, s15
 80260e6:	2b00      	cmp	r3, #0
 80260e8:	d05b      	beq.n	80261a2 <__kernel_cosf+0xd2>
 80260ea:	ee20 7a00 	vmul.f32	s14, s0, s0
 80260ee:	eddf 4a31 	vldr	s9, [pc, #196]	; 80261b4 <__kernel_cosf+0xe4>
 80260f2:	ed9f 5a31 	vldr	s10, [pc, #196]	; 80261b8 <__kernel_cosf+0xe8>
 80260f6:	eddf 5a31 	vldr	s11, [pc, #196]	; 80261bc <__kernel_cosf+0xec>
 80260fa:	ed9f 6a31 	vldr	s12, [pc, #196]	; 80261c0 <__kernel_cosf+0xf0>
 80260fe:	eddf 7a31 	vldr	s15, [pc, #196]	; 80261c4 <__kernel_cosf+0xf4>
 8026102:	eddf 6a31 	vldr	s13, [pc, #196]	; 80261c8 <__kernel_cosf+0xf8>
 8026106:	eea7 5a24 	vfma.f32	s10, s14, s9
 802610a:	eee7 5a05 	vfma.f32	s11, s14, s10
 802610e:	eea7 6a25 	vfma.f32	s12, s14, s11
 8026112:	eee7 7a06 	vfma.f32	s15, s14, s12
 8026116:	eee7 6a27 	vfma.f32	s13, s14, s15
 802611a:	ee66 6a87 	vmul.f32	s13, s13, s14
 802611e:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8026122:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8026126:	eee7 0a26 	vfma.f32	s1, s14, s13
 802612a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802612e:	eed7 0a06 	vfnms.f32	s1, s14, s12
 8026132:	ee37 0ae0 	vsub.f32	s0, s15, s1
 8026136:	4770      	bx	lr
 8026138:	ee20 7a00 	vmul.f32	s14, s0, s0
 802613c:	eddf 4a1d 	vldr	s9, [pc, #116]	; 80261b4 <__kernel_cosf+0xe4>
 8026140:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 80261b8 <__kernel_cosf+0xe8>
 8026144:	eddf 5a1d 	vldr	s11, [pc, #116]	; 80261bc <__kernel_cosf+0xec>
 8026148:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 80261c0 <__kernel_cosf+0xf0>
 802614c:	eddf 7a1d 	vldr	s15, [pc, #116]	; 80261c4 <__kernel_cosf+0xf4>
 8026150:	eddf 6a1d 	vldr	s13, [pc, #116]	; 80261c8 <__kernel_cosf+0xf8>
 8026154:	4a1d      	ldr	r2, [pc, #116]	; (80261cc <__kernel_cosf+0xfc>)
 8026156:	eea7 5a24 	vfma.f32	s10, s14, s9
 802615a:	4293      	cmp	r3, r2
 802615c:	eee5 5a07 	vfma.f32	s11, s10, s14
 8026160:	eea5 6a87 	vfma.f32	s12, s11, s14
 8026164:	eee6 7a07 	vfma.f32	s15, s12, s14
 8026168:	eee7 6a87 	vfma.f32	s13, s15, s14
 802616c:	ee66 6a87 	vmul.f32	s13, s13, s14
 8026170:	ddd5      	ble.n	802611e <__kernel_cosf+0x4e>
 8026172:	4a17      	ldr	r2, [pc, #92]	; (80261d0 <__kernel_cosf+0x100>)
 8026174:	4293      	cmp	r3, r2
 8026176:	dc17      	bgt.n	80261a8 <__kernel_cosf+0xd8>
 8026178:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
 802617c:	ee07 3a90 	vmov	s15, r3
 8026180:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8026184:	ee36 6a67 	vsub.f32	s12, s12, s15
 8026188:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 802618c:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 8026190:	eee7 0a26 	vfma.f32	s1, s14, s13
 8026194:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8026198:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802619c:	ee36 0a67 	vsub.f32	s0, s12, s15
 80261a0:	4770      	bx	lr
 80261a2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80261a6:	4770      	bx	lr
 80261a8:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
 80261ac:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
 80261b0:	e7ea      	b.n	8026188 <__kernel_cosf+0xb8>
 80261b2:	bf00      	nop
 80261b4:	ad47d74e 	.word	0xad47d74e
 80261b8:	310f74f6 	.word	0x310f74f6
 80261bc:	b493f27c 	.word	0xb493f27c
 80261c0:	37d00d01 	.word	0x37d00d01
 80261c4:	bab60b61 	.word	0xbab60b61
 80261c8:	3d2aaaab 	.word	0x3d2aaaab
 80261cc:	3e999999 	.word	0x3e999999
 80261d0:	3f480000 	.word	0x3f480000
	...

080261e0 <__kernel_rem_pio2f>:
 80261e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80261e4:	ed2d 8b04 	vpush	{d8-d9}
 80261e8:	b0d7      	sub	sp, #348	; 0x15c
 80261ea:	f103 39ff 	add.w	r9, r3, #4294967295
 80261ee:	9302      	str	r3, [sp, #8]
 80261f0:	1ed3      	subs	r3, r2, #3
 80261f2:	bf48      	it	mi
 80261f4:	1d13      	addmi	r3, r2, #4
 80261f6:	4cb2      	ldr	r4, [pc, #712]	; (80264c0 <__kernel_rem_pio2f+0x2e0>)
 80261f8:	9d64      	ldr	r5, [sp, #400]	; 0x190
 80261fa:	9105      	str	r1, [sp, #20]
 80261fc:	10db      	asrs	r3, r3, #3
 80261fe:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8026202:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
 8026206:	9303      	str	r3, [sp, #12]
 8026208:	f103 0801 	add.w	r8, r3, #1
 802620c:	eba2 08c8 	sub.w	r8, r2, r8, lsl #3
 8026210:	eb16 0209 	adds.w	r2, r6, r9
 8026214:	4686      	mov	lr, r0
 8026216:	eba3 0309 	sub.w	r3, r3, r9
 802621a:	d416      	bmi.n	802624a <__kernel_rem_pio2f+0x6a>
 802621c:	441a      	add	r2, r3
 802621e:	ed9f 7aa9 	vldr	s14, [pc, #676]	; 80264c4 <__kernel_rem_pio2f+0x2e4>
 8026222:	9865      	ldr	r0, [sp, #404]	; 0x194
 8026224:	1c51      	adds	r1, r2, #1
 8026226:	aa1a      	add	r2, sp, #104	; 0x68
 8026228:	2b00      	cmp	r3, #0
 802622a:	bfa4      	itt	ge
 802622c:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
 8026230:	ee07 4a90 	vmovge	s15, r4
 8026234:	f103 0301 	add.w	r3, r3, #1
 8026238:	bfac      	ite	ge
 802623a:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
 802623e:	eef0 7a47 	vmovlt.f32	s15, s14
 8026242:	428b      	cmp	r3, r1
 8026244:	ece2 7a01 	vstmia	r2!, {s15}
 8026248:	d1ee      	bne.n	8026228 <__kernel_rem_pio2f+0x48>
 802624a:	9b02      	ldr	r3, [sp, #8]
 802624c:	2e00      	cmp	r6, #0
 802624e:	ea4f 0483 	mov.w	r4, r3, lsl #2
 8026252:	ea4f 0a86 	mov.w	sl, r6, lsl #2
 8026256:	db1d      	blt.n	8026294 <__kernel_rem_pio2f+0xb4>
 8026258:	ab1a      	add	r3, sp, #104	; 0x68
 802625a:	1918      	adds	r0, r3, r4
 802625c:	aa43      	add	r2, sp, #268	; 0x10c
 802625e:	4673      	mov	r3, lr
 8026260:	1919      	adds	r1, r3, r4
 8026262:	eb02 070a 	add.w	r7, r2, sl
 8026266:	ad42      	add	r5, sp, #264	; 0x108
 8026268:	46f4      	mov	ip, lr
 802626a:	f1b9 0f00 	cmp.w	r9, #0
 802626e:	eddf 7a95 	vldr	s15, [pc, #596]	; 80264c4 <__kernel_rem_pio2f+0x2e4>
 8026272:	db09      	blt.n	8026288 <__kernel_rem_pio2f+0xa8>
 8026274:	4602      	mov	r2, r0
 8026276:	4663      	mov	r3, ip
 8026278:	ecf3 6a01 	vldmia	r3!, {s13}
 802627c:	ed32 7a01 	vldmdb	r2!, {s14}
 8026280:	428b      	cmp	r3, r1
 8026282:	eee6 7a87 	vfma.f32	s15, s13, s14
 8026286:	d1f7      	bne.n	8026278 <__kernel_rem_pio2f+0x98>
 8026288:	ece5 7a01 	vstmia	r5!, {s15}
 802628c:	42bd      	cmp	r5, r7
 802628e:	f100 0004 	add.w	r0, r0, #4
 8026292:	d1ea      	bne.n	802626a <__kernel_rem_pio2f+0x8a>
 8026294:	f1aa 0308 	sub.w	r3, sl, #8
 8026298:	ad06      	add	r5, sp, #24
 802629a:	18eb      	adds	r3, r5, r3
 802629c:	9304      	str	r3, [sp, #16]
 802629e:	ed9f 9a8b 	vldr	s18, [pc, #556]	; 80264cc <__kernel_rem_pio2f+0x2ec>
 80262a2:	eddf 8a89 	vldr	s17, [pc, #548]	; 80264c8 <__kernel_rem_pio2f+0x2e8>
 80262a6:	9600      	str	r6, [sp, #0]
 80262a8:	ab05      	add	r3, sp, #20
 80262aa:	46b3      	mov	fp, r6
 80262ac:	4474      	add	r4, lr
 80262ae:	449a      	add	sl, r3
 80262b0:	af42      	add	r7, sp, #264	; 0x108
 80262b2:	4676      	mov	r6, lr
 80262b4:	ea4f 018b 	mov.w	r1, fp, lsl #2
 80262b8:	ab56      	add	r3, sp, #344	; 0x158
 80262ba:	440b      	add	r3, r1
 80262bc:	f1bb 0f00 	cmp.w	fp, #0
 80262c0:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 80262c4:	dd16      	ble.n	80262f4 <__kernel_rem_pio2f+0x114>
 80262c6:	eb07 038b 	add.w	r3, r7, fp, lsl #2
 80262ca:	462a      	mov	r2, r5
 80262cc:	ee60 7a09 	vmul.f32	s15, s0, s18
 80262d0:	eeb0 7a40 	vmov.f32	s14, s0
 80262d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80262d8:	ed73 6a01 	vldmdb	r3!, {s13}
 80262dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80262e0:	42bb      	cmp	r3, r7
 80262e2:	eea7 7ae8 	vfms.f32	s14, s15, s17
 80262e6:	ee37 0aa6 	vadd.f32	s0, s15, s13
 80262ea:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80262ee:	eca2 7a01 	vstmia	r2!, {s14}
 80262f2:	d1eb      	bne.n	80262cc <__kernel_rem_pio2f+0xec>
 80262f4:	4640      	mov	r0, r8
 80262f6:	9101      	str	r1, [sp, #4]
 80262f8:	f7ff f81a 	bl	8025330 <scalbnf>
 80262fc:	eeb0 8a40 	vmov.f32	s16, s0
 8026300:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 8026304:	ee28 0a00 	vmul.f32	s0, s16, s0
 8026308:	f7fe fcca 	bl	8024ca0 <floorf>
 802630c:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 8026310:	eea0 8a67 	vfms.f32	s16, s0, s15
 8026314:	f1b8 0f00 	cmp.w	r8, #0
 8026318:	9901      	ldr	r1, [sp, #4]
 802631a:	eefd 9ac8 	vcvt.s32.f32	s19, s16
 802631e:	eef8 7ae9 	vcvt.f32.s32	s15, s19
 8026322:	ee38 8a67 	vsub.f32	s16, s16, s15
 8026326:	f340 80c4 	ble.w	80264b2 <__kernel_rem_pio2f+0x2d2>
 802632a:	f10b 3cff 	add.w	ip, fp, #4294967295
 802632e:	f1c8 0308 	rsb	r3, r8, #8
 8026332:	f855 202c 	ldr.w	r2, [r5, ip, lsl #2]
 8026336:	fa42 f003 	asr.w	r0, r2, r3
 802633a:	fa00 f303 	lsl.w	r3, r0, r3
 802633e:	1ad3      	subs	r3, r2, r3
 8026340:	f845 302c 	str.w	r3, [r5, ip, lsl #2]
 8026344:	ee19 ca90 	vmov	ip, s19
 8026348:	4484      	add	ip, r0
 802634a:	f1c8 0207 	rsb	r2, r8, #7
 802634e:	ee09 ca90 	vmov	s19, ip
 8026352:	fa43 f202 	asr.w	r2, r3, r2
 8026356:	2a00      	cmp	r2, #0
 8026358:	dd31      	ble.n	80263be <__kernel_rem_pio2f+0x1de>
 802635a:	ee19 3a90 	vmov	r3, s19
 802635e:	f1bb 0f00 	cmp.w	fp, #0
 8026362:	f103 0301 	add.w	r3, r3, #1
 8026366:	ee09 3a90 	vmov	s19, r3
 802636a:	f340 8229 	ble.w	80267c0 <__kernel_rem_pio2f+0x5e0>
 802636e:	6828      	ldr	r0, [r5, #0]
 8026370:	2800      	cmp	r0, #0
 8026372:	f040 8086 	bne.w	8026482 <__kernel_rem_pio2f+0x2a2>
 8026376:	f1bb 0f01 	cmp.w	fp, #1
 802637a:	d00b      	beq.n	8026394 <__kernel_rem_pio2f+0x1b4>
 802637c:	46ae      	mov	lr, r5
 802637e:	f04f 0c01 	mov.w	ip, #1
 8026382:	f85e 0f04 	ldr.w	r0, [lr, #4]!
 8026386:	f10c 0301 	add.w	r3, ip, #1
 802638a:	2800      	cmp	r0, #0
 802638c:	d17c      	bne.n	8026488 <__kernel_rem_pio2f+0x2a8>
 802638e:	459b      	cmp	fp, r3
 8026390:	469c      	mov	ip, r3
 8026392:	d1f6      	bne.n	8026382 <__kernel_rem_pio2f+0x1a2>
 8026394:	f1b8 0f00 	cmp.w	r8, #0
 8026398:	dd0e      	ble.n	80263b8 <__kernel_rem_pio2f+0x1d8>
 802639a:	f1b8 0f01 	cmp.w	r8, #1
 802639e:	f000 8132 	beq.w	8026606 <__kernel_rem_pio2f+0x426>
 80263a2:	f1b8 0f02 	cmp.w	r8, #2
 80263a6:	d107      	bne.n	80263b8 <__kernel_rem_pio2f+0x1d8>
 80263a8:	f10b 31ff 	add.w	r1, fp, #4294967295
 80263ac:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
 80263b0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80263b4:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
 80263b8:	2a02      	cmp	r2, #2
 80263ba:	f000 8112 	beq.w	80265e2 <__kernel_rem_pio2f+0x402>
 80263be:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80263c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80263c6:	f040 8095 	bne.w	80264f4 <__kernel_rem_pio2f+0x314>
 80263ca:	9b00      	ldr	r3, [sp, #0]
 80263cc:	f10b 3cff 	add.w	ip, fp, #4294967295
 80263d0:	4563      	cmp	r3, ip
 80263d2:	dc0e      	bgt.n	80263f2 <__kernel_rem_pio2f+0x212>
 80263d4:	f10b 4180 	add.w	r1, fp, #1073741824	; 0x40000000
 80263d8:	3901      	subs	r1, #1
 80263da:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 80263de:	2000      	movs	r0, #0
 80263e0:	f851 3904 	ldr.w	r3, [r1], #-4
 80263e4:	4551      	cmp	r1, sl
 80263e6:	ea40 0003 	orr.w	r0, r0, r3
 80263ea:	d1f9      	bne.n	80263e0 <__kernel_rem_pio2f+0x200>
 80263ec:	2800      	cmp	r0, #0
 80263ee:	f040 8113 	bne.w	8026618 <__kernel_rem_pio2f+0x438>
 80263f2:	9b00      	ldr	r3, [sp, #0]
 80263f4:	3b01      	subs	r3, #1
 80263f6:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80263fa:	2b00      	cmp	r3, #0
 80263fc:	f040 8100 	bne.w	8026600 <__kernel_rem_pio2f+0x420>
 8026400:	9b04      	ldr	r3, [sp, #16]
 8026402:	f04f 0c01 	mov.w	ip, #1
 8026406:	f853 2904 	ldr.w	r2, [r3], #-4
 802640a:	f10c 0c01 	add.w	ip, ip, #1
 802640e:	2a00      	cmp	r2, #0
 8026410:	d0f9      	beq.n	8026406 <__kernel_rem_pio2f+0x226>
 8026412:	44dc      	add	ip, fp
 8026414:	f10b 0e01 	add.w	lr, fp, #1
 8026418:	45e6      	cmp	lr, ip
 802641a:	dc30      	bgt.n	802647e <__kernel_rem_pio2f+0x29e>
 802641c:	9b03      	ldr	r3, [sp, #12]
 802641e:	9a02      	ldr	r2, [sp, #8]
 8026420:	eb0e 0103 	add.w	r1, lr, r3
 8026424:	445a      	add	r2, fp
 8026426:	eb03 0b0c 	add.w	fp, r3, ip
 802642a:	ab1a      	add	r3, sp, #104	; 0x68
 802642c:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8026430:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8026434:	9b65      	ldr	r3, [sp, #404]	; 0x194
 8026436:	3901      	subs	r1, #1
 8026438:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 802643c:	eb07 0e8e 	add.w	lr, r7, lr, lsl #2
 8026440:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
 8026444:	f851 3f04 	ldr.w	r3, [r1, #4]!
 8026448:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 80264c4 <__kernel_rem_pio2f+0x2e4>
 802644c:	ee07 3a90 	vmov	s15, r3
 8026450:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026454:	4610      	mov	r0, r2
 8026456:	f1b9 0f00 	cmp.w	r9, #0
 802645a:	ece0 7a01 	vstmia	r0!, {s15}
 802645e:	db09      	blt.n	8026474 <__kernel_rem_pio2f+0x294>
 8026460:	4633      	mov	r3, r6
 8026462:	e001      	b.n	8026468 <__kernel_rem_pio2f+0x288>
 8026464:	ed72 7a01 	vldmdb	r2!, {s15}
 8026468:	ecf3 6a01 	vldmia	r3!, {s13}
 802646c:	42a3      	cmp	r3, r4
 802646e:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8026472:	d1f7      	bne.n	8026464 <__kernel_rem_pio2f+0x284>
 8026474:	4559      	cmp	r1, fp
 8026476:	ecae 7a01 	vstmia	lr!, {s14}
 802647a:	4602      	mov	r2, r0
 802647c:	d1e2      	bne.n	8026444 <__kernel_rem_pio2f+0x264>
 802647e:	46e3      	mov	fp, ip
 8026480:	e718      	b.n	80262b4 <__kernel_rem_pio2f+0xd4>
 8026482:	2301      	movs	r3, #1
 8026484:	f04f 0c00 	mov.w	ip, #0
 8026488:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 802648c:	459b      	cmp	fp, r3
 802648e:	f845 002c 	str.w	r0, [r5, ip, lsl #2]
 8026492:	dd0c      	ble.n	80264ae <__kernel_rem_pio2f+0x2ce>
 8026494:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
 8026498:	4429      	add	r1, r5
 802649a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 802649e:	e000      	b.n	80264a2 <__kernel_rem_pio2f+0x2c2>
 80264a0:	6818      	ldr	r0, [r3, #0]
 80264a2:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 80264a6:	f843 0b04 	str.w	r0, [r3], #4
 80264aa:	428b      	cmp	r3, r1
 80264ac:	d1f8      	bne.n	80264a0 <__kernel_rem_pio2f+0x2c0>
 80264ae:	2001      	movs	r0, #1
 80264b0:	e770      	b.n	8026394 <__kernel_rem_pio2f+0x1b4>
 80264b2:	d10f      	bne.n	80264d4 <__kernel_rem_pio2f+0x2f4>
 80264b4:	f10b 33ff 	add.w	r3, fp, #4294967295
 80264b8:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 80264bc:	1212      	asrs	r2, r2, #8
 80264be:	e74a      	b.n	8026356 <__kernel_rem_pio2f+0x176>
 80264c0:	0802fe80 	.word	0x0802fe80
 80264c4:	00000000 	.word	0x00000000
 80264c8:	43800000 	.word	0x43800000
 80264cc:	3b800000 	.word	0x3b800000
 80264d0:	3fc90000 	.word	0x3fc90000
 80264d4:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80264d8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80264dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80264e0:	f280 8158 	bge.w	8026794 <__kernel_rem_pio2f+0x5b4>
 80264e4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80264e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80264ec:	f04f 0200 	mov.w	r2, #0
 80264f0:	f43f af6b 	beq.w	80263ca <__kernel_rem_pio2f+0x1ea>
 80264f4:	eeb0 0a48 	vmov.f32	s0, s16
 80264f8:	f1c8 0000 	rsb	r0, r8, #0
 80264fc:	4691      	mov	r9, r2
 80264fe:	9e00      	ldr	r6, [sp, #0]
 8026500:	f7fe ff16 	bl	8025330 <scalbnf>
 8026504:	ed1f 7a10 	vldr	s14, [pc, #-64]	; 80264c8 <__kernel_rem_pio2f+0x2e8>
 8026508:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802650c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026510:	f2c0 8158 	blt.w	80267c4 <__kernel_rem_pio2f+0x5e4>
 8026514:	ed5f 7a13 	vldr	s15, [pc, #-76]	; 80264cc <__kernel_rem_pio2f+0x2ec>
 8026518:	ee60 7a27 	vmul.f32	s15, s0, s15
 802651c:	f10b 0301 	add.w	r3, fp, #1
 8026520:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026524:	f108 0808 	add.w	r8, r8, #8
 8026528:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802652c:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8026530:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026534:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8026538:	ee10 2a10 	vmov	r2, s0
 802653c:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
 8026540:	ee17 2a90 	vmov	r2, s15
 8026544:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
 8026548:	4640      	mov	r0, r8
 802654a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802654e:	9300      	str	r3, [sp, #0]
 8026550:	f7fe feee 	bl	8025330 <scalbnf>
 8026554:	9b00      	ldr	r3, [sp, #0]
 8026556:	2b00      	cmp	r3, #0
 8026558:	f2c0 814b 	blt.w	80267f2 <__kernel_rem_pio2f+0x612>
 802655c:	0098      	lsls	r0, r3, #2
 802655e:	aa42      	add	r2, sp, #264	; 0x108
 8026560:	f100 0c04 	add.w	ip, r0, #4
 8026564:	ed1f 7a27 	vldr	s14, [pc, #-156]	; 80264cc <__kernel_rem_pio2f+0x2ec>
 8026568:	4410      	add	r0, r2
 802656a:	1d01      	adds	r1, r0, #4
 802656c:	eb05 020c 	add.w	r2, r5, ip
 8026570:	ed72 7a01 	vldmdb	r2!, {s15}
 8026574:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026578:	42aa      	cmp	r2, r5
 802657a:	ee67 7a80 	vmul.f32	s15, s15, s0
 802657e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026582:	ed61 7a01 	vstmdb	r1!, {s15}
 8026586:	d1f3      	bne.n	8026570 <__kernel_rem_pio2f+0x390>
 8026588:	f10d 0eb8 	add.w	lr, sp, #184	; 0xb8
 802658c:	ed1f 6a30 	vldr	s12, [pc, #-192]	; 80264d0 <__kernel_rem_pio2f+0x2f0>
 8026590:	4605      	mov	r5, r0
 8026592:	4677      	mov	r7, lr
 8026594:	f103 0801 	add.w	r8, r3, #1
 8026598:	2400      	movs	r4, #0
 802659a:	2e00      	cmp	r6, #0
 802659c:	f2c0 8105 	blt.w	80267aa <__kernel_rem_pio2f+0x5ca>
 80265a0:	48a1      	ldr	r0, [pc, #644]	; (8026828 <__kernel_rem_pio2f+0x648>)
 80265a2:	eddf 7aa2 	vldr	s15, [pc, #648]	; 802682c <__kernel_rem_pio2f+0x64c>
 80265a6:	4629      	mov	r1, r5
 80265a8:	eeb0 7a46 	vmov.f32	s14, s12
 80265ac:	2200      	movs	r2, #0
 80265ae:	e003      	b.n	80265b8 <__kernel_rem_pio2f+0x3d8>
 80265b0:	42a2      	cmp	r2, r4
 80265b2:	dc08      	bgt.n	80265c6 <__kernel_rem_pio2f+0x3e6>
 80265b4:	ecb0 7a01 	vldmia	r0!, {s14}
 80265b8:	ecf1 6a01 	vldmia	r1!, {s13}
 80265bc:	3201      	adds	r2, #1
 80265be:	4296      	cmp	r6, r2
 80265c0:	eee6 7a87 	vfma.f32	s15, s13, s14
 80265c4:	daf4      	bge.n	80265b0 <__kernel_rem_pio2f+0x3d0>
 80265c6:	3401      	adds	r4, #1
 80265c8:	4544      	cmp	r4, r8
 80265ca:	ece7 7a01 	vstmia	r7!, {s15}
 80265ce:	f1a5 0504 	sub.w	r5, r5, #4
 80265d2:	d1e2      	bne.n	802659a <__kernel_rem_pio2f+0x3ba>
 80265d4:	9a64      	ldr	r2, [sp, #400]	; 0x190
 80265d6:	2a03      	cmp	r2, #3
 80265d8:	d853      	bhi.n	8026682 <__kernel_rem_pio2f+0x4a2>
 80265da:	e8df f002 	tbb	[pc, r2]
 80265de:	b6ca      	.short	0xb6ca
 80265e0:	5bb6      	.short	0x5bb6
 80265e2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80265e6:	ee30 8a48 	vsub.f32	s16, s0, s16
 80265ea:	2800      	cmp	r0, #0
 80265ec:	f43f aee7 	beq.w	80263be <__kernel_rem_pio2f+0x1de>
 80265f0:	4640      	mov	r0, r8
 80265f2:	9201      	str	r2, [sp, #4]
 80265f4:	f7fe fe9c 	bl	8025330 <scalbnf>
 80265f8:	9a01      	ldr	r2, [sp, #4]
 80265fa:	ee38 8a40 	vsub.f32	s16, s16, s0
 80265fe:	e6de      	b.n	80263be <__kernel_rem_pio2f+0x1de>
 8026600:	f04f 0c01 	mov.w	ip, #1
 8026604:	e705      	b.n	8026412 <__kernel_rem_pio2f+0x232>
 8026606:	f10b 31ff 	add.w	r1, fp, #4294967295
 802660a:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
 802660e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8026612:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
 8026616:	e6cf      	b.n	80263b8 <__kernel_rem_pio2f+0x1d8>
 8026618:	4691      	mov	r9, r2
 802661a:	f855 202c 	ldr.w	r2, [r5, ip, lsl #2]
 802661e:	9e00      	ldr	r6, [sp, #0]
 8026620:	4663      	mov	r3, ip
 8026622:	f1a8 0808 	sub.w	r8, r8, #8
 8026626:	2a00      	cmp	r2, #0
 8026628:	d18e      	bne.n	8026548 <__kernel_rem_pio2f+0x368>
 802662a:	f10c 4280 	add.w	r2, ip, #1073741824	; 0x40000000
 802662e:	3a01      	subs	r2, #1
 8026630:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 8026634:	f852 1904 	ldr.w	r1, [r2], #-4
 8026638:	3b01      	subs	r3, #1
 802663a:	f1a8 0808 	sub.w	r8, r8, #8
 802663e:	2900      	cmp	r1, #0
 8026640:	d0f8      	beq.n	8026634 <__kernel_rem_pio2f+0x454>
 8026642:	e781      	b.n	8026548 <__kernel_rem_pio2f+0x368>
 8026644:	464a      	mov	r2, r9
 8026646:	eddf 7a79 	vldr	s15, [pc, #484]	; 802682c <__kernel_rem_pio2f+0x64c>
 802664a:	2a00      	cmp	r2, #0
 802664c:	f040 80c2 	bne.w	80267d4 <__kernel_rem_pio2f+0x5f4>
 8026650:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
 8026654:	9a05      	ldr	r2, [sp, #20]
 8026656:	2b00      	cmp	r3, #0
 8026658:	edc2 7a00 	vstr	s15, [r2]
 802665c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8026660:	dd0c      	ble.n	802667c <__kernel_rem_pio2f+0x49c>
 8026662:	a92f      	add	r1, sp, #188	; 0xbc
 8026664:	2201      	movs	r2, #1
 8026666:	ecb1 7a01 	vldmia	r1!, {s14}
 802666a:	3201      	adds	r2, #1
 802666c:	4293      	cmp	r3, r2
 802666e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026672:	daf8      	bge.n	8026666 <__kernel_rem_pio2f+0x486>
 8026674:	464b      	mov	r3, r9
 8026676:	2b00      	cmp	r3, #0
 8026678:	f040 80b8 	bne.w	80267ec <__kernel_rem_pio2f+0x60c>
 802667c:	9b05      	ldr	r3, [sp, #20]
 802667e:	edc3 7a01 	vstr	s15, [r3, #4]
 8026682:	ee19 3a90 	vmov	r3, s19
 8026686:	f003 0007 	and.w	r0, r3, #7
 802668a:	b057      	add	sp, #348	; 0x15c
 802668c:	ecbd 8b04 	vpop	{d8-d9}
 8026690:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026694:	2b00      	cmp	r3, #0
 8026696:	f340 80c4 	ble.w	8026822 <__kernel_rem_pio2f+0x642>
 802669a:	0098      	lsls	r0, r3, #2
 802669c:	aa56      	add	r2, sp, #344	; 0x158
 802669e:	4402      	add	r2, r0
 80266a0:	f10d 0eb8 	add.w	lr, sp, #184	; 0xb8
 80266a4:	f103 4180 	add.w	r1, r3, #1073741824	; 0x40000000
 80266a8:	ed52 6a28 	vldr	s13, [r2, #-160]	; 0xffffff60
 80266ac:	3901      	subs	r1, #1
 80266ae:	eb0e 0283 	add.w	r2, lr, r3, lsl #2
 80266b2:	ed72 7a01 	vldmdb	r2!, {s15}
 80266b6:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80266ba:	4596      	cmp	lr, r2
 80266bc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80266c0:	ed82 7a00 	vstr	s14, [r2]
 80266c4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80266c8:	eef0 6a47 	vmov.f32	s13, s14
 80266cc:	edc2 7a01 	vstr	s15, [r2, #4]
 80266d0:	d1ef      	bne.n	80266b2 <__kernel_rem_pio2f+0x4d2>
 80266d2:	2b01      	cmp	r3, #1
 80266d4:	f340 80a5 	ble.w	8026822 <__kernel_rem_pio2f+0x642>
 80266d8:	ab56      	add	r3, sp, #344	; 0x158
 80266da:	4418      	add	r0, r3
 80266dc:	0089      	lsls	r1, r1, #2
 80266de:	1d0b      	adds	r3, r1, #4
 80266e0:	ed50 6a28 	vldr	s13, [r0, #-160]	; 0xffffff60
 80266e4:	4473      	add	r3, lr
 80266e6:	aa2f      	add	r2, sp, #188	; 0xbc
 80266e8:	ed73 7a01 	vldmdb	r3!, {s15}
 80266ec:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80266f0:	429a      	cmp	r2, r3
 80266f2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80266f6:	ed83 7a00 	vstr	s14, [r3]
 80266fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80266fe:	eef0 6a47 	vmov.f32	s13, s14
 8026702:	edc3 7a01 	vstr	s15, [r3, #4]
 8026706:	d1ef      	bne.n	80266e8 <__kernel_rem_pio2f+0x508>
 8026708:	3108      	adds	r1, #8
 802670a:	eddf 7a48 	vldr	s15, [pc, #288]	; 802682c <__kernel_rem_pio2f+0x64c>
 802670e:	eb0e 0301 	add.w	r3, lr, r1
 8026712:	f10e 0e08 	add.w	lr, lr, #8
 8026716:	ed33 7a01 	vldmdb	r3!, {s14}
 802671a:	459e      	cmp	lr, r3
 802671c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026720:	d1f9      	bne.n	8026716 <__kernel_rem_pio2f+0x536>
 8026722:	464b      	mov	r3, r9
 8026724:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 8026728:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 802672c:	b12b      	cbz	r3, 802673a <__kernel_rem_pio2f+0x55a>
 802672e:	eef1 6a66 	vneg.f32	s13, s13
 8026732:	eeb1 7a47 	vneg.f32	s14, s14
 8026736:	eef1 7a67 	vneg.f32	s15, s15
 802673a:	9b05      	ldr	r3, [sp, #20]
 802673c:	edc3 6a00 	vstr	s13, [r3]
 8026740:	ed83 7a01 	vstr	s14, [r3, #4]
 8026744:	edc3 7a02 	vstr	s15, [r3, #8]
 8026748:	e79b      	b.n	8026682 <__kernel_rem_pio2f+0x4a2>
 802674a:	2b00      	cmp	r3, #0
 802674c:	f6ff af7a 	blt.w	8026644 <__kernel_rem_pio2f+0x464>
 8026750:	a92e      	add	r1, sp, #184	; 0xb8
 8026752:	eb01 0283 	add.w	r2, r1, r3, lsl #2
 8026756:	eddf 7a35 	vldr	s15, [pc, #212]	; 802682c <__kernel_rem_pio2f+0x64c>
 802675a:	3204      	adds	r2, #4
 802675c:	ed32 7a01 	vldmdb	r2!, {s14}
 8026760:	4291      	cmp	r1, r2
 8026762:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026766:	d1f9      	bne.n	802675c <__kernel_rem_pio2f+0x57c>
 8026768:	464a      	mov	r2, r9
 802676a:	2a00      	cmp	r2, #0
 802676c:	f43f af70 	beq.w	8026650 <__kernel_rem_pio2f+0x470>
 8026770:	e030      	b.n	80267d4 <__kernel_rem_pio2f+0x5f4>
 8026772:	eddf 7a2e 	vldr	s15, [pc, #184]	; 802682c <__kernel_rem_pio2f+0x64c>
 8026776:	44f4      	add	ip, lr
 8026778:	ed3c 7a01 	vldmdb	ip!, {s14}
 802677c:	45e6      	cmp	lr, ip
 802677e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026782:	d1f9      	bne.n	8026778 <__kernel_rem_pio2f+0x598>
 8026784:	464b      	mov	r3, r9
 8026786:	b10b      	cbz	r3, 802678c <__kernel_rem_pio2f+0x5ac>
 8026788:	eef1 7a67 	vneg.f32	s15, s15
 802678c:	9b05      	ldr	r3, [sp, #20]
 802678e:	edc3 7a00 	vstr	s15, [r3]
 8026792:	e776      	b.n	8026682 <__kernel_rem_pio2f+0x4a2>
 8026794:	ee19 3a90 	vmov	r3, s19
 8026798:	f1bb 0f00 	cmp.w	fp, #0
 802679c:	f103 0301 	add.w	r3, r3, #1
 80267a0:	ee09 3a90 	vmov	s19, r3
 80267a4:	dd37      	ble.n	8026816 <__kernel_rem_pio2f+0x636>
 80267a6:	2202      	movs	r2, #2
 80267a8:	e5e1      	b.n	802636e <__kernel_rem_pio2f+0x18e>
 80267aa:	eddf 7a20 	vldr	s15, [pc, #128]	; 802682c <__kernel_rem_pio2f+0x64c>
 80267ae:	3401      	adds	r4, #1
 80267b0:	4544      	cmp	r4, r8
 80267b2:	ece7 7a01 	vstmia	r7!, {s15}
 80267b6:	f1a5 0504 	sub.w	r5, r5, #4
 80267ba:	f47f aeee 	bne.w	802659a <__kernel_rem_pio2f+0x3ba>
 80267be:	e709      	b.n	80265d4 <__kernel_rem_pio2f+0x3f4>
 80267c0:	2000      	movs	r0, #0
 80267c2:	e5e7      	b.n	8026394 <__kernel_rem_pio2f+0x1b4>
 80267c4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80267c8:	465b      	mov	r3, fp
 80267ca:	ee10 2a10 	vmov	r2, s0
 80267ce:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
 80267d2:	e6b9      	b.n	8026548 <__kernel_rem_pio2f+0x368>
 80267d4:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 80267d8:	9a05      	ldr	r2, [sp, #20]
 80267da:	eeb1 7a67 	vneg.f32	s14, s15
 80267de:	2b00      	cmp	r3, #0
 80267e0:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80267e4:	ed82 7a00 	vstr	s14, [r2]
 80267e8:	f73f af3b 	bgt.w	8026662 <__kernel_rem_pio2f+0x482>
 80267ec:	eef1 7a67 	vneg.f32	s15, s15
 80267f0:	e744      	b.n	802667c <__kernel_rem_pio2f+0x49c>
 80267f2:	9a64      	ldr	r2, [sp, #400]	; 0x190
 80267f4:	2a03      	cmp	r2, #3
 80267f6:	f63f af44 	bhi.w	8026682 <__kernel_rem_pio2f+0x4a2>
 80267fa:	a101      	add	r1, pc, #4	; (adr r1, 8026800 <__kernel_rem_pio2f+0x620>)
 80267fc:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 8026800:	08026811 	.word	0x08026811
 8026804:	0802674b 	.word	0x0802674b
 8026808:	0802674b 	.word	0x0802674b
 802680c:	08026695 	.word	0x08026695
 8026810:	eddf 7a06 	vldr	s15, [pc, #24]	; 802682c <__kernel_rem_pio2f+0x64c>
 8026814:	e7b6      	b.n	8026784 <__kernel_rem_pio2f+0x5a4>
 8026816:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802681a:	ee37 8ac8 	vsub.f32	s16, s15, s16
 802681e:	2202      	movs	r2, #2
 8026820:	e5cd      	b.n	80263be <__kernel_rem_pio2f+0x1de>
 8026822:	eddf 7a02 	vldr	s15, [pc, #8]	; 802682c <__kernel_rem_pio2f+0x64c>
 8026826:	e77c      	b.n	8026722 <__kernel_rem_pio2f+0x542>
 8026828:	0802fe54 	.word	0x0802fe54
 802682c:	00000000 	.word	0x00000000

08026830 <__kernel_sinf>:
 8026830:	ee10 3a10 	vmov	r3, s0
 8026834:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026838:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802683c:	da04      	bge.n	8026848 <__kernel_sinf+0x18>
 802683e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8026842:	ee17 3a90 	vmov	r3, s15
 8026846:	b323      	cbz	r3, 8026892 <__kernel_sinf+0x62>
 8026848:	ee60 7a00 	vmul.f32	s15, s0, s0
 802684c:	ed9f 5a15 	vldr	s10, [pc, #84]	; 80268a4 <__kernel_sinf+0x74>
 8026850:	eddf 5a15 	vldr	s11, [pc, #84]	; 80268a8 <__kernel_sinf+0x78>
 8026854:	ed9f 6a15 	vldr	s12, [pc, #84]	; 80268ac <__kernel_sinf+0x7c>
 8026858:	eddf 6a15 	vldr	s13, [pc, #84]	; 80268b0 <__kernel_sinf+0x80>
 802685c:	ed9f 7a15 	vldr	s14, [pc, #84]	; 80268b4 <__kernel_sinf+0x84>
 8026860:	eee7 5a85 	vfma.f32	s11, s15, s10
 8026864:	ee20 5a27 	vmul.f32	s10, s0, s15
 8026868:	eea5 6aa7 	vfma.f32	s12, s11, s15
 802686c:	eee6 6a27 	vfma.f32	s13, s12, s15
 8026870:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8026874:	b170      	cbz	r0, 8026894 <__kernel_sinf+0x64>
 8026876:	ee27 7a45 	vnmul.f32	s14, s14, s10
 802687a:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802687e:	eea0 7aa6 	vfma.f32	s14, s1, s13
 8026882:	eddf 6a0d 	vldr	s13, [pc, #52]	; 80268b8 <__kernel_sinf+0x88>
 8026886:	eed7 0a27 	vfnms.f32	s1, s14, s15
 802688a:	eee5 0a26 	vfma.f32	s1, s10, s13
 802688e:	ee30 0a60 	vsub.f32	s0, s0, s1
 8026892:	4770      	bx	lr
 8026894:	eddf 6a09 	vldr	s13, [pc, #36]	; 80268bc <__kernel_sinf+0x8c>
 8026898:	eee7 6a87 	vfma.f32	s13, s15, s14
 802689c:	eea6 0a85 	vfma.f32	s0, s13, s10
 80268a0:	4770      	bx	lr
 80268a2:	bf00      	nop
 80268a4:	2f2ec9d3 	.word	0x2f2ec9d3
 80268a8:	b2d72f34 	.word	0xb2d72f34
 80268ac:	3638ef1b 	.word	0x3638ef1b
 80268b0:	b9500d01 	.word	0xb9500d01
 80268b4:	3c088889 	.word	0x3c088889
 80268b8:	3e2aaaab 	.word	0x3e2aaaab
 80268bc:	be2aaaab 	.word	0xbe2aaaab

080268c0 <with_errnof>:
 80268c0:	b510      	push	{r4, lr}
 80268c2:	ed2d 8b02 	vpush	{d8}
 80268c6:	eeb0 8a40 	vmov.f32	s16, s0
 80268ca:	4604      	mov	r4, r0
 80268cc:	f000 f968 	bl	8026ba0 <__errno>
 80268d0:	eeb0 0a48 	vmov.f32	s0, s16
 80268d4:	ecbd 8b02 	vpop	{d8}
 80268d8:	6004      	str	r4, [r0, #0]
 80268da:	bd10      	pop	{r4, pc}
 80268dc:	0000      	movs	r0, r0
	...

080268e0 <xflowf>:
 80268e0:	b130      	cbz	r0, 80268f0 <xflowf+0x10>
 80268e2:	eef1 7a40 	vneg.f32	s15, s0
 80268e6:	ee27 0a80 	vmul.f32	s0, s15, s0
 80268ea:	2022      	movs	r0, #34	; 0x22
 80268ec:	f7ff bfe8 	b.w	80268c0 <with_errnof>
 80268f0:	eef0 7a40 	vmov.f32	s15, s0
 80268f4:	ee27 0a80 	vmul.f32	s0, s15, s0
 80268f8:	2022      	movs	r0, #34	; 0x22
 80268fa:	f7ff bfe1 	b.w	80268c0 <with_errnof>
 80268fe:	bf00      	nop

08026900 <__math_uflowf>:
 8026900:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8026908 <__math_uflowf+0x8>
 8026904:	f7ff bfec 	b.w	80268e0 <xflowf>
 8026908:	10000000 	.word	0x10000000
 802690c:	00000000 	.word	0x00000000

08026910 <__math_may_uflowf>:
 8026910:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8026918 <__math_may_uflowf+0x8>
 8026914:	f7ff bfe4 	b.w	80268e0 <xflowf>
 8026918:	1a200000 	.word	0x1a200000
 802691c:	00000000 	.word	0x00000000

08026920 <__math_oflowf>:
 8026920:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8026928 <__math_oflowf+0x8>
 8026924:	f7ff bfdc 	b.w	80268e0 <xflowf>
 8026928:	70000000 	.word	0x70000000
 802692c:	00000000 	.word	0x00000000

08026930 <__math_divzerof>:
 8026930:	2800      	cmp	r0, #0
 8026932:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8026936:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802693a:	ed9f 0a05 	vldr	s0, [pc, #20]	; 8026950 <__math_divzerof+0x20>
 802693e:	bf08      	it	eq
 8026940:	eef0 7a47 	vmoveq.f32	s15, s14
 8026944:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8026948:	2022      	movs	r0, #34	; 0x22
 802694a:	f7ff bfb9 	b.w	80268c0 <with_errnof>
 802694e:	bf00      	nop
	...

08026960 <__math_invalidf>:
 8026960:	ee70 7a40 	vsub.f32	s15, s0, s0
 8026964:	eeb4 0a40 	vcmp.f32	s0, s0
 8026968:	ee87 7aa7 	vdiv.f32	s14, s15, s15
 802696c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026970:	eeb0 0a47 	vmov.f32	s0, s14
 8026974:	d602      	bvs.n	802697c <__math_invalidf+0x1c>
 8026976:	2021      	movs	r0, #33	; 0x21
 8026978:	f7ff bfa2 	b.w	80268c0 <with_errnof>
 802697c:	4770      	bx	lr
 802697e:	bf00      	nop

08026980 <matherr>:
 8026980:	2000      	movs	r0, #0
 8026982:	4770      	bx	lr
	...

08026990 <nan>:
 8026990:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8026998 <nan+0x8>
 8026994:	4770      	bx	lr
 8026996:	bf00      	nop
 8026998:	00000000 	.word	0x00000000
 802699c:	7ff80000 	.word	0x7ff80000

080269a0 <atanf>:
 80269a0:	b538      	push	{r3, r4, r5, lr}
 80269a2:	ee10 5a10 	vmov	r5, s0
 80269a6:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 80269aa:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 80269ae:	eef0 7a40 	vmov.f32	s15, s0
 80269b2:	db0b      	blt.n	80269cc <atanf+0x2c>
 80269b4:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 80269b8:	dc58      	bgt.n	8026a6c <atanf+0xcc>
 80269ba:	eddf 7a4f 	vldr	s15, [pc, #316]	; 8026af8 <atanf+0x158>
 80269be:	ed9f 0a4f 	vldr	s0, [pc, #316]	; 8026afc <atanf+0x15c>
 80269c2:	2d00      	cmp	r5, #0
 80269c4:	bfd8      	it	le
 80269c6:	eeb0 0a67 	vmovle.f32	s0, s15
 80269ca:	bd38      	pop	{r3, r4, r5, pc}
 80269cc:	4b4c      	ldr	r3, [pc, #304]	; (8026b00 <atanf+0x160>)
 80269ce:	429c      	cmp	r4, r3
 80269d0:	dc5b      	bgt.n	8026a8a <atanf+0xea>
 80269d2:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 80269d6:	db4c      	blt.n	8026a72 <atanf+0xd2>
 80269d8:	f04f 33ff 	mov.w	r3, #4294967295
 80269dc:	ee67 6aa7 	vmul.f32	s13, s15, s15
 80269e0:	eddf 1a48 	vldr	s3, [pc, #288]	; 8026b04 <atanf+0x164>
 80269e4:	eddf 2a48 	vldr	s5, [pc, #288]	; 8026b08 <atanf+0x168>
 80269e8:	ed9f 2a48 	vldr	s4, [pc, #288]	; 8026b0c <atanf+0x16c>
 80269ec:	ed9f 3a48 	vldr	s6, [pc, #288]	; 8026b10 <atanf+0x170>
 80269f0:	eddf 3a48 	vldr	s7, [pc, #288]	; 8026b14 <atanf+0x174>
 80269f4:	ed9f 4a48 	vldr	s8, [pc, #288]	; 8026b18 <atanf+0x178>
 80269f8:	eddf 4a48 	vldr	s9, [pc, #288]	; 8026b1c <atanf+0x17c>
 80269fc:	ed9f 5a48 	vldr	s10, [pc, #288]	; 8026b20 <atanf+0x180>
 8026a00:	eddf 5a48 	vldr	s11, [pc, #288]	; 8026b24 <atanf+0x184>
 8026a04:	ed9f 0a48 	vldr	s0, [pc, #288]	; 8026b28 <atanf+0x188>
 8026a08:	ed9f 6a48 	vldr	s12, [pc, #288]	; 8026b2c <atanf+0x18c>
 8026a0c:	ee26 7aa6 	vmul.f32	s14, s13, s13
 8026a10:	1c5a      	adds	r2, r3, #1
 8026a12:	eee7 2a21 	vfma.f32	s5, s14, s3
 8026a16:	eea7 3a02 	vfma.f32	s6, s14, s4
 8026a1a:	eee2 3a87 	vfma.f32	s7, s5, s14
 8026a1e:	eea3 4a07 	vfma.f32	s8, s6, s14
 8026a22:	eee3 4a87 	vfma.f32	s9, s7, s14
 8026a26:	eea4 5a07 	vfma.f32	s10, s8, s14
 8026a2a:	eee4 5a87 	vfma.f32	s11, s9, s14
 8026a2e:	eea5 0a07 	vfma.f32	s0, s10, s14
 8026a32:	eea5 6a87 	vfma.f32	s12, s11, s14
 8026a36:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026a3a:	eea6 0a26 	vfma.f32	s0, s12, s13
 8026a3e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8026a42:	d037      	beq.n	8026ab4 <atanf+0x114>
 8026a44:	493a      	ldr	r1, [pc, #232]	; (8026b30 <atanf+0x190>)
 8026a46:	4a3b      	ldr	r2, [pc, #236]	; (8026b34 <atanf+0x194>)
 8026a48:	009b      	lsls	r3, r3, #2
 8026a4a:	4419      	add	r1, r3
 8026a4c:	ed91 7a00 	vldr	s14, [r1]
 8026a50:	ee30 0a47 	vsub.f32	s0, s0, s14
 8026a54:	4413      	add	r3, r2
 8026a56:	ee30 0a67 	vsub.f32	s0, s0, s15
 8026a5a:	edd3 7a00 	vldr	s15, [r3]
 8026a5e:	2d00      	cmp	r5, #0
 8026a60:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8026a64:	dab1      	bge.n	80269ca <atanf+0x2a>
 8026a66:	eeb1 0a40 	vneg.f32	s0, s0
 8026a6a:	bd38      	pop	{r3, r4, r5, pc}
 8026a6c:	ee30 0a00 	vadd.f32	s0, s0, s0
 8026a70:	bd38      	pop	{r3, r4, r5, pc}
 8026a72:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8026b38 <atanf+0x198>
 8026a76:	ee30 7a07 	vadd.f32	s14, s0, s14
 8026a7a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8026a7e:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8026a82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026a86:	dda7      	ble.n	80269d8 <atanf+0x38>
 8026a88:	bd38      	pop	{r3, r4, r5, pc}
 8026a8a:	f000 f871 	bl	8026b70 <fabsf>
 8026a8e:	4b2b      	ldr	r3, [pc, #172]	; (8026b3c <atanf+0x19c>)
 8026a90:	429c      	cmp	r4, r3
 8026a92:	dc12      	bgt.n	8026aba <atanf+0x11a>
 8026a94:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 8026a98:	429c      	cmp	r4, r3
 8026a9a:	dc23      	bgt.n	8026ae4 <atanf+0x144>
 8026a9c:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8026aa0:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8026aa4:	eea0 7a27 	vfma.f32	s14, s0, s15
 8026aa8:	2300      	movs	r3, #0
 8026aaa:	ee30 0a27 	vadd.f32	s0, s0, s15
 8026aae:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8026ab2:	e793      	b.n	80269dc <atanf+0x3c>
 8026ab4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8026ab8:	bd38      	pop	{r3, r4, r5, pc}
 8026aba:	4b21      	ldr	r3, [pc, #132]	; (8026b40 <atanf+0x1a0>)
 8026abc:	429c      	cmp	r4, r3
 8026abe:	dc0b      	bgt.n	8026ad8 <atanf+0x138>
 8026ac0:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 8026ac4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8026ac8:	eea0 7a27 	vfma.f32	s14, s0, s15
 8026acc:	2302      	movs	r3, #2
 8026ace:	ee30 0a67 	vsub.f32	s0, s0, s15
 8026ad2:	eec0 7a07 	vdiv.f32	s15, s0, s14
 8026ad6:	e781      	b.n	80269dc <atanf+0x3c>
 8026ad8:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8026adc:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8026ae0:	2303      	movs	r3, #3
 8026ae2:	e77b      	b.n	80269dc <atanf+0x3c>
 8026ae4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8026ae8:	ee30 7a67 	vsub.f32	s14, s0, s15
 8026aec:	ee30 0a27 	vadd.f32	s0, s0, s15
 8026af0:	2301      	movs	r3, #1
 8026af2:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8026af6:	e771      	b.n	80269dc <atanf+0x3c>
 8026af8:	bfc90fdb 	.word	0xbfc90fdb
 8026afc:	3fc90fdb 	.word	0x3fc90fdb
 8026b00:	3edfffff 	.word	0x3edfffff
 8026b04:	3c8569d7 	.word	0x3c8569d7
 8026b08:	3d4bda59 	.word	0x3d4bda59
 8026b0c:	bd15a221 	.word	0xbd15a221
 8026b10:	bd6ef16b 	.word	0xbd6ef16b
 8026b14:	3d886b35 	.word	0x3d886b35
 8026b18:	bd9d8795 	.word	0xbd9d8795
 8026b1c:	3dba2e6e 	.word	0x3dba2e6e
 8026b20:	bde38e38 	.word	0xbde38e38
 8026b24:	3e124925 	.word	0x3e124925
 8026b28:	be4ccccd 	.word	0xbe4ccccd
 8026b2c:	3eaaaaab 	.word	0x3eaaaaab
 8026b30:	0802fea0 	.word	0x0802fea0
 8026b34:	0802fe90 	.word	0x0802fe90
 8026b38:	7149f2ca 	.word	0x7149f2ca
 8026b3c:	3f97ffff 	.word	0x3f97ffff
 8026b40:	401bffff 	.word	0x401bffff
	...

08026b50 <copysignf>:
 8026b50:	ee10 3a10 	vmov	r3, s0
 8026b54:	ee10 2a90 	vmov	r2, s1
 8026b58:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026b5c:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8026b60:	4313      	orrs	r3, r2
 8026b62:	ee00 3a10 	vmov	s0, r3
 8026b66:	4770      	bx	lr
	...

08026b70 <fabsf>:
 8026b70:	ee10 3a10 	vmov	r3, s0
 8026b74:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8026b78:	ee00 3a10 	vmov	s0, r3
 8026b7c:	4770      	bx	lr
 8026b7e:	bf00      	nop

08026b80 <finitef>:
 8026b80:	ee10 3a10 	vmov	r3, s0
 8026b84:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8026b88:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8026b8c:	bfac      	ite	ge
 8026b8e:	2000      	movge	r0, #0
 8026b90:	2001      	movlt	r0, #1
 8026b92:	4770      	bx	lr
	...

08026ba0 <__errno>:
 8026ba0:	4b01      	ldr	r3, [pc, #4]	; (8026ba8 <__errno+0x8>)
 8026ba2:	6818      	ldr	r0, [r3, #0]
 8026ba4:	4770      	bx	lr
 8026ba6:	bf00      	nop
 8026ba8:	20001098 	.word	0x20001098
 8026bac:	00000000 	.word	0x00000000

08026bb0 <memcmp>:
 8026bb0:	2a03      	cmp	r2, #3
 8026bb2:	b470      	push	{r4, r5, r6}
 8026bb4:	d914      	bls.n	8026be0 <memcmp+0x30>
 8026bb6:	ea40 0501 	orr.w	r5, r0, r1
 8026bba:	07ad      	lsls	r5, r5, #30
 8026bbc:	4604      	mov	r4, r0
 8026bbe:	460b      	mov	r3, r1
 8026bc0:	d122      	bne.n	8026c08 <memcmp+0x58>
 8026bc2:	681d      	ldr	r5, [r3, #0]
 8026bc4:	6826      	ldr	r6, [r4, #0]
 8026bc6:	42ae      	cmp	r6, r5
 8026bc8:	4619      	mov	r1, r3
 8026bca:	4620      	mov	r0, r4
 8026bcc:	f103 0304 	add.w	r3, r3, #4
 8026bd0:	f104 0404 	add.w	r4, r4, #4
 8026bd4:	d118      	bne.n	8026c08 <memcmp+0x58>
 8026bd6:	3a04      	subs	r2, #4
 8026bd8:	2a03      	cmp	r2, #3
 8026bda:	4620      	mov	r0, r4
 8026bdc:	4619      	mov	r1, r3
 8026bde:	d8f0      	bhi.n	8026bc2 <memcmp+0x12>
 8026be0:	1e54      	subs	r4, r2, #1
 8026be2:	b172      	cbz	r2, 8026c02 <memcmp+0x52>
 8026be4:	7802      	ldrb	r2, [r0, #0]
 8026be6:	780b      	ldrb	r3, [r1, #0]
 8026be8:	429a      	cmp	r2, r3
 8026bea:	bf08      	it	eq
 8026bec:	1864      	addeq	r4, r4, r1
 8026bee:	d006      	beq.n	8026bfe <memcmp+0x4e>
 8026bf0:	e00c      	b.n	8026c0c <memcmp+0x5c>
 8026bf2:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8026bf6:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8026bfa:	429a      	cmp	r2, r3
 8026bfc:	d106      	bne.n	8026c0c <memcmp+0x5c>
 8026bfe:	42a1      	cmp	r1, r4
 8026c00:	d1f7      	bne.n	8026bf2 <memcmp+0x42>
 8026c02:	2000      	movs	r0, #0
 8026c04:	bc70      	pop	{r4, r5, r6}
 8026c06:	4770      	bx	lr
 8026c08:	1e54      	subs	r4, r2, #1
 8026c0a:	e7eb      	b.n	8026be4 <memcmp+0x34>
 8026c0c:	1ad0      	subs	r0, r2, r3
 8026c0e:	bc70      	pop	{r4, r5, r6}
 8026c10:	4770      	bx	lr
 8026c12:	bf00      	nop
	...

08026c20 <memset>:
 8026c20:	b4f0      	push	{r4, r5, r6, r7}
 8026c22:	0786      	lsls	r6, r0, #30
 8026c24:	d043      	beq.n	8026cae <memset+0x8e>
 8026c26:	1e54      	subs	r4, r2, #1
 8026c28:	2a00      	cmp	r2, #0
 8026c2a:	d03e      	beq.n	8026caa <memset+0x8a>
 8026c2c:	b2ca      	uxtb	r2, r1
 8026c2e:	4603      	mov	r3, r0
 8026c30:	e002      	b.n	8026c38 <memset+0x18>
 8026c32:	f114 34ff 	adds.w	r4, r4, #4294967295
 8026c36:	d338      	bcc.n	8026caa <memset+0x8a>
 8026c38:	f803 2b01 	strb.w	r2, [r3], #1
 8026c3c:	079d      	lsls	r5, r3, #30
 8026c3e:	d1f8      	bne.n	8026c32 <memset+0x12>
 8026c40:	2c03      	cmp	r4, #3
 8026c42:	d92b      	bls.n	8026c9c <memset+0x7c>
 8026c44:	b2cd      	uxtb	r5, r1
 8026c46:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8026c4a:	2c0f      	cmp	r4, #15
 8026c4c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8026c50:	d916      	bls.n	8026c80 <memset+0x60>
 8026c52:	f1a4 0710 	sub.w	r7, r4, #16
 8026c56:	093f      	lsrs	r7, r7, #4
 8026c58:	f103 0620 	add.w	r6, r3, #32
 8026c5c:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8026c60:	f103 0210 	add.w	r2, r3, #16
 8026c64:	e942 5504 	strd	r5, r5, [r2, #-16]
 8026c68:	e942 5502 	strd	r5, r5, [r2, #-8]
 8026c6c:	3210      	adds	r2, #16
 8026c6e:	42b2      	cmp	r2, r6
 8026c70:	d1f8      	bne.n	8026c64 <memset+0x44>
 8026c72:	f004 040f 	and.w	r4, r4, #15
 8026c76:	3701      	adds	r7, #1
 8026c78:	2c03      	cmp	r4, #3
 8026c7a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 8026c7e:	d90d      	bls.n	8026c9c <memset+0x7c>
 8026c80:	461e      	mov	r6, r3
 8026c82:	4622      	mov	r2, r4
 8026c84:	3a04      	subs	r2, #4
 8026c86:	2a03      	cmp	r2, #3
 8026c88:	f846 5b04 	str.w	r5, [r6], #4
 8026c8c:	d8fa      	bhi.n	8026c84 <memset+0x64>
 8026c8e:	1f22      	subs	r2, r4, #4
 8026c90:	f022 0203 	bic.w	r2, r2, #3
 8026c94:	3204      	adds	r2, #4
 8026c96:	4413      	add	r3, r2
 8026c98:	f004 0403 	and.w	r4, r4, #3
 8026c9c:	b12c      	cbz	r4, 8026caa <memset+0x8a>
 8026c9e:	b2c9      	uxtb	r1, r1
 8026ca0:	441c      	add	r4, r3
 8026ca2:	f803 1b01 	strb.w	r1, [r3], #1
 8026ca6:	429c      	cmp	r4, r3
 8026ca8:	d1fb      	bne.n	8026ca2 <memset+0x82>
 8026caa:	bcf0      	pop	{r4, r5, r6, r7}
 8026cac:	4770      	bx	lr
 8026cae:	4614      	mov	r4, r2
 8026cb0:	4603      	mov	r3, r0
 8026cb2:	e7c5      	b.n	8026c40 <memset+0x20>
	...

08026cc0 <sscanf>:
 8026cc0:	b40e      	push	{r1, r2, r3}
 8026cc2:	b570      	push	{r4, r5, r6, lr}
 8026cc4:	b09d      	sub	sp, #116	; 0x74
 8026cc6:	ac21      	add	r4, sp, #132	; 0x84
 8026cc8:	f44f 7201 	mov.w	r2, #516	; 0x204
 8026ccc:	f854 5b04 	ldr.w	r5, [r4], #4
 8026cd0:	f8ad 2014 	strh.w	r2, [sp, #20]
 8026cd4:	9002      	str	r0, [sp, #8]
 8026cd6:	9006      	str	r0, [sp, #24]
 8026cd8:	f7e6 f932 	bl	800cf40 <strlen>
 8026cdc:	4b0c      	ldr	r3, [pc, #48]	; (8026d10 <sscanf+0x50>)
 8026cde:	9401      	str	r4, [sp, #4]
 8026ce0:	4601      	mov	r1, r0
 8026ce2:	462a      	mov	r2, r5
 8026ce4:	9103      	str	r1, [sp, #12]
 8026ce6:	9107      	str	r1, [sp, #28]
 8026ce8:	4e0a      	ldr	r6, [pc, #40]	; (8026d14 <sscanf+0x54>)
 8026cea:	6818      	ldr	r0, [r3, #0]
 8026cec:	960a      	str	r6, [sp, #40]	; 0x28
 8026cee:	4623      	mov	r3, r4
 8026cf0:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8026cf4:	2400      	movs	r4, #0
 8026cf6:	a902      	add	r1, sp, #8
 8026cf8:	940e      	str	r4, [sp, #56]	; 0x38
 8026cfa:	9413      	str	r4, [sp, #76]	; 0x4c
 8026cfc:	f8ad 5016 	strh.w	r5, [sp, #22]
 8026d00:	f000 f856 	bl	8026db0 <__ssvfscanf_r>
 8026d04:	b01d      	add	sp, #116	; 0x74
 8026d06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8026d0a:	b003      	add	sp, #12
 8026d0c:	4770      	bx	lr
 8026d0e:	bf00      	nop
 8026d10:	20001098 	.word	0x20001098
 8026d14:	08026d21 	.word	0x08026d21
	...

08026d20 <__seofread>:
 8026d20:	2000      	movs	r0, #0
 8026d22:	4770      	bx	lr
	...

08026d30 <strtok>:
 8026d30:	4b02      	ldr	r3, [pc, #8]	; (8026d3c <strtok+0xc>)
 8026d32:	681a      	ldr	r2, [r3, #0]
 8026d34:	2301      	movs	r3, #1
 8026d36:	325c      	adds	r2, #92	; 0x5c
 8026d38:	f000 b802 	b.w	8026d40 <__strtok_r>
 8026d3c:	20001098 	.word	0x20001098

08026d40 <__strtok_r>:
 8026d40:	b4f0      	push	{r4, r5, r6, r7}
 8026d42:	b320      	cbz	r0, 8026d8e <__strtok_r+0x4e>
 8026d44:	4607      	mov	r7, r0
 8026d46:	460d      	mov	r5, r1
 8026d48:	f817 6b01 	ldrb.w	r6, [r7], #1
 8026d4c:	e001      	b.n	8026d52 <__strtok_r+0x12>
 8026d4e:	42a6      	cmp	r6, r4
 8026d50:	d016      	beq.n	8026d80 <__strtok_r+0x40>
 8026d52:	f815 4b01 	ldrb.w	r4, [r5], #1
 8026d56:	2c00      	cmp	r4, #0
 8026d58:	d1f9      	bne.n	8026d4e <__strtok_r+0xe>
 8026d5a:	b1ee      	cbz	r6, 8026d98 <__strtok_r+0x58>
 8026d5c:	463e      	mov	r6, r7
 8026d5e:	460c      	mov	r4, r1
 8026d60:	f816 5b01 	ldrb.w	r5, [r6], #1
 8026d64:	e000      	b.n	8026d68 <__strtok_r+0x28>
 8026d66:	b173      	cbz	r3, 8026d86 <__strtok_r+0x46>
 8026d68:	f814 3b01 	ldrb.w	r3, [r4], #1
 8026d6c:	429d      	cmp	r5, r3
 8026d6e:	d1fa      	bne.n	8026d66 <__strtok_r+0x26>
 8026d70:	b15d      	cbz	r5, 8026d8a <__strtok_r+0x4a>
 8026d72:	2300      	movs	r3, #0
 8026d74:	703b      	strb	r3, [r7, #0]
 8026d76:	6016      	str	r6, [r2, #0]
 8026d78:	4606      	mov	r6, r0
 8026d7a:	4630      	mov	r0, r6
 8026d7c:	bcf0      	pop	{r4, r5, r6, r7}
 8026d7e:	4770      	bx	lr
 8026d80:	b163      	cbz	r3, 8026d9c <__strtok_r+0x5c>
 8026d82:	4638      	mov	r0, r7
 8026d84:	e7de      	b.n	8026d44 <__strtok_r+0x4>
 8026d86:	4637      	mov	r7, r6
 8026d88:	e7e8      	b.n	8026d5c <__strtok_r+0x1c>
 8026d8a:	462e      	mov	r6, r5
 8026d8c:	e7f3      	b.n	8026d76 <__strtok_r+0x36>
 8026d8e:	6810      	ldr	r0, [r2, #0]
 8026d90:	2800      	cmp	r0, #0
 8026d92:	d1d7      	bne.n	8026d44 <__strtok_r+0x4>
 8026d94:	4606      	mov	r6, r0
 8026d96:	e7f0      	b.n	8026d7a <__strtok_r+0x3a>
 8026d98:	6016      	str	r6, [r2, #0]
 8026d9a:	e7ee      	b.n	8026d7a <__strtok_r+0x3a>
 8026d9c:	6017      	str	r7, [r2, #0]
 8026d9e:	4606      	mov	r6, r0
 8026da0:	7003      	strb	r3, [r0, #0]
 8026da2:	e7ea      	b.n	8026d7a <__strtok_r+0x3a>
	...

08026db0 <__ssvfscanf_r>:
 8026db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026db4:	ed2d 8b02 	vpush	{d8}
 8026db8:	468a      	mov	sl, r1
 8026dba:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
 8026dbe:	f5ad 7d2b 	sub.w	sp, sp, #684	; 0x2ac
 8026dc2:	048e      	lsls	r6, r1, #18
 8026dc4:	9002      	str	r0, [sp, #8]
 8026dc6:	4693      	mov	fp, r2
 8026dc8:	9305      	str	r3, [sp, #20]
 8026dca:	d409      	bmi.n	8026de0 <__ssvfscanf_r+0x30>
 8026dcc:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
 8026dd0:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8026dd4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8026dd8:	f8aa 100c 	strh.w	r1, [sl, #12]
 8026ddc:	f8ca 3064 	str.w	r3, [sl, #100]	; 0x64
 8026de0:	2300      	movs	r3, #0
 8026de2:	9306      	str	r3, [sp, #24]
 8026de4:	9304      	str	r3, [sp, #16]
 8026de6:	4699      	mov	r9, r3
 8026de8:	9303      	str	r3, [sp, #12]
 8026dea:	465f      	mov	r7, fp
 8026dec:	f817 3b01 	ldrb.w	r3, [r7], #1
 8026df0:	930f      	str	r3, [sp, #60]	; 0x3c
 8026df2:	2b00      	cmp	r3, #0
 8026df4:	f000 817b 	beq.w	80270ee <__ssvfscanf_r+0x33e>
 8026df8:	f000 ff3a 	bl	8027c70 <__locale_ctype_ptr>
 8026dfc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8026dfe:	4418      	add	r0, r3
 8026e00:	7846      	ldrb	r6, [r0, #1]
 8026e02:	f016 0608 	ands.w	r6, r6, #8
 8026e06:	f040 827f 	bne.w	8027308 <__ssvfscanf_r+0x558>
 8026e0a:	2b25      	cmp	r3, #37	; 0x25
 8026e0c:	f040 829e 	bne.w	802734c <__ssvfscanf_r+0x59c>
 8026e10:	f89b 8001 	ldrb.w	r8, [fp, #1]
 8026e14:	4635      	mov	r5, r6
 8026e16:	4634      	mov	r4, r6
 8026e18:	f107 0b01 	add.w	fp, r7, #1
 8026e1c:	f1b8 0f78 	cmp.w	r8, #120	; 0x78
 8026e20:	d87a      	bhi.n	8026f18 <__ssvfscanf_r+0x168>
 8026e22:	e8df f018 	tbh	[pc, r8, lsl #1]
 8026e26:	033f      	.short	0x033f
 8026e28:	00790079 	.word	0x00790079
 8026e2c:	00790079 	.word	0x00790079
 8026e30:	00790079 	.word	0x00790079
 8026e34:	00790079 	.word	0x00790079
 8026e38:	00790079 	.word	0x00790079
 8026e3c:	00790079 	.word	0x00790079
 8026e40:	00790079 	.word	0x00790079
 8026e44:	00790079 	.word	0x00790079
 8026e48:	00790079 	.word	0x00790079
 8026e4c:	00790079 	.word	0x00790079
 8026e50:	00790079 	.word	0x00790079
 8026e54:	00790079 	.word	0x00790079
 8026e58:	00790079 	.word	0x00790079
 8026e5c:	00790079 	.word	0x00790079
 8026e60:	00790079 	.word	0x00790079
 8026e64:	00790079 	.word	0x00790079
 8026e68:	00790079 	.word	0x00790079
 8026e6c:	00790079 	.word	0x00790079
 8026e70:	00790292 	.word	0x00790292
 8026e74:	00790079 	.word	0x00790079
 8026e78:	03910079 	.word	0x03910079
 8026e7c:	00790079 	.word	0x00790079
 8026e80:	00790079 	.word	0x00790079
 8026e84:	03880079 	.word	0x03880079
 8026e88:	03880388 	.word	0x03880388
 8026e8c:	03880388 	.word	0x03880388
 8026e90:	03880388 	.word	0x03880388
 8026e94:	03880388 	.word	0x03880388
 8026e98:	00790388 	.word	0x00790388
 8026e9c:	00790079 	.word	0x00790079
 8026ea0:	00790079 	.word	0x00790079
 8026ea4:	00790079 	.word	0x00790079
 8026ea8:	00790079 	.word	0x00790079
 8026eac:	00810079 	.word	0x00810079
 8026eb0:	00790386 	.word	0x00790386
 8026eb4:	00790386 	.word	0x00790386
 8026eb8:	00790079 	.word	0x00790079
 8026ebc:	03a30079 	.word	0x03a30079
 8026ec0:	00790079 	.word	0x00790079
 8026ec4:	0079024a 	.word	0x0079024a
 8026ec8:	00790079 	.word	0x00790079
 8026ecc:	00790079 	.word	0x00790079
 8026ed0:	00790079 	.word	0x00790079
 8026ed4:	03a00079 	.word	0x03a00079
 8026ed8:	00790079 	.word	0x00790079
 8026edc:	00790397 	.word	0x00790397
 8026ee0:	00790079 	.word	0x00790079
 8026ee4:	00790079 	.word	0x00790079
 8026ee8:	00790079 	.word	0x00790079
 8026eec:	0083035f 	.word	0x0083035f
 8026ef0:	03860386 	.word	0x03860386
 8026ef4:	03590386 	.word	0x03590386
 8026ef8:	00790349 	.word	0x00790349
 8026efc:	034f0079 	.word	0x034f0079
 8026f00:	03790079 	.word	0x03790079
 8026f04:	036b024c 	.word	0x036b024c
 8026f08:	00790079 	.word	0x00790079
 8026f0c:	00790369 	.word	0x00790369
 8026f10:	00790363 	.word	0x00790363
 8026f14:	03a00079 	.word	0x03a00079
 8026f18:	f000 feaa 	bl	8027c70 <__locale_ctype_ptr>
 8026f1c:	4440      	add	r0, r8
 8026f1e:	7843      	ldrb	r3, [r0, #1]
 8026f20:	f003 0303 	and.w	r3, r3, #3
 8026f24:	2b01      	cmp	r3, #1
 8026f26:	d101      	bne.n	8026f2c <__ssvfscanf_r+0x17c>
 8026f28:	f045 0501 	orr.w	r5, r5, #1
 8026f2c:	4ba3      	ldr	r3, [pc, #652]	; (80271bc <__ssvfscanf_r+0x40c>)
 8026f2e:	9306      	str	r3, [sp, #24]
 8026f30:	230a      	movs	r3, #10
 8026f32:	9304      	str	r3, [sp, #16]
 8026f34:	2703      	movs	r7, #3
 8026f36:	f8da 3004 	ldr.w	r3, [sl, #4]
 8026f3a:	2b00      	cmp	r3, #0
 8026f3c:	f340 81ca 	ble.w	80272d4 <__ssvfscanf_r+0x524>
 8026f40:	066b      	lsls	r3, r5, #25
 8026f42:	d510      	bpl.n	8026f66 <__ssvfscanf_r+0x1b6>
 8026f44:	3f01      	subs	r7, #1
 8026f46:	2f03      	cmp	r7, #3
 8026f48:	f200 80d8 	bhi.w	80270fc <__ssvfscanf_r+0x34c>
 8026f4c:	e8df f017 	tbh	[pc, r7, lsl #1]
 8026f50:	008f00fc 	.word	0x008f00fc
 8026f54:	02170021 	.word	0x02170021
 8026f58:	4651      	mov	r1, sl
 8026f5a:	9802      	ldr	r0, [sp, #8]
 8026f5c:	f002 fab8 	bl	80294d0 <__ssrefill_r>
 8026f60:	2800      	cmp	r0, #0
 8026f62:	f040 81be 	bne.w	80272e2 <__ssvfscanf_r+0x532>
 8026f66:	f000 fe83 	bl	8027c70 <__locale_ctype_ptr>
 8026f6a:	f8da 3000 	ldr.w	r3, [sl]
 8026f6e:	781a      	ldrb	r2, [r3, #0]
 8026f70:	4410      	add	r0, r2
 8026f72:	3301      	adds	r3, #1
 8026f74:	7842      	ldrb	r2, [r0, #1]
 8026f76:	0710      	lsls	r0, r2, #28
 8026f78:	d5e4      	bpl.n	8026f44 <__ssvfscanf_r+0x194>
 8026f7a:	f8da 2004 	ldr.w	r2, [sl, #4]
 8026f7e:	3a01      	subs	r2, #1
 8026f80:	2a00      	cmp	r2, #0
 8026f82:	f109 0901 	add.w	r9, r9, #1
 8026f86:	f8ca 2004 	str.w	r2, [sl, #4]
 8026f8a:	dde5      	ble.n	8026f58 <__ssvfscanf_r+0x1a8>
 8026f8c:	f8ca 3000 	str.w	r3, [sl]
 8026f90:	e7e9      	b.n	8026f66 <__ssvfscanf_r+0x1b6>
 8026f92:	1e63      	subs	r3, r4, #1
 8026f94:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
 8026f98:	bf86      	itte	hi
 8026f9a:	f46f 72ae 	mvnhi.w	r2, #348	; 0x15c
 8026f9e:	eb04 0802 	addhi.w	r8, r4, r2
 8026fa2:	f04f 0800 	movls.w	r8, #0
 8026fa6:	ae52      	add	r6, sp, #328	; 0x148
 8026fa8:	f8cd 8020 	str.w	r8, [sp, #32]
 8026fac:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8026fb0:	9607      	str	r6, [sp, #28]
 8026fb2:	bf88      	it	hi
 8026fb4:	f240 145d 	movwhi	r4, #349	; 0x15d
 8026fb8:	f445 6558 	orr.w	r5, r5, #3456	; 0xd80
 8026fbc:	2700      	movs	r7, #0
 8026fbe:	f8da 1000 	ldr.w	r1, [sl]
 8026fc2:	7808      	ldrb	r0, [r1, #0]
 8026fc4:	f1a0 032b 	sub.w	r3, r0, #43	; 0x2b
 8026fc8:	2b4d      	cmp	r3, #77	; 0x4d
 8026fca:	f200 8114 	bhi.w	80271f6 <__ssvfscanf_r+0x446>
 8026fce:	e8df f013 	tbh	[pc, r3, lsl #1]
 8026fd2:	0168      	.short	0x0168
 8026fd4:	01680112 	.word	0x01680112
 8026fd8:	01120112 	.word	0x01120112
 8026fdc:	013f0145 	.word	0x013f0145
 8026fe0:	013f013f 	.word	0x013f013f
 8026fe4:	013f013f 	.word	0x013f013f
 8026fe8:	013f013f 	.word	0x013f013f
 8026fec:	016d016d 	.word	0x016d016d
 8026ff0:	01120112 	.word	0x01120112
 8026ff4:	01120112 	.word	0x01120112
 8026ff8:	01120112 	.word	0x01120112
 8026ffc:	01390112 	.word	0x01390112
 8027000:	01390139 	.word	0x01390139
 8027004:	01390139 	.word	0x01390139
 8027008:	01120139 	.word	0x01120139
 802700c:	01120112 	.word	0x01120112
 8027010:	01120112 	.word	0x01120112
 8027014:	01120112 	.word	0x01120112
 8027018:	01120112 	.word	0x01120112
 802701c:	01120112 	.word	0x01120112
 8027020:	01120112 	.word	0x01120112
 8027024:	01120112 	.word	0x01120112
 8027028:	01120112 	.word	0x01120112
 802702c:	011200f7 	.word	0x011200f7
 8027030:	01120112 	.word	0x01120112
 8027034:	01120112 	.word	0x01120112
 8027038:	01120112 	.word	0x01120112
 802703c:	01390112 	.word	0x01390112
 8027040:	01390139 	.word	0x01390139
 8027044:	01390139 	.word	0x01390139
 8027048:	01120139 	.word	0x01120139
 802704c:	01120112 	.word	0x01120112
 8027050:	01120112 	.word	0x01120112
 8027054:	01120112 	.word	0x01120112
 8027058:	01120112 	.word	0x01120112
 802705c:	01120112 	.word	0x01120112
 8027060:	01120112 	.word	0x01120112
 8027064:	01120112 	.word	0x01120112
 8027068:	01120112 	.word	0x01120112
 802706c:	00f7      	.short	0x00f7
 802706e:	2c00      	cmp	r4, #0
 8027070:	bf08      	it	eq
 8027072:	f04f 34ff 	moveq.w	r4, #4294967295
 8027076:	f005 0610 	and.w	r6, r5, #16
 802707a:	f015 0501 	ands.w	r5, r5, #1
 802707e:	f040 83ae 	bne.w	80277de <__ssvfscanf_r+0xa2e>
 8027082:	2e00      	cmp	r6, #0
 8027084:	f040 81f5 	bne.w	8027472 <__ssvfscanf_r+0x6c2>
 8027088:	9b05      	ldr	r3, [sp, #20]
 802708a:	681f      	ldr	r7, [r3, #0]
 802708c:	1d1d      	adds	r5, r3, #4
 802708e:	463e      	mov	r6, r7
 8027090:	f000 fdee 	bl	8027c70 <__locale_ctype_ptr>
 8027094:	f8da 2000 	ldr.w	r2, [sl]
 8027098:	7813      	ldrb	r3, [r2, #0]
 802709a:	4418      	add	r0, r3
 802709c:	1c51      	adds	r1, r2, #1
 802709e:	7843      	ldrb	r3, [r0, #1]
 80270a0:	0718      	lsls	r0, r3, #28
 80270a2:	d415      	bmi.n	80270d0 <__ssvfscanf_r+0x320>
 80270a4:	f8da 3004 	ldr.w	r3, [sl, #4]
 80270a8:	f8ca 1000 	str.w	r1, [sl]
 80270ac:	3b01      	subs	r3, #1
 80270ae:	f8ca 3004 	str.w	r3, [sl, #4]
 80270b2:	7813      	ldrb	r3, [r2, #0]
 80270b4:	f806 3b01 	strb.w	r3, [r6], #1
 80270b8:	3c01      	subs	r4, #1
 80270ba:	d009      	beq.n	80270d0 <__ssvfscanf_r+0x320>
 80270bc:	f8da 3004 	ldr.w	r3, [sl, #4]
 80270c0:	2b00      	cmp	r3, #0
 80270c2:	dce5      	bgt.n	8027090 <__ssvfscanf_r+0x2e0>
 80270c4:	4651      	mov	r1, sl
 80270c6:	9802      	ldr	r0, [sp, #8]
 80270c8:	f002 fa02 	bl	80294d0 <__ssrefill_r>
 80270cc:	2800      	cmp	r0, #0
 80270ce:	d0df      	beq.n	8027090 <__ssvfscanf_r+0x2e0>
 80270d0:	1bf7      	subs	r7, r6, r7
 80270d2:	2300      	movs	r3, #0
 80270d4:	44b9      	add	r9, r7
 80270d6:	465f      	mov	r7, fp
 80270d8:	9a03      	ldr	r2, [sp, #12]
 80270da:	7033      	strb	r3, [r6, #0]
 80270dc:	f817 3b01 	ldrb.w	r3, [r7], #1
 80270e0:	9505      	str	r5, [sp, #20]
 80270e2:	3201      	adds	r2, #1
 80270e4:	9203      	str	r2, [sp, #12]
 80270e6:	930f      	str	r3, [sp, #60]	; 0x3c
 80270e8:	2b00      	cmp	r3, #0
 80270ea:	f47f ae85 	bne.w	8026df8 <__ssvfscanf_r+0x48>
 80270ee:	9803      	ldr	r0, [sp, #12]
 80270f0:	f50d 7d2b 	add.w	sp, sp, #684	; 0x2ac
 80270f4:	ecbd 8b02 	vpop	{d8}
 80270f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80270fc:	2c00      	cmp	r4, #0
 80270fe:	bf08      	it	eq
 8027100:	2401      	moveq	r4, #1
 8027102:	f005 0710 	and.w	r7, r5, #16
 8027106:	f015 0501 	ands.w	r5, r5, #1
 802710a:	f040 8444 	bne.w	8027996 <__ssvfscanf_r+0xbe6>
 802710e:	2f00      	cmp	r7, #0
 8027110:	f000 8351 	beq.w	80277b6 <__ssvfscanf_r+0xa06>
 8027114:	9f02      	ldr	r7, [sp, #8]
 8027116:	e008      	b.n	802712a <__ssvfscanf_r+0x37a>
 8027118:	f8ca 6000 	str.w	r6, [sl]
 802711c:	441d      	add	r5, r3
 802711e:	1ae4      	subs	r4, r4, r3
 8027120:	f002 f9d6 	bl	80294d0 <__ssrefill_r>
 8027124:	2800      	cmp	r0, #0
 8027126:	f040 8497 	bne.w	8027a58 <__ssvfscanf_r+0xca8>
 802712a:	e9da 2300 	ldrd	r2, r3, [sl]
 802712e:	429c      	cmp	r4, r3
 8027130:	4651      	mov	r1, sl
 8027132:	4638      	mov	r0, r7
 8027134:	eb02 0603 	add.w	r6, r2, r3
 8027138:	dcee      	bgt.n	8027118 <__ssvfscanf_r+0x368>
 802713a:	1b1b      	subs	r3, r3, r4
 802713c:	4422      	add	r2, r4
 802713e:	e9ca 2300 	strd	r2, r3, [sl]
 8027142:	4425      	add	r5, r4
 8027144:	44a9      	add	r9, r5
 8027146:	e650      	b.n	8026dea <__ssvfscanf_r+0x3a>
 8027148:	2c00      	cmp	r4, #0
 802714a:	bf08      	it	eq
 802714c:	f04f 34ff 	moveq.w	r4, #4294967295
 8027150:	06ea      	lsls	r2, r5, #27
 8027152:	f8da 3000 	ldr.w	r3, [sl]
 8027156:	f100 82eb 	bmi.w	8027730 <__ssvfscanf_r+0x980>
 802715a:	9a05      	ldr	r2, [sp, #20]
 802715c:	6815      	ldr	r5, [r2, #0]
 802715e:	1d16      	adds	r6, r2, #4
 8027160:	462f      	mov	r7, r5
 8027162:	f10d 0848 	add.w	r8, sp, #72	; 0x48
 8027166:	e001      	b.n	802716c <__ssvfscanf_r+0x3bc>
 8027168:	f8da 3000 	ldr.w	r3, [sl]
 802716c:	781a      	ldrb	r2, [r3, #0]
 802716e:	f818 2002 	ldrb.w	r2, [r8, r2]
 8027172:	1c59      	adds	r1, r3, #1
 8027174:	b1c2      	cbz	r2, 80271a8 <__ssvfscanf_r+0x3f8>
 8027176:	f8da 2004 	ldr.w	r2, [sl, #4]
 802717a:	f8ca 1000 	str.w	r1, [sl]
 802717e:	3a01      	subs	r2, #1
 8027180:	f8ca 2004 	str.w	r2, [sl, #4]
 8027184:	781b      	ldrb	r3, [r3, #0]
 8027186:	f807 3b01 	strb.w	r3, [r7], #1
 802718a:	3c01      	subs	r4, #1
 802718c:	d00c      	beq.n	80271a8 <__ssvfscanf_r+0x3f8>
 802718e:	f8da 3004 	ldr.w	r3, [sl, #4]
 8027192:	2b00      	cmp	r3, #0
 8027194:	dce8      	bgt.n	8027168 <__ssvfscanf_r+0x3b8>
 8027196:	4651      	mov	r1, sl
 8027198:	9802      	ldr	r0, [sp, #8]
 802719a:	f002 f999 	bl	80294d0 <__ssrefill_r>
 802719e:	2800      	cmp	r0, #0
 80271a0:	d0e2      	beq.n	8027168 <__ssvfscanf_r+0x3b8>
 80271a2:	42bd      	cmp	r5, r7
 80271a4:	f000 809d 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 80271a8:	1b7d      	subs	r5, r7, r5
 80271aa:	d0a0      	beq.n	80270ee <__ssvfscanf_r+0x33e>
 80271ac:	9a03      	ldr	r2, [sp, #12]
 80271ae:	9605      	str	r6, [sp, #20]
 80271b0:	2300      	movs	r3, #0
 80271b2:	3201      	adds	r2, #1
 80271b4:	9203      	str	r2, [sp, #12]
 80271b6:	703b      	strb	r3, [r7, #0]
 80271b8:	44a9      	add	r9, r5
 80271ba:	e616      	b.n	8026dea <__ssvfscanf_r+0x3a>
 80271bc:	08028ed1 	.word	0x08028ed1
 80271c0:	f405 63c0 	and.w	r3, r5, #1536	; 0x600
 80271c4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80271c8:	d115      	bne.n	80271f6 <__ssvfscanf_r+0x446>
 80271ca:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 80271ce:	f445 65a0 	orr.w	r5, r5, #1280	; 0x500
 80271d2:	f04f 0810 	mov.w	r8, #16
 80271d6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80271da:	7030      	strb	r0, [r6, #0]
 80271dc:	3b01      	subs	r3, #1
 80271de:	2b00      	cmp	r3, #0
 80271e0:	f106 0601 	add.w	r6, r6, #1
 80271e4:	f8ca 3004 	str.w	r3, [sl, #4]
 80271e8:	dd54      	ble.n	8027294 <__ssvfscanf_r+0x4e4>
 80271ea:	3101      	adds	r1, #1
 80271ec:	f8ca 1000 	str.w	r1, [sl]
 80271f0:	3c01      	subs	r4, #1
 80271f2:	f47f aee4 	bne.w	8026fbe <__ssvfscanf_r+0x20e>
 80271f6:	05e9      	lsls	r1, r5, #23
 80271f8:	f8cd 8010 	str.w	r8, [sp, #16]
 80271fc:	d507      	bpl.n	802720e <__ssvfscanf_r+0x45e>
 80271fe:	9b07      	ldr	r3, [sp, #28]
 8027200:	429e      	cmp	r6, r3
 8027202:	f200 843f 	bhi.w	8027a84 <__ssvfscanf_r+0xcd4>
 8027206:	9b07      	ldr	r3, [sp, #28]
 8027208:	429e      	cmp	r6, r3
 802720a:	f43f af70 	beq.w	80270ee <__ssvfscanf_r+0x33e>
 802720e:	f015 0410 	ands.w	r4, r5, #16
 8027212:	d112      	bne.n	802723a <__ssvfscanf_r+0x48a>
 8027214:	4622      	mov	r2, r4
 8027216:	9b04      	ldr	r3, [sp, #16]
 8027218:	7034      	strb	r4, [r6, #0]
 802721a:	9907      	ldr	r1, [sp, #28]
 802721c:	9c06      	ldr	r4, [sp, #24]
 802721e:	9802      	ldr	r0, [sp, #8]
 8027220:	47a0      	blx	r4
 8027222:	9b05      	ldr	r3, [sp, #20]
 8027224:	06aa      	lsls	r2, r5, #26
 8027226:	f103 0404 	add.w	r4, r3, #4
 802722a:	f140 82ab 	bpl.w	8027784 <__ssvfscanf_r+0x9d4>
 802722e:	681b      	ldr	r3, [r3, #0]
 8027230:	6018      	str	r0, [r3, #0]
 8027232:	9b03      	ldr	r3, [sp, #12]
 8027234:	9405      	str	r4, [sp, #20]
 8027236:	3301      	adds	r3, #1
 8027238:	9303      	str	r3, [sp, #12]
 802723a:	9b07      	ldr	r3, [sp, #28]
 802723c:	1af6      	subs	r6, r6, r3
 802723e:	4437      	add	r7, r6
 8027240:	44b9      	add	r9, r7
 8027242:	e5d2      	b.n	8026dea <__ssvfscanf_r+0x3a>
 8027244:	f1b8 0f0a 	cmp.w	r8, #10
 8027248:	ddd5      	ble.n	80271f6 <__ssvfscanf_r+0x446>
 802724a:	f425 6538 	bic.w	r5, r5, #2944	; 0xb80
 802724e:	e7c2      	b.n	80271d6 <__ssvfscanf_r+0x426>
 8027250:	4bae      	ldr	r3, [pc, #696]	; (802750c <__ssvfscanf_r+0x75c>)
 8027252:	f425 6538 	bic.w	r5, r5, #2944	; 0xb80
 8027256:	f933 8018 	ldrsh.w	r8, [r3, r8, lsl #1]
 802725a:	e7bc      	b.n	80271d6 <__ssvfscanf_r+0x426>
 802725c:	052b      	lsls	r3, r5, #20
 802725e:	d5ba      	bpl.n	80271d6 <__ssvfscanf_r+0x426>
 8027260:	f1b8 0f00 	cmp.w	r8, #0
 8027264:	d103      	bne.n	802726e <__ssvfscanf_r+0x4be>
 8027266:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 802726a:	f04f 0808 	mov.w	r8, #8
 802726e:	056a      	lsls	r2, r5, #21
 8027270:	f100 834a 	bmi.w	8027908 <__ssvfscanf_r+0xb58>
 8027274:	9b08      	ldr	r3, [sp, #32]
 8027276:	f425 7560 	bic.w	r5, r5, #896	; 0x380
 802727a:	b113      	cbz	r3, 8027282 <__ssvfscanf_r+0x4d2>
 802727c:	3b01      	subs	r3, #1
 802727e:	9308      	str	r3, [sp, #32]
 8027280:	3401      	adds	r4, #1
 8027282:	f8da 3004 	ldr.w	r3, [sl, #4]
 8027286:	3b01      	subs	r3, #1
 8027288:	2b00      	cmp	r3, #0
 802728a:	f107 0701 	add.w	r7, r7, #1
 802728e:	f8ca 3004 	str.w	r3, [sl, #4]
 8027292:	dcaa      	bgt.n	80271ea <__ssvfscanf_r+0x43a>
 8027294:	4651      	mov	r1, sl
 8027296:	9802      	ldr	r0, [sp, #8]
 8027298:	f002 f91a 	bl	80294d0 <__ssrefill_r>
 802729c:	2800      	cmp	r0, #0
 802729e:	d0a7      	beq.n	80271f0 <__ssvfscanf_r+0x440>
 80272a0:	e7a9      	b.n	80271f6 <__ssvfscanf_r+0x446>
 80272a2:	062b      	lsls	r3, r5, #24
 80272a4:	d5a7      	bpl.n	80271f6 <__ssvfscanf_r+0x446>
 80272a6:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 80272aa:	e794      	b.n	80271d6 <__ssvfscanf_r+0x426>
 80272ac:	4b97      	ldr	r3, [pc, #604]	; (802750c <__ssvfscanf_r+0x75c>)
 80272ae:	f933 8018 	ldrsh.w	r8, [r3, r8, lsl #1]
 80272b2:	f1b8 0f08 	cmp.w	r8, #8
 80272b6:	dcc8      	bgt.n	802724a <__ssvfscanf_r+0x49a>
 80272b8:	e79d      	b.n	80271f6 <__ssvfscanf_r+0x446>
 80272ba:	f045 0501 	orr.w	r5, r5, #1
 80272be:	4b94      	ldr	r3, [pc, #592]	; (8027510 <__ssvfscanf_r+0x760>)
 80272c0:	9306      	str	r3, [sp, #24]
 80272c2:	2308      	movs	r3, #8
 80272c4:	9304      	str	r3, [sp, #16]
 80272c6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80272ca:	2b00      	cmp	r3, #0
 80272cc:	f04f 0703 	mov.w	r7, #3
 80272d0:	f73f ae36 	bgt.w	8026f40 <__ssvfscanf_r+0x190>
 80272d4:	4651      	mov	r1, sl
 80272d6:	9802      	ldr	r0, [sp, #8]
 80272d8:	f002 f8fa 	bl	80294d0 <__ssrefill_r>
 80272dc:	2800      	cmp	r0, #0
 80272de:	f43f ae2f 	beq.w	8026f40 <__ssvfscanf_r+0x190>
 80272e2:	9a03      	ldr	r2, [sp, #12]
 80272e4:	2a00      	cmp	r2, #0
 80272e6:	f000 80dd 	beq.w	80274a4 <__ssvfscanf_r+0x6f4>
 80272ea:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 80272ee:	f013 0f40 	tst.w	r3, #64	; 0x40
 80272f2:	bf18      	it	ne
 80272f4:	f04f 32ff 	movne.w	r2, #4294967295
 80272f8:	9203      	str	r2, [sp, #12]
 80272fa:	9803      	ldr	r0, [sp, #12]
 80272fc:	f50d 7d2b 	add.w	sp, sp, #684	; 0x2ac
 8027300:	ecbd 8b02 	vpop	{d8}
 8027304:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027308:	f8da 2004 	ldr.w	r2, [sl, #4]
 802730c:	9c02      	ldr	r4, [sp, #8]
 802730e:	e012      	b.n	8027336 <__ssvfscanf_r+0x586>
 8027310:	f000 fcae 	bl	8027c70 <__locale_ctype_ptr>
 8027314:	f8da 3000 	ldr.w	r3, [sl]
 8027318:	781a      	ldrb	r2, [r3, #0]
 802731a:	4410      	add	r0, r2
 802731c:	3301      	adds	r3, #1
 802731e:	7842      	ldrb	r2, [r0, #1]
 8027320:	0715      	lsls	r5, r2, #28
 8027322:	d510      	bpl.n	8027346 <__ssvfscanf_r+0x596>
 8027324:	f8da 2004 	ldr.w	r2, [sl, #4]
 8027328:	f8ca 3000 	str.w	r3, [sl]
 802732c:	3a01      	subs	r2, #1
 802732e:	f109 0901 	add.w	r9, r9, #1
 8027332:	f8ca 2004 	str.w	r2, [sl, #4]
 8027336:	2a00      	cmp	r2, #0
 8027338:	dcea      	bgt.n	8027310 <__ssvfscanf_r+0x560>
 802733a:	4651      	mov	r1, sl
 802733c:	4620      	mov	r0, r4
 802733e:	f002 f8c7 	bl	80294d0 <__ssrefill_r>
 8027342:	2800      	cmp	r0, #0
 8027344:	d0e4      	beq.n	8027310 <__ssvfscanf_r+0x560>
 8027346:	46bb      	mov	fp, r7
 8027348:	e54f      	b.n	8026dea <__ssvfscanf_r+0x3a>
 802734a:	465f      	mov	r7, fp
 802734c:	f8da 3004 	ldr.w	r3, [sl, #4]
 8027350:	2b00      	cmp	r3, #0
 8027352:	f340 82ab 	ble.w	80278ac <__ssvfscanf_r+0xafc>
 8027356:	f8da 3000 	ldr.w	r3, [sl]
 802735a:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 802735e:	7819      	ldrb	r1, [r3, #0]
 8027360:	4291      	cmp	r1, r2
 8027362:	f47f aec4 	bne.w	80270ee <__ssvfscanf_r+0x33e>
 8027366:	f8da 2004 	ldr.w	r2, [sl, #4]
 802736a:	3301      	adds	r3, #1
 802736c:	3a01      	subs	r2, #1
 802736e:	f8ca 3000 	str.w	r3, [sl]
 8027372:	f109 0901 	add.w	r9, r9, #1
 8027376:	46bb      	mov	fp, r7
 8027378:	f8ca 2004 	str.w	r2, [sl, #4]
 802737c:	e535      	b.n	8026dea <__ssvfscanf_r+0x3a>
 802737e:	9802      	ldr	r0, [sp, #8]
 8027380:	f000 fc8e 	bl	8027ca0 <_localeconv_r>
 8027384:	1e63      	subs	r3, r4, #1
 8027386:	6802      	ldr	r2, [r0, #0]
 8027388:	9209      	str	r2, [sp, #36]	; 0x24
 802738a:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
 802738e:	f200 81c8 	bhi.w	8027722 <__ssvfscanf_r+0x972>
 8027392:	2300      	movs	r3, #0
 8027394:	930b      	str	r3, [sp, #44]	; 0x2c
 8027396:	2300      	movs	r3, #0
 8027398:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 802739c:	aa52      	add	r2, sp, #328	; 0x148
 802739e:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 80273a2:	9207      	str	r2, [sp, #28]
 80273a4:	f445 65f0 	orr.w	r5, r5, #1920	; 0x780
 80273a8:	461f      	mov	r7, r3
 80273aa:	9308      	str	r3, [sp, #32]
 80273ac:	4690      	mov	r8, r2
 80273ae:	469b      	mov	fp, r3
 80273b0:	f8da 0000 	ldr.w	r0, [sl]
 80273b4:	7801      	ldrb	r1, [r0, #0]
 80273b6:	f1a1 0c2b 	sub.w	ip, r1, #43	; 0x2b
 80273ba:	f1bc 0f4e 	cmp.w	ip, #78	; 0x4e
 80273be:	f200 81a3 	bhi.w	8027708 <__ssvfscanf_r+0x958>
 80273c2:	e8df f01c 	tbh	[pc, ip, lsl #1]
 80273c6:	0106      	.short	0x0106
 80273c8:	010601a1 	.word	0x010601a1
 80273cc:	01a101a1 	.word	0x01a101a1
 80273d0:	00d900fa 	.word	0x00d900fa
 80273d4:	00d900d9 	.word	0x00d900d9
 80273d8:	00d900d9 	.word	0x00d900d9
 80273dc:	00d900d9 	.word	0x00d900d9
 80273e0:	00d900d9 	.word	0x00d900d9
 80273e4:	01a101a1 	.word	0x01a101a1
 80273e8:	01a101a1 	.word	0x01a101a1
 80273ec:	01a101a1 	.word	0x01a101a1
 80273f0:	019a01a1 	.word	0x019a01a1
 80273f4:	01a101a1 	.word	0x01a101a1
 80273f8:	018401a1 	.word	0x018401a1
 80273fc:	01a1017f 	.word	0x01a1017f
 8027400:	012501a1 	.word	0x012501a1
 8027404:	01a101a1 	.word	0x01a101a1
 8027408:	01a101a1 	.word	0x01a101a1
 802740c:	01a10113 	.word	0x01a10113
 8027410:	01a101a1 	.word	0x01a101a1
 8027414:	01a101a1 	.word	0x01a101a1
 8027418:	01a1010f 	.word	0x01a1010f
 802741c:	01a101a1 	.word	0x01a101a1
 8027420:	010b01a1 	.word	0x010b01a1
 8027424:	01a101a1 	.word	0x01a101a1
 8027428:	01a101a1 	.word	0x01a101a1
 802742c:	01a101a1 	.word	0x01a101a1
 8027430:	019a01a1 	.word	0x019a01a1
 8027434:	01a101a1 	.word	0x01a101a1
 8027438:	018401a1 	.word	0x018401a1
 802743c:	01a1017f 	.word	0x01a1017f
 8027440:	012501a1 	.word	0x012501a1
 8027444:	01a101a1 	.word	0x01a101a1
 8027448:	01a101a1 	.word	0x01a101a1
 802744c:	01a10113 	.word	0x01a10113
 8027450:	01a101a1 	.word	0x01a101a1
 8027454:	01a101a1 	.word	0x01a101a1
 8027458:	01a1010f 	.word	0x01a1010f
 802745c:	01a101a1 	.word	0x01a101a1
 8027460:	010b01a1 	.word	0x010b01a1
 8027464:	4651      	mov	r1, sl
 8027466:	9802      	ldr	r0, [sp, #8]
 8027468:	f002 f832 	bl	80294d0 <__ssrefill_r>
 802746c:	2800      	cmp	r0, #0
 802746e:	f47f ae69 	bne.w	8027144 <__ssvfscanf_r+0x394>
 8027472:	f000 fbfd 	bl	8027c70 <__locale_ctype_ptr>
 8027476:	f8da 3000 	ldr.w	r3, [sl]
 802747a:	781a      	ldrb	r2, [r3, #0]
 802747c:	4410      	add	r0, r2
 802747e:	3301      	adds	r3, #1
 8027480:	7842      	ldrb	r2, [r0, #1]
 8027482:	0716      	lsls	r6, r2, #28
 8027484:	f53f ae5e 	bmi.w	8027144 <__ssvfscanf_r+0x394>
 8027488:	f8da 2004 	ldr.w	r2, [sl, #4]
 802748c:	f8ca 3000 	str.w	r3, [sl]
 8027490:	3501      	adds	r5, #1
 8027492:	3a01      	subs	r2, #1
 8027494:	42ac      	cmp	r4, r5
 8027496:	f8ca 2004 	str.w	r2, [sl, #4]
 802749a:	f43f ae53 	beq.w	8027144 <__ssvfscanf_r+0x394>
 802749e:	2a00      	cmp	r2, #0
 80274a0:	dce7      	bgt.n	8027472 <__ssvfscanf_r+0x6c2>
 80274a2:	e7df      	b.n	8027464 <__ssvfscanf_r+0x6b4>
 80274a4:	f04f 33ff 	mov.w	r3, #4294967295
 80274a8:	9303      	str	r3, [sp, #12]
 80274aa:	9803      	ldr	r0, [sp, #12]
 80274ac:	f50d 7d2b 	add.w	sp, sp, #684	; 0x2ac
 80274b0:	ecbd 8b02 	vpop	{d8}
 80274b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80274b8:	4b16      	ldr	r3, [pc, #88]	; (8027514 <__ssvfscanf_r+0x764>)
 80274ba:	9306      	str	r3, [sp, #24]
 80274bc:	2300      	movs	r3, #0
 80274be:	9304      	str	r3, [sp, #16]
 80274c0:	2703      	movs	r7, #3
 80274c2:	e538      	b.n	8026f36 <__ssvfscanf_r+0x186>
 80274c4:	f897 8001 	ldrb.w	r8, [r7, #1]
 80274c8:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
 80274cc:	f000 82d3 	beq.w	8027a76 <__ssvfscanf_r+0xcc6>
 80274d0:	f045 0501 	orr.w	r5, r5, #1
 80274d4:	465f      	mov	r7, fp
 80274d6:	e49f      	b.n	8026e18 <__ssvfscanf_r+0x68>
 80274d8:	f897 8001 	ldrb.w	r8, [r7, #1]
 80274dc:	f045 0504 	orr.w	r5, r5, #4
 80274e0:	465f      	mov	r7, fp
 80274e2:	e499      	b.n	8026e18 <__ssvfscanf_r+0x68>
 80274e4:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 80274e8:	2700      	movs	r7, #0
 80274ea:	e524      	b.n	8026f36 <__ssvfscanf_r+0x186>
 80274ec:	4b08      	ldr	r3, [pc, #32]	; (8027510 <__ssvfscanf_r+0x760>)
 80274ee:	9306      	str	r3, [sp, #24]
 80274f0:	230a      	movs	r3, #10
 80274f2:	9304      	str	r3, [sp, #16]
 80274f4:	2703      	movs	r7, #3
 80274f6:	e51e      	b.n	8026f36 <__ssvfscanf_r+0x186>
 80274f8:	2702      	movs	r7, #2
 80274fa:	e51c      	b.n	8026f36 <__ssvfscanf_r+0x186>
 80274fc:	f445 7508 	orr.w	r5, r5, #544	; 0x220
 8027500:	4b03      	ldr	r3, [pc, #12]	; (8027510 <__ssvfscanf_r+0x760>)
 8027502:	9306      	str	r3, [sp, #24]
 8027504:	2310      	movs	r3, #16
 8027506:	9304      	str	r3, [sp, #16]
 8027508:	2703      	movs	r7, #3
 802750a:	e514      	b.n	8026f36 <__ssvfscanf_r+0x186>
 802750c:	0802fec0 	.word	0x0802fec0
 8027510:	08029221 	.word	0x08029221
 8027514:	08028ed1 	.word	0x08028ed1
 8027518:	06ec      	lsls	r4, r5, #27
 802751a:	f53f ac66 	bmi.w	8026dea <__ssvfscanf_r+0x3a>
 802751e:	9a05      	ldr	r2, [sp, #20]
 8027520:	0768      	lsls	r0, r5, #29
 8027522:	f852 3b04 	ldr.w	r3, [r2], #4
 8027526:	9205      	str	r2, [sp, #20]
 8027528:	f140 82c0 	bpl.w	8027aac <__ssvfscanf_r+0xcfc>
 802752c:	f8a3 9000 	strh.w	r9, [r3]
 8027530:	e45b      	b.n	8026dea <__ssvfscanf_r+0x3a>
 8027532:	2704      	movs	r7, #4
 8027534:	e4ff      	b.n	8026f36 <__ssvfscanf_r+0x186>
 8027536:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 802753a:	eb08 0444 	add.w	r4, r8, r4, lsl #1
 802753e:	3c30      	subs	r4, #48	; 0x30
 8027540:	f897 8001 	ldrb.w	r8, [r7, #1]
 8027544:	465f      	mov	r7, fp
 8027546:	e467      	b.n	8026e18 <__ssvfscanf_r+0x68>
 8027548:	f897 8001 	ldrb.w	r8, [r7, #1]
 802754c:	f045 0510 	orr.w	r5, r5, #16
 8027550:	465f      	mov	r7, fp
 8027552:	e461      	b.n	8026e18 <__ssvfscanf_r+0x68>
 8027554:	4659      	mov	r1, fp
 8027556:	a812      	add	r0, sp, #72	; 0x48
 8027558:	f000 fbfa 	bl	8027d50 <__sccl>
 802755c:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 8027560:	4683      	mov	fp, r0
 8027562:	2701      	movs	r7, #1
 8027564:	e4e7      	b.n	8026f36 <__ssvfscanf_r+0x186>
 8027566:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 802756a:	e7c9      	b.n	8027500 <__ssvfscanf_r+0x750>
 802756c:	f897 8001 	ldrb.w	r8, [r7, #1]
 8027570:	f045 0502 	orr.w	r5, r5, #2
 8027574:	465f      	mov	r7, fp
 8027576:	e44f      	b.n	8026e18 <__ssvfscanf_r+0x68>
 8027578:	eb1b 0f06 	cmn.w	fp, r6
 802757c:	d117      	bne.n	80275ae <__ssvfscanf_r+0x7fe>
 802757e:	f425 75c0 	bic.w	r5, r5, #384	; 0x180
 8027582:	f888 1000 	strb.w	r1, [r8]
 8027586:	f108 0801 	add.w	r8, r8, #1
 802758a:	f8da 1004 	ldr.w	r1, [sl, #4]
 802758e:	3901      	subs	r1, #1
 8027590:	2900      	cmp	r1, #0
 8027592:	f104 34ff 	add.w	r4, r4, #4294967295
 8027596:	f109 0901 	add.w	r9, r9, #1
 802759a:	f8ca 1004 	str.w	r1, [sl, #4]
 802759e:	f340 8166 	ble.w	802786e <__ssvfscanf_r+0xabe>
 80275a2:	3001      	adds	r0, #1
 80275a4:	f8ca 0000 	str.w	r0, [sl]
 80275a8:	2c00      	cmp	r4, #0
 80275aa:	f47f af01 	bne.w	80273b0 <__ssvfscanf_r+0x600>
 80275ae:	465b      	mov	r3, fp
 80275b0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80275b4:	2f00      	cmp	r7, #0
 80275b6:	d03a      	beq.n	802762e <__ssvfscanf_r+0x87e>
 80275b8:	e175      	b.n	80278a6 <__ssvfscanf_r+0xaf6>
 80275ba:	05eb      	lsls	r3, r5, #23
 80275bc:	d5dc      	bpl.n	8027578 <__ssvfscanf_r+0x7c8>
 80275be:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80275c0:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 80275c4:	3701      	adds	r7, #1
 80275c6:	2b00      	cmp	r3, #0
 80275c8:	d0df      	beq.n	802758a <__ssvfscanf_r+0x7da>
 80275ca:	3b01      	subs	r3, #1
 80275cc:	930b      	str	r3, [sp, #44]	; 0x2c
 80275ce:	3401      	adds	r4, #1
 80275d0:	e7db      	b.n	802758a <__ssvfscanf_r+0x7da>
 80275d2:	062a      	lsls	r2, r5, #24
 80275d4:	d5eb      	bpl.n	80275ae <__ssvfscanf_r+0x7fe>
 80275d6:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 80275da:	e7d2      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 80275dc:	2e07      	cmp	r6, #7
 80275de:	d1e6      	bne.n	80275ae <__ssvfscanf_r+0x7fe>
 80275e0:	2608      	movs	r6, #8
 80275e2:	e7ce      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 80275e4:	2e06      	cmp	r6, #6
 80275e6:	d1e2      	bne.n	80275ae <__ssvfscanf_r+0x7fe>
 80275e8:	2607      	movs	r6, #7
 80275ea:	e7ca      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 80275ec:	f1bb 0f00 	cmp.w	fp, #0
 80275f0:	f040 8148 	bne.w	8027884 <__ssvfscanf_r+0xad4>
 80275f4:	b92f      	cbnz	r7, 8027602 <__ssvfscanf_r+0x852>
 80275f6:	f405 6ce0 	and.w	ip, r5, #1792	; 0x700
 80275fa:	f5bc 6fe0 	cmp.w	ip, #1792	; 0x700
 80275fe:	f000 8235 	beq.w	8027a6c <__ssvfscanf_r+0xcbc>
 8027602:	2e01      	cmp	r6, #1
 8027604:	d001      	beq.n	802760a <__ssvfscanf_r+0x85a>
 8027606:	2e04      	cmp	r6, #4
 8027608:	d1d1      	bne.n	80275ae <__ssvfscanf_r+0x7fe>
 802760a:	3601      	adds	r6, #1
 802760c:	b2f6      	uxtb	r6, r6
 802760e:	e7b8      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027610:	2e00      	cmp	r6, #0
 8027612:	f040 813e 	bne.w	8027892 <__ssvfscanf_r+0xae2>
 8027616:	2f00      	cmp	r7, #0
 8027618:	f040 8142 	bne.w	80278a0 <__ssvfscanf_r+0xaf0>
 802761c:	f405 6ce0 	and.w	ip, r5, #1792	; 0x700
 8027620:	f5bc 6fe0 	cmp.w	ip, #1792	; 0x700
 8027624:	f000 821e 	beq.w	8027a64 <__ssvfscanf_r+0xcb4>
 8027628:	465b      	mov	r3, fp
 802762a:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 802762e:	3b01      	subs	r3, #1
 8027630:	2b01      	cmp	r3, #1
 8027632:	f240 8270 	bls.w	8027b16 <__ssvfscanf_r+0xd66>
 8027636:	1e73      	subs	r3, r6, #1
 8027638:	2b06      	cmp	r3, #6
 802763a:	f240 813f 	bls.w	80278bc <__ssvfscanf_r+0xb0c>
 802763e:	05e8      	lsls	r0, r5, #23
 8027640:	d513      	bpl.n	802766a <__ssvfscanf_r+0x8ba>
 8027642:	0569      	lsls	r1, r5, #21
 8027644:	f100 8279 	bmi.w	8027b3a <__ssvfscanf_r+0xd8a>
 8027648:	f818 1c01 	ldrb.w	r1, [r8, #-1]
 802764c:	2965      	cmp	r1, #101	; 0x65
 802764e:	f108 34ff 	add.w	r4, r8, #4294967295
 8027652:	f109 36ff 	add.w	r6, r9, #4294967295
 8027656:	d002      	beq.n	802765e <__ssvfscanf_r+0x8ae>
 8027658:	2945      	cmp	r1, #69	; 0x45
 802765a:	f040 815e 	bne.w	802791a <__ssvfscanf_r+0xb6a>
 802765e:	4652      	mov	r2, sl
 8027660:	9802      	ldr	r0, [sp, #8]
 8027662:	f001 fef5 	bl	8029450 <_sungetc_r>
 8027666:	46b1      	mov	r9, r6
 8027668:	46a0      	mov	r8, r4
 802766a:	f015 0210 	ands.w	r2, r5, #16
 802766e:	f47f abbc 	bne.w	8026dea <__ssvfscanf_r+0x3a>
 8027672:	f405 63c0 	and.w	r3, r5, #1536	; 0x600
 8027676:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802767a:	f888 2000 	strb.w	r2, [r8]
 802767e:	f000 820a 	beq.w	8027a96 <__ssvfscanf_r+0xce6>
 8027682:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027684:	2b00      	cmp	r3, #0
 8027686:	f040 8153 	bne.w	8027930 <__ssvfscanf_r+0xb80>
 802768a:	2200      	movs	r2, #0
 802768c:	9907      	ldr	r1, [sp, #28]
 802768e:	9802      	ldr	r0, [sp, #8]
 8027690:	f001 fb76 	bl	8028d80 <_strtod_r>
 8027694:	9b05      	ldr	r3, [sp, #20]
 8027696:	eeb0 8a40 	vmov.f32	s16, s0
 802769a:	eef0 8a60 	vmov.f32	s17, s1
 802769e:	07ea      	lsls	r2, r5, #31
 80276a0:	f103 0404 	add.w	r4, r3, #4
 80276a4:	f100 8128 	bmi.w	80278f8 <__ssvfscanf_r+0xb48>
 80276a8:	9b05      	ldr	r3, [sp, #20]
 80276aa:	f015 0502 	ands.w	r5, r5, #2
 80276ae:	681e      	ldr	r6, [r3, #0]
 80276b0:	f000 820a 	beq.w	8027ac8 <__ssvfscanf_r+0xd18>
 80276b4:	ed86 0b00 	vstr	d0, [r6]
 80276b8:	9b03      	ldr	r3, [sp, #12]
 80276ba:	9405      	str	r4, [sp, #20]
 80276bc:	3301      	adds	r3, #1
 80276be:	9303      	str	r3, [sp, #12]
 80276c0:	f7ff bb93 	b.w	8026dea <__ssvfscanf_r+0x3a>
 80276c4:	2e02      	cmp	r6, #2
 80276c6:	f47f af72 	bne.w	80275ae <__ssvfscanf_r+0x7fe>
 80276ca:	2603      	movs	r6, #3
 80276cc:	e759      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 80276ce:	f405 6ca0 	and.w	ip, r5, #1280	; 0x500
 80276d2:	f5bc 6f80 	cmp.w	ip, #1024	; 0x400
 80276d6:	d004      	beq.n	80276e2 <__ssvfscanf_r+0x932>
 80276d8:	056b      	lsls	r3, r5, #21
 80276da:	f57f af68 	bpl.w	80275ae <__ssvfscanf_r+0x7fe>
 80276de:	2f00      	cmp	r7, #0
 80276e0:	d0a2      	beq.n	8027628 <__ssvfscanf_r+0x878>
 80276e2:	05aa      	lsls	r2, r5, #22
 80276e4:	d403      	bmi.n	80276ee <__ssvfscanf_r+0x93e>
 80276e6:	9b08      	ldr	r3, [sp, #32]
 80276e8:	1afb      	subs	r3, r7, r3
 80276ea:	e9cd 380c 	strd	r3, r8, [sp, #48]	; 0x30
 80276ee:	f425 65f0 	bic.w	r5, r5, #1920	; 0x780
 80276f2:	f445 75c0 	orr.w	r5, r5, #384	; 0x180
 80276f6:	2700      	movs	r7, #0
 80276f8:	e743      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 80276fa:	f1bb 0f01 	cmp.w	fp, #1
 80276fe:	f47f af56 	bne.w	80275ae <__ssvfscanf_r+0x7fe>
 8027702:	f04f 0b02 	mov.w	fp, #2
 8027706:	e73c      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027708:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802770a:	f893 c000 	ldrb.w	ip, [r3]
 802770e:	458c      	cmp	ip, r1
 8027710:	f47f af4d 	bne.w	80275ae <__ssvfscanf_r+0x7fe>
 8027714:	05ab      	lsls	r3, r5, #22
 8027716:	f57f af4a 	bpl.w	80275ae <__ssvfscanf_r+0x7fe>
 802771a:	f425 7520 	bic.w	r5, r5, #640	; 0x280
 802771e:	9708      	str	r7, [sp, #32]
 8027720:	e72f      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027722:	f46f 72ae 	mvn.w	r2, #348	; 0x15c
 8027726:	18a3      	adds	r3, r4, r2
 8027728:	930b      	str	r3, [sp, #44]	; 0x2c
 802772a:	f240 145d 	movw	r4, #349	; 0x15d
 802772e:	e632      	b.n	8027396 <__ssvfscanf_r+0x5e6>
 8027730:	2500      	movs	r5, #0
 8027732:	f10d 0848 	add.w	r8, sp, #72	; 0x48
 8027736:	781a      	ldrb	r2, [r3, #0]
 8027738:	f818 2002 	ldrb.w	r2, [r8, r2]
 802773c:	3301      	adds	r3, #1
 802773e:	b1da      	cbz	r2, 8027778 <__ssvfscanf_r+0x9c8>
 8027740:	f8da 2004 	ldr.w	r2, [sl, #4]
 8027744:	f8ca 3000 	str.w	r3, [sl]
 8027748:	3501      	adds	r5, #1
 802774a:	3a01      	subs	r2, #1
 802774c:	42ac      	cmp	r4, r5
 802774e:	f8ca 2004 	str.w	r2, [sl, #4]
 8027752:	f43f acf7 	beq.w	8027144 <__ssvfscanf_r+0x394>
 8027756:	2a00      	cmp	r2, #0
 8027758:	dced      	bgt.n	8027736 <__ssvfscanf_r+0x986>
 802775a:	4651      	mov	r1, sl
 802775c:	9802      	ldr	r0, [sp, #8]
 802775e:	f001 feb7 	bl	80294d0 <__ssrefill_r>
 8027762:	2800      	cmp	r0, #0
 8027764:	f47f acee 	bne.w	8027144 <__ssvfscanf_r+0x394>
 8027768:	f8da 3000 	ldr.w	r3, [sl]
 802776c:	781a      	ldrb	r2, [r3, #0]
 802776e:	f818 2002 	ldrb.w	r2, [r8, r2]
 8027772:	3301      	adds	r3, #1
 8027774:	2a00      	cmp	r2, #0
 8027776:	d1e3      	bne.n	8027740 <__ssvfscanf_r+0x990>
 8027778:	2d00      	cmp	r5, #0
 802777a:	f43f acb8 	beq.w	80270ee <__ssvfscanf_r+0x33e>
 802777e:	44a9      	add	r9, r5
 8027780:	f7ff bb33 	b.w	8026dea <__ssvfscanf_r+0x3a>
 8027784:	076b      	lsls	r3, r5, #29
 8027786:	f100 80bb 	bmi.w	8027900 <__ssvfscanf_r+0xb50>
 802778a:	f015 0201 	ands.w	r2, r5, #1
 802778e:	f040 80e4 	bne.w	802795a <__ssvfscanf_r+0xbaa>
 8027792:	07a9      	lsls	r1, r5, #30
 8027794:	f140 80e1 	bpl.w	802795a <__ssvfscanf_r+0xbaa>
 8027798:	4bc2      	ldr	r3, [pc, #776]	; (8027aa4 <__ssvfscanf_r+0xcf4>)
 802779a:	9906      	ldr	r1, [sp, #24]
 802779c:	9802      	ldr	r0, [sp, #8]
 802779e:	4299      	cmp	r1, r3
 80277a0:	9b04      	ldr	r3, [sp, #16]
 80277a2:	9907      	ldr	r1, [sp, #28]
 80277a4:	f000 81c6 	beq.w	8027b34 <__ssvfscanf_r+0xd84>
 80277a8:	f001 fc7a 	bl	80290a0 <_strtoll_r>
 80277ac:	9b05      	ldr	r3, [sp, #20]
 80277ae:	681b      	ldr	r3, [r3, #0]
 80277b0:	e9c3 0100 	strd	r0, r1, [r3]
 80277b4:	e53d      	b.n	8027232 <__ssvfscanf_r+0x482>
 80277b6:	9d05      	ldr	r5, [sp, #20]
 80277b8:	9802      	ldr	r0, [sp, #8]
 80277ba:	6829      	ldr	r1, [r5, #0]
 80277bc:	f8cd a000 	str.w	sl, [sp]
 80277c0:	4623      	mov	r3, r4
 80277c2:	2201      	movs	r2, #1
 80277c4:	f001 fea4 	bl	8029510 <_sfread_r>
 80277c8:	1d2b      	adds	r3, r5, #4
 80277ca:	2800      	cmp	r0, #0
 80277cc:	f43f ad89 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 80277d0:	9a03      	ldr	r2, [sp, #12]
 80277d2:	9305      	str	r3, [sp, #20]
 80277d4:	3201      	adds	r2, #1
 80277d6:	4481      	add	r9, r0
 80277d8:	9203      	str	r2, [sp, #12]
 80277da:	f7ff bb06 	b.w	8026dea <__ssvfscanf_r+0x3a>
 80277de:	ab10      	add	r3, sp, #64	; 0x40
 80277e0:	4618      	mov	r0, r3
 80277e2:	2208      	movs	r2, #8
 80277e4:	2100      	movs	r1, #0
 80277e6:	9307      	str	r3, [sp, #28]
 80277e8:	f7ff fa1a 	bl	8026c20 <memset>
 80277ec:	2e00      	cmp	r6, #0
 80277ee:	f000 808e 	beq.w	802790e <__ssvfscanf_r+0xb5e>
 80277f2:	f10d 083c 	add.w	r8, sp, #60	; 0x3c
 80277f6:	2500      	movs	r5, #0
 80277f8:	f000 fa3a 	bl	8027c70 <__locale_ctype_ptr>
 80277fc:	f8da 3000 	ldr.w	r3, [sl]
 8027800:	781b      	ldrb	r3, [r3, #0]
 8027802:	4418      	add	r0, r3
 8027804:	7843      	ldrb	r3, [r0, #1]
 8027806:	071f      	lsls	r7, r3, #28
 8027808:	f100 80bb 	bmi.w	8027982 <__ssvfscanf_r+0xbd2>
 802780c:	2c00      	cmp	r4, #0
 802780e:	f000 80b8 	beq.w	8027982 <__ssvfscanf_r+0xbd2>
 8027812:	f000 fa15 	bl	8027c40 <__locale_mb_cur_max>
 8027816:	42a8      	cmp	r0, r5
 8027818:	f43f ad63 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 802781c:	e9da 2300 	ldrd	r2, r3, [sl]
 8027820:	f812 0b01 	ldrb.w	r0, [r2], #1
 8027824:	f8ca 2000 	str.w	r2, [sl]
 8027828:	9a07      	ldr	r2, [sp, #28]
 802782a:	9200      	str	r2, [sp, #0]
 802782c:	aa52      	add	r2, sp, #328	; 0x148
 802782e:	3b01      	subs	r3, #1
 8027830:	1c6f      	adds	r7, r5, #1
 8027832:	f8ca 3004 	str.w	r3, [sl, #4]
 8027836:	5550      	strb	r0, [r2, r5]
 8027838:	463b      	mov	r3, r7
 802783a:	4641      	mov	r1, r8
 802783c:	9802      	ldr	r0, [sp, #8]
 802783e:	f000 fa3f 	bl	8027cc0 <_mbrtowc_r>
 8027842:	1c43      	adds	r3, r0, #1
 8027844:	f43f ad4d 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 8027848:	2800      	cmp	r0, #0
 802784a:	f040 8088 	bne.w	802795e <__ssvfscanf_r+0xbae>
 802784e:	f8c8 0000 	str.w	r0, [r8]
 8027852:	f000 f9e5 	bl	8027c20 <iswspace>
 8027856:	2800      	cmp	r0, #0
 8027858:	f040 8149 	bne.w	8027aee <__ssvfscanf_r+0xd3e>
 802785c:	44b9      	add	r9, r7
 802785e:	3c01      	subs	r4, #1
 8027860:	2e00      	cmp	r6, #0
 8027862:	f040 8156 	bne.w	8027b12 <__ssvfscanf_r+0xd62>
 8027866:	f108 0804 	add.w	r8, r8, #4
 802786a:	4637      	mov	r7, r6
 802786c:	e07a      	b.n	8027964 <__ssvfscanf_r+0xbb4>
 802786e:	4651      	mov	r1, sl
 8027870:	9802      	ldr	r0, [sp, #8]
 8027872:	f001 fe2d 	bl	80294d0 <__ssrefill_r>
 8027876:	2800      	cmp	r0, #0
 8027878:	f47f ae99 	bne.w	80275ae <__ssvfscanf_r+0x7fe>
 802787c:	2c00      	cmp	r4, #0
 802787e:	f47f ad97 	bne.w	80273b0 <__ssvfscanf_r+0x600>
 8027882:	e694      	b.n	80275ae <__ssvfscanf_r+0x7fe>
 8027884:	f1bb 0f02 	cmp.w	fp, #2
 8027888:	f47f aebb 	bne.w	8027602 <__ssvfscanf_r+0x852>
 802788c:	f04f 0b03 	mov.w	fp, #3
 8027890:	e677      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027892:	2e03      	cmp	r6, #3
 8027894:	f43f aeb9 	beq.w	802760a <__ssvfscanf_r+0x85a>
 8027898:	2e05      	cmp	r6, #5
 802789a:	f43f aeb6 	beq.w	802760a <__ssvfscanf_r+0x85a>
 802789e:	e686      	b.n	80275ae <__ssvfscanf_r+0x7fe>
 80278a0:	465b      	mov	r3, fp
 80278a2:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80278a6:	f425 7580 	bic.w	r5, r5, #256	; 0x100
 80278aa:	e6c0      	b.n	802762e <__ssvfscanf_r+0x87e>
 80278ac:	4651      	mov	r1, sl
 80278ae:	9802      	ldr	r0, [sp, #8]
 80278b0:	f001 fe0e 	bl	80294d0 <__ssrefill_r>
 80278b4:	2800      	cmp	r0, #0
 80278b6:	f43f ad4e 	beq.w	8027356 <__ssvfscanf_r+0x5a6>
 80278ba:	e512      	b.n	80272e2 <__ssvfscanf_r+0x532>
 80278bc:	2e02      	cmp	r6, #2
 80278be:	f240 814b 	bls.w	8027b58 <__ssvfscanf_r+0xda8>
 80278c2:	2e03      	cmp	r6, #3
 80278c4:	f43f aebb 	beq.w	802763e <__ssvfscanf_r+0x88e>
 80278c8:	1f34      	subs	r4, r6, #4
 80278ca:	b2e4      	uxtb	r4, r4
 80278cc:	43e6      	mvns	r6, r4
 80278ce:	4446      	add	r6, r8
 80278d0:	9509      	str	r5, [sp, #36]	; 0x24
 80278d2:	4645      	mov	r5, r8
 80278d4:	46a0      	mov	r8, r4
 80278d6:	9c02      	ldr	r4, [sp, #8]
 80278d8:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
 80278dc:	4652      	mov	r2, sl
 80278de:	4620      	mov	r0, r4
 80278e0:	f001 fdb6 	bl	8029450 <_sungetc_r>
 80278e4:	42b5      	cmp	r5, r6
 80278e6:	d1f7      	bne.n	80278d8 <__ssvfscanf_r+0xb28>
 80278e8:	4644      	mov	r4, r8
 80278ea:	f109 39ff 	add.w	r9, r9, #4294967295
 80278ee:	46a8      	mov	r8, r5
 80278f0:	eba9 0904 	sub.w	r9, r9, r4
 80278f4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80278f6:	e6a2      	b.n	802763e <__ssvfscanf_r+0x88e>
 80278f8:	681b      	ldr	r3, [r3, #0]
 80278fa:	ed83 0b00 	vstr	d0, [r3]
 80278fe:	e6db      	b.n	80276b8 <__ssvfscanf_r+0x908>
 8027900:	9b05      	ldr	r3, [sp, #20]
 8027902:	681b      	ldr	r3, [r3, #0]
 8027904:	8018      	strh	r0, [r3, #0]
 8027906:	e494      	b.n	8027232 <__ssvfscanf_r+0x482>
 8027908:	f425 65b0 	bic.w	r5, r5, #1408	; 0x580
 802790c:	e463      	b.n	80271d6 <__ssvfscanf_r+0x426>
 802790e:	9b05      	ldr	r3, [sp, #20]
 8027910:	f8d3 8000 	ldr.w	r8, [r3]
 8027914:	3304      	adds	r3, #4
 8027916:	9305      	str	r3, [sp, #20]
 8027918:	e76d      	b.n	80277f6 <__ssvfscanf_r+0xa46>
 802791a:	4652      	mov	r2, sl
 802791c:	9802      	ldr	r0, [sp, #8]
 802791e:	f001 fd97 	bl	8029450 <_sungetc_r>
 8027922:	f1a9 0602 	sub.w	r6, r9, #2
 8027926:	f818 1c02 	ldrb.w	r1, [r8, #-2]
 802792a:	f1a8 0402 	sub.w	r4, r8, #2
 802792e:	e696      	b.n	802765e <__ssvfscanf_r+0x8ae>
 8027930:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8027932:	9802      	ldr	r0, [sp, #8]
 8027934:	4621      	mov	r1, r4
 8027936:	230a      	movs	r3, #10
 8027938:	3101      	adds	r1, #1
 802793a:	f001 fac9 	bl	8028ed0 <_strtol_r>
 802793e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027940:	46a0      	mov	r8, r4
 8027942:	1ac2      	subs	r2, r0, r3
 8027944:	f20d 239b 	addw	r3, sp, #667	; 0x29b
 8027948:	4598      	cmp	r8, r3
 802794a:	bf28      	it	cs
 802794c:	f20d 289a 	addwcs	r8, sp, #666	; 0x29a
 8027950:	4640      	mov	r0, r8
 8027952:	4955      	ldr	r1, [pc, #340]	; (8027aa8 <__ssvfscanf_r+0xcf8>)
 8027954:	f000 fa3c 	bl	8027dd0 <sprintf>
 8027958:	e697      	b.n	802768a <__ssvfscanf_r+0x8da>
 802795a:	9b05      	ldr	r3, [sp, #20]
 802795c:	e467      	b.n	802722e <__ssvfscanf_r+0x47e>
 802795e:	3002      	adds	r0, #2
 8027960:	f040 810f 	bne.w	8027b82 <__ssvfscanf_r+0xdd2>
 8027964:	f8da 3004 	ldr.w	r3, [sl, #4]
 8027968:	2b00      	cmp	r3, #0
 802796a:	f300 80be 	bgt.w	8027aea <__ssvfscanf_r+0xd3a>
 802796e:	4651      	mov	r1, sl
 8027970:	9802      	ldr	r0, [sp, #8]
 8027972:	f001 fdad 	bl	80294d0 <__ssrefill_r>
 8027976:	2800      	cmp	r0, #0
 8027978:	f000 80b7 	beq.w	8027aea <__ssvfscanf_r+0xd3a>
 802797c:	2f00      	cmp	r7, #0
 802797e:	f47f acb0 	bne.w	80272e2 <__ssvfscanf_r+0x532>
 8027982:	2e00      	cmp	r6, #0
 8027984:	f47f aa31 	bne.w	8026dea <__ssvfscanf_r+0x3a>
 8027988:	f8c8 6000 	str.w	r6, [r8]
 802798c:	9b03      	ldr	r3, [sp, #12]
 802798e:	3301      	adds	r3, #1
 8027990:	9303      	str	r3, [sp, #12]
 8027992:	f7ff ba2a 	b.w	8026dea <__ssvfscanf_r+0x3a>
 8027996:	ab10      	add	r3, sp, #64	; 0x40
 8027998:	4618      	mov	r0, r3
 802799a:	2208      	movs	r2, #8
 802799c:	2100      	movs	r1, #0
 802799e:	9307      	str	r3, [sp, #28]
 80279a0:	f7ff f93e 	bl	8026c20 <memset>
 80279a4:	2f00      	cmp	r7, #0
 80279a6:	f040 809d 	bne.w	8027ae4 <__ssvfscanf_r+0xd34>
 80279aa:	9b05      	ldr	r3, [sp, #20]
 80279ac:	681a      	ldr	r2, [r3, #0]
 80279ae:	3304      	adds	r3, #4
 80279b0:	9305      	str	r3, [sp, #20]
 80279b2:	9708      	str	r7, [sp, #32]
 80279b4:	9f02      	ldr	r7, [sp, #8]
 80279b6:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 80279ba:	2500      	movs	r5, #0
 80279bc:	f50d 78a4 	add.w	r8, sp, #328	; 0x148
 80279c0:	4693      	mov	fp, r2
 80279c2:	f000 f93d 	bl	8027c40 <__locale_mb_cur_max>
 80279c6:	42a8      	cmp	r0, r5
 80279c8:	f43f ac8b 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 80279cc:	e9da 2300 	ldrd	r2, r3, [sl]
 80279d0:	f812 0b01 	ldrb.w	r0, [r2], #1
 80279d4:	f8ca 2000 	str.w	r2, [sl]
 80279d8:	3b01      	subs	r3, #1
 80279da:	9a07      	ldr	r2, [sp, #28]
 80279dc:	9200      	str	r2, [sp, #0]
 80279de:	1c6e      	adds	r6, r5, #1
 80279e0:	f8ca 3004 	str.w	r3, [sl, #4]
 80279e4:	4659      	mov	r1, fp
 80279e6:	f808 0005 	strb.w	r0, [r8, r5]
 80279ea:	4633      	mov	r3, r6
 80279ec:	4642      	mov	r2, r8
 80279ee:	4638      	mov	r0, r7
 80279f0:	f000 f966 	bl	8027cc0 <_mbrtowc_r>
 80279f4:	1c41      	adds	r1, r0, #1
 80279f6:	f43f ac74 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 80279fa:	bb18      	cbnz	r0, 8027a44 <__ssvfscanf_r+0xc94>
 80279fc:	9b08      	ldr	r3, [sp, #32]
 80279fe:	44b1      	add	r9, r6
 8027a00:	3c01      	subs	r4, #1
 8027a02:	b91b      	cbnz	r3, 8027a0c <__ssvfscanf_r+0xc5c>
 8027a04:	f8cb 3000 	str.w	r3, [fp]
 8027a08:	f10b 0b04 	add.w	fp, fp, #4
 8027a0c:	2500      	movs	r5, #0
 8027a0e:	f8da 3004 	ldr.w	r3, [sl, #4]
 8027a12:	2b00      	cmp	r3, #0
 8027a14:	dd07      	ble.n	8027a26 <__ssvfscanf_r+0xc76>
 8027a16:	2c00      	cmp	r4, #0
 8027a18:	d1d3      	bne.n	80279c2 <__ssvfscanf_r+0xc12>
 8027a1a:	e9dd 7b08 	ldrd	r7, fp, [sp, #32]
 8027a1e:	2f00      	cmp	r7, #0
 8027a20:	f47f a9e3 	bne.w	8026dea <__ssvfscanf_r+0x3a>
 8027a24:	e7b2      	b.n	802798c <__ssvfscanf_r+0xbdc>
 8027a26:	4651      	mov	r1, sl
 8027a28:	4638      	mov	r0, r7
 8027a2a:	f001 fd51 	bl	80294d0 <__ssrefill_r>
 8027a2e:	2800      	cmp	r0, #0
 8027a30:	d0f1      	beq.n	8027a16 <__ssvfscanf_r+0xc66>
 8027a32:	e9dd 7b08 	ldrd	r7, fp, [sp, #32]
 8027a36:	2d00      	cmp	r5, #0
 8027a38:	f47f ac53 	bne.w	80272e2 <__ssvfscanf_r+0x532>
 8027a3c:	2f00      	cmp	r7, #0
 8027a3e:	f47f a9d4 	bne.w	8026dea <__ssvfscanf_r+0x3a>
 8027a42:	e7a3      	b.n	802798c <__ssvfscanf_r+0xbdc>
 8027a44:	3002      	adds	r0, #2
 8027a46:	d101      	bne.n	8027a4c <__ssvfscanf_r+0xc9c>
 8027a48:	4635      	mov	r5, r6
 8027a4a:	e7e0      	b.n	8027a0e <__ssvfscanf_r+0xc5e>
 8027a4c:	9b08      	ldr	r3, [sp, #32]
 8027a4e:	44b1      	add	r9, r6
 8027a50:	3c01      	subs	r4, #1
 8027a52:	2b00      	cmp	r3, #0
 8027a54:	d0d8      	beq.n	8027a08 <__ssvfscanf_r+0xc58>
 8027a56:	e7d9      	b.n	8027a0c <__ssvfscanf_r+0xc5c>
 8027a58:	2d00      	cmp	r5, #0
 8027a5a:	f43f ac42 	beq.w	80272e2 <__ssvfscanf_r+0x532>
 8027a5e:	44a9      	add	r9, r5
 8027a60:	f7ff b9c3 	b.w	8026dea <__ssvfscanf_r+0x3a>
 8027a64:	f425 65f0 	bic.w	r5, r5, #1920	; 0x780
 8027a68:	2601      	movs	r6, #1
 8027a6a:	e58a      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027a6c:	f425 65f0 	bic.w	r5, r5, #1920	; 0x780
 8027a70:	f04f 0b01 	mov.w	fp, #1
 8027a74:	e585      	b.n	8027582 <__ssvfscanf_r+0x7d2>
 8027a76:	f897 8002 	ldrb.w	r8, [r7, #2]
 8027a7a:	f045 0502 	orr.w	r5, r5, #2
 8027a7e:	3702      	adds	r7, #2
 8027a80:	f7ff b9ca 	b.w	8026e18 <__ssvfscanf_r+0x68>
 8027a84:	f816 1c01 	ldrb.w	r1, [r6, #-1]
 8027a88:	9802      	ldr	r0, [sp, #8]
 8027a8a:	4652      	mov	r2, sl
 8027a8c:	f001 fce0 	bl	8029450 <_sungetc_r>
 8027a90:	3e01      	subs	r6, #1
 8027a92:	f7ff bbb8 	b.w	8027206 <__ssvfscanf_r+0x456>
 8027a96:	9b08      	ldr	r3, [sp, #32]
 8027a98:	1aff      	subs	r7, r7, r3
 8027a9a:	427a      	negs	r2, r7
 8027a9c:	2f00      	cmp	r7, #0
 8027a9e:	f47f af51 	bne.w	8027944 <__ssvfscanf_r+0xb94>
 8027aa2:	e5f2      	b.n	802768a <__ssvfscanf_r+0x8da>
 8027aa4:	08029221 	.word	0x08029221
 8027aa8:	0802feb0 	.word	0x0802feb0
 8027aac:	07e9      	lsls	r1, r5, #31
 8027aae:	d407      	bmi.n	8027ac0 <__ssvfscanf_r+0xd10>
 8027ab0:	07aa      	lsls	r2, r5, #30
 8027ab2:	d505      	bpl.n	8027ac0 <__ssvfscanf_r+0xd10>
 8027ab4:	4648      	mov	r0, r9
 8027ab6:	17c1      	asrs	r1, r0, #31
 8027ab8:	e9c3 0100 	strd	r0, r1, [r3]
 8027abc:	f7ff b995 	b.w	8026dea <__ssvfscanf_r+0x3a>
 8027ac0:	f8c3 9000 	str.w	r9, [r3]
 8027ac4:	f7ff b991 	b.w	8026dea <__ssvfscanf_r+0x3a>
 8027ac8:	ec53 2b10 	vmov	r2, r3, d0
 8027acc:	ec51 0b10 	vmov	r0, r1, d0
 8027ad0:	f7e4 ff96 	bl	800ca00 <__aeabi_dcmpun>
 8027ad4:	2800      	cmp	r0, #0
 8027ad6:	d14e      	bne.n	8027b76 <__ssvfscanf_r+0xdc6>
 8027ad8:	ec51 0b18 	vmov	r0, r1, d8
 8027adc:	f7e4 ffd0 	bl	800ca80 <__aeabi_d2f>
 8027ae0:	6030      	str	r0, [r6, #0]
 8027ae2:	e5e9      	b.n	80276b8 <__ssvfscanf_r+0x908>
 8027ae4:	2300      	movs	r3, #0
 8027ae6:	461a      	mov	r2, r3
 8027ae8:	e763      	b.n	80279b2 <__ssvfscanf_r+0xc02>
 8027aea:	463d      	mov	r5, r7
 8027aec:	e684      	b.n	80277f8 <__ssvfscanf_r+0xa48>
 8027aee:	2f00      	cmp	r7, #0
 8027af0:	f43f af47 	beq.w	8027982 <__ssvfscanf_r+0xbd2>
 8027af4:	1e7d      	subs	r5, r7, #1
 8027af6:	ab52      	add	r3, sp, #328	; 0x148
 8027af8:	9f02      	ldr	r7, [sp, #8]
 8027afa:	441d      	add	r5, r3
 8027afc:	f20d 1447 	addw	r4, sp, #327	; 0x147
 8027b00:	f815 1901 	ldrb.w	r1, [r5], #-1
 8027b04:	4652      	mov	r2, sl
 8027b06:	4638      	mov	r0, r7
 8027b08:	f001 fca2 	bl	8029450 <_sungetc_r>
 8027b0c:	42ac      	cmp	r4, r5
 8027b0e:	d1f7      	bne.n	8027b00 <__ssvfscanf_r+0xd50>
 8027b10:	e737      	b.n	8027982 <__ssvfscanf_r+0xbd2>
 8027b12:	4607      	mov	r7, r0
 8027b14:	e726      	b.n	8027964 <__ssvfscanf_r+0xbb4>
 8027b16:	9d07      	ldr	r5, [sp, #28]
 8027b18:	45a8      	cmp	r8, r5
 8027b1a:	f67f aae8 	bls.w	80270ee <__ssvfscanf_r+0x33e>
 8027b1e:	9c02      	ldr	r4, [sp, #8]
 8027b20:	f818 1d01 	ldrb.w	r1, [r8, #-1]!
 8027b24:	4652      	mov	r2, sl
 8027b26:	4620      	mov	r0, r4
 8027b28:	f001 fc92 	bl	8029450 <_sungetc_r>
 8027b2c:	45a8      	cmp	r8, r5
 8027b2e:	d1f7      	bne.n	8027b20 <__ssvfscanf_r+0xd70>
 8027b30:	f7ff badd 	b.w	80270ee <__ssvfscanf_r+0x33e>
 8027b34:	f001 fc74 	bl	8029420 <_strtoull_r>
 8027b38:	e638      	b.n	80277ac <__ssvfscanf_r+0x9fc>
 8027b3a:	9d07      	ldr	r5, [sp, #28]
 8027b3c:	45a8      	cmp	r8, r5
 8027b3e:	f67f aad6 	bls.w	80270ee <__ssvfscanf_r+0x33e>
 8027b42:	9c02      	ldr	r4, [sp, #8]
 8027b44:	f818 1d01 	ldrb.w	r1, [r8, #-1]!
 8027b48:	4652      	mov	r2, sl
 8027b4a:	4620      	mov	r0, r4
 8027b4c:	f001 fc80 	bl	8029450 <_sungetc_r>
 8027b50:	45a8      	cmp	r8, r5
 8027b52:	d1f7      	bne.n	8027b44 <__ssvfscanf_r+0xd94>
 8027b54:	f7ff bacb 	b.w	80270ee <__ssvfscanf_r+0x33e>
 8027b58:	9b07      	ldr	r3, [sp, #28]
 8027b5a:	4598      	cmp	r8, r3
 8027b5c:	f67f aac7 	bls.w	80270ee <__ssvfscanf_r+0x33e>
 8027b60:	f818 1d01 	ldrb.w	r1, [r8, #-1]!
 8027b64:	9802      	ldr	r0, [sp, #8]
 8027b66:	4652      	mov	r2, sl
 8027b68:	f001 fc72 	bl	8029450 <_sungetc_r>
 8027b6c:	9b07      	ldr	r3, [sp, #28]
 8027b6e:	4598      	cmp	r8, r3
 8027b70:	d1f6      	bne.n	8027b60 <__ssvfscanf_r+0xdb0>
 8027b72:	f7ff babc 	b.w	80270ee <__ssvfscanf_r+0x33e>
 8027b76:	4628      	mov	r0, r5
 8027b78:	f000 f922 	bl	8027dc0 <nanf>
 8027b7c:	ed86 0a00 	vstr	s0, [r6]
 8027b80:	e59a      	b.n	80276b8 <__ssvfscanf_r+0x908>
 8027b82:	f8d8 0000 	ldr.w	r0, [r8]
 8027b86:	e664      	b.n	8027852 <__ssvfscanf_r+0xaa2>
	...

08027b90 <_vsnprintf_r>:
 8027b90:	b570      	push	{r4, r5, r6, lr}
 8027b92:	1e14      	subs	r4, r2, #0
 8027b94:	b09a      	sub	sp, #104	; 0x68
 8027b96:	4605      	mov	r5, r0
 8027b98:	db2c      	blt.n	8027bf4 <_vsnprintf_r+0x64>
 8027b9a:	461a      	mov	r2, r3
 8027b9c:	f44f 7302 	mov.w	r3, #520	; 0x208
 8027ba0:	9100      	str	r1, [sp, #0]
 8027ba2:	9104      	str	r1, [sp, #16]
 8027ba4:	f8ad 300c 	strh.w	r3, [sp, #12]
 8027ba8:	d013      	beq.n	8027bd2 <_vsnprintf_r+0x42>
 8027baa:	3c01      	subs	r4, #1
 8027bac:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8027bb0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8027bb2:	9402      	str	r4, [sp, #8]
 8027bb4:	4669      	mov	r1, sp
 8027bb6:	9405      	str	r4, [sp, #20]
 8027bb8:	f8ad 600e 	strh.w	r6, [sp, #14]
 8027bbc:	f001 fce8 	bl	8029590 <_svfprintf_r>
 8027bc0:	1c42      	adds	r2, r0, #1
 8027bc2:	da01      	bge.n	8027bc8 <_vsnprintf_r+0x38>
 8027bc4:	238b      	movs	r3, #139	; 0x8b
 8027bc6:	602b      	str	r3, [r5, #0]
 8027bc8:	9b00      	ldr	r3, [sp, #0]
 8027bca:	2200      	movs	r2, #0
 8027bcc:	701a      	strb	r2, [r3, #0]
 8027bce:	b01a      	add	sp, #104	; 0x68
 8027bd0:	bd70      	pop	{r4, r5, r6, pc}
 8027bd2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8027bd4:	9402      	str	r4, [sp, #8]
 8027bd6:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8027bda:	4669      	mov	r1, sp
 8027bdc:	9405      	str	r4, [sp, #20]
 8027bde:	f8ad 600e 	strh.w	r6, [sp, #14]
 8027be2:	f001 fcd5 	bl	8029590 <_svfprintf_r>
 8027be6:	1c43      	adds	r3, r0, #1
 8027be8:	db01      	blt.n	8027bee <_vsnprintf_r+0x5e>
 8027bea:	b01a      	add	sp, #104	; 0x68
 8027bec:	bd70      	pop	{r4, r5, r6, pc}
 8027bee:	238b      	movs	r3, #139	; 0x8b
 8027bf0:	602b      	str	r3, [r5, #0]
 8027bf2:	e7fa      	b.n	8027bea <_vsnprintf_r+0x5a>
 8027bf4:	238b      	movs	r3, #139	; 0x8b
 8027bf6:	6003      	str	r3, [r0, #0]
 8027bf8:	f04f 30ff 	mov.w	r0, #4294967295
 8027bfc:	e7f5      	b.n	8027bea <_vsnprintf_r+0x5a>
 8027bfe:	bf00      	nop

08027c00 <vsnprintf>:
 8027c00:	b510      	push	{r4, lr}
 8027c02:	b082      	sub	sp, #8
 8027c04:	4c05      	ldr	r4, [pc, #20]	; (8027c1c <vsnprintf+0x1c>)
 8027c06:	9300      	str	r3, [sp, #0]
 8027c08:	6824      	ldr	r4, [r4, #0]
 8027c0a:	4613      	mov	r3, r2
 8027c0c:	460a      	mov	r2, r1
 8027c0e:	4601      	mov	r1, r0
 8027c10:	4620      	mov	r0, r4
 8027c12:	f7ff ffbd 	bl	8027b90 <_vsnprintf_r>
 8027c16:	b002      	add	sp, #8
 8027c18:	bd10      	pop	{r4, pc}
 8027c1a:	bf00      	nop
 8027c1c:	20001098 	.word	0x20001098

08027c20 <iswspace>:
 8027c20:	28ff      	cmp	r0, #255	; 0xff
 8027c22:	d901      	bls.n	8027c28 <iswspace+0x8>
 8027c24:	2000      	movs	r0, #0
 8027c26:	4770      	bx	lr
 8027c28:	b510      	push	{r4, lr}
 8027c2a:	4604      	mov	r4, r0
 8027c2c:	f000 f820 	bl	8027c70 <__locale_ctype_ptr>
 8027c30:	4420      	add	r0, r4
 8027c32:	7840      	ldrb	r0, [r0, #1]
 8027c34:	f000 0008 	and.w	r0, r0, #8
 8027c38:	bd10      	pop	{r4, pc}
 8027c3a:	bf00      	nop
 8027c3c:	0000      	movs	r0, r0
	...

08027c40 <__locale_mb_cur_max>:
 8027c40:	4b04      	ldr	r3, [pc, #16]	; (8027c54 <__locale_mb_cur_max+0x14>)
 8027c42:	4a05      	ldr	r2, [pc, #20]	; (8027c58 <__locale_mb_cur_max+0x18>)
 8027c44:	681b      	ldr	r3, [r3, #0]
 8027c46:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8027c48:	2b00      	cmp	r3, #0
 8027c4a:	bf08      	it	eq
 8027c4c:	4613      	moveq	r3, r2
 8027c4e:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 8027c52:	4770      	bx	lr
 8027c54:	20001098 	.word	0x20001098
 8027c58:	200014c8 	.word	0x200014c8
 8027c5c:	00000000 	.word	0x00000000

08027c60 <__locale_ctype_ptr_l>:
 8027c60:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8027c64:	4770      	bx	lr
 8027c66:	bf00      	nop
	...

08027c70 <__locale_ctype_ptr>:
 8027c70:	4b04      	ldr	r3, [pc, #16]	; (8027c84 <__locale_ctype_ptr+0x14>)
 8027c72:	4a05      	ldr	r2, [pc, #20]	; (8027c88 <__locale_ctype_ptr+0x18>)
 8027c74:	681b      	ldr	r3, [r3, #0]
 8027c76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8027c78:	2b00      	cmp	r3, #0
 8027c7a:	bf08      	it	eq
 8027c7c:	4613      	moveq	r3, r2
 8027c7e:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 8027c82:	4770      	bx	lr
 8027c84:	20001098 	.word	0x20001098
 8027c88:	200014c8 	.word	0x200014c8
 8027c8c:	00000000 	.word	0x00000000

08027c90 <__localeconv_l>:
 8027c90:	30f0      	adds	r0, #240	; 0xf0
 8027c92:	4770      	bx	lr
	...

08027ca0 <_localeconv_r>:
 8027ca0:	4a04      	ldr	r2, [pc, #16]	; (8027cb4 <_localeconv_r+0x14>)
 8027ca2:	4b05      	ldr	r3, [pc, #20]	; (8027cb8 <_localeconv_r+0x18>)
 8027ca4:	6812      	ldr	r2, [r2, #0]
 8027ca6:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8027ca8:	2800      	cmp	r0, #0
 8027caa:	bf08      	it	eq
 8027cac:	4618      	moveq	r0, r3
 8027cae:	30f0      	adds	r0, #240	; 0xf0
 8027cb0:	4770      	bx	lr
 8027cb2:	bf00      	nop
 8027cb4:	20001098 	.word	0x20001098
 8027cb8:	200014c8 	.word	0x200014c8
 8027cbc:	00000000 	.word	0x00000000

08027cc0 <_mbrtowc_r>:
 8027cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027cc2:	4c13      	ldr	r4, [pc, #76]	; (8027d10 <_mbrtowc_r+0x50>)
 8027cc4:	b083      	sub	sp, #12
 8027cc6:	6824      	ldr	r4, [r4, #0]
 8027cc8:	9d08      	ldr	r5, [sp, #32]
 8027cca:	6b64      	ldr	r4, [r4, #52]	; 0x34
 8027ccc:	4607      	mov	r7, r0
 8027cce:	b15a      	cbz	r2, 8027ce8 <_mbrtowc_r+0x28>
 8027cd0:	4e10      	ldr	r6, [pc, #64]	; (8027d14 <_mbrtowc_r+0x54>)
 8027cd2:	9500      	str	r5, [sp, #0]
 8027cd4:	2c00      	cmp	r4, #0
 8027cd6:	bf08      	it	eq
 8027cd8:	4634      	moveq	r4, r6
 8027cda:	f8d4 40e4 	ldr.w	r4, [r4, #228]	; 0xe4
 8027cde:	47a0      	blx	r4
 8027ce0:	1c43      	adds	r3, r0, #1
 8027ce2:	d00e      	beq.n	8027d02 <_mbrtowc_r+0x42>
 8027ce4:	b003      	add	sp, #12
 8027ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027ce8:	4b0a      	ldr	r3, [pc, #40]	; (8027d14 <_mbrtowc_r+0x54>)
 8027cea:	9500      	str	r5, [sp, #0]
 8027cec:	2c00      	cmp	r4, #0
 8027cee:	bf08      	it	eq
 8027cf0:	461c      	moveq	r4, r3
 8027cf2:	4611      	mov	r1, r2
 8027cf4:	2301      	movs	r3, #1
 8027cf6:	f8d4 40e4 	ldr.w	r4, [r4, #228]	; 0xe4
 8027cfa:	4a07      	ldr	r2, [pc, #28]	; (8027d18 <_mbrtowc_r+0x58>)
 8027cfc:	47a0      	blx	r4
 8027cfe:	1c43      	adds	r3, r0, #1
 8027d00:	d1f0      	bne.n	8027ce4 <_mbrtowc_r+0x24>
 8027d02:	2200      	movs	r2, #0
 8027d04:	238a      	movs	r3, #138	; 0x8a
 8027d06:	602a      	str	r2, [r5, #0]
 8027d08:	603b      	str	r3, [r7, #0]
 8027d0a:	b003      	add	sp, #12
 8027d0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027d0e:	bf00      	nop
 8027d10:	20001098 	.word	0x20001098
 8027d14:	200014c8 	.word	0x200014c8
 8027d18:	0802e8e0 	.word	0x0802e8e0
 8027d1c:	00000000 	.word	0x00000000

08027d20 <__ascii_mbtowc>:
 8027d20:	b082      	sub	sp, #8
 8027d22:	b149      	cbz	r1, 8027d38 <__ascii_mbtowc+0x18>
 8027d24:	b15a      	cbz	r2, 8027d3e <__ascii_mbtowc+0x1e>
 8027d26:	b16b      	cbz	r3, 8027d44 <__ascii_mbtowc+0x24>
 8027d28:	7813      	ldrb	r3, [r2, #0]
 8027d2a:	600b      	str	r3, [r1, #0]
 8027d2c:	7812      	ldrb	r2, [r2, #0]
 8027d2e:	1c10      	adds	r0, r2, #0
 8027d30:	bf18      	it	ne
 8027d32:	2001      	movne	r0, #1
 8027d34:	b002      	add	sp, #8
 8027d36:	4770      	bx	lr
 8027d38:	a901      	add	r1, sp, #4
 8027d3a:	2a00      	cmp	r2, #0
 8027d3c:	d1f3      	bne.n	8027d26 <__ascii_mbtowc+0x6>
 8027d3e:	4610      	mov	r0, r2
 8027d40:	b002      	add	sp, #8
 8027d42:	4770      	bx	lr
 8027d44:	f06f 0001 	mvn.w	r0, #1
 8027d48:	e7f4      	b.n	8027d34 <__ascii_mbtowc+0x14>
 8027d4a:	bf00      	nop
 8027d4c:	0000      	movs	r0, r0
	...

08027d50 <__sccl>:
 8027d50:	b470      	push	{r4, r5, r6}
 8027d52:	780c      	ldrb	r4, [r1, #0]
 8027d54:	2c5e      	cmp	r4, #94	; 0x5e
 8027d56:	4606      	mov	r6, r0
 8027d58:	d01e      	beq.n	8027d98 <__sccl+0x48>
 8027d5a:	2200      	movs	r2, #0
 8027d5c:	1c48      	adds	r0, r1, #1
 8027d5e:	4615      	mov	r5, r2
 8027d60:	1e73      	subs	r3, r6, #1
 8027d62:	f106 01ff 	add.w	r1, r6, #255	; 0xff
 8027d66:	f803 2f01 	strb.w	r2, [r3, #1]!
 8027d6a:	428b      	cmp	r3, r1
 8027d6c:	d1fb      	bne.n	8027d66 <__sccl+0x16>
 8027d6e:	b184      	cbz	r4, 8027d92 <__sccl+0x42>
 8027d70:	f085 0301 	eor.w	r3, r5, #1
 8027d74:	5533      	strb	r3, [r6, r4]
 8027d76:	1c41      	adds	r1, r0, #1
 8027d78:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 8027d7c:	2a2d      	cmp	r2, #45	; 0x2d
 8027d7e:	d010      	beq.n	8027da2 <__sccl+0x52>
 8027d80:	2a5d      	cmp	r2, #93	; 0x5d
 8027d82:	d003      	beq.n	8027d8c <__sccl+0x3c>
 8027d84:	b11a      	cbz	r2, 8027d8e <__sccl+0x3e>
 8027d86:	4614      	mov	r4, r2
 8027d88:	4608      	mov	r0, r1
 8027d8a:	e7f3      	b.n	8027d74 <__sccl+0x24>
 8027d8c:	4608      	mov	r0, r1
 8027d8e:	bc70      	pop	{r4, r5, r6}
 8027d90:	4770      	bx	lr
 8027d92:	3801      	subs	r0, #1
 8027d94:	bc70      	pop	{r4, r5, r6}
 8027d96:	4770      	bx	lr
 8027d98:	2201      	movs	r2, #1
 8027d9a:	784c      	ldrb	r4, [r1, #1]
 8027d9c:	4615      	mov	r5, r2
 8027d9e:	1c88      	adds	r0, r1, #2
 8027da0:	e7de      	b.n	8027d60 <__sccl+0x10>
 8027da2:	7845      	ldrb	r5, [r0, #1]
 8027da4:	2d5d      	cmp	r5, #93	; 0x5d
 8027da6:	d0ee      	beq.n	8027d86 <__sccl+0x36>
 8027da8:	42ac      	cmp	r4, r5
 8027daa:	dcec      	bgt.n	8027d86 <__sccl+0x36>
 8027dac:	3002      	adds	r0, #2
 8027dae:	1932      	adds	r2, r6, r4
 8027db0:	3401      	adds	r4, #1
 8027db2:	42a5      	cmp	r5, r4
 8027db4:	f802 3f01 	strb.w	r3, [r2, #1]!
 8027db8:	dcfa      	bgt.n	8027db0 <__sccl+0x60>
 8027dba:	3102      	adds	r1, #2
 8027dbc:	e7dc      	b.n	8027d78 <__sccl+0x28>
 8027dbe:	bf00      	nop

08027dc0 <nanf>:
 8027dc0:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8027dc8 <nanf+0x8>
 8027dc4:	4770      	bx	lr
 8027dc6:	bf00      	nop
 8027dc8:	7fc00000 	.word	0x7fc00000
 8027dcc:	00000000 	.word	0x00000000

08027dd0 <sprintf>:
 8027dd0:	b40e      	push	{r1, r2, r3}
 8027dd2:	b530      	push	{r4, r5, lr}
 8027dd4:	b09c      	sub	sp, #112	; 0x70
 8027dd6:	ab1f      	add	r3, sp, #124	; 0x7c
 8027dd8:	4c0c      	ldr	r4, [pc, #48]	; (8027e0c <sprintf+0x3c>)
 8027dda:	4d0d      	ldr	r5, [pc, #52]	; (8027e10 <sprintf+0x40>)
 8027ddc:	f853 2b04 	ldr.w	r2, [r3], #4
 8027de0:	9301      	str	r3, [sp, #4]
 8027de2:	4601      	mov	r1, r0
 8027de4:	9102      	str	r1, [sp, #8]
 8027de6:	9106      	str	r1, [sp, #24]
 8027de8:	6820      	ldr	r0, [r4, #0]
 8027dea:	a902      	add	r1, sp, #8
 8027dec:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 8027df0:	9407      	str	r4, [sp, #28]
 8027df2:	e9cd 4504 	strd	r4, r5, [sp, #16]
 8027df6:	f001 fbcb 	bl	8029590 <_svfprintf_r>
 8027dfa:	9b02      	ldr	r3, [sp, #8]
 8027dfc:	2200      	movs	r2, #0
 8027dfe:	701a      	strb	r2, [r3, #0]
 8027e00:	b01c      	add	sp, #112	; 0x70
 8027e02:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8027e06:	b003      	add	sp, #12
 8027e08:	4770      	bx	lr
 8027e0a:	bf00      	nop
 8027e0c:	20001098 	.word	0x20001098
 8027e10:	ffff0208 	.word	0xffff0208
	...

08027e20 <sulp>:
 8027e20:	b570      	push	{r4, r5, r6, lr}
 8027e22:	4604      	mov	r4, r0
 8027e24:	460d      	mov	r5, r1
 8027e26:	ec45 4b10 	vmov	d0, r4, r5
 8027e2a:	4616      	mov	r6, r2
 8027e2c:	f005 f8c8 	bl	802cfc0 <__ulp>
 8027e30:	ec51 0b10 	vmov	r0, r1, d0
 8027e34:	b17e      	cbz	r6, 8027e56 <sulp+0x36>
 8027e36:	f3c5 530a 	ubfx	r3, r5, #20, #11
 8027e3a:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8027e3e:	2b00      	cmp	r3, #0
 8027e40:	dd09      	ble.n	8027e56 <sulp+0x36>
 8027e42:	051b      	lsls	r3, r3, #20
 8027e44:	f103 557f 	add.w	r5, r3, #1069547520	; 0x3fc00000
 8027e48:	2400      	movs	r4, #0
 8027e4a:	f505 1540 	add.w	r5, r5, #3145728	; 0x300000
 8027e4e:	4622      	mov	r2, r4
 8027e50:	462b      	mov	r3, r5
 8027e52:	f7e4 fb35 	bl	800c4c0 <__aeabi_dmul>
 8027e56:	bd70      	pop	{r4, r5, r6, pc}
	...

08027e60 <_strtod_l>:
 8027e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027e64:	b0a5      	sub	sp, #148	; 0x94
 8027e66:	461c      	mov	r4, r3
 8027e68:	9008      	str	r0, [sp, #32]
 8027e6a:	2300      	movs	r3, #0
 8027e6c:	4620      	mov	r0, r4
 8027e6e:	460f      	mov	r7, r1
 8027e70:	9207      	str	r2, [sp, #28]
 8027e72:	9320      	str	r3, [sp, #128]	; 0x80
 8027e74:	f7ff ff0c 	bl	8027c90 <__localeconv_l>
 8027e78:	2300      	movs	r3, #0
 8027e7a:	2200      	movs	r2, #0
 8027e7c:	4605      	mov	r5, r0
 8027e7e:	6800      	ldr	r0, [r0, #0]
 8027e80:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8027e84:	f7e5 f85c 	bl	800cf40 <strlen>
 8027e88:	971f      	str	r7, [sp, #124]	; 0x7c
 8027e8a:	4682      	mov	sl, r0
 8027e8c:	463b      	mov	r3, r7
 8027e8e:	461a      	mov	r2, r3
 8027e90:	f813 6b01 	ldrb.w	r6, [r3], #1
 8027e94:	2e2d      	cmp	r6, #45	; 0x2d
 8027e96:	f200 80ef 	bhi.w	8028078 <_strtod_l+0x218>
 8027e9a:	e8df f016 	tbh	[pc, r6, lsl #1]
 8027e9e:	005b      	.short	0x005b
 8027ea0:	00ed00ed 	.word	0x00ed00ed
 8027ea4:	00ed00ed 	.word	0x00ed00ed
 8027ea8:	00ed00ed 	.word	0x00ed00ed
 8027eac:	00ed00ed 	.word	0x00ed00ed
 8027eb0:	00bf00bf 	.word	0x00bf00bf
 8027eb4:	00bf00bf 	.word	0x00bf00bf
 8027eb8:	00ed00bf 	.word	0x00ed00bf
 8027ebc:	00ed00ed 	.word	0x00ed00ed
 8027ec0:	00ed00ed 	.word	0x00ed00ed
 8027ec4:	00ed00ed 	.word	0x00ed00ed
 8027ec8:	00ed00ed 	.word	0x00ed00ed
 8027ecc:	00ed00ed 	.word	0x00ed00ed
 8027ed0:	00ed00ed 	.word	0x00ed00ed
 8027ed4:	00ed00ed 	.word	0x00ed00ed
 8027ed8:	00ed00ed 	.word	0x00ed00ed
 8027edc:	00bf00ed 	.word	0x00bf00ed
 8027ee0:	00ed00ed 	.word	0x00ed00ed
 8027ee4:	00ed00ed 	.word	0x00ed00ed
 8027ee8:	00ed00ed 	.word	0x00ed00ed
 8027eec:	00ed00ed 	.word	0x00ed00ed
 8027ef0:	00ed00ed 	.word	0x00ed00ed
 8027ef4:	00ed0068 	.word	0x00ed0068
 8027ef8:	00bc      	.short	0x00bc
 8027efa:	4652      	mov	r2, sl
 8027efc:	4648      	mov	r0, r9
 8027efe:	f005 fb8f 	bl	802d620 <strncmp>
 8027f02:	4601      	mov	r1, r0
 8027f04:	2800      	cmp	r0, #0
 8027f06:	f040 834b 	bne.w	80285a0 <_strtod_l+0x740>
 8027f0a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8027f0c:	eb03 020a 	add.w	r2, r3, sl
 8027f10:	921f      	str	r2, [sp, #124]	; 0x7c
 8027f12:	f813 600a 	ldrb.w	r6, [r3, sl]
 8027f16:	2e30      	cmp	r6, #48	; 0x30
 8027f18:	460b      	mov	r3, r1
 8027f1a:	d106      	bne.n	8027f2a <_strtod_l+0xca>
 8027f1c:	3201      	adds	r2, #1
 8027f1e:	921f      	str	r2, [sp, #124]	; 0x7c
 8027f20:	7816      	ldrb	r6, [r2, #0]
 8027f22:	2e30      	cmp	r6, #48	; 0x30
 8027f24:	f103 0301 	add.w	r3, r3, #1
 8027f28:	d0f8      	beq.n	8027f1c <_strtod_l+0xbc>
 8027f2a:	f1a6 0231 	sub.w	r2, r6, #49	; 0x31
 8027f2e:	2a08      	cmp	r2, #8
 8027f30:	f240 85b0 	bls.w	8028a94 <_strtod_l+0xc34>
 8027f34:	2e65      	cmp	r6, #101	; 0x65
 8027f36:	f04f 0b00 	mov.w	fp, #0
 8027f3a:	f040 832b 	bne.w	8028594 <_strtod_l+0x734>
 8027f3e:	465d      	mov	r5, fp
 8027f40:	46d8      	mov	r8, fp
 8027f42:	f04f 0a01 	mov.w	sl, #1
 8027f46:	2b00      	cmp	r3, #0
 8027f48:	f040 813f 	bne.w	80281ca <_strtod_l+0x36a>
 8027f4c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8027f4e:	2a00      	cmp	r2, #0
 8027f50:	f040 813b 	bne.w	80281ca <_strtod_l+0x36a>
 8027f54:	9b07      	ldr	r3, [sp, #28]
 8027f56:	b10b      	cbz	r3, 8027f5c <_strtod_l+0xfc>
 8027f58:	9b07      	ldr	r3, [sp, #28]
 8027f5a:	601f      	str	r7, [r3, #0]
 8027f5c:	f04f 0a00 	mov.w	sl, #0
 8027f60:	f04f 0b00 	mov.w	fp, #0
 8027f64:	ec4b ab10 	vmov	d0, sl, fp
 8027f68:	b025      	add	sp, #148	; 0x94
 8027f6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027f6e:	2300      	movs	r3, #0
 8027f70:	9309      	str	r3, [sp, #36]	; 0x24
 8027f72:	f102 0901 	add.w	r9, r2, #1
 8027f76:	f8cd 907c 	str.w	r9, [sp, #124]	; 0x7c
 8027f7a:	7856      	ldrb	r6, [r2, #1]
 8027f7c:	2e00      	cmp	r6, #0
 8027f7e:	d0e9      	beq.n	8027f54 <_strtod_l+0xf4>
 8027f80:	2e30      	cmp	r6, #48	; 0x30
 8027f82:	d07e      	beq.n	8028082 <_strtod_l+0x222>
 8027f84:	2300      	movs	r3, #0
 8027f86:	930c      	str	r3, [sp, #48]	; 0x30
 8027f88:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8027f8c:	b2da      	uxtb	r2, r3
 8027f8e:	2a09      	cmp	r2, #9
 8027f90:	6829      	ldr	r1, [r5, #0]
 8027f92:	d8b2      	bhi.n	8027efa <_strtod_l+0x9a>
 8027f94:	2500      	movs	r5, #0
 8027f96:	46a8      	mov	r8, r5
 8027f98:	462c      	mov	r4, r5
 8027f9a:	4648      	mov	r0, r9
 8027f9c:	3001      	adds	r0, #1
 8027f9e:	901f      	str	r0, [sp, #124]	; 0x7c
 8027fa0:	2c08      	cmp	r4, #8
 8027fa2:	7806      	ldrb	r6, [r0, #0]
 8027fa4:	eb08 0288 	add.w	r2, r8, r8, lsl #2
 8027fa8:	bfca      	itet	gt
 8027faa:	eb05 0585 	addgt.w	r5, r5, r5, lsl #2
 8027fae:	eb03 0842 	addle.w	r8, r3, r2, lsl #1
 8027fb2:	eb03 0545 	addgt.w	r5, r3, r5, lsl #1
 8027fb6:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8027fba:	b2da      	uxtb	r2, r3
 8027fbc:	2a09      	cmp	r2, #9
 8027fbe:	f104 0401 	add.w	r4, r4, #1
 8027fc2:	d9eb      	bls.n	8027f9c <_strtod_l+0x13c>
 8027fc4:	4652      	mov	r2, sl
 8027fc6:	f005 fb2b 	bl	802d620 <strncmp>
 8027fca:	4601      	mov	r1, r0
 8027fcc:	b340      	cbz	r0, 8028020 <_strtod_l+0x1c0>
 8027fce:	2300      	movs	r3, #0
 8027fd0:	4619      	mov	r1, r3
 8027fd2:	469a      	mov	sl, r3
 8027fd4:	46a3      	mov	fp, r4
 8027fd6:	2e65      	cmp	r6, #101	; 0x65
 8027fd8:	d067      	beq.n	80280aa <_strtod_l+0x24a>
 8027fda:	2e45      	cmp	r6, #69	; 0x45
 8027fdc:	d065      	beq.n	80280aa <_strtod_l+0x24a>
 8027fde:	2200      	movs	r2, #0
 8027fe0:	2c00      	cmp	r4, #0
 8027fe2:	f040 80b1 	bne.w	8028148 <_strtod_l+0x2e8>
 8027fe6:	b91b      	cbnz	r3, 8027ff0 <_strtod_l+0x190>
 8027fe8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027fea:	2b00      	cmp	r3, #0
 8027fec:	f000 827a 	beq.w	80284e4 <_strtod_l+0x684>
 8027ff0:	f04f 0a00 	mov.w	sl, #0
 8027ff4:	f04f 0b00 	mov.w	fp, #0
 8027ff8:	9a07      	ldr	r2, [sp, #28]
 8027ffa:	b10a      	cbz	r2, 8028000 <_strtod_l+0x1a0>
 8027ffc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8027ffe:	6013      	str	r3, [r2, #0]
 8028000:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028002:	2b00      	cmp	r3, #0
 8028004:	d0ae      	beq.n	8027f64 <_strtod_l+0x104>
 8028006:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 802800a:	469b      	mov	fp, r3
 802800c:	ec4b ab10 	vmov	d0, sl, fp
 8028010:	b025      	add	sp, #148	; 0x94
 8028012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028016:	2301      	movs	r3, #1
 8028018:	9309      	str	r3, [sp, #36]	; 0x24
 802801a:	e7aa      	b.n	8027f72 <_strtod_l+0x112>
 802801c:	931f      	str	r3, [sp, #124]	; 0x7c
 802801e:	e736      	b.n	8027e8e <_strtod_l+0x2e>
 8028020:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8028022:	eb03 020a 	add.w	r2, r3, sl
 8028026:	921f      	str	r2, [sp, #124]	; 0x7c
 8028028:	f813 600a 	ldrb.w	r6, [r3, sl]
 802802c:	46a3      	mov	fp, r4
 802802e:	4603      	mov	r3, r0
 8028030:	f1a6 0030 	sub.w	r0, r6, #48	; 0x30
 8028034:	2809      	cmp	r0, #9
 8028036:	f200 822a 	bhi.w	802848e <_strtod_l+0x62e>
 802803a:	1c5a      	adds	r2, r3, #1
 802803c:	4686      	mov	lr, r0
 802803e:	f8dd c07c 	ldr.w	ip, [sp, #124]	; 0x7c
 8028042:	2800      	cmp	r0, #0
 8028044:	f000 868c 	beq.w	8028d60 <_strtod_l+0xf00>
 8028048:	2a01      	cmp	r2, #1
 802804a:	4411      	add	r1, r2
 802804c:	f000 8685 	beq.w	8028d5a <_strtod_l+0xefa>
 8028050:	4423      	add	r3, r4
 8028052:	e005      	b.n	8028060 <_strtod_l+0x200>
 8028054:	ea4f 0846 	mov.w	r8, r6, lsl #1
 8028058:	429a      	cmp	r2, r3
 802805a:	4614      	mov	r4, r2
 802805c:	f000 847e 	beq.w	802895c <_strtod_l+0xafc>
 8028060:	2c08      	cmp	r4, #8
 8028062:	f104 0201 	add.w	r2, r4, #1
 8028066:	eb08 0688 	add.w	r6, r8, r8, lsl #2
 802806a:	ddf3      	ble.n	8028054 <_strtod_l+0x1f4>
 802806c:	2a10      	cmp	r2, #16
 802806e:	bfdc      	itt	le
 8028070:	eb05 0585 	addle.w	r5, r5, r5, lsl #2
 8028074:	006d      	lslle	r5, r5, #1
 8028076:	e7ef      	b.n	8028058 <_strtod_l+0x1f8>
 8028078:	2300      	movs	r3, #0
 802807a:	2e30      	cmp	r6, #48	; 0x30
 802807c:	4691      	mov	r9, r2
 802807e:	9309      	str	r3, [sp, #36]	; 0x24
 8028080:	d180      	bne.n	8027f84 <_strtod_l+0x124>
 8028082:	f899 3001 	ldrb.w	r3, [r9, #1]
 8028086:	2b58      	cmp	r3, #88	; 0x58
 8028088:	f000 8204 	beq.w	8028494 <_strtod_l+0x634>
 802808c:	2b78      	cmp	r3, #120	; 0x78
 802808e:	f000 8201 	beq.w	8028494 <_strtod_l+0x634>
 8028092:	464b      	mov	r3, r9
 8028094:	3301      	adds	r3, #1
 8028096:	931f      	str	r3, [sp, #124]	; 0x7c
 8028098:	781e      	ldrb	r6, [r3, #0]
 802809a:	2e30      	cmp	r6, #48	; 0x30
 802809c:	d0fa      	beq.n	8028094 <_strtod_l+0x234>
 802809e:	4699      	mov	r9, r3
 80280a0:	2e00      	cmp	r6, #0
 80280a2:	d0a5      	beq.n	8027ff0 <_strtod_l+0x190>
 80280a4:	2301      	movs	r3, #1
 80280a6:	930c      	str	r3, [sp, #48]	; 0x30
 80280a8:	e76e      	b.n	8027f88 <_strtod_l+0x128>
 80280aa:	2c00      	cmp	r4, #0
 80280ac:	f43f af4b 	beq.w	8027f46 <_strtod_l+0xe6>
 80280b0:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
 80280b2:	1c7a      	adds	r2, r7, #1
 80280b4:	921f      	str	r2, [sp, #124]	; 0x7c
 80280b6:	787e      	ldrb	r6, [r7, #1]
 80280b8:	2e2b      	cmp	r6, #43	; 0x2b
 80280ba:	f000 820a 	beq.w	80284d2 <_strtod_l+0x672>
 80280be:	2e2d      	cmp	r6, #45	; 0x2d
 80280c0:	f000 820d 	beq.w	80284de <_strtod_l+0x67e>
 80280c4:	f04f 0e00 	mov.w	lr, #0
 80280c8:	f1a6 0230 	sub.w	r2, r6, #48	; 0x30
 80280cc:	2a09      	cmp	r2, #9
 80280ce:	d87e      	bhi.n	80281ce <_strtod_l+0x36e>
 80280d0:	2e30      	cmp	r6, #48	; 0x30
 80280d2:	d105      	bne.n	80280e0 <_strtod_l+0x280>
 80280d4:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80280d6:	3201      	adds	r2, #1
 80280d8:	921f      	str	r2, [sp, #124]	; 0x7c
 80280da:	7816      	ldrb	r6, [r2, #0]
 80280dc:	2e30      	cmp	r6, #48	; 0x30
 80280de:	d0fa      	beq.n	80280d6 <_strtod_l+0x276>
 80280e0:	f1a6 0231 	sub.w	r2, r6, #49	; 0x31
 80280e4:	2a08      	cmp	r2, #8
 80280e6:	f63f af7a 	bhi.w	8027fde <_strtod_l+0x17e>
 80280ea:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80280ec:	920d      	str	r2, [sp, #52]	; 0x34
 80280ee:	1c50      	adds	r0, r2, #1
 80280f0:	3e30      	subs	r6, #48	; 0x30
 80280f2:	901f      	str	r0, [sp, #124]	; 0x7c
 80280f4:	960a      	str	r6, [sp, #40]	; 0x28
 80280f6:	7856      	ldrb	r6, [r2, #1]
 80280f8:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
 80280fc:	f1bc 0f09 	cmp.w	ip, #9
 8028100:	d80f      	bhi.n	8028122 <_strtod_l+0x2c2>
 8028102:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8028104:	3001      	adds	r0, #1
 8028106:	901f      	str	r0, [sp, #124]	; 0x7c
 8028108:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 802810c:	eb06 0242 	add.w	r2, r6, r2, lsl #1
 8028110:	7806      	ldrb	r6, [r0, #0]
 8028112:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
 8028116:	f1bc 0f09 	cmp.w	ip, #9
 802811a:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
 802811e:	d9f1      	bls.n	8028104 <_strtod_l+0x2a4>
 8028120:	920a      	str	r2, [sp, #40]	; 0x28
 8028122:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8028124:	1a80      	subs	r0, r0, r2
 8028126:	2808      	cmp	r0, #8
 8028128:	f300 842b 	bgt.w	8028982 <_strtod_l+0xb22>
 802812c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802812e:	f644 601f 	movw	r0, #19999	; 0x4e1f
 8028132:	4282      	cmp	r2, r0
 8028134:	bfa8      	it	ge
 8028136:	4602      	movge	r2, r0
 8028138:	f1be 0f00 	cmp.w	lr, #0
 802813c:	f43f af50 	beq.w	8027fe0 <_strtod_l+0x180>
 8028140:	4252      	negs	r2, r2
 8028142:	2c00      	cmp	r4, #0
 8028144:	f43f af4f 	beq.w	8027fe6 <_strtod_l+0x186>
 8028148:	1a53      	subs	r3, r2, r1
 802814a:	4640      	mov	r0, r8
 802814c:	930d      	str	r3, [sp, #52]	; 0x34
 802814e:	f7e4 f939 	bl	800c3c4 <__aeabi_ui2d>
 8028152:	f1bb 0f00 	cmp.w	fp, #0
 8028156:	bf08      	it	eq
 8028158:	46a3      	moveq	fp, r4
 802815a:	2c10      	cmp	r4, #16
 802815c:	46a2      	mov	sl, r4
 802815e:	bfa8      	it	ge
 8028160:	f04f 0a10 	movge.w	sl, #16
 8028164:	2c09      	cmp	r4, #9
 8028166:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802816a:	dc33      	bgt.n	80281d4 <_strtod_l+0x374>
 802816c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802816e:	2b00      	cmp	r3, #0
 8028170:	d028      	beq.n	80281c4 <_strtod_l+0x364>
 8028172:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028174:	f340 847d 	ble.w	8028a72 <_strtod_l+0xc12>
 8028178:	2b16      	cmp	r3, #22
 802817a:	f300 849c 	bgt.w	8028ab6 <_strtod_l+0xc56>
 802817e:	4942      	ldr	r1, [pc, #264]	; (8028288 <_strtod_l+0x428>)
 8028180:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8028184:	e9d1 0100 	ldrd	r0, r1, [r1]
 8028188:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802818c:	f7e4 f998 	bl	800c4c0 <__aeabi_dmul>
 8028190:	4682      	mov	sl, r0
 8028192:	468b      	mov	fp, r1
 8028194:	e730      	b.n	8027ff8 <_strtod_l+0x198>
 8028196:	a81f      	add	r0, sp, #124	; 0x7c
 8028198:	493c      	ldr	r1, [pc, #240]	; (802828c <_strtod_l+0x42c>)
 802819a:	f004 f851 	bl	802c240 <__match>
 802819e:	2800      	cmp	r0, #0
 80281a0:	f43f aed8 	beq.w	8027f54 <_strtod_l+0xf4>
 80281a4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80281a6:	493a      	ldr	r1, [pc, #232]	; (8028290 <_strtod_l+0x430>)
 80281a8:	3b01      	subs	r3, #1
 80281aa:	a81f      	add	r0, sp, #124	; 0x7c
 80281ac:	931f      	str	r3, [sp, #124]	; 0x7c
 80281ae:	f004 f847 	bl	802c240 <__match>
 80281b2:	b910      	cbnz	r0, 80281ba <_strtod_l+0x35a>
 80281b4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80281b6:	3301      	adds	r3, #1
 80281b8:	931f      	str	r3, [sp, #124]	; 0x7c
 80281ba:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8028294 <_strtod_l+0x434>
 80281be:	2300      	movs	r3, #0
 80281c0:	e9cd 3904 	strd	r3, r9, [sp, #16]
 80281c4:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80281c8:	e716      	b.n	8027ff8 <_strtod_l+0x198>
 80281ca:	2400      	movs	r4, #0
 80281cc:	e770      	b.n	80280b0 <_strtod_l+0x250>
 80281ce:	971f      	str	r7, [sp, #124]	; 0x7c
 80281d0:	2200      	movs	r2, #0
 80281d2:	e705      	b.n	8027fe0 <_strtod_l+0x180>
 80281d4:	4b2c      	ldr	r3, [pc, #176]	; (8028288 <_strtod_l+0x428>)
 80281d6:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 80281da:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
 80281de:	f7e4 f96f 	bl	800c4c0 <__aeabi_dmul>
 80281e2:	4606      	mov	r6, r0
 80281e4:	4628      	mov	r0, r5
 80281e6:	460f      	mov	r7, r1
 80281e8:	f7e4 f8ec 	bl	800c3c4 <__aeabi_ui2d>
 80281ec:	4602      	mov	r2, r0
 80281ee:	460b      	mov	r3, r1
 80281f0:	4630      	mov	r0, r6
 80281f2:	4639      	mov	r1, r7
 80281f4:	f7e3 ffaa 	bl	800c14c <__adddf3>
 80281f8:	2c0f      	cmp	r4, #15
 80281fa:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80281fe:	ddb5      	ble.n	802816c <_strtod_l+0x30c>
 8028200:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028202:	eba4 0a0a 	sub.w	sl, r4, sl
 8028206:	449a      	add	sl, r3
 8028208:	f1ba 0f00 	cmp.w	sl, #0
 802820c:	f340 82fe 	ble.w	802880c <_strtod_l+0x9ac>
 8028210:	f01a 030f 	ands.w	r3, sl, #15
 8028214:	d00a      	beq.n	802822c <_strtod_l+0x3cc>
 8028216:	491c      	ldr	r1, [pc, #112]	; (8028288 <_strtod_l+0x428>)
 8028218:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 802821c:	e9d1 0100 	ldrd	r0, r1, [r1]
 8028220:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8028224:	f7e4 f94c 	bl	800c4c0 <__aeabi_dmul>
 8028228:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802822c:	f03a 0a0f 	bics.w	sl, sl, #15
 8028230:	d00d      	beq.n	802824e <_strtod_l+0x3ee>
 8028232:	f5ba 7f9a 	cmp.w	sl, #308	; 0x134
 8028236:	f340 83db 	ble.w	80289f0 <_strtod_l+0xb90>
 802823a:	2200      	movs	r2, #0
 802823c:	4b15      	ldr	r3, [pc, #84]	; (8028294 <_strtod_l+0x434>)
 802823e:	9204      	str	r2, [sp, #16]
 8028240:	9a08      	ldr	r2, [sp, #32]
 8028242:	9305      	str	r3, [sp, #20]
 8028244:	2322      	movs	r3, #34	; 0x22
 8028246:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 802824a:	6013      	str	r3, [r2, #0]
 802824c:	e6d4      	b.n	8027ff8 <_strtod_l+0x198>
 802824e:	2300      	movs	r3, #0
 8028250:	930c      	str	r3, [sp, #48]	; 0x30
 8028252:	4623      	mov	r3, r4
 8028254:	9c08      	ldr	r4, [sp, #32]
 8028256:	f8cd 8000 	str.w	r8, [sp]
 802825a:	465a      	mov	r2, fp
 802825c:	4649      	mov	r1, r9
 802825e:	4620      	mov	r0, r4
 8028260:	f004 fc16 	bl	802ca90 <__s2b>
 8028264:	9013      	str	r0, [sp, #76]	; 0x4c
 8028266:	2800      	cmp	r0, #0
 8028268:	f000 81a3 	beq.w	80285b2 <_strtod_l+0x752>
 802826c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802826e:	2700      	movs	r7, #0
 8028270:	2a00      	cmp	r2, #0
 8028272:	f1c2 0300 	rsb	r3, r2, #0
 8028276:	bfa8      	it	ge
 8028278:	463b      	movge	r3, r7
 802827a:	930e      	str	r3, [sp, #56]	; 0x38
 802827c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8028280:	46b8      	mov	r8, r7
 8028282:	9316      	str	r3, [sp, #88]	; 0x58
 8028284:	46bb      	mov	fp, r7
 8028286:	e0c3      	b.n	8028410 <_strtod_l+0x5b0>
 8028288:	08030240 	.word	0x08030240
 802828c:	0802ff00 	.word	0x0802ff00
 8028290:	0802ff04 	.word	0x0802ff04
 8028294:	7ff00000 	.word	0x7ff00000
 8028298:	1ad2      	subs	r2, r2, r3
 802829a:	2a1f      	cmp	r2, #31
 802829c:	eba5 0502 	sub.w	r5, r5, r2
 80282a0:	f300 8229 	bgt.w	80286f6 <_strtod_l+0x896>
 80282a4:	2301      	movs	r3, #1
 80282a6:	4093      	lsls	r3, r2
 80282a8:	9310      	str	r3, [sp, #64]	; 0x40
 80282aa:	2300      	movs	r3, #0
 80282ac:	9317      	str	r3, [sp, #92]	; 0x5c
 80282ae:	442e      	add	r6, r5
 80282b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80282b2:	443d      	add	r5, r7
 80282b4:	42af      	cmp	r7, r5
 80282b6:	441e      	add	r6, r3
 80282b8:	463b      	mov	r3, r7
 80282ba:	bfa8      	it	ge
 80282bc:	462b      	movge	r3, r5
 80282be:	42b3      	cmp	r3, r6
 80282c0:	bfa8      	it	ge
 80282c2:	4633      	movge	r3, r6
 80282c4:	2b00      	cmp	r3, #0
 80282c6:	dd02      	ble.n	80282ce <_strtod_l+0x46e>
 80282c8:	1aed      	subs	r5, r5, r3
 80282ca:	1af6      	subs	r6, r6, r3
 80282cc:	1aff      	subs	r7, r7, r3
 80282ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80282d0:	2b00      	cmp	r3, #0
 80282d2:	f040 81a3 	bne.w	802861c <_strtod_l+0x7bc>
 80282d6:	2d00      	cmp	r5, #0
 80282d8:	f300 81b9 	bgt.w	802864e <_strtod_l+0x7ee>
 80282dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80282de:	2b00      	cmp	r3, #0
 80282e0:	f300 81de 	bgt.w	80286a0 <_strtod_l+0x840>
 80282e4:	2e00      	cmp	r6, #0
 80282e6:	f300 81e7 	bgt.w	80286b8 <_strtod_l+0x858>
 80282ea:	2f00      	cmp	r7, #0
 80282ec:	dd08      	ble.n	8028300 <_strtod_l+0x4a0>
 80282ee:	4641      	mov	r1, r8
 80282f0:	463a      	mov	r2, r7
 80282f2:	4620      	mov	r0, r4
 80282f4:	f004 fd74 	bl	802cde0 <__lshift>
 80282f8:	4680      	mov	r8, r0
 80282fa:	2800      	cmp	r0, #0
 80282fc:	f000 81d9 	beq.w	80286b2 <_strtod_l+0x852>
 8028300:	464a      	mov	r2, r9
 8028302:	9920      	ldr	r1, [sp, #128]	; 0x80
 8028304:	4620      	mov	r0, r4
 8028306:	f004 fde3 	bl	802ced0 <__mdiff>
 802830a:	4683      	mov	fp, r0
 802830c:	2800      	cmp	r0, #0
 802830e:	f000 81d0 	beq.w	80286b2 <_strtod_l+0x852>
 8028312:	2300      	movs	r3, #0
 8028314:	68c2      	ldr	r2, [r0, #12]
 8028316:	60c3      	str	r3, [r0, #12]
 8028318:	4641      	mov	r1, r8
 802831a:	9212      	str	r2, [sp, #72]	; 0x48
 802831c:	f004 fdb8 	bl	802ce90 <__mcmp>
 8028320:	2800      	cmp	r0, #0
 8028322:	f2c0 843d 	blt.w	8028ba0 <_strtod_l+0xd40>
 8028326:	9b05      	ldr	r3, [sp, #20]
 8028328:	930f      	str	r3, [sp, #60]	; 0x3c
 802832a:	f000 83ff 	beq.w	8028b2c <_strtod_l+0xccc>
 802832e:	4641      	mov	r1, r8
 8028330:	4658      	mov	r0, fp
 8028332:	f004 ff3d 	bl	802d1b0 <__ratio>
 8028336:	ec57 6b10 	vmov	r6, r7, d0
 802833a:	2200      	movs	r2, #0
 802833c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8028340:	ee10 0a10 	vmov	r0, s0
 8028344:	4639      	mov	r1, r7
 8028346:	f7e4 fb3d 	bl	800c9c4 <__aeabi_dcmple>
 802834a:	2800      	cmp	r0, #0
 802834c:	f000 81be 	beq.w	80286cc <_strtod_l+0x86c>
 8028350:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028352:	2b00      	cmp	r3, #0
 8028354:	f000 81dc 	beq.w	8028710 <_strtod_l+0x8b0>
 8028358:	ed9f 7ba5 	vldr	d7, [pc, #660]	; 80285f0 <_strtod_l+0x790>
 802835c:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8028360:	4fa7      	ldr	r7, [pc, #668]	; (8028600 <_strtod_l+0x7a0>)
 8028362:	2600      	movs	r6, #0
 8028364:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8028366:	4da7      	ldr	r5, [pc, #668]	; (8028604 <_strtod_l+0x7a4>)
 8028368:	4ba7      	ldr	r3, [pc, #668]	; (8028608 <_strtod_l+0x7a8>)
 802836a:	4015      	ands	r5, r2
 802836c:	429d      	cmp	r5, r3
 802836e:	f000 81f2 	beq.w	8028756 <_strtod_l+0x8f6>
 8028372:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028374:	b323      	cbz	r3, 80283c0 <_strtod_l+0x560>
 8028376:	f1b5 6fd4 	cmp.w	r5, #111149056	; 0x6a00000
 802837a:	d821      	bhi.n	80283c0 <_strtod_l+0x560>
 802837c:	a39e      	add	r3, pc, #632	; (adr r3, 80285f8 <_strtod_l+0x798>)
 802837e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028382:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8028386:	f7e4 fb1d 	bl	800c9c4 <__aeabi_dcmple>
 802838a:	b1b0      	cbz	r0, 80283ba <_strtod_l+0x55a>
 802838c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8028390:	f7e4 fe96 	bl	800d0c0 <__aeabi_d2uiz>
 8028394:	2800      	cmp	r0, #0
 8028396:	f000 83af 	beq.w	8028af8 <_strtod_l+0xc98>
 802839a:	f7e4 f813 	bl	800c3c4 <__aeabi_ui2d>
 802839e:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 80283a2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80283a4:	2b00      	cmp	r3, #0
 80283a6:	f040 83a2 	bne.w	8028aee <_strtod_l+0xc8e>
 80283aa:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
 80283ae:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 80283b2:	911a      	str	r1, [sp, #104]	; 0x68
 80283b4:	931b      	str	r3, [sp, #108]	; 0x6c
 80283b6:	e9dd 671a 	ldrd	r6, r7, [sp, #104]	; 0x68
 80283ba:	f107 63d6 	add.w	r3, r7, #112197632	; 0x6b00000
 80283be:	1b5f      	subs	r7, r3, r5
 80283c0:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 80283c4:	f004 fdfc 	bl	802cfc0 <__ulp>
 80283c8:	4630      	mov	r0, r6
 80283ca:	ec53 2b10 	vmov	r2, r3, d0
 80283ce:	4639      	mov	r1, r7
 80283d0:	f7e4 f876 	bl	800c4c0 <__aeabi_dmul>
 80283d4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80283d8:	f7e3 feb8 	bl	800c14c <__adddf3>
 80283dc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80283e0:	460e      	mov	r6, r1
 80283e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80283e4:	b923      	cbnz	r3, 80283f0 <_strtod_l+0x590>
 80283e6:	4b87      	ldr	r3, [pc, #540]	; (8028604 <_strtod_l+0x7a4>)
 80283e8:	4033      	ands	r3, r6
 80283ea:	429d      	cmp	r5, r3
 80283ec:	f000 81e9 	beq.w	80287c2 <_strtod_l+0x962>
 80283f0:	9920      	ldr	r1, [sp, #128]	; 0x80
 80283f2:	4620      	mov	r0, r4
 80283f4:	f004 fafc 	bl	802c9f0 <_Bfree>
 80283f8:	4649      	mov	r1, r9
 80283fa:	4620      	mov	r0, r4
 80283fc:	f004 faf8 	bl	802c9f0 <_Bfree>
 8028400:	4641      	mov	r1, r8
 8028402:	4620      	mov	r0, r4
 8028404:	f004 faf4 	bl	802c9f0 <_Bfree>
 8028408:	4659      	mov	r1, fp
 802840a:	4620      	mov	r0, r4
 802840c:	f004 faf0 	bl	802c9f0 <_Bfree>
 8028410:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8028412:	4620      	mov	r0, r4
 8028414:	6869      	ldr	r1, [r5, #4]
 8028416:	f004 fac3 	bl	802c9a0 <_Balloc>
 802841a:	4681      	mov	r9, r0
 802841c:	2800      	cmp	r0, #0
 802841e:	f000 8148 	beq.w	80286b2 <_strtod_l+0x852>
 8028422:	692a      	ldr	r2, [r5, #16]
 8028424:	ed9d 7b04 	vldr	d7, [sp, #16]
 8028428:	3202      	adds	r2, #2
 802842a:	0092      	lsls	r2, r2, #2
 802842c:	f105 010c 	add.w	r1, r5, #12
 8028430:	300c      	adds	r0, #12
 8028432:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 8028436:	f7e4 fb73 	bl	800cb20 <memcpy>
 802843a:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 802843e:	aa22      	add	r2, sp, #136	; 0x88
 8028440:	a921      	add	r1, sp, #132	; 0x84
 8028442:	4620      	mov	r0, r4
 8028444:	f004 fe4c 	bl	802d0e0 <__d2b>
 8028448:	9020      	str	r0, [sp, #128]	; 0x80
 802844a:	2800      	cmp	r0, #0
 802844c:	f000 8108 	beq.w	8028660 <_strtod_l+0x800>
 8028450:	2101      	movs	r1, #1
 8028452:	4620      	mov	r0, r4
 8028454:	f004 fbbc 	bl	802cbd0 <__i2b>
 8028458:	4680      	mov	r8, r0
 802845a:	2800      	cmp	r0, #0
 802845c:	f000 8129 	beq.w	80286b2 <_strtod_l+0x852>
 8028460:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028462:	2b00      	cmp	r3, #0
 8028464:	f2c0 8143 	blt.w	80286ee <_strtod_l+0x88e>
 8028468:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802846a:	9e16      	ldr	r6, [sp, #88]	; 0x58
 802846c:	189f      	adds	r7, r3, r2
 802846e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8028470:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8028472:	4a66      	ldr	r2, [pc, #408]	; (802860c <_strtod_l+0x7ac>)
 8028474:	1a5b      	subs	r3, r3, r1
 8028476:	442b      	add	r3, r5
 8028478:	3b01      	subs	r3, #1
 802847a:	4293      	cmp	r3, r2
 802847c:	f1c5 0536 	rsb	r5, r5, #54	; 0x36
 8028480:	f6ff af0a 	blt.w	8028298 <_strtod_l+0x438>
 8028484:	2300      	movs	r3, #0
 8028486:	9317      	str	r3, [sp, #92]	; 0x5c
 8028488:	2301      	movs	r3, #1
 802848a:	9310      	str	r3, [sp, #64]	; 0x40
 802848c:	e70f      	b.n	80282ae <_strtod_l+0x44e>
 802848e:	f04f 0a01 	mov.w	sl, #1
 8028492:	e5a0      	b.n	8027fd6 <_strtod_l+0x176>
 8028494:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8028496:	9402      	str	r4, [sp, #8]
 8028498:	ab20      	add	r3, sp, #128	; 0x80
 802849a:	e9cd 3200 	strd	r3, r2, [sp]
 802849e:	a91f      	add	r1, sp, #124	; 0x7c
 80284a0:	ab21      	add	r3, sp, #132	; 0x84
 80284a2:	4a5b      	ldr	r2, [pc, #364]	; (8028610 <_strtod_l+0x7b0>)
 80284a4:	9808      	ldr	r0, [sp, #32]
 80284a6:	f003 fc3b 	bl	802bd20 <__gethex>
 80284aa:	f010 0507 	ands.w	r5, r0, #7
 80284ae:	4604      	mov	r4, r0
 80284b0:	f43f ad9e 	beq.w	8027ff0 <_strtod_l+0x190>
 80284b4:	2d06      	cmp	r5, #6
 80284b6:	f040 8268 	bne.w	802898a <_strtod_l+0xb2a>
 80284ba:	9a07      	ldr	r2, [sp, #28]
 80284bc:	f109 0301 	add.w	r3, r9, #1
 80284c0:	2a00      	cmp	r2, #0
 80284c2:	f43f ad4b 	beq.w	8027f5c <_strtod_l+0xfc>
 80284c6:	6013      	str	r3, [r2, #0]
 80284c8:	f04f 0a00 	mov.w	sl, #0
 80284cc:	f04f 0b00 	mov.w	fp, #0
 80284d0:	e548      	b.n	8027f64 <_strtod_l+0x104>
 80284d2:	f04f 0e00 	mov.w	lr, #0
 80284d6:	1cba      	adds	r2, r7, #2
 80284d8:	921f      	str	r2, [sp, #124]	; 0x7c
 80284da:	78be      	ldrb	r6, [r7, #2]
 80284dc:	e5f4      	b.n	80280c8 <_strtod_l+0x268>
 80284de:	f04f 0e01 	mov.w	lr, #1
 80284e2:	e7f8      	b.n	80284d6 <_strtod_l+0x676>
 80284e4:	f1ba 0f00 	cmp.w	sl, #0
 80284e8:	f47f ad34 	bne.w	8027f54 <_strtod_l+0xf4>
 80284ec:	3e49      	subs	r6, #73	; 0x49
 80284ee:	2e25      	cmp	r6, #37	; 0x25
 80284f0:	f63f ad30 	bhi.w	8027f54 <_strtod_l+0xf4>
 80284f4:	a301      	add	r3, pc, #4	; (adr r3, 80284fc <_strtod_l+0x69c>)
 80284f6:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
 80284fa:	bf00      	nop
 80284fc:	08028197 	.word	0x08028197
 8028500:	08027f55 	.word	0x08027f55
 8028504:	08027f55 	.word	0x08027f55
 8028508:	08027f55 	.word	0x08027f55
 802850c:	08027f55 	.word	0x08027f55
 8028510:	080285c7 	.word	0x080285c7
 8028514:	08027f55 	.word	0x08027f55
 8028518:	08027f55 	.word	0x08027f55
 802851c:	08027f55 	.word	0x08027f55
 8028520:	08027f55 	.word	0x08027f55
 8028524:	08027f55 	.word	0x08027f55
 8028528:	08027f55 	.word	0x08027f55
 802852c:	08027f55 	.word	0x08027f55
 8028530:	08027f55 	.word	0x08027f55
 8028534:	08027f55 	.word	0x08027f55
 8028538:	08027f55 	.word	0x08027f55
 802853c:	08027f55 	.word	0x08027f55
 8028540:	08027f55 	.word	0x08027f55
 8028544:	08027f55 	.word	0x08027f55
 8028548:	08027f55 	.word	0x08027f55
 802854c:	08027f55 	.word	0x08027f55
 8028550:	08027f55 	.word	0x08027f55
 8028554:	08027f55 	.word	0x08027f55
 8028558:	08027f55 	.word	0x08027f55
 802855c:	08027f55 	.word	0x08027f55
 8028560:	08027f55 	.word	0x08027f55
 8028564:	08027f55 	.word	0x08027f55
 8028568:	08027f55 	.word	0x08027f55
 802856c:	08027f55 	.word	0x08027f55
 8028570:	08027f55 	.word	0x08027f55
 8028574:	08027f55 	.word	0x08027f55
 8028578:	08027f55 	.word	0x08027f55
 802857c:	08028197 	.word	0x08028197
 8028580:	08027f55 	.word	0x08027f55
 8028584:	08027f55 	.word	0x08027f55
 8028588:	08027f55 	.word	0x08027f55
 802858c:	08027f55 	.word	0x08027f55
 8028590:	080285c7 	.word	0x080285c7
 8028594:	465c      	mov	r4, fp
 8028596:	465d      	mov	r5, fp
 8028598:	46d8      	mov	r8, fp
 802859a:	f04f 0a01 	mov.w	sl, #1
 802859e:	e51c      	b.n	8027fda <_strtod_l+0x17a>
 80285a0:	f04f 0b00 	mov.w	fp, #0
 80285a4:	465d      	mov	r5, fp
 80285a6:	46d8      	mov	r8, fp
 80285a8:	465b      	mov	r3, fp
 80285aa:	4659      	mov	r1, fp
 80285ac:	465c      	mov	r4, fp
 80285ae:	46da      	mov	sl, fp
 80285b0:	e511      	b.n	8027fd6 <_strtod_l+0x176>
 80285b2:	4b14      	ldr	r3, [pc, #80]	; (8028604 <_strtod_l+0x7a4>)
 80285b4:	9305      	str	r3, [sp, #20]
 80285b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80285b8:	9a08      	ldr	r2, [sp, #32]
 80285ba:	9304      	str	r3, [sp, #16]
 80285bc:	2322      	movs	r3, #34	; 0x22
 80285be:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80285c2:	6013      	str	r3, [r2, #0]
 80285c4:	e518      	b.n	8027ff8 <_strtod_l+0x198>
 80285c6:	a81f      	add	r0, sp, #124	; 0x7c
 80285c8:	4912      	ldr	r1, [pc, #72]	; (8028614 <_strtod_l+0x7b4>)
 80285ca:	f003 fe39 	bl	802c240 <__match>
 80285ce:	2800      	cmp	r0, #0
 80285d0:	f43f acc0 	beq.w	8027f54 <_strtod_l+0xf4>
 80285d4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80285d6:	781b      	ldrb	r3, [r3, #0]
 80285d8:	2b28      	cmp	r3, #40	; 0x28
 80285da:	f000 8392 	beq.w	8028d02 <_strtod_l+0xea2>
 80285de:	f8df 8038 	ldr.w	r8, [pc, #56]	; 8028618 <_strtod_l+0x7b8>
 80285e2:	2300      	movs	r3, #0
 80285e4:	e9cd 3804 	strd	r3, r8, [sp, #16]
 80285e8:	e5ec      	b.n	80281c4 <_strtod_l+0x364>
 80285ea:	bf00      	nop
 80285ec:	f3af 8000 	nop.w
 80285f0:	00000000 	.word	0x00000000
 80285f4:	3ff00000 	.word	0x3ff00000
 80285f8:	ffc00000 	.word	0xffc00000
 80285fc:	41dfffff 	.word	0x41dfffff
 8028600:	3ff00000 	.word	0x3ff00000
 8028604:	7ff00000 	.word	0x7ff00000
 8028608:	7fe00000 	.word	0x7fe00000
 802860c:	fffffc02 	.word	0xfffffc02
 8028610:	0802ff10 	.word	0x0802ff10
 8028614:	0802ff0c 	.word	0x0802ff0c
 8028618:	fff80000 	.word	0xfff80000
 802861c:	4641      	mov	r1, r8
 802861e:	461a      	mov	r2, r3
 8028620:	4620      	mov	r0, r4
 8028622:	f004 fb8d 	bl	802cd40 <__pow5mult>
 8028626:	4680      	mov	r8, r0
 8028628:	2800      	cmp	r0, #0
 802862a:	d042      	beq.n	80286b2 <_strtod_l+0x852>
 802862c:	4601      	mov	r1, r0
 802862e:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8028630:	4620      	mov	r0, r4
 8028632:	f004 fadd 	bl	802cbf0 <__multiply>
 8028636:	2800      	cmp	r0, #0
 8028638:	d03b      	beq.n	80286b2 <_strtod_l+0x852>
 802863a:	900f      	str	r0, [sp, #60]	; 0x3c
 802863c:	9920      	ldr	r1, [sp, #128]	; 0x80
 802863e:	4620      	mov	r0, r4
 8028640:	f004 f9d6 	bl	802c9f0 <_Bfree>
 8028644:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8028646:	9320      	str	r3, [sp, #128]	; 0x80
 8028648:	2d00      	cmp	r5, #0
 802864a:	f77f ae47 	ble.w	80282dc <_strtod_l+0x47c>
 802864e:	462a      	mov	r2, r5
 8028650:	9920      	ldr	r1, [sp, #128]	; 0x80
 8028652:	4620      	mov	r0, r4
 8028654:	f004 fbc4 	bl	802cde0 <__lshift>
 8028658:	9020      	str	r0, [sp, #128]	; 0x80
 802865a:	2800      	cmp	r0, #0
 802865c:	f47f ae3e 	bne.w	80282dc <_strtod_l+0x47c>
 8028660:	465f      	mov	r7, fp
 8028662:	4bb5      	ldr	r3, [pc, #724]	; (8028938 <_strtod_l+0xad8>)
 8028664:	9305      	str	r3, [sp, #20]
 8028666:	2200      	movs	r2, #0
 8028668:	9204      	str	r2, [sp, #16]
 802866a:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 802866e:	9a08      	ldr	r2, [sp, #32]
 8028670:	2322      	movs	r3, #34	; 0x22
 8028672:	6013      	str	r3, [r2, #0]
 8028674:	9c08      	ldr	r4, [sp, #32]
 8028676:	4601      	mov	r1, r0
 8028678:	4620      	mov	r0, r4
 802867a:	f004 f9b9 	bl	802c9f0 <_Bfree>
 802867e:	4649      	mov	r1, r9
 8028680:	4620      	mov	r0, r4
 8028682:	f004 f9b5 	bl	802c9f0 <_Bfree>
 8028686:	4641      	mov	r1, r8
 8028688:	4620      	mov	r0, r4
 802868a:	f004 f9b1 	bl	802c9f0 <_Bfree>
 802868e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8028690:	4620      	mov	r0, r4
 8028692:	f004 f9ad 	bl	802c9f0 <_Bfree>
 8028696:	4639      	mov	r1, r7
 8028698:	4620      	mov	r0, r4
 802869a:	f004 f9a9 	bl	802c9f0 <_Bfree>
 802869e:	e4ab      	b.n	8027ff8 <_strtod_l+0x198>
 80286a0:	4649      	mov	r1, r9
 80286a2:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80286a4:	4620      	mov	r0, r4
 80286a6:	f004 fb4b 	bl	802cd40 <__pow5mult>
 80286aa:	4681      	mov	r9, r0
 80286ac:	2800      	cmp	r0, #0
 80286ae:	f47f ae19 	bne.w	80282e4 <_strtod_l+0x484>
 80286b2:	465f      	mov	r7, fp
 80286b4:	9820      	ldr	r0, [sp, #128]	; 0x80
 80286b6:	e7d4      	b.n	8028662 <_strtod_l+0x802>
 80286b8:	4649      	mov	r1, r9
 80286ba:	4632      	mov	r2, r6
 80286bc:	4620      	mov	r0, r4
 80286be:	f004 fb8f 	bl	802cde0 <__lshift>
 80286c2:	4681      	mov	r9, r0
 80286c4:	2800      	cmp	r0, #0
 80286c6:	f47f ae10 	bne.w	80282ea <_strtod_l+0x48a>
 80286ca:	e7f2      	b.n	80286b2 <_strtod_l+0x852>
 80286cc:	4b9b      	ldr	r3, [pc, #620]	; (802893c <_strtod_l+0xadc>)
 80286ce:	4630      	mov	r0, r6
 80286d0:	4639      	mov	r1, r7
 80286d2:	2200      	movs	r2, #0
 80286d4:	f7e3 fef4 	bl	800c4c0 <__aeabi_dmul>
 80286d8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80286da:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 80286de:	b993      	cbnz	r3, 8028706 <_strtod_l+0x8a6>
 80286e0:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80286e4:	9014      	str	r0, [sp, #80]	; 0x50
 80286e6:	9315      	str	r3, [sp, #84]	; 0x54
 80286e8:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
 80286ec:	e63a      	b.n	8028364 <_strtod_l+0x504>
 80286ee:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80286f0:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 80286f2:	1ad6      	subs	r6, r2, r3
 80286f4:	e6bb      	b.n	802846e <_strtod_l+0x60e>
 80286f6:	4a92      	ldr	r2, [pc, #584]	; (8028940 <_strtod_l+0xae0>)
 80286f8:	1ad3      	subs	r3, r2, r3
 80286fa:	2201      	movs	r2, #1
 80286fc:	fa02 f303 	lsl.w	r3, r2, r3
 8028700:	9317      	str	r3, [sp, #92]	; 0x5c
 8028702:	9210      	str	r2, [sp, #64]	; 0x40
 8028704:	e5d3      	b.n	80282ae <_strtod_l+0x44e>
 8028706:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 802870a:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
 802870e:	e7eb      	b.n	80286e8 <_strtod_l+0x888>
 8028710:	9b04      	ldr	r3, [sp, #16]
 8028712:	2b00      	cmp	r3, #0
 8028714:	f040 80e9 	bne.w	80288ea <_strtod_l+0xa8a>
 8028718:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802871a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802871e:	2b00      	cmp	r3, #0
 8028720:	d148      	bne.n	80287b4 <_strtod_l+0x954>
 8028722:	2200      	movs	r2, #0
 8028724:	4b87      	ldr	r3, [pc, #540]	; (8028944 <_strtod_l+0xae4>)
 8028726:	4630      	mov	r0, r6
 8028728:	4639      	mov	r1, r7
 802872a:	f7e4 f941 	bl	800c9b0 <__aeabi_dcmplt>
 802872e:	2800      	cmp	r0, #0
 8028730:	f040 81f3 	bne.w	8028b1a <_strtod_l+0xcba>
 8028734:	2200      	movs	r2, #0
 8028736:	4b81      	ldr	r3, [pc, #516]	; (802893c <_strtod_l+0xadc>)
 8028738:	4630      	mov	r0, r6
 802873a:	4639      	mov	r1, r7
 802873c:	f7e3 fec0 	bl	800c4c0 <__aeabi_dmul>
 8028740:	460a      	mov	r2, r1
 8028742:	4601      	mov	r1, r0
 8028744:	e9cd 1210 	strd	r1, r2, [sp, #64]	; 0x40
 8028748:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 802874c:	901c      	str	r0, [sp, #112]	; 0x70
 802874e:	931d      	str	r3, [sp, #116]	; 0x74
 8028750:	e9dd 671c 	ldrd	r6, r7, [sp, #112]	; 0x70
 8028754:	e606      	b.n	8028364 <_strtod_l+0x504>
 8028756:	f1a2 7354 	sub.w	r3, r2, #55574528	; 0x3500000
 802875a:	9305      	str	r3, [sp, #20]
 802875c:	ed9d 7b04 	vldr	d7, [sp, #16]
 8028760:	eeb0 0a47 	vmov.f32	s0, s14
 8028764:	eef0 0a67 	vmov.f32	s1, s15
 8028768:	f004 fc2a 	bl	802cfc0 <__ulp>
 802876c:	4630      	mov	r0, r6
 802876e:	ec53 2b10 	vmov	r2, r3, d0
 8028772:	4639      	mov	r1, r7
 8028774:	f7e3 fea4 	bl	800c4c0 <__aeabi_dmul>
 8028778:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802877c:	f7e3 fce6 	bl	800c14c <__adddf3>
 8028780:	4b6d      	ldr	r3, [pc, #436]	; (8028938 <_strtod_l+0xad8>)
 8028782:	f8df c1d4 	ldr.w	ip, [pc, #468]	; 8028958 <_strtod_l+0xaf8>
 8028786:	400b      	ands	r3, r1
 8028788:	460a      	mov	r2, r1
 802878a:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802878e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8028792:	4563      	cmp	r3, ip
 8028794:	4606      	mov	r6, r0
 8028796:	460f      	mov	r7, r1
 8028798:	e9cd 6718 	strd	r6, r7, [sp, #96]	; 0x60
 802879c:	f240 80b7 	bls.w	802890e <_strtod_l+0xaae>
 80287a0:	4b69      	ldr	r3, [pc, #420]	; (8028948 <_strtod_l+0xae8>)
 80287a2:	4299      	cmp	r1, r3
 80287a4:	f000 81ad 	beq.w	8028b02 <_strtod_l+0xca2>
 80287a8:	4967      	ldr	r1, [pc, #412]	; (8028948 <_strtod_l+0xae8>)
 80287aa:	f04f 33ff 	mov.w	r3, #4294967295
 80287ae:	e9cd 3104 	strd	r3, r1, [sp, #16]
 80287b2:	e61d      	b.n	80283f0 <_strtod_l+0x590>
 80287b4:	ed9f 7b58 	vldr	d7, [pc, #352]	; 8028918 <_strtod_l+0xab8>
 80287b8:	2600      	movs	r6, #0
 80287ba:	4f64      	ldr	r7, [pc, #400]	; (802894c <_strtod_l+0xaec>)
 80287bc:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 80287c0:	e5d0      	b.n	8028364 <_strtod_l+0x504>
 80287c2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80287c6:	f7e4 f933 	bl	800ca30 <__aeabi_d2iz>
 80287ca:	f7e3 fe0b 	bl	800c3e4 <__aeabi_i2d>
 80287ce:	460b      	mov	r3, r1
 80287d0:	4602      	mov	r2, r0
 80287d2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80287d6:	f7e3 fcb7 	bl	800c148 <__aeabi_dsub>
 80287da:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80287dc:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 80287e0:	2b00      	cmp	r3, #0
 80287e2:	d16e      	bne.n	80288c2 <_strtod_l+0xa62>
 80287e4:	9b04      	ldr	r3, [sp, #16]
 80287e6:	2b00      	cmp	r3, #0
 80287e8:	d16b      	bne.n	80288c2 <_strtod_l+0xa62>
 80287ea:	f3c6 0613 	ubfx	r6, r6, #0, #20
 80287ee:	2e00      	cmp	r6, #0
 80287f0:	d167      	bne.n	80288c2 <_strtod_l+0xa62>
 80287f2:	a34b      	add	r3, pc, #300	; (adr r3, 8028920 <_strtod_l+0xac0>)
 80287f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80287f8:	f7e4 f8da 	bl	800c9b0 <__aeabi_dcmplt>
 80287fc:	2800      	cmp	r0, #0
 80287fe:	f43f adf7 	beq.w	80283f0 <_strtod_l+0x590>
 8028802:	465f      	mov	r7, fp
 8028804:	9820      	ldr	r0, [sp, #128]	; 0x80
 8028806:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 802880a:	e733      	b.n	8028674 <_strtod_l+0x814>
 802880c:	f43f ad1f 	beq.w	802824e <_strtod_l+0x3ee>
 8028810:	f1ca 0500 	rsb	r5, sl, #0
 8028814:	f015 020f 	ands.w	r2, r5, #15
 8028818:	d00a      	beq.n	8028830 <_strtod_l+0x9d0>
 802881a:	4b4d      	ldr	r3, [pc, #308]	; (8028950 <_strtod_l+0xaf0>)
 802881c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028820:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028824:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028828:	f7e3 ff74 	bl	800c714 <__aeabi_ddiv>
 802882c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8028830:	112d      	asrs	r5, r5, #4
 8028832:	f43f ad0c 	beq.w	802824e <_strtod_l+0x3ee>
 8028836:	2d1f      	cmp	r5, #31
 8028838:	dc3a      	bgt.n	80288b0 <_strtod_l+0xa50>
 802883a:	f015 0310 	ands.w	r3, r5, #16
 802883e:	930c      	str	r3, [sp, #48]	; 0x30
 8028840:	f040 81fd 	bne.w	8028c3e <_strtod_l+0xdde>
 8028844:	2d00      	cmp	r5, #0
 8028846:	f340 81f7 	ble.w	8028c38 <_strtod_l+0xdd8>
 802884a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802884e:	4e41      	ldr	r6, [pc, #260]	; (8028954 <_strtod_l+0xaf4>)
 8028850:	2300      	movs	r3, #0
 8028852:	07ef      	lsls	r7, r5, #31
 8028854:	d504      	bpl.n	8028860 <_strtod_l+0xa00>
 8028856:	e9d6 2300 	ldrd	r2, r3, [r6]
 802885a:	f7e3 fe31 	bl	800c4c0 <__aeabi_dmul>
 802885e:	2301      	movs	r3, #1
 8028860:	106d      	asrs	r5, r5, #1
 8028862:	f106 0608 	add.w	r6, r6, #8
 8028866:	d1f4      	bne.n	8028852 <_strtod_l+0x9f2>
 8028868:	2b00      	cmp	r3, #0
 802886a:	f040 827b 	bne.w	8028d64 <_strtod_l+0xf04>
 802886e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028870:	2b00      	cmp	r3, #0
 8028872:	f000 81e1 	beq.w	8028c38 <_strtod_l+0xdd8>
 8028876:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 802887a:	f3c2 530a 	ubfx	r3, r2, #20, #11
 802887e:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8028882:	2b00      	cmp	r3, #0
 8028884:	4611      	mov	r1, r2
 8028886:	dd0a      	ble.n	802889e <_strtod_l+0xa3e>
 8028888:	2b1f      	cmp	r3, #31
 802888a:	f340 8232 	ble.w	8028cf2 <_strtod_l+0xe92>
 802888e:	2200      	movs	r2, #0
 8028890:	2b34      	cmp	r3, #52	; 0x34
 8028892:	9204      	str	r2, [sp, #16]
 8028894:	f340 8256 	ble.w	8028d44 <_strtod_l+0xee4>
 8028898:	f04f 735c 	mov.w	r3, #57671680	; 0x3700000
 802889c:	9305      	str	r3, [sp, #20]
 802889e:	2200      	movs	r2, #0
 80288a0:	2300      	movs	r3, #0
 80288a2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80288a6:	f7e4 f879 	bl	800c99c <__aeabi_dcmpeq>
 80288aa:	2800      	cmp	r0, #0
 80288ac:	f43f acd1 	beq.w	8028252 <_strtod_l+0x3f2>
 80288b0:	9a08      	ldr	r2, [sp, #32]
 80288b2:	2322      	movs	r3, #34	; 0x22
 80288b4:	6013      	str	r3, [r2, #0]
 80288b6:	f04f 0a00 	mov.w	sl, #0
 80288ba:	f04f 0b00 	mov.w	fp, #0
 80288be:	f7ff bb9b 	b.w	8027ff8 <_strtod_l+0x198>
 80288c2:	a319      	add	r3, pc, #100	; (adr r3, 8028928 <_strtod_l+0xac8>)
 80288c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80288c8:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80288cc:	f7e4 f870 	bl	800c9b0 <__aeabi_dcmplt>
 80288d0:	2800      	cmp	r0, #0
 80288d2:	d196      	bne.n	8028802 <_strtod_l+0x9a2>
 80288d4:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80288d8:	a315      	add	r3, pc, #84	; (adr r3, 8028930 <_strtod_l+0xad0>)
 80288da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80288de:	f7e4 f885 	bl	800c9ec <__aeabi_dcmpgt>
 80288e2:	2800      	cmp	r0, #0
 80288e4:	f43f ad84 	beq.w	80283f0 <_strtod_l+0x590>
 80288e8:	e78b      	b.n	8028802 <_strtod_l+0x9a2>
 80288ea:	9b04      	ldr	r3, [sp, #16]
 80288ec:	2b01      	cmp	r3, #1
 80288ee:	f47f af61 	bne.w	80287b4 <_strtod_l+0x954>
 80288f2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80288f4:	2b00      	cmp	r3, #0
 80288f6:	f47f af5d 	bne.w	80287b4 <_strtod_l+0x954>
 80288fa:	465f      	mov	r7, fp
 80288fc:	9a08      	ldr	r2, [sp, #32]
 80288fe:	9820      	ldr	r0, [sp, #128]	; 0x80
 8028900:	2322      	movs	r3, #34	; 0x22
 8028902:	6013      	str	r3, [r2, #0]
 8028904:	f04f 0a00 	mov.w	sl, #0
 8028908:	f04f 0b00 	mov.w	fp, #0
 802890c:	e6b2      	b.n	8028674 <_strtod_l+0x814>
 802890e:	f102 7654 	add.w	r6, r2, #55574528	; 0x3500000
 8028912:	9605      	str	r6, [sp, #20]
 8028914:	e565      	b.n	80283e2 <_strtod_l+0x582>
 8028916:	bf00      	nop
 8028918:	00000000 	.word	0x00000000
 802891c:	3ff00000 	.word	0x3ff00000
 8028920:	94a03595 	.word	0x94a03595
 8028924:	3fcfffff 	.word	0x3fcfffff
 8028928:	94a03595 	.word	0x94a03595
 802892c:	3fdfffff 	.word	0x3fdfffff
 8028930:	35afe535 	.word	0x35afe535
 8028934:	3fe00000 	.word	0x3fe00000
 8028938:	7ff00000 	.word	0x7ff00000
 802893c:	3fe00000 	.word	0x3fe00000
 8028940:	fffffbe2 	.word	0xfffffbe2
 8028944:	3ff00000 	.word	0x3ff00000
 8028948:	7fefffff 	.word	0x7fefffff
 802894c:	bff00000 	.word	0xbff00000
 8028950:	08030240 	.word	0x08030240
 8028954:	0802ff50 	.word	0x0802ff50
 8028958:	7c9fffff 	.word	0x7c9fffff
 802895c:	1c54      	adds	r4, r2, #1
 802895e:	2a08      	cmp	r2, #8
 8028960:	f340 80a3 	ble.w	8028aaa <_strtod_l+0xc4a>
 8028964:	2c10      	cmp	r4, #16
 8028966:	f300 80d6 	bgt.w	8028b16 <_strtod_l+0xcb6>
 802896a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 802896e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
 8028972:	2300      	movs	r3, #0
 8028974:	f10c 0201 	add.w	r2, ip, #1
 8028978:	921f      	str	r2, [sp, #124]	; 0x7c
 802897a:	f89c 6001 	ldrb.w	r6, [ip, #1]
 802897e:	f7ff bb57 	b.w	8028030 <_strtod_l+0x1d0>
 8028982:	f644 621f 	movw	r2, #19999	; 0x4e1f
 8028986:	f7ff bbd7 	b.w	8028138 <_strtod_l+0x2d8>
 802898a:	9a20      	ldr	r2, [sp, #128]	; 0x80
 802898c:	b13a      	cbz	r2, 802899e <_strtod_l+0xb3e>
 802898e:	2135      	movs	r1, #53	; 0x35
 8028990:	a822      	add	r0, sp, #136	; 0x88
 8028992:	f004 fc3d 	bl	802d210 <__copybits>
 8028996:	9808      	ldr	r0, [sp, #32]
 8028998:	9920      	ldr	r1, [sp, #128]	; 0x80
 802899a:	f004 f829 	bl	802c9f0 <_Bfree>
 802899e:	3d01      	subs	r5, #1
 80289a0:	2d04      	cmp	r5, #4
 80289a2:	d806      	bhi.n	80289b2 <_strtod_l+0xb52>
 80289a4:	e8df f005 	tbb	[pc, r5]
 80289a8:	11030c18 	.word	0x11030c18
 80289ac:	18          	.byte	0x18
 80289ad:	00          	.byte	0x00
 80289ae:	4bae      	ldr	r3, [pc, #696]	; (8028c68 <_strtod_l+0xe08>)
 80289b0:	9305      	str	r3, [sp, #20]
 80289b2:	0723      	lsls	r3, r4, #28
 80289b4:	bf42      	ittt	mi
 80289b6:	9b05      	ldrmi	r3, [sp, #20]
 80289b8:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 80289bc:	9305      	strmi	r3, [sp, #20]
 80289be:	e401      	b.n	80281c4 <_strtod_l+0x364>
 80289c0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80289c2:	9304      	str	r3, [sp, #16]
 80289c4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80289c6:	9305      	str	r3, [sp, #20]
 80289c8:	e7f3      	b.n	80289b2 <_strtod_l+0xb52>
 80289ca:	f04f 33ff 	mov.w	r3, #4294967295
 80289ce:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 80289d2:	e9cd 3204 	strd	r3, r2, [sp, #16]
 80289d6:	e7ec      	b.n	80289b2 <_strtod_l+0xb52>
 80289d8:	e9dd 1322 	ldrd	r1, r3, [sp, #136]	; 0x88
 80289dc:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80289de:	9104      	str	r1, [sp, #16]
 80289e0:	f202 4233 	addw	r2, r2, #1075	; 0x433
 80289e4:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80289e8:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 80289ec:	9305      	str	r3, [sp, #20]
 80289ee:	e7e0      	b.n	80289b2 <_strtod_l+0xb52>
 80289f0:	ea4f 152a 	mov.w	r5, sl, asr #4
 80289f4:	2d01      	cmp	r5, #1
 80289f6:	f8df a288 	ldr.w	sl, [pc, #648]	; 8028c80 <_strtod_l+0xe20>
 80289fa:	f340 8110 	ble.w	8028c1e <_strtod_l+0xdbe>
 80289fe:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028a02:	2300      	movs	r3, #0
 8028a04:	4656      	mov	r6, sl
 8028a06:	461f      	mov	r7, r3
 8028a08:	f015 0f01 	tst.w	r5, #1
 8028a0c:	f107 0701 	add.w	r7, r7, #1
 8028a10:	ea4f 0565 	mov.w	r5, r5, asr #1
 8028a14:	d004      	beq.n	8028a20 <_strtod_l+0xbc0>
 8028a16:	e9d6 2300 	ldrd	r2, r3, [r6]
 8028a1a:	f7e3 fd51 	bl	800c4c0 <__aeabi_dmul>
 8028a1e:	2301      	movs	r3, #1
 8028a20:	2d01      	cmp	r5, #1
 8028a22:	f106 0608 	add.w	r6, r6, #8
 8028a26:	d1ef      	bne.n	8028a08 <_strtod_l+0xba8>
 8028a28:	2b00      	cmp	r3, #0
 8028a2a:	f040 819e 	bne.w	8028d6a <_strtod_l+0xf0a>
 8028a2e:	9b05      	ldr	r3, [sp, #20]
 8028a30:	4e8e      	ldr	r6, [pc, #568]	; (8028c6c <_strtod_l+0xe0c>)
 8028a32:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
 8028a36:	9305      	str	r3, [sp, #20]
 8028a38:	eb0a 07c7 	add.w	r7, sl, r7, lsl #3
 8028a3c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8028a40:	e9d7 0100 	ldrd	r0, r1, [r7]
 8028a44:	f7e3 fd3c 	bl	800c4c0 <__aeabi_dmul>
 8028a48:	4a87      	ldr	r2, [pc, #540]	; (8028c68 <_strtod_l+0xe08>)
 8028a4a:	ea01 0302 	and.w	r3, r1, r2
 8028a4e:	42b3      	cmp	r3, r6
 8028a50:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8028a54:	d85c      	bhi.n	8028b10 <_strtod_l+0xcb0>
 8028a56:	f1a2 7258 	sub.w	r2, r2, #56623104	; 0x3600000
 8028a5a:	4293      	cmp	r3, r2
 8028a5c:	f240 80d8 	bls.w	8028c10 <_strtod_l+0xdb0>
 8028a60:	4b83      	ldr	r3, [pc, #524]	; (8028c70 <_strtod_l+0xe10>)
 8028a62:	9305      	str	r3, [sp, #20]
 8028a64:	2300      	movs	r3, #0
 8028a66:	930c      	str	r3, [sp, #48]	; 0x30
 8028a68:	f04f 33ff 	mov.w	r3, #4294967295
 8028a6c:	9304      	str	r3, [sp, #16]
 8028a6e:	f7ff bbf0 	b.w	8028252 <_strtod_l+0x3f2>
 8028a72:	f113 0216 	adds.w	r2, r3, #22
 8028a76:	f6ff abc3 	blt.w	8028200 <_strtod_l+0x3a0>
 8028a7a:	4a7e      	ldr	r2, [pc, #504]	; (8028c74 <_strtod_l+0xe14>)
 8028a7c:	eba2 02c3 	sub.w	r2, r2, r3, lsl #3
 8028a80:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028a84:	e9d2 2300 	ldrd	r2, r3, [r2]
 8028a88:	f7e3 fe44 	bl	800c714 <__aeabi_ddiv>
 8028a8c:	4682      	mov	sl, r0
 8028a8e:	468b      	mov	fp, r1
 8028a90:	f7ff bab2 	b.w	8027ff8 <_strtod_l+0x198>
 8028a94:	f8dd 907c 	ldr.w	r9, [sp, #124]	; 0x7c
 8028a98:	f04f 0b00 	mov.w	fp, #0
 8028a9c:	f1a6 0e30 	sub.w	lr, r6, #48	; 0x30
 8028aa0:	1c59      	adds	r1, r3, #1
 8028aa2:	46cc      	mov	ip, r9
 8028aa4:	46d8      	mov	r8, fp
 8028aa6:	465d      	mov	r5, fp
 8028aa8:	2401      	movs	r4, #1
 8028aaa:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8028aae:	eb0e 0848 	add.w	r8, lr, r8, lsl #1
 8028ab2:	2300      	movs	r3, #0
 8028ab4:	e75e      	b.n	8028974 <_strtod_l+0xb14>
 8028ab6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8028ab8:	f1c4 0325 	rsb	r3, r4, #37	; 0x25
 8028abc:	42b3      	cmp	r3, r6
 8028abe:	f6ff ab9f 	blt.w	8028200 <_strtod_l+0x3a0>
 8028ac2:	4d6c      	ldr	r5, [pc, #432]	; (8028c74 <_strtod_l+0xe14>)
 8028ac4:	f1c4 040f 	rsb	r4, r4, #15
 8028ac8:	eb05 01c4 	add.w	r1, r5, r4, lsl #3
 8028acc:	1b34      	subs	r4, r6, r4
 8028ace:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8028ad2:	e9d1 0100 	ldrd	r0, r1, [r1]
 8028ad6:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 8028ada:	f7e3 fcf1 	bl	800c4c0 <__aeabi_dmul>
 8028ade:	e9d5 2300 	ldrd	r2, r3, [r5]
 8028ae2:	f7e3 fced 	bl	800c4c0 <__aeabi_dmul>
 8028ae6:	4682      	mov	sl, r0
 8028ae8:	468b      	mov	fp, r1
 8028aea:	f7ff ba85 	b.w	8027ff8 <_strtod_l+0x198>
 8028aee:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 8028af2:	ed8d 7b1a 	vstr	d7, [sp, #104]	; 0x68
 8028af6:	e45e      	b.n	80283b6 <_strtod_l+0x556>
 8028af8:	ed9f 7b55 	vldr	d7, [pc, #340]	; 8028c50 <_strtod_l+0xdf0>
 8028afc:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8028b00:	e44f      	b.n	80283a2 <_strtod_l+0x542>
 8028b02:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8028b06:	f1ba 3fff 	cmp.w	sl, #4294967295
 8028b0a:	f47f ae4d 	bne.w	80287a8 <_strtod_l+0x948>
 8028b0e:	e5d0      	b.n	80286b2 <_strtod_l+0x852>
 8028b10:	9205      	str	r2, [sp, #20]
 8028b12:	2300      	movs	r3, #0
 8028b14:	e550      	b.n	80285b8 <_strtod_l+0x758>
 8028b16:	2300      	movs	r3, #0
 8028b18:	e72c      	b.n	8028974 <_strtod_l+0xb14>
 8028b1a:	ed9f 7b4f 	vldr	d7, [pc, #316]	; 8028c58 <_strtod_l+0xdf8>
 8028b1e:	ed8d 7b1c 	vstr	d7, [sp, #112]	; 0x70
 8028b22:	ed9f 7b4f 	vldr	d7, [pc, #316]	; 8028c60 <_strtod_l+0xe00>
 8028b26:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8028b2a:	e611      	b.n	8028750 <_strtod_l+0x8f0>
 8028b2c:	9912      	ldr	r1, [sp, #72]	; 0x48
 8028b2e:	4a52      	ldr	r2, [pc, #328]	; (8028c78 <_strtod_l+0xe18>)
 8028b30:	465f      	mov	r7, fp
 8028b32:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8028b36:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 8028b3a:	2900      	cmp	r1, #0
 8028b3c:	d071      	beq.n	8028c22 <_strtod_l+0xdc2>
 8028b3e:	4293      	cmp	r3, r2
 8028b40:	f000 80a0 	beq.w	8028c84 <_strtod_l+0xe24>
 8028b44:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8028b46:	2b00      	cmp	r3, #0
 8028b48:	d071      	beq.n	8028c2e <_strtod_l+0xdce>
 8028b4a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8028b4c:	4213      	tst	r3, r2
 8028b4e:	d010      	beq.n	8028b72 <_strtod_l+0xd12>
 8028b50:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028b52:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8028b54:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028b58:	2b00      	cmp	r3, #0
 8028b5a:	f000 80b5 	beq.w	8028cc8 <_strtod_l+0xe68>
 8028b5e:	f7ff f95f 	bl	8027e20 <sulp>
 8028b62:	4602      	mov	r2, r0
 8028b64:	460b      	mov	r3, r1
 8028b66:	4650      	mov	r0, sl
 8028b68:	4659      	mov	r1, fp
 8028b6a:	f7e3 faef 	bl	800c14c <__adddf3>
 8028b6e:	4682      	mov	sl, r0
 8028b70:	468b      	mov	fp, r1
 8028b72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028b74:	b193      	cbz	r3, 8028b9c <_strtod_l+0xd3c>
 8028b76:	4a41      	ldr	r2, [pc, #260]	; (8028c7c <_strtod_l+0xe1c>)
 8028b78:	2300      	movs	r3, #0
 8028b7a:	e9cd 3218 	strd	r3, r2, [sp, #96]	; 0x60
 8028b7e:	4650      	mov	r0, sl
 8028b80:	4659      	mov	r1, fp
 8028b82:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 8028b86:	f7e3 fc9b 	bl	800c4c0 <__aeabi_dmul>
 8028b8a:	4682      	mov	sl, r0
 8028b8c:	468b      	mov	fp, r1
 8028b8e:	b929      	cbnz	r1, 8028b9c <_strtod_l+0xd3c>
 8028b90:	b920      	cbnz	r0, 8028b9c <_strtod_l+0xd3c>
 8028b92:	9a08      	ldr	r2, [sp, #32]
 8028b94:	9820      	ldr	r0, [sp, #128]	; 0x80
 8028b96:	2322      	movs	r3, #34	; 0x22
 8028b98:	6013      	str	r3, [r2, #0]
 8028b9a:	e56b      	b.n	8028674 <_strtod_l+0x814>
 8028b9c:	9820      	ldr	r0, [sp, #128]	; 0x80
 8028b9e:	e569      	b.n	8028674 <_strtod_l+0x814>
 8028ba0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028ba2:	465f      	mov	r7, fp
 8028ba4:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 8028ba8:	2b00      	cmp	r3, #0
 8028baa:	d1e2      	bne.n	8028b72 <_strtod_l+0xd12>
 8028bac:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 8028bb0:	2900      	cmp	r1, #0
 8028bb2:	d1de      	bne.n	8028b72 <_strtod_l+0xd12>
 8028bb4:	f3c2 0313 	ubfx	r3, r2, #0, #20
 8028bb8:	2b00      	cmp	r3, #0
 8028bba:	d1da      	bne.n	8028b72 <_strtod_l+0xd12>
 8028bbc:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8028bc0:	0d1b      	lsrs	r3, r3, #20
 8028bc2:	051b      	lsls	r3, r3, #20
 8028bc4:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 8028bc8:	d9d3      	bls.n	8028b72 <_strtod_l+0xd12>
 8028bca:	697b      	ldr	r3, [r7, #20]
 8028bcc:	b913      	cbnz	r3, 8028bd4 <_strtod_l+0xd74>
 8028bce:	693b      	ldr	r3, [r7, #16]
 8028bd0:	2b01      	cmp	r3, #1
 8028bd2:	ddce      	ble.n	8028b72 <_strtod_l+0xd12>
 8028bd4:	4639      	mov	r1, r7
 8028bd6:	2201      	movs	r2, #1
 8028bd8:	9808      	ldr	r0, [sp, #32]
 8028bda:	f004 f901 	bl	802cde0 <__lshift>
 8028bde:	4641      	mov	r1, r8
 8028be0:	4607      	mov	r7, r0
 8028be2:	f004 f955 	bl	802ce90 <__mcmp>
 8028be6:	2800      	cmp	r0, #0
 8028be8:	ddc3      	ble.n	8028b72 <_strtod_l+0xd12>
 8028bea:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028bee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028bf0:	460a      	mov	r2, r1
 8028bf2:	2b00      	cmp	r3, #0
 8028bf4:	f000 8097 	beq.w	8028d26 <_strtod_l+0xec6>
 8028bf8:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8028bfc:	0d1b      	lsrs	r3, r3, #20
 8028bfe:	051b      	lsls	r3, r3, #20
 8028c00:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 8028c04:	f300 808f 	bgt.w	8028d26 <_strtod_l+0xec6>
 8028c08:	f1b3 7f5c 	cmp.w	r3, #57671680	; 0x3700000
 8028c0c:	dcb3      	bgt.n	8028b76 <_strtod_l+0xd16>
 8028c0e:	e675      	b.n	80288fc <_strtod_l+0xa9c>
 8028c10:	f101 7354 	add.w	r3, r1, #55574528	; 0x3500000
 8028c14:	9305      	str	r3, [sp, #20]
 8028c16:	2300      	movs	r3, #0
 8028c18:	930c      	str	r3, [sp, #48]	; 0x30
 8028c1a:	f7ff bb1a 	b.w	8028252 <_strtod_l+0x3f2>
 8028c1e:	2700      	movs	r7, #0
 8028c20:	e705      	b.n	8028a2e <_strtod_l+0xbce>
 8028c22:	2b00      	cmp	r3, #0
 8028c24:	d18e      	bne.n	8028b44 <_strtod_l+0xce4>
 8028c26:	9b04      	ldr	r3, [sp, #16]
 8028c28:	2b00      	cmp	r3, #0
 8028c2a:	d18b      	bne.n	8028b44 <_strtod_l+0xce4>
 8028c2c:	e7dd      	b.n	8028bea <_strtod_l+0xd8a>
 8028c2e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8028c30:	9a04      	ldr	r2, [sp, #16]
 8028c32:	4213      	tst	r3, r2
 8028c34:	d09d      	beq.n	8028b72 <_strtod_l+0xd12>
 8028c36:	e78b      	b.n	8028b50 <_strtod_l+0xcf0>
 8028c38:	2300      	movs	r3, #0
 8028c3a:	930c      	str	r3, [sp, #48]	; 0x30
 8028c3c:	e62f      	b.n	802889e <_strtod_l+0xa3e>
 8028c3e:	236a      	movs	r3, #106	; 0x6a
 8028c40:	2d00      	cmp	r5, #0
 8028c42:	930c      	str	r3, [sp, #48]	; 0x30
 8028c44:	f73f ae01 	bgt.w	802884a <_strtod_l+0x9ea>
 8028c48:	e615      	b.n	8028876 <_strtod_l+0xa16>
 8028c4a:	bf00      	nop
 8028c4c:	f3af 8000 	nop.w
 8028c50:	00000000 	.word	0x00000000
 8028c54:	3ff00000 	.word	0x3ff00000
 8028c58:	00000000 	.word	0x00000000
 8028c5c:	bfe00000 	.word	0xbfe00000
 8028c60:	00000000 	.word	0x00000000
 8028c64:	3fe00000 	.word	0x3fe00000
 8028c68:	7ff00000 	.word	0x7ff00000
 8028c6c:	7ca00000 	.word	0x7ca00000
 8028c70:	7fefffff 	.word	0x7fefffff
 8028c74:	08030240 	.word	0x08030240
 8028c78:	000fffff 	.word	0x000fffff
 8028c7c:	39500000 	.word	0x39500000
 8028c80:	08030210 	.word	0x08030210
 8028c84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028c86:	9904      	ldr	r1, [sp, #16]
 8028c88:	b383      	cbz	r3, 8028cec <_strtod_l+0xe8c>
 8028c8a:	4b39      	ldr	r3, [pc, #228]	; (8028d70 <_strtod_l+0xf10>)
 8028c8c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8028c8e:	4013      	ands	r3, r2
 8028c90:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
 8028c94:	d82a      	bhi.n	8028cec <_strtod_l+0xe8c>
 8028c96:	0d1b      	lsrs	r3, r3, #20
 8028c98:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8028c9c:	f04f 32ff 	mov.w	r2, #4294967295
 8028ca0:	fa02 f303 	lsl.w	r3, r2, r3
 8028ca4:	4299      	cmp	r1, r3
 8028ca6:	f47f af4d 	bne.w	8028b44 <_strtod_l+0xce4>
 8028caa:	4b32      	ldr	r3, [pc, #200]	; (8028d74 <_strtod_l+0xf14>)
 8028cac:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8028cae:	429a      	cmp	r2, r3
 8028cb0:	d050      	beq.n	8028d54 <_strtod_l+0xef4>
 8028cb2:	4b2f      	ldr	r3, [pc, #188]	; (8028d70 <_strtod_l+0xf10>)
 8028cb4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8028cb6:	401a      	ands	r2, r3
 8028cb8:	f502 1380 	add.w	r3, r2, #1048576	; 0x100000
 8028cbc:	9305      	str	r3, [sp, #20]
 8028cbe:	2300      	movs	r3, #0
 8028cc0:	9304      	str	r3, [sp, #16]
 8028cc2:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8028cc6:	e754      	b.n	8028b72 <_strtod_l+0xd12>
 8028cc8:	f7ff f8aa 	bl	8027e20 <sulp>
 8028ccc:	4602      	mov	r2, r0
 8028cce:	460b      	mov	r3, r1
 8028cd0:	4650      	mov	r0, sl
 8028cd2:	4659      	mov	r1, fp
 8028cd4:	f7e3 fa38 	bl	800c148 <__aeabi_dsub>
 8028cd8:	2200      	movs	r2, #0
 8028cda:	2300      	movs	r3, #0
 8028cdc:	4682      	mov	sl, r0
 8028cde:	468b      	mov	fp, r1
 8028ce0:	f7e3 fe5c 	bl	800c99c <__aeabi_dcmpeq>
 8028ce4:	2800      	cmp	r0, #0
 8028ce6:	f47f ae09 	bne.w	80288fc <_strtod_l+0xa9c>
 8028cea:	e742      	b.n	8028b72 <_strtod_l+0xd12>
 8028cec:	f04f 33ff 	mov.w	r3, #4294967295
 8028cf0:	e7d8      	b.n	8028ca4 <_strtod_l+0xe44>
 8028cf2:	f04f 32ff 	mov.w	r2, #4294967295
 8028cf6:	fa02 f303 	lsl.w	r3, r2, r3
 8028cfa:	9a04      	ldr	r2, [sp, #16]
 8028cfc:	401a      	ands	r2, r3
 8028cfe:	9204      	str	r2, [sp, #16]
 8028d00:	e5cd      	b.n	802889e <_strtod_l+0xa3e>
 8028d02:	a81f      	add	r0, sp, #124	; 0x7c
 8028d04:	aa22      	add	r2, sp, #136	; 0x88
 8028d06:	491c      	ldr	r1, [pc, #112]	; (8028d78 <_strtod_l+0xf18>)
 8028d08:	f003 fab2 	bl	802c270 <__hexnan>
 8028d0c:	2805      	cmp	r0, #5
 8028d0e:	f47f ac66 	bne.w	80285de <_strtod_l+0x77e>
 8028d12:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028d14:	f043 43ff 	orr.w	r3, r3, #2139095040	; 0x7f800000
 8028d18:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 8028d1c:	9305      	str	r3, [sp, #20]
 8028d1e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8028d20:	9304      	str	r3, [sp, #16]
 8028d22:	f7ff ba4f 	b.w	80281c4 <_strtod_l+0x364>
 8028d26:	4b12      	ldr	r3, [pc, #72]	; (8028d70 <_strtod_l+0xf10>)
 8028d28:	4013      	ands	r3, r2
 8028d2a:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 8028d2e:	ea6f 5313 	mvn.w	r3, r3, lsr #20
 8028d32:	ea6f 5303 	mvn.w	r3, r3, lsl #20
 8028d36:	9305      	str	r3, [sp, #20]
 8028d38:	f04f 33ff 	mov.w	r3, #4294967295
 8028d3c:	9304      	str	r3, [sp, #16]
 8028d3e:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8028d42:	e716      	b.n	8028b72 <_strtod_l+0xd12>
 8028d44:	3b20      	subs	r3, #32
 8028d46:	f04f 32ff 	mov.w	r2, #4294967295
 8028d4a:	fa02 f303 	lsl.w	r3, r2, r3
 8028d4e:	400b      	ands	r3, r1
 8028d50:	9305      	str	r3, [sp, #20]
 8028d52:	e5a4      	b.n	802889e <_strtod_l+0xa3e>
 8028d54:	3101      	adds	r1, #1
 8028d56:	d1ac      	bne.n	8028cb2 <_strtod_l+0xe52>
 8028d58:	e4ac      	b.n	80286b4 <_strtod_l+0x854>
 8028d5a:	4622      	mov	r2, r4
 8028d5c:	3401      	adds	r4, #1
 8028d5e:	e5fe      	b.n	802895e <_strtod_l+0xafe>
 8028d60:	4613      	mov	r3, r2
 8028d62:	e607      	b.n	8028974 <_strtod_l+0xb14>
 8028d64:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8028d68:	e581      	b.n	802886e <_strtod_l+0xa0e>
 8028d6a:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8028d6e:	e65e      	b.n	8028a2e <_strtod_l+0xbce>
 8028d70:	7ff00000 	.word	0x7ff00000
 8028d74:	7fefffff 	.word	0x7fefffff
 8028d78:	0802ff30 	.word	0x0802ff30
 8028d7c:	00000000 	.word	0x00000000

08028d80 <_strtod_r>:
 8028d80:	4b05      	ldr	r3, [pc, #20]	; (8028d98 <_strtod_r+0x18>)
 8028d82:	681b      	ldr	r3, [r3, #0]
 8028d84:	b410      	push	{r4}
 8028d86:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8028d88:	4c04      	ldr	r4, [pc, #16]	; (8028d9c <_strtod_r+0x1c>)
 8028d8a:	2b00      	cmp	r3, #0
 8028d8c:	bf08      	it	eq
 8028d8e:	4623      	moveq	r3, r4
 8028d90:	f85d 4b04 	ldr.w	r4, [sp], #4
 8028d94:	f7ff b864 	b.w	8027e60 <_strtod_l>
 8028d98:	20001098 	.word	0x20001098
 8028d9c:	200014c8 	.word	0x200014c8

08028da0 <_strtol_l.isra.0>:
 8028da0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028da4:	460e      	mov	r6, r1
 8028da6:	4680      	mov	r8, r0
 8028da8:	4617      	mov	r7, r2
 8028daa:	4699      	mov	r9, r3
 8028dac:	460d      	mov	r5, r1
 8028dae:	e000      	b.n	8028db2 <_strtol_l.isra.0+0x12>
 8028db0:	4625      	mov	r5, r4
 8028db2:	462c      	mov	r4, r5
 8028db4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8028db6:	f814 bb01 	ldrb.w	fp, [r4], #1
 8028dba:	f7fe ff51 	bl	8027c60 <__locale_ctype_ptr_l>
 8028dbe:	4458      	add	r0, fp
 8028dc0:	7841      	ldrb	r1, [r0, #1]
 8028dc2:	f011 0108 	ands.w	r1, r1, #8
 8028dc6:	d1f3      	bne.n	8028db0 <_strtol_l.isra.0+0x10>
 8028dc8:	f1bb 0f2d 	cmp.w	fp, #45	; 0x2d
 8028dcc:	d057      	beq.n	8028e7e <_strtol_l.isra.0+0xde>
 8028dce:	f1bb 0f2b 	cmp.w	fp, #43	; 0x2b
 8028dd2:	bf04      	itt	eq
 8028dd4:	f895 b001 	ldrbeq.w	fp, [r5, #1]
 8028dd8:	1cac      	addeq	r4, r5, #2
 8028dda:	f1b9 0f00 	cmp.w	r9, #0
 8028dde:	d004      	beq.n	8028dea <_strtol_l.isra.0+0x4a>
 8028de0:	f1b9 0f10 	cmp.w	r9, #16
 8028de4:	d050      	beq.n	8028e88 <_strtol_l.isra.0+0xe8>
 8028de6:	46cc      	mov	ip, r9
 8028de8:	e005      	b.n	8028df6 <_strtol_l.isra.0+0x56>
 8028dea:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 8028dee:	d055      	beq.n	8028e9c <_strtol_l.isra.0+0xfc>
 8028df0:	f04f 090a 	mov.w	r9, #10
 8028df4:	46cc      	mov	ip, r9
 8028df6:	2900      	cmp	r1, #0
 8028df8:	bf0c      	ite	eq
 8028dfa:	f06f 4e00 	mvneq.w	lr, #2147483648	; 0x80000000
 8028dfe:	f04f 4e00 	movne.w	lr, #2147483648	; 0x80000000
 8028e02:	2500      	movs	r5, #0
 8028e04:	fbbe f3fc 	udiv	r3, lr, ip
 8028e08:	4628      	mov	r0, r5
 8028e0a:	fb0c ea13 	mls	sl, ip, r3, lr
 8028e0e:	e005      	b.n	8028e1c <_strtol_l.isra.0+0x7c>
 8028e10:	d029      	beq.n	8028e66 <_strtol_l.isra.0+0xc6>
 8028e12:	fb0c 2000 	mla	r0, ip, r0, r2
 8028e16:	2501      	movs	r5, #1
 8028e18:	f814 bb01 	ldrb.w	fp, [r4], #1
 8028e1c:	f1ab 0230 	sub.w	r2, fp, #48	; 0x30
 8028e20:	2a09      	cmp	r2, #9
 8028e22:	d905      	bls.n	8028e30 <_strtol_l.isra.0+0x90>
 8028e24:	f1ab 0241 	sub.w	r2, fp, #65	; 0x41
 8028e28:	2a19      	cmp	r2, #25
 8028e2a:	d80b      	bhi.n	8028e44 <_strtol_l.isra.0+0xa4>
 8028e2c:	f1ab 0237 	sub.w	r2, fp, #55	; 0x37
 8028e30:	4591      	cmp	r9, r2
 8028e32:	dd0f      	ble.n	8028e54 <_strtol_l.isra.0+0xb4>
 8028e34:	f1b5 3fff 	cmp.w	r5, #4294967295
 8028e38:	d0ee      	beq.n	8028e18 <_strtol_l.isra.0+0x78>
 8028e3a:	4283      	cmp	r3, r0
 8028e3c:	d2e8      	bcs.n	8028e10 <_strtol_l.isra.0+0x70>
 8028e3e:	f04f 35ff 	mov.w	r5, #4294967295
 8028e42:	e7e9      	b.n	8028e18 <_strtol_l.isra.0+0x78>
 8028e44:	f1ab 0261 	sub.w	r2, fp, #97	; 0x61
 8028e48:	2a19      	cmp	r2, #25
 8028e4a:	d803      	bhi.n	8028e54 <_strtol_l.isra.0+0xb4>
 8028e4c:	f1ab 0257 	sub.w	r2, fp, #87	; 0x57
 8028e50:	4591      	cmp	r9, r2
 8028e52:	dcef      	bgt.n	8028e34 <_strtol_l.isra.0+0x94>
 8028e54:	1c6b      	adds	r3, r5, #1
 8028e56:	d00b      	beq.n	8028e70 <_strtol_l.isra.0+0xd0>
 8028e58:	b101      	cbz	r1, 8028e5c <_strtol_l.isra.0+0xbc>
 8028e5a:	4240      	negs	r0, r0
 8028e5c:	b10f      	cbz	r7, 8028e62 <_strtol_l.isra.0+0xc2>
 8028e5e:	bb4d      	cbnz	r5, 8028eb4 <_strtol_l.isra.0+0x114>
 8028e60:	603e      	str	r6, [r7, #0]
 8028e62:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028e66:	4592      	cmp	sl, r2
 8028e68:	dad3      	bge.n	8028e12 <_strtol_l.isra.0+0x72>
 8028e6a:	f04f 35ff 	mov.w	r5, #4294967295
 8028e6e:	e7d3      	b.n	8028e18 <_strtol_l.isra.0+0x78>
 8028e70:	2322      	movs	r3, #34	; 0x22
 8028e72:	f8c8 3000 	str.w	r3, [r8]
 8028e76:	b1ff      	cbz	r7, 8028eb8 <_strtol_l.isra.0+0x118>
 8028e78:	1e66      	subs	r6, r4, #1
 8028e7a:	4670      	mov	r0, lr
 8028e7c:	e7f0      	b.n	8028e60 <_strtol_l.isra.0+0xc0>
 8028e7e:	1cac      	adds	r4, r5, #2
 8028e80:	f895 b001 	ldrb.w	fp, [r5, #1]
 8028e84:	2101      	movs	r1, #1
 8028e86:	e7a8      	b.n	8028dda <_strtol_l.isra.0+0x3a>
 8028e88:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 8028e8c:	d1ab      	bne.n	8028de6 <_strtol_l.isra.0+0x46>
 8028e8e:	7823      	ldrb	r3, [r4, #0]
 8028e90:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8028e94:	2b58      	cmp	r3, #88	; 0x58
 8028e96:	d006      	beq.n	8028ea6 <_strtol_l.isra.0+0x106>
 8028e98:	46cc      	mov	ip, r9
 8028e9a:	e7ac      	b.n	8028df6 <_strtol_l.isra.0+0x56>
 8028e9c:	7823      	ldrb	r3, [r4, #0]
 8028e9e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8028ea2:	2b58      	cmp	r3, #88	; 0x58
 8028ea4:	d10a      	bne.n	8028ebc <_strtol_l.isra.0+0x11c>
 8028ea6:	f04f 0c10 	mov.w	ip, #16
 8028eaa:	f894 b001 	ldrb.w	fp, [r4, #1]
 8028eae:	46e1      	mov	r9, ip
 8028eb0:	3402      	adds	r4, #2
 8028eb2:	e7a0      	b.n	8028df6 <_strtol_l.isra.0+0x56>
 8028eb4:	4686      	mov	lr, r0
 8028eb6:	e7df      	b.n	8028e78 <_strtol_l.isra.0+0xd8>
 8028eb8:	4670      	mov	r0, lr
 8028eba:	e7d2      	b.n	8028e62 <_strtol_l.isra.0+0xc2>
 8028ebc:	f04f 0908 	mov.w	r9, #8
 8028ec0:	46cc      	mov	ip, r9
 8028ec2:	e798      	b.n	8028df6 <_strtol_l.isra.0+0x56>
	...

08028ed0 <_strtol_r>:
 8028ed0:	b530      	push	{r4, r5, lr}
 8028ed2:	4c06      	ldr	r4, [pc, #24]	; (8028eec <_strtol_r+0x1c>)
 8028ed4:	4d06      	ldr	r5, [pc, #24]	; (8028ef0 <_strtol_r+0x20>)
 8028ed6:	6824      	ldr	r4, [r4, #0]
 8028ed8:	6b64      	ldr	r4, [r4, #52]	; 0x34
 8028eda:	b083      	sub	sp, #12
 8028edc:	2c00      	cmp	r4, #0
 8028ede:	bf08      	it	eq
 8028ee0:	462c      	moveq	r4, r5
 8028ee2:	9400      	str	r4, [sp, #0]
 8028ee4:	f7ff ff5c 	bl	8028da0 <_strtol_l.isra.0>
 8028ee8:	b003      	add	sp, #12
 8028eea:	bd30      	pop	{r4, r5, pc}
 8028eec:	20001098 	.word	0x20001098
 8028ef0:	200014c8 	.word	0x200014c8
	...

08028f00 <_strtoll_l.isra.0>:
 8028f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028f04:	b089      	sub	sp, #36	; 0x24
 8028f06:	e9cd 1006 	strd	r1, r0, [sp, #24]
 8028f0a:	9203      	str	r2, [sp, #12]
 8028f0c:	461f      	mov	r7, r3
 8028f0e:	468a      	mov	sl, r1
 8028f10:	e000      	b.n	8028f14 <_strtoll_l.isra.0+0x14>
 8028f12:	46aa      	mov	sl, r5
 8028f14:	4655      	mov	r5, sl
 8028f16:	9812      	ldr	r0, [sp, #72]	; 0x48
 8028f18:	f815 4b01 	ldrb.w	r4, [r5], #1
 8028f1c:	f7fe fea0 	bl	8027c60 <__locale_ctype_ptr_l>
 8028f20:	4420      	add	r0, r4
 8028f22:	7846      	ldrb	r6, [r0, #1]
 8028f24:	f016 0608 	ands.w	r6, r6, #8
 8028f28:	d1f3      	bne.n	8028f12 <_strtoll_l.isra.0+0x12>
 8028f2a:	2c2d      	cmp	r4, #45	; 0x2d
 8028f2c:	f000 8089 	beq.w	8029042 <_strtoll_l.isra.0+0x142>
 8028f30:	2c2b      	cmp	r4, #43	; 0x2b
 8028f32:	bf04      	itt	eq
 8028f34:	f89a 4001 	ldrbeq.w	r4, [sl, #1]
 8028f38:	f10a 0502 	addeq.w	r5, sl, #2
 8028f3c:	2f00      	cmp	r7, #0
 8028f3e:	d046      	beq.n	8028fce <_strtoll_l.isra.0+0xce>
 8028f40:	2f10      	cmp	r7, #16
 8028f42:	f000 8084 	beq.w	802904e <_strtoll_l.isra.0+0x14e>
 8028f46:	46ba      	mov	sl, r7
 8028f48:	ea4f 7be7 	mov.w	fp, r7, asr #31
 8028f4c:	2e00      	cmp	r6, #0
 8028f4e:	d047      	beq.n	8028fe0 <_strtoll_l.isra.0+0xe0>
 8028f50:	2100      	movs	r1, #0
 8028f52:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8028f56:	e9cd 1304 	strd	r1, r3, [sp, #16]
 8028f5a:	4652      	mov	r2, sl
 8028f5c:	465b      	mov	r3, fp
 8028f5e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028f62:	f7e4 f8cd 	bl	800d100 <__aeabi_uldivmod>
 8028f66:	4680      	mov	r8, r0
 8028f68:	4689      	mov	r9, r1
 8028f6a:	f04f 0c00 	mov.w	ip, #0
 8028f6e:	2000      	movs	r0, #0
 8028f70:	2100      	movs	r1, #0
 8028f72:	e9cd 8900 	strd	r8, r9, [sp]
 8028f76:	e012      	b.n	8028f9e <_strtoll_l.isra.0+0x9e>
 8028f78:	d054      	beq.n	8029024 <_strtoll_l.isra.0+0x124>
 8028f7a:	4689      	mov	r9, r1
 8028f7c:	fb00 f40b 	mul.w	r4, r0, fp
 8028f80:	fb0a 4409 	mla	r4, sl, r9, r4
 8028f84:	fba0 010a 	umull	r0, r1, r0, sl
 8028f88:	4421      	add	r1, r4
 8028f8a:	eb10 0803 	adds.w	r8, r0, r3
 8028f8e:	eb41 79e3 	adc.w	r9, r1, r3, asr #31
 8028f92:	4640      	mov	r0, r8
 8028f94:	4649      	mov	r1, r9
 8028f96:	f04f 0c01 	mov.w	ip, #1
 8028f9a:	f815 4b01 	ldrb.w	r4, [r5], #1
 8028f9e:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 8028fa2:	2b09      	cmp	r3, #9
 8028fa4:	d905      	bls.n	8028fb2 <_strtoll_l.isra.0+0xb2>
 8028fa6:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8028faa:	2b19      	cmp	r3, #25
 8028fac:	d81f      	bhi.n	8028fee <_strtoll_l.isra.0+0xee>
 8028fae:	f1a4 0337 	sub.w	r3, r4, #55	; 0x37
 8028fb2:	429f      	cmp	r7, r3
 8028fb4:	dd23      	ble.n	8028ffe <_strtoll_l.isra.0+0xfe>
 8028fb6:	f1bc 3fff 	cmp.w	ip, #4294967295
 8028fba:	d0ee      	beq.n	8028f9a <_strtoll_l.isra.0+0x9a>
 8028fbc:	e9dd 8900 	ldrd	r8, r9, [sp]
 8028fc0:	4589      	cmp	r9, r1
 8028fc2:	bf08      	it	eq
 8028fc4:	4580      	cmpeq	r8, r0
 8028fc6:	d2d7      	bcs.n	8028f78 <_strtoll_l.isra.0+0x78>
 8028fc8:	f04f 3cff 	mov.w	ip, #4294967295
 8028fcc:	e7e5      	b.n	8028f9a <_strtoll_l.isra.0+0x9a>
 8028fce:	2c30      	cmp	r4, #48	; 0x30
 8028fd0:	d044      	beq.n	802905c <_strtoll_l.isra.0+0x15c>
 8028fd2:	f04f 0a0a 	mov.w	sl, #10
 8028fd6:	f04f 0b00 	mov.w	fp, #0
 8028fda:	270a      	movs	r7, #10
 8028fdc:	2e00      	cmp	r6, #0
 8028fde:	d1b7      	bne.n	8028f50 <_strtoll_l.isra.0+0x50>
 8028fe0:	f04f 32ff 	mov.w	r2, #4294967295
 8028fe4:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8028fe8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8028fec:	e7b5      	b.n	8028f5a <_strtoll_l.isra.0+0x5a>
 8028fee:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8028ff2:	2b19      	cmp	r3, #25
 8028ff4:	d803      	bhi.n	8028ffe <_strtoll_l.isra.0+0xfe>
 8028ff6:	f1a4 0357 	sub.w	r3, r4, #87	; 0x57
 8028ffa:	429f      	cmp	r7, r3
 8028ffc:	dcdb      	bgt.n	8028fb6 <_strtoll_l.isra.0+0xb6>
 8028ffe:	f1bc 3fff 	cmp.w	ip, #4294967295
 8029002:	d014      	beq.n	802902e <_strtoll_l.isra.0+0x12e>
 8029004:	b116      	cbz	r6, 802900c <_strtoll_l.isra.0+0x10c>
 8029006:	4240      	negs	r0, r0
 8029008:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802900c:	9b03      	ldr	r3, [sp, #12]
 802900e:	b133      	cbz	r3, 802901e <_strtoll_l.isra.0+0x11e>
 8029010:	f1bc 0f00 	cmp.w	ip, #0
 8029014:	d12f      	bne.n	8029076 <_strtoll_l.isra.0+0x176>
 8029016:	9b03      	ldr	r3, [sp, #12]
 8029018:	461a      	mov	r2, r3
 802901a:	9b06      	ldr	r3, [sp, #24]
 802901c:	6013      	str	r3, [r2, #0]
 802901e:	b009      	add	sp, #36	; 0x24
 8029020:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029024:	429a      	cmp	r2, r3
 8029026:	daa8      	bge.n	8028f7a <_strtoll_l.isra.0+0x7a>
 8029028:	f04f 3cff 	mov.w	ip, #4294967295
 802902c:	e7b5      	b.n	8028f9a <_strtoll_l.isra.0+0x9a>
 802902e:	9a07      	ldr	r2, [sp, #28]
 8029030:	2322      	movs	r3, #34	; 0x22
 8029032:	6013      	str	r3, [r2, #0]
 8029034:	9b03      	ldr	r3, [sp, #12]
 8029036:	b30b      	cbz	r3, 802907c <_strtoll_l.isra.0+0x17c>
 8029038:	1e6b      	subs	r3, r5, #1
 802903a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802903e:	9306      	str	r3, [sp, #24]
 8029040:	e7e9      	b.n	8029016 <_strtoll_l.isra.0+0x116>
 8029042:	f10a 0502 	add.w	r5, sl, #2
 8029046:	f89a 4001 	ldrb.w	r4, [sl, #1]
 802904a:	2601      	movs	r6, #1
 802904c:	e776      	b.n	8028f3c <_strtoll_l.isra.0+0x3c>
 802904e:	2c30      	cmp	r4, #48	; 0x30
 8029050:	d017      	beq.n	8029082 <_strtoll_l.isra.0+0x182>
 8029052:	f04f 0a10 	mov.w	sl, #16
 8029056:	f04f 0b00 	mov.w	fp, #0
 802905a:	e777      	b.n	8028f4c <_strtoll_l.isra.0+0x4c>
 802905c:	782b      	ldrb	r3, [r5, #0]
 802905e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8029062:	2b58      	cmp	r3, #88	; 0x58
 8029064:	d113      	bne.n	802908e <_strtoll_l.isra.0+0x18e>
 8029066:	786c      	ldrb	r4, [r5, #1]
 8029068:	f04f 0a10 	mov.w	sl, #16
 802906c:	f04f 0b00 	mov.w	fp, #0
 8029070:	3502      	adds	r5, #2
 8029072:	2710      	movs	r7, #16
 8029074:	e76a      	b.n	8028f4c <_strtoll_l.isra.0+0x4c>
 8029076:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802907a:	e7dd      	b.n	8029038 <_strtoll_l.isra.0+0x138>
 802907c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8029080:	e7cd      	b.n	802901e <_strtoll_l.isra.0+0x11e>
 8029082:	782b      	ldrb	r3, [r5, #0]
 8029084:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8029088:	2b58      	cmp	r3, #88	; 0x58
 802908a:	d1e2      	bne.n	8029052 <_strtoll_l.isra.0+0x152>
 802908c:	e7eb      	b.n	8029066 <_strtoll_l.isra.0+0x166>
 802908e:	f04f 0a08 	mov.w	sl, #8
 8029092:	f04f 0b00 	mov.w	fp, #0
 8029096:	2708      	movs	r7, #8
 8029098:	e758      	b.n	8028f4c <_strtoll_l.isra.0+0x4c>
 802909a:	bf00      	nop
 802909c:	0000      	movs	r0, r0
	...

080290a0 <_strtoll_r>:
 80290a0:	b530      	push	{r4, r5, lr}
 80290a2:	4c06      	ldr	r4, [pc, #24]	; (80290bc <_strtoll_r+0x1c>)
 80290a4:	4d06      	ldr	r5, [pc, #24]	; (80290c0 <_strtoll_r+0x20>)
 80290a6:	6824      	ldr	r4, [r4, #0]
 80290a8:	6b64      	ldr	r4, [r4, #52]	; 0x34
 80290aa:	b083      	sub	sp, #12
 80290ac:	2c00      	cmp	r4, #0
 80290ae:	bf08      	it	eq
 80290b0:	462c      	moveq	r4, r5
 80290b2:	9400      	str	r4, [sp, #0]
 80290b4:	f7ff ff24 	bl	8028f00 <_strtoll_l.isra.0>
 80290b8:	b003      	add	sp, #12
 80290ba:	bd30      	pop	{r4, r5, pc}
 80290bc:	20001098 	.word	0x20001098
 80290c0:	200014c8 	.word	0x200014c8
	...

080290d0 <_strtoul_l.isra.0>:
 80290d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80290d4:	460d      	mov	r5, r1
 80290d6:	4607      	mov	r7, r0
 80290d8:	4616      	mov	r6, r2
 80290da:	4698      	mov	r8, r3
 80290dc:	468a      	mov	sl, r1
 80290de:	e000      	b.n	80290e2 <_strtoul_l.isra.0+0x12>
 80290e0:	46a2      	mov	sl, r4
 80290e2:	4654      	mov	r4, sl
 80290e4:	9808      	ldr	r0, [sp, #32]
 80290e6:	f814 9b01 	ldrb.w	r9, [r4], #1
 80290ea:	f7fe fdb9 	bl	8027c60 <__locale_ctype_ptr_l>
 80290ee:	4448      	add	r0, r9
 80290f0:	7840      	ldrb	r0, [r0, #1]
 80290f2:	f010 0008 	ands.w	r0, r0, #8
 80290f6:	d1f3      	bne.n	80290e0 <_strtoul_l.isra.0+0x10>
 80290f8:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 80290fc:	d05c      	beq.n	80291b8 <_strtoul_l.isra.0+0xe8>
 80290fe:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 8029102:	bf0a      	itet	eq
 8029104:	f89a 1001 	ldrbeq.w	r1, [sl, #1]
 8029108:	4649      	movne	r1, r9
 802910a:	f10a 0402 	addeq.w	r4, sl, #2
 802910e:	f1b8 0f00 	cmp.w	r8, #0
 8029112:	d00c      	beq.n	802912e <_strtoul_l.isra.0+0x5e>
 8029114:	f1b8 0f10 	cmp.w	r8, #16
 8029118:	d054      	beq.n	80291c4 <_strtoul_l.isra.0+0xf4>
 802911a:	f04f 3eff 	mov.w	lr, #4294967295
 802911e:	fbbe fef8 	udiv	lr, lr, r8
 8029122:	fb08 fa0e 	mul.w	sl, r8, lr
 8029126:	ea6f 0a0a 	mvn.w	sl, sl
 802912a:	46c1      	mov	r9, r8
 802912c:	e008      	b.n	8029140 <_strtoul_l.isra.0+0x70>
 802912e:	2930      	cmp	r1, #48	; 0x30
 8029130:	d050      	beq.n	80291d4 <_strtoul_l.isra.0+0x104>
 8029132:	f04f 080a 	mov.w	r8, #10
 8029136:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 8029218 <_strtoul_l.isra.0+0x148>
 802913a:	46c1      	mov	r9, r8
 802913c:	f04f 0a05 	mov.w	sl, #5
 8029140:	2300      	movs	r3, #0
 8029142:	469c      	mov	ip, r3
 8029144:	e007      	b.n	8029156 <_strtoul_l.isra.0+0x86>
 8029146:	45f4      	cmp	ip, lr
 8029148:	d813      	bhi.n	8029172 <_strtoul_l.isra.0+0xa2>
 802914a:	d028      	beq.n	802919e <_strtoul_l.isra.0+0xce>
 802914c:	fb09 2c0c 	mla	ip, r9, ip, r2
 8029150:	2301      	movs	r3, #1
 8029152:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029156:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 802915a:	2a09      	cmp	r2, #9
 802915c:	d905      	bls.n	802916a <_strtoul_l.isra.0+0x9a>
 802915e:	f1a1 0241 	sub.w	r2, r1, #65	; 0x41
 8029162:	2a19      	cmp	r2, #25
 8029164:	d808      	bhi.n	8029178 <_strtoul_l.isra.0+0xa8>
 8029166:	f1a1 0237 	sub.w	r2, r1, #55	; 0x37
 802916a:	4590      	cmp	r8, r2
 802916c:	dd0c      	ble.n	8029188 <_strtoul_l.isra.0+0xb8>
 802916e:	2b00      	cmp	r3, #0
 8029170:	dae9      	bge.n	8029146 <_strtoul_l.isra.0+0x76>
 8029172:	f04f 33ff 	mov.w	r3, #4294967295
 8029176:	e7ec      	b.n	8029152 <_strtoul_l.isra.0+0x82>
 8029178:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 802917c:	2a19      	cmp	r2, #25
 802917e:	d803      	bhi.n	8029188 <_strtoul_l.isra.0+0xb8>
 8029180:	f1a1 0257 	sub.w	r2, r1, #87	; 0x57
 8029184:	4590      	cmp	r8, r2
 8029186:	dcf2      	bgt.n	802916e <_strtoul_l.isra.0+0x9e>
 8029188:	2b00      	cmp	r3, #0
 802918a:	db0d      	blt.n	80291a8 <_strtoul_l.isra.0+0xd8>
 802918c:	b108      	cbz	r0, 8029192 <_strtoul_l.isra.0+0xc2>
 802918e:	f1cc 0c00 	rsb	ip, ip, #0
 8029192:	b10e      	cbz	r6, 8029198 <_strtoul_l.isra.0+0xc8>
 8029194:	b973      	cbnz	r3, 80291b4 <_strtoul_l.isra.0+0xe4>
 8029196:	6035      	str	r5, [r6, #0]
 8029198:	4660      	mov	r0, ip
 802919a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802919e:	4552      	cmp	r2, sl
 80291a0:	ddd4      	ble.n	802914c <_strtoul_l.isra.0+0x7c>
 80291a2:	f04f 33ff 	mov.w	r3, #4294967295
 80291a6:	e7d4      	b.n	8029152 <_strtoul_l.isra.0+0x82>
 80291a8:	2322      	movs	r3, #34	; 0x22
 80291aa:	603b      	str	r3, [r7, #0]
 80291ac:	f04f 3cff 	mov.w	ip, #4294967295
 80291b0:	2e00      	cmp	r6, #0
 80291b2:	d0f1      	beq.n	8029198 <_strtoul_l.isra.0+0xc8>
 80291b4:	1e65      	subs	r5, r4, #1
 80291b6:	e7ee      	b.n	8029196 <_strtoul_l.isra.0+0xc6>
 80291b8:	f10a 0402 	add.w	r4, sl, #2
 80291bc:	f89a 1001 	ldrb.w	r1, [sl, #1]
 80291c0:	2001      	movs	r0, #1
 80291c2:	e7a4      	b.n	802910e <_strtoul_l.isra.0+0x3e>
 80291c4:	2930      	cmp	r1, #48	; 0x30
 80291c6:	d012      	beq.n	80291ee <_strtoul_l.isra.0+0x11e>
 80291c8:	f04f 0a0f 	mov.w	sl, #15
 80291cc:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
 80291d0:	46c1      	mov	r9, r8
 80291d2:	e7b5      	b.n	8029140 <_strtoul_l.isra.0+0x70>
 80291d4:	7823      	ldrb	r3, [r4, #0]
 80291d6:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80291da:	2b58      	cmp	r3, #88	; 0x58
 80291dc:	d00c      	beq.n	80291f8 <_strtoul_l.isra.0+0x128>
 80291de:	f04f 0808 	mov.w	r8, #8
 80291e2:	46c1      	mov	r9, r8
 80291e4:	f04f 0a07 	mov.w	sl, #7
 80291e8:	f06f 4e60 	mvn.w	lr, #3758096384	; 0xe0000000
 80291ec:	e7a8      	b.n	8029140 <_strtoul_l.isra.0+0x70>
 80291ee:	7823      	ldrb	r3, [r4, #0]
 80291f0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80291f4:	2b58      	cmp	r3, #88	; 0x58
 80291f6:	d109      	bne.n	802920c <_strtoul_l.isra.0+0x13c>
 80291f8:	f04f 0910 	mov.w	r9, #16
 80291fc:	7861      	ldrb	r1, [r4, #1]
 80291fe:	46c8      	mov	r8, r9
 8029200:	f04f 0a0f 	mov.w	sl, #15
 8029204:	3402      	adds	r4, #2
 8029206:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
 802920a:	e799      	b.n	8029140 <_strtoul_l.isra.0+0x70>
 802920c:	46c1      	mov	r9, r8
 802920e:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
 8029212:	f04f 0a0f 	mov.w	sl, #15
 8029216:	e793      	b.n	8029140 <_strtoul_l.isra.0+0x70>
 8029218:	19999999 	.word	0x19999999
 802921c:	00000000 	.word	0x00000000

08029220 <_strtoul_r>:
 8029220:	b530      	push	{r4, r5, lr}
 8029222:	4c06      	ldr	r4, [pc, #24]	; (802923c <_strtoul_r+0x1c>)
 8029224:	4d06      	ldr	r5, [pc, #24]	; (8029240 <_strtoul_r+0x20>)
 8029226:	6824      	ldr	r4, [r4, #0]
 8029228:	6b64      	ldr	r4, [r4, #52]	; 0x34
 802922a:	b083      	sub	sp, #12
 802922c:	2c00      	cmp	r4, #0
 802922e:	bf08      	it	eq
 8029230:	462c      	moveq	r4, r5
 8029232:	9400      	str	r4, [sp, #0]
 8029234:	f7ff ff4c 	bl	80290d0 <_strtoul_l.isra.0>
 8029238:	b003      	add	sp, #12
 802923a:	bd30      	pop	{r4, r5, pc}
 802923c:	20001098 	.word	0x20001098
 8029240:	200014c8 	.word	0x200014c8
	...

08029250 <_strtoull_l.isra.0>:
 8029250:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029254:	b087      	sub	sp, #28
 8029256:	460f      	mov	r7, r1
 8029258:	9005      	str	r0, [sp, #20]
 802925a:	9203      	str	r2, [sp, #12]
 802925c:	461e      	mov	r6, r3
 802925e:	4688      	mov	r8, r1
 8029260:	e000      	b.n	8029264 <_strtoull_l.isra.0+0x14>
 8029262:	46a8      	mov	r8, r5
 8029264:	4645      	mov	r5, r8
 8029266:	9810      	ldr	r0, [sp, #64]	; 0x40
 8029268:	f815 4b01 	ldrb.w	r4, [r5], #1
 802926c:	f7fe fcf8 	bl	8027c60 <__locale_ctype_ptr_l>
 8029270:	4420      	add	r0, r4
 8029272:	f890 b001 	ldrb.w	fp, [r0, #1]
 8029276:	f01b 0b08 	ands.w	fp, fp, #8
 802927a:	d1f2      	bne.n	8029262 <_strtoull_l.isra.0+0x12>
 802927c:	2c2d      	cmp	r4, #45	; 0x2d
 802927e:	f000 8091 	beq.w	80293a4 <_strtoull_l.isra.0+0x154>
 8029282:	2c2b      	cmp	r4, #43	; 0x2b
 8029284:	bf09      	itett	eq
 8029286:	f898 4001 	ldrbeq.w	r4, [r8, #1]
 802928a:	f8cd b010 	strne.w	fp, [sp, #16]
 802928e:	f8cd b010 	streq.w	fp, [sp, #16]
 8029292:	f108 0502 	addeq.w	r5, r8, #2
 8029296:	b1c6      	cbz	r6, 80292ca <_strtoull_l.isra.0+0x7a>
 8029298:	2e10      	cmp	r6, #16
 802929a:	f000 808a 	beq.w	80293b2 <_strtoull_l.isra.0+0x162>
 802929e:	46b2      	mov	sl, r6
 80292a0:	ea4f 7be6 	mov.w	fp, r6, asr #31
 80292a4:	4652      	mov	r2, sl
 80292a6:	465b      	mov	r3, fp
 80292a8:	f04f 30ff 	mov.w	r0, #4294967295
 80292ac:	f04f 31ff 	mov.w	r1, #4294967295
 80292b0:	f7e3 ff26 	bl	800d100 <__aeabi_uldivmod>
 80292b4:	4652      	mov	r2, sl
 80292b6:	4680      	mov	r8, r0
 80292b8:	4689      	mov	r9, r1
 80292ba:	465b      	mov	r3, fp
 80292bc:	f04f 30ff 	mov.w	r0, #4294967295
 80292c0:	f04f 31ff 	mov.w	r1, #4294967295
 80292c4:	f7e3 ff1c 	bl	800d100 <__aeabi_uldivmod>
 80292c8:	e00b      	b.n	80292e2 <_strtoull_l.isra.0+0x92>
 80292ca:	2c30      	cmp	r4, #48	; 0x30
 80292cc:	d07d      	beq.n	80293ca <_strtoull_l.isra.0+0x17a>
 80292ce:	f8df 9148 	ldr.w	r9, [pc, #328]	; 8029418 <_strtoull_l.isra.0+0x1c8>
 80292d2:	2205      	movs	r2, #5
 80292d4:	f04f 3899 	mov.w	r8, #2576980377	; 0x99999999
 80292d8:	f04f 0a0a 	mov.w	sl, #10
 80292dc:	f04f 0b00 	mov.w	fp, #0
 80292e0:	260a      	movs	r6, #10
 80292e2:	f04f 0c00 	mov.w	ip, #0
 80292e6:	2000      	movs	r0, #0
 80292e8:	2100      	movs	r1, #0
 80292ea:	e9cd ab00 	strd	sl, fp, [sp]
 80292ee:	e01c      	b.n	802932a <_strtoull_l.isra.0+0xda>
 80292f0:	4589      	cmp	r9, r1
 80292f2:	bf08      	it	eq
 80292f4:	4580      	cmpeq	r8, r0
 80292f6:	d327      	bcc.n	8029348 <_strtoull_l.isra.0+0xf8>
 80292f8:	4549      	cmp	r1, r9
 80292fa:	bf08      	it	eq
 80292fc:	4540      	cmpeq	r0, r8
 80292fe:	d040      	beq.n	8029382 <_strtoull_l.isra.0+0x132>
 8029300:	4682      	mov	sl, r0
 8029302:	9801      	ldr	r0, [sp, #4]
 8029304:	fb0a f400 	mul.w	r4, sl, r0
 8029308:	9800      	ldr	r0, [sp, #0]
 802930a:	468b      	mov	fp, r1
 802930c:	fb00 440b 	mla	r4, r0, fp, r4
 8029310:	fbaa 0100 	umull	r0, r1, sl, r0
 8029314:	4421      	add	r1, r4
 8029316:	eb10 0a03 	adds.w	sl, r0, r3
 802931a:	eb41 7be3 	adc.w	fp, r1, r3, asr #31
 802931e:	4650      	mov	r0, sl
 8029320:	4659      	mov	r1, fp
 8029322:	f04f 0c01 	mov.w	ip, #1
 8029326:	f815 4b01 	ldrb.w	r4, [r5], #1
 802932a:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 802932e:	2b09      	cmp	r3, #9
 8029330:	d905      	bls.n	802933e <_strtoull_l.isra.0+0xee>
 8029332:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8029336:	2b19      	cmp	r3, #25
 8029338:	d809      	bhi.n	802934e <_strtoull_l.isra.0+0xfe>
 802933a:	f1a4 0337 	sub.w	r3, r4, #55	; 0x37
 802933e:	429e      	cmp	r6, r3
 8029340:	dd0d      	ble.n	802935e <_strtoull_l.isra.0+0x10e>
 8029342:	f1bc 0f00 	cmp.w	ip, #0
 8029346:	dad3      	bge.n	80292f0 <_strtoull_l.isra.0+0xa0>
 8029348:	f04f 3cff 	mov.w	ip, #4294967295
 802934c:	e7eb      	b.n	8029326 <_strtoull_l.isra.0+0xd6>
 802934e:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8029352:	2b19      	cmp	r3, #25
 8029354:	d803      	bhi.n	802935e <_strtoull_l.isra.0+0x10e>
 8029356:	f1a4 0357 	sub.w	r3, r4, #87	; 0x57
 802935a:	429e      	cmp	r6, r3
 802935c:	dcf1      	bgt.n	8029342 <_strtoull_l.isra.0+0xf2>
 802935e:	f1bc 0f00 	cmp.w	ip, #0
 8029362:	db13      	blt.n	802938c <_strtoull_l.isra.0+0x13c>
 8029364:	9b04      	ldr	r3, [sp, #16]
 8029366:	b113      	cbz	r3, 802936e <_strtoull_l.isra.0+0x11e>
 8029368:	4240      	negs	r0, r0
 802936a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802936e:	9b03      	ldr	r3, [sp, #12]
 8029370:	b123      	cbz	r3, 802937c <_strtoull_l.isra.0+0x12c>
 8029372:	f1bc 0f00 	cmp.w	ip, #0
 8029376:	d113      	bne.n	80293a0 <_strtoull_l.isra.0+0x150>
 8029378:	9b03      	ldr	r3, [sp, #12]
 802937a:	601f      	str	r7, [r3, #0]
 802937c:	b007      	add	sp, #28
 802937e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029382:	4293      	cmp	r3, r2
 8029384:	ddbc      	ble.n	8029300 <_strtoull_l.isra.0+0xb0>
 8029386:	f04f 3cff 	mov.w	ip, #4294967295
 802938a:	e7cc      	b.n	8029326 <_strtoull_l.isra.0+0xd6>
 802938c:	9a05      	ldr	r2, [sp, #20]
 802938e:	2322      	movs	r3, #34	; 0x22
 8029390:	6013      	str	r3, [r2, #0]
 8029392:	9b03      	ldr	r3, [sp, #12]
 8029394:	f04f 30ff 	mov.w	r0, #4294967295
 8029398:	f04f 31ff 	mov.w	r1, #4294967295
 802939c:	2b00      	cmp	r3, #0
 802939e:	d0ed      	beq.n	802937c <_strtoull_l.isra.0+0x12c>
 80293a0:	1e6f      	subs	r7, r5, #1
 80293a2:	e7e9      	b.n	8029378 <_strtoull_l.isra.0+0x128>
 80293a4:	2301      	movs	r3, #1
 80293a6:	f108 0502 	add.w	r5, r8, #2
 80293aa:	f898 4001 	ldrb.w	r4, [r8, #1]
 80293ae:	9304      	str	r3, [sp, #16]
 80293b0:	e771      	b.n	8029296 <_strtoull_l.isra.0+0x46>
 80293b2:	2c30      	cmp	r4, #48	; 0x30
 80293b4:	d019      	beq.n	80293ea <_strtoull_l.isra.0+0x19a>
 80293b6:	220f      	movs	r2, #15
 80293b8:	f04f 38ff 	mov.w	r8, #4294967295
 80293bc:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 80293c0:	f04f 0a10 	mov.w	sl, #16
 80293c4:	f04f 0b00 	mov.w	fp, #0
 80293c8:	e78b      	b.n	80292e2 <_strtoull_l.isra.0+0x92>
 80293ca:	782b      	ldrb	r3, [r5, #0]
 80293cc:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80293d0:	2b58      	cmp	r3, #88	; 0x58
 80293d2:	d00f      	beq.n	80293f4 <_strtoull_l.isra.0+0x1a4>
 80293d4:	2207      	movs	r2, #7
 80293d6:	f04f 38ff 	mov.w	r8, #4294967295
 80293da:	f06f 4960 	mvn.w	r9, #3758096384	; 0xe0000000
 80293de:	f04f 0a08 	mov.w	sl, #8
 80293e2:	f04f 0b00 	mov.w	fp, #0
 80293e6:	2608      	movs	r6, #8
 80293e8:	e77b      	b.n	80292e2 <_strtoull_l.isra.0+0x92>
 80293ea:	782b      	ldrb	r3, [r5, #0]
 80293ec:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80293f0:	2b58      	cmp	r3, #88	; 0x58
 80293f2:	d10c      	bne.n	802940e <_strtoull_l.isra.0+0x1be>
 80293f4:	786c      	ldrb	r4, [r5, #1]
 80293f6:	220f      	movs	r2, #15
 80293f8:	3502      	adds	r5, #2
 80293fa:	f04f 38ff 	mov.w	r8, #4294967295
 80293fe:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
 8029402:	f04f 0a10 	mov.w	sl, #16
 8029406:	f04f 0b00 	mov.w	fp, #0
 802940a:	2610      	movs	r6, #16
 802940c:	e769      	b.n	80292e2 <_strtoull_l.isra.0+0x92>
 802940e:	f04f 0a10 	mov.w	sl, #16
 8029412:	f04f 0b00 	mov.w	fp, #0
 8029416:	e745      	b.n	80292a4 <_strtoull_l.isra.0+0x54>
 8029418:	19999999 	.word	0x19999999
 802941c:	00000000 	.word	0x00000000

08029420 <_strtoull_r>:
 8029420:	b530      	push	{r4, r5, lr}
 8029422:	4c06      	ldr	r4, [pc, #24]	; (802943c <_strtoull_r+0x1c>)
 8029424:	4d06      	ldr	r5, [pc, #24]	; (8029440 <_strtoull_r+0x20>)
 8029426:	6824      	ldr	r4, [r4, #0]
 8029428:	6b64      	ldr	r4, [r4, #52]	; 0x34
 802942a:	b083      	sub	sp, #12
 802942c:	2c00      	cmp	r4, #0
 802942e:	bf08      	it	eq
 8029430:	462c      	moveq	r4, r5
 8029432:	9400      	str	r4, [sp, #0]
 8029434:	f7ff ff0c 	bl	8029250 <_strtoull_l.isra.0>
 8029438:	b003      	add	sp, #12
 802943a:	bd30      	pop	{r4, r5, pc}
 802943c:	20001098 	.word	0x20001098
 8029440:	200014c8 	.word	0x200014c8
	...

08029450 <_sungetc_r>:
 8029450:	1c4b      	adds	r3, r1, #1
 8029452:	b570      	push	{r4, r5, r6, lr}
 8029454:	d01a      	beq.n	802948c <_sungetc_r+0x3c>
 8029456:	8993      	ldrh	r3, [r2, #12]
 8029458:	6b14      	ldr	r4, [r2, #48]	; 0x30
 802945a:	6856      	ldr	r6, [r2, #4]
 802945c:	f023 0320 	bic.w	r3, r3, #32
 8029460:	b2cd      	uxtb	r5, r1
 8029462:	8193      	strh	r3, [r2, #12]
 8029464:	b1ac      	cbz	r4, 8029492 <_sungetc_r+0x42>
 8029466:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8029468:	42b3      	cmp	r3, r6
 802946a:	4614      	mov	r4, r2
 802946c:	dd09      	ble.n	8029482 <_sungetc_r+0x32>
 802946e:	6823      	ldr	r3, [r4, #0]
 8029470:	1e5a      	subs	r2, r3, #1
 8029472:	6022      	str	r2, [r4, #0]
 8029474:	f803 5c01 	strb.w	r5, [r3, #-1]
 8029478:	6863      	ldr	r3, [r4, #4]
 802947a:	3301      	adds	r3, #1
 802947c:	6063      	str	r3, [r4, #4]
 802947e:	4628      	mov	r0, r5
 8029480:	bd70      	pop	{r4, r5, r6, pc}
 8029482:	4611      	mov	r1, r2
 8029484:	f001 faac 	bl	802a9e0 <__submore>
 8029488:	2800      	cmp	r0, #0
 802948a:	d0f0      	beq.n	802946e <_sungetc_r+0x1e>
 802948c:	f04f 35ff 	mov.w	r5, #4294967295
 8029490:	e7f5      	b.n	802947e <_sungetc_r+0x2e>
 8029492:	6913      	ldr	r3, [r2, #16]
 8029494:	6811      	ldr	r1, [r2, #0]
 8029496:	b12b      	cbz	r3, 80294a4 <_sungetc_r+0x54>
 8029498:	428b      	cmp	r3, r1
 802949a:	d203      	bcs.n	80294a4 <_sungetc_r+0x54>
 802949c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80294a0:	42ab      	cmp	r3, r5
 80294a2:	d00e      	beq.n	80294c2 <_sungetc_r+0x72>
 80294a4:	4613      	mov	r3, r2
 80294a6:	f102 0440 	add.w	r4, r2, #64	; 0x40
 80294aa:	2003      	movs	r0, #3
 80294ac:	6391      	str	r1, [r2, #56]	; 0x38
 80294ae:	e9c2 400c 	strd	r4, r0, [r2, #48]	; 0x30
 80294b2:	63d6      	str	r6, [r2, #60]	; 0x3c
 80294b4:	f803 5f42 	strb.w	r5, [r3, #66]!
 80294b8:	2101      	movs	r1, #1
 80294ba:	e9c2 3100 	strd	r3, r1, [r2]
 80294be:	4628      	mov	r0, r5
 80294c0:	bd70      	pop	{r4, r5, r6, pc}
 80294c2:	3901      	subs	r1, #1
 80294c4:	3601      	adds	r6, #1
 80294c6:	e9c2 1600 	strd	r1, r6, [r2]
 80294ca:	e7d8      	b.n	802947e <_sungetc_r+0x2e>
 80294cc:	0000      	movs	r0, r0
	...

080294d0 <__ssrefill_r>:
 80294d0:	b510      	push	{r4, lr}
 80294d2:	460c      	mov	r4, r1
 80294d4:	6b09      	ldr	r1, [r1, #48]	; 0x30
 80294d6:	b169      	cbz	r1, 80294f4 <__ssrefill_r+0x24>
 80294d8:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80294dc:	4299      	cmp	r1, r3
 80294de:	d001      	beq.n	80294e4 <__ssrefill_r+0x14>
 80294e0:	f002 face 	bl	802ba80 <_free_r>
 80294e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80294e6:	6063      	str	r3, [r4, #4]
 80294e8:	2000      	movs	r0, #0
 80294ea:	6320      	str	r0, [r4, #48]	; 0x30
 80294ec:	b113      	cbz	r3, 80294f4 <__ssrefill_r+0x24>
 80294ee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80294f0:	6023      	str	r3, [r4, #0]
 80294f2:	bd10      	pop	{r4, pc}
 80294f4:	89a3      	ldrh	r3, [r4, #12]
 80294f6:	6922      	ldr	r2, [r4, #16]
 80294f8:	6022      	str	r2, [r4, #0]
 80294fa:	f043 0320 	orr.w	r3, r3, #32
 80294fe:	2200      	movs	r2, #0
 8029500:	81a3      	strh	r3, [r4, #12]
 8029502:	6062      	str	r2, [r4, #4]
 8029504:	f04f 30ff 	mov.w	r0, #4294967295
 8029508:	bd10      	pop	{r4, pc}
 802950a:	bf00      	nop
 802950c:	0000      	movs	r0, r0
	...

08029510 <_sfread_r>:
 8029510:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029514:	b083      	sub	sp, #12
 8029516:	fb02 f703 	mul.w	r7, r2, r3
 802951a:	9201      	str	r2, [sp, #4]
 802951c:	469a      	mov	sl, r3
 802951e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8029520:	b32f      	cbz	r7, 802956e <_sfread_r+0x5e>
 8029522:	4680      	mov	r8, r0
 8029524:	460e      	mov	r6, r1
 8029526:	463d      	mov	r5, r7
 8029528:	f04f 0900 	mov.w	r9, #0
 802952c:	e00e      	b.n	802954c <_sfread_r+0x3c>
 802952e:	f7e3 faf7 	bl	800cb20 <memcpy>
 8029532:	6822      	ldr	r2, [r4, #0]
 8029534:	f8c4 9004 	str.w	r9, [r4, #4]
 8029538:	445a      	add	r2, fp
 802953a:	6022      	str	r2, [r4, #0]
 802953c:	4621      	mov	r1, r4
 802953e:	4640      	mov	r0, r8
 8029540:	445e      	add	r6, fp
 8029542:	eba5 050b 	sub.w	r5, r5, fp
 8029546:	f7ff ffc3 	bl	80294d0 <__ssrefill_r>
 802954a:	b9a0      	cbnz	r0, 8029576 <_sfread_r+0x66>
 802954c:	e9d4 cb00 	ldrd	ip, fp, [r4]
 8029550:	45ab      	cmp	fp, r5
 8029552:	4630      	mov	r0, r6
 8029554:	465a      	mov	r2, fp
 8029556:	4661      	mov	r1, ip
 8029558:	d3e9      	bcc.n	802952e <_sfread_r+0x1e>
 802955a:	462a      	mov	r2, r5
 802955c:	f7e3 fae0 	bl	800cb20 <memcpy>
 8029560:	e9d4 3200 	ldrd	r3, r2, [r4]
 8029564:	1b52      	subs	r2, r2, r5
 8029566:	441d      	add	r5, r3
 8029568:	e9c4 5200 	strd	r5, r2, [r4]
 802956c:	4657      	mov	r7, sl
 802956e:	4638      	mov	r0, r7
 8029570:	b003      	add	sp, #12
 8029572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029576:	9b01      	ldr	r3, [sp, #4]
 8029578:	1b7f      	subs	r7, r7, r5
 802957a:	fbb7 f7f3 	udiv	r7, r7, r3
 802957e:	4638      	mov	r0, r7
 8029580:	b003      	add	sp, #12
 8029582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029586:	bf00      	nop
	...

08029590 <_svfprintf_r>:
 8029590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029594:	b0c1      	sub	sp, #260	; 0x104
 8029596:	460c      	mov	r4, r1
 8029598:	9108      	str	r1, [sp, #32]
 802959a:	4691      	mov	r9, r2
 802959c:	930b      	str	r3, [sp, #44]	; 0x2c
 802959e:	9009      	str	r0, [sp, #36]	; 0x24
 80295a0:	f7fe fb7e 	bl	8027ca0 <_localeconv_r>
 80295a4:	6803      	ldr	r3, [r0, #0]
 80295a6:	9314      	str	r3, [sp, #80]	; 0x50
 80295a8:	4618      	mov	r0, r3
 80295aa:	f7e3 fcc9 	bl	800cf40 <strlen>
 80295ae:	89a3      	ldrh	r3, [r4, #12]
 80295b0:	9013      	str	r0, [sp, #76]	; 0x4c
 80295b2:	061d      	lsls	r5, r3, #24
 80295b4:	d503      	bpl.n	80295be <_svfprintf_r+0x2e>
 80295b6:	6923      	ldr	r3, [r4, #16]
 80295b8:	2b00      	cmp	r3, #0
 80295ba:	f000 8718 	beq.w	802a3ee <_svfprintf_r+0xe5e>
 80295be:	ed9f 7b94 	vldr	d7, [pc, #592]	; 8029810 <_svfprintf_r+0x280>
 80295c2:	2300      	movs	r3, #0
 80295c4:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 80295c8:	e9cd 3324 	strd	r3, r3, [sp, #144]	; 0x90
 80295cc:	f10d 08c0 	add.w	r8, sp, #192	; 0xc0
 80295d0:	930f      	str	r3, [sp, #60]	; 0x3c
 80295d2:	9312      	str	r3, [sp, #72]	; 0x48
 80295d4:	9315      	str	r3, [sp, #84]	; 0x54
 80295d6:	9306      	str	r3, [sp, #24]
 80295d8:	f8cd 808c 	str.w	r8, [sp, #140]	; 0x8c
 80295dc:	46c2      	mov	sl, r8
 80295de:	46cb      	mov	fp, r9
 80295e0:	f89b 3000 	ldrb.w	r3, [fp]
 80295e4:	2b00      	cmp	r3, #0
 80295e6:	f000 8099 	beq.w	802971c <_svfprintf_r+0x18c>
 80295ea:	2b25      	cmp	r3, #37	; 0x25
 80295ec:	465c      	mov	r4, fp
 80295ee:	d102      	bne.n	80295f6 <_svfprintf_r+0x66>
 80295f0:	e01c      	b.n	802962c <_svfprintf_r+0x9c>
 80295f2:	2b25      	cmp	r3, #37	; 0x25
 80295f4:	d003      	beq.n	80295fe <_svfprintf_r+0x6e>
 80295f6:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 80295fa:	2b00      	cmp	r3, #0
 80295fc:	d1f9      	bne.n	80295f2 <_svfprintf_r+0x62>
 80295fe:	eba4 050b 	sub.w	r5, r4, fp
 8029602:	b185      	cbz	r5, 8029626 <_svfprintf_r+0x96>
 8029604:	e9dd 3224 	ldrd	r3, r2, [sp, #144]	; 0x90
 8029608:	3301      	adds	r3, #1
 802960a:	442a      	add	r2, r5
 802960c:	2b07      	cmp	r3, #7
 802960e:	f8ca b000 	str.w	fp, [sl]
 8029612:	f8ca 5004 	str.w	r5, [sl, #4]
 8029616:	e9cd 3224 	strd	r3, r2, [sp, #144]	; 0x90
 802961a:	dc77      	bgt.n	802970c <_svfprintf_r+0x17c>
 802961c:	f10a 0a08 	add.w	sl, sl, #8
 8029620:	9b06      	ldr	r3, [sp, #24]
 8029622:	442b      	add	r3, r5
 8029624:	9306      	str	r3, [sp, #24]
 8029626:	7823      	ldrb	r3, [r4, #0]
 8029628:	2b00      	cmp	r3, #0
 802962a:	d077      	beq.n	802971c <_svfprintf_r+0x18c>
 802962c:	2300      	movs	r3, #0
 802962e:	461a      	mov	r2, r3
 8029630:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 8029634:	4619      	mov	r1, r3
 8029636:	9307      	str	r3, [sp, #28]
 8029638:	461f      	mov	r7, r3
 802963a:	f04f 30ff 	mov.w	r0, #4294967295
 802963e:	7863      	ldrb	r3, [r4, #1]
 8029640:	9005      	str	r0, [sp, #20]
 8029642:	f104 0b01 	add.w	fp, r4, #1
 8029646:	f10b 0b01 	add.w	fp, fp, #1
 802964a:	4699      	mov	r9, r3
 802964c:	f1a9 0320 	sub.w	r3, r9, #32
 8029650:	2b58      	cmp	r3, #88	; 0x58
 8029652:	f200 8375 	bhi.w	8029d40 <_svfprintf_r+0x7b0>
 8029656:	e8df f013 	tbh	[pc, r3, lsl #1]
 802965a:	02c3      	.short	0x02c3
 802965c:	03730373 	.word	0x03730373
 8029660:	037302be 	.word	0x037302be
 8029664:	03730373 	.word	0x03730373
 8029668:	03730373 	.word	0x03730373
 802966c:	02b20373 	.word	0x02b20373
 8029670:	037302ad 	.word	0x037302ad
 8029674:	034c0367 	.word	0x034c0367
 8029678:	036c0373 	.word	0x036c0373
 802967c:	00b600b6 	.word	0x00b600b6
 8029680:	00b600b6 	.word	0x00b600b6
 8029684:	00b600b6 	.word	0x00b600b6
 8029688:	00b600b6 	.word	0x00b600b6
 802968c:	037300b6 	.word	0x037300b6
 8029690:	03730373 	.word	0x03730373
 8029694:	03730373 	.word	0x03730373
 8029698:	03730373 	.word	0x03730373
 802969c:	03730373 	.word	0x03730373
 80296a0:	03370373 	.word	0x03370373
 80296a4:	037302e4 	.word	0x037302e4
 80296a8:	037302e4 	.word	0x037302e4
 80296ac:	03730373 	.word	0x03730373
 80296b0:	02df0373 	.word	0x02df0373
 80296b4:	03730373 	.word	0x03730373
 80296b8:	037300a5 	.word	0x037300a5
 80296bc:	03730373 	.word	0x03730373
 80296c0:	03730373 	.word	0x03730373
 80296c4:	03730075 	.word	0x03730075
 80296c8:	028d0373 	.word	0x028d0373
 80296cc:	03730373 	.word	0x03730373
 80296d0:	03730373 	.word	0x03730373
 80296d4:	03730373 	.word	0x03730373
 80296d8:	03730373 	.word	0x03730373
 80296dc:	03730373 	.word	0x03730373
 80296e0:	012f017c 	.word	0x012f017c
 80296e4:	02e402e4 	.word	0x02e402e4
 80296e8:	012a02e4 	.word	0x012a02e4
 80296ec:	0373012f 	.word	0x0373012f
 80296f0:	011d0373 	.word	0x011d0373
 80296f4:	01090373 	.word	0x01090373
 80296f8:	00ca00a7 	.word	0x00ca00a7
 80296fc:	037300c5 	.word	0x037300c5
 8029700:	037300e1 	.word	0x037300e1
 8029704:	03730077 	.word	0x03730077
 8029708:	02cb0373 	.word	0x02cb0373
 802970c:	aa23      	add	r2, sp, #140	; 0x8c
 802970e:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029712:	f003 ffd5 	bl	802d6c0 <__ssprint_r>
 8029716:	b940      	cbnz	r0, 802972a <_svfprintf_r+0x19a>
 8029718:	46c2      	mov	sl, r8
 802971a:	e781      	b.n	8029620 <_svfprintf_r+0x90>
 802971c:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802971e:	b123      	cbz	r3, 802972a <_svfprintf_r+0x19a>
 8029720:	9809      	ldr	r0, [sp, #36]	; 0x24
 8029722:	9908      	ldr	r1, [sp, #32]
 8029724:	aa23      	add	r2, sp, #140	; 0x8c
 8029726:	f003 ffcb 	bl	802d6c0 <__ssprint_r>
 802972a:	9b08      	ldr	r3, [sp, #32]
 802972c:	899b      	ldrh	r3, [r3, #12]
 802972e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8029732:	9b06      	ldr	r3, [sp, #24]
 8029734:	bf18      	it	ne
 8029736:	f04f 33ff 	movne.w	r3, #4294967295
 802973a:	9306      	str	r3, [sp, #24]
 802973c:	9806      	ldr	r0, [sp, #24]
 802973e:	b041      	add	sp, #260	; 0x104
 8029740:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029744:	f047 0710 	orr.w	r7, r7, #16
 8029748:	06be      	lsls	r6, r7, #26
 802974a:	f140 8527 	bpl.w	802a19c <_svfprintf_r+0xc0c>
 802974e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8029750:	3507      	adds	r5, #7
 8029752:	f025 0307 	bic.w	r3, r5, #7
 8029756:	f103 0208 	add.w	r2, r3, #8
 802975a:	e9d3 4500 	ldrd	r4, r5, [r3]
 802975e:	920b      	str	r2, [sp, #44]	; 0x2c
 8029760:	2301      	movs	r3, #1
 8029762:	9a05      	ldr	r2, [sp, #20]
 8029764:	2600      	movs	r6, #0
 8029766:	3201      	adds	r2, #1
 8029768:	f88d 606f 	strb.w	r6, [sp, #111]	; 0x6f
 802976c:	f000 8428 	beq.w	8029fc0 <_svfprintf_r+0xa30>
 8029770:	f027 0280 	bic.w	r2, r7, #128	; 0x80
 8029774:	9203      	str	r2, [sp, #12]
 8029776:	ea54 0205 	orrs.w	r2, r4, r5
 802977a:	f040 80c0 	bne.w	80298fe <_svfprintf_r+0x36e>
 802977e:	9a05      	ldr	r2, [sp, #20]
 8029780:	2a00      	cmp	r2, #0
 8029782:	f040 86b0 	bne.w	802a4e6 <_svfprintf_r+0xf56>
 8029786:	2b00      	cmp	r3, #0
 8029788:	f040 84d6 	bne.w	802a138 <_svfprintf_r+0xba8>
 802978c:	f017 0301 	ands.w	r3, r7, #1
 8029790:	930a      	str	r3, [sp, #40]	; 0x28
 8029792:	f000 8548 	beq.w	802a226 <_svfprintf_r+0xc96>
 8029796:	ab40      	add	r3, sp, #256	; 0x100
 8029798:	461a      	mov	r2, r3
 802979a:	2330      	movs	r3, #48	; 0x30
 802979c:	f802 3d41 	strb.w	r3, [r2, #-65]!
 80297a0:	920d      	str	r2, [sp, #52]	; 0x34
 80297a2:	e0cd      	b.n	8029940 <_svfprintf_r+0x3b0>
 80297a4:	f047 0710 	orr.w	r7, r7, #16
 80297a8:	f017 0320 	ands.w	r3, r7, #32
 80297ac:	f000 8500 	beq.w	802a1b0 <_svfprintf_r+0xc20>
 80297b0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80297b2:	3507      	adds	r5, #7
 80297b4:	f025 0307 	bic.w	r3, r5, #7
 80297b8:	f103 0208 	add.w	r2, r3, #8
 80297bc:	e9d3 4500 	ldrd	r4, r5, [r3]
 80297c0:	920b      	str	r2, [sp, #44]	; 0x2c
 80297c2:	2300      	movs	r3, #0
 80297c4:	e7cd      	b.n	8029762 <_svfprintf_r+0x1d2>
 80297c6:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 80297ca:	2000      	movs	r0, #0
 80297cc:	f81b 9b01 	ldrb.w	r9, [fp], #1
 80297d0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80297d4:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 80297d8:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 80297dc:	2b09      	cmp	r3, #9
 80297de:	d9f5      	bls.n	80297cc <_svfprintf_r+0x23c>
 80297e0:	9007      	str	r0, [sp, #28]
 80297e2:	e733      	b.n	802964c <_svfprintf_r+0xbc>
 80297e4:	f047 0720 	orr.w	r7, r7, #32
 80297e8:	f89b 3000 	ldrb.w	r3, [fp]
 80297ec:	e72b      	b.n	8029646 <_svfprintf_r+0xb6>
 80297ee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80297f0:	4b09      	ldr	r3, [pc, #36]	; (8029818 <_svfprintf_r+0x288>)
 80297f2:	6814      	ldr	r4, [r2, #0]
 80297f4:	9312      	str	r3, [sp, #72]	; 0x48
 80297f6:	3204      	adds	r2, #4
 80297f8:	f647 0330 	movw	r3, #30768	; 0x7830
 80297fc:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
 8029800:	f047 0702 	orr.w	r7, r7, #2
 8029804:	920b      	str	r2, [sp, #44]	; 0x2c
 8029806:	2500      	movs	r5, #0
 8029808:	2302      	movs	r3, #2
 802980a:	f04f 0978 	mov.w	r9, #120	; 0x78
 802980e:	e7a8      	b.n	8029762 <_svfprintf_r+0x1d2>
	...
 8029818:	0802ffa4 	.word	0x0802ffa4
 802981c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802981e:	6813      	ldr	r3, [r2, #0]
 8029820:	930d      	str	r3, [sp, #52]	; 0x34
 8029822:	2400      	movs	r4, #0
 8029824:	f88d 406f 	strb.w	r4, [sp, #111]	; 0x6f
 8029828:	1d15      	adds	r5, r2, #4
 802982a:	2b00      	cmp	r3, #0
 802982c:	f000 860b 	beq.w	802a446 <_svfprintf_r+0xeb6>
 8029830:	9a05      	ldr	r2, [sp, #20]
 8029832:	1c53      	adds	r3, r2, #1
 8029834:	f000 86b3 	beq.w	802a59e <_svfprintf_r+0x100e>
 8029838:	4621      	mov	r1, r4
 802983a:	980d      	ldr	r0, [sp, #52]	; 0x34
 802983c:	f7e3 fbf0 	bl	800d020 <memchr>
 8029840:	2800      	cmp	r0, #0
 8029842:	f000 8794 	beq.w	802a76e <_svfprintf_r+0x11de>
 8029846:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8029848:	9405      	str	r4, [sp, #20]
 802984a:	1ac3      	subs	r3, r0, r3
 802984c:	930a      	str	r3, [sp, #40]	; 0x28
 802984e:	950b      	str	r5, [sp, #44]	; 0x2c
 8029850:	9703      	str	r7, [sp, #12]
 8029852:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8029856:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 802985a:	9304      	str	r3, [sp, #16]
 802985c:	940e      	str	r4, [sp, #56]	; 0x38
 802985e:	2e00      	cmp	r6, #0
 8029860:	f000 8089 	beq.w	8029976 <_svfprintf_r+0x3e6>
 8029864:	9b04      	ldr	r3, [sp, #16]
 8029866:	3301      	adds	r3, #1
 8029868:	9304      	str	r3, [sp, #16]
 802986a:	e084      	b.n	8029976 <_svfprintf_r+0x3e6>
 802986c:	2a00      	cmp	r2, #0
 802986e:	f041 80a4 	bne.w	802a9ba <_svfprintf_r+0x142a>
 8029872:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8029874:	06b9      	lsls	r1, r7, #26
 8029876:	f852 3b04 	ldr.w	r3, [r2], #4
 802987a:	920b      	str	r2, [sp, #44]	; 0x2c
 802987c:	f100 8512 	bmi.w	802a2a4 <_svfprintf_r+0xd14>
 8029880:	06fa      	lsls	r2, r7, #27
 8029882:	f100 8606 	bmi.w	802a492 <_svfprintf_r+0xf02>
 8029886:	067f      	lsls	r7, r7, #25
 8029888:	f140 8603 	bpl.w	802a492 <_svfprintf_r+0xf02>
 802988c:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 8029890:	801a      	strh	r2, [r3, #0]
 8029892:	e6a5      	b.n	80295e0 <_svfprintf_r+0x50>
 8029894:	f89b 3000 	ldrb.w	r3, [fp]
 8029898:	2b6c      	cmp	r3, #108	; 0x6c
 802989a:	bf03      	ittte	eq
 802989c:	f89b 3001 	ldrbeq.w	r3, [fp, #1]
 80298a0:	f047 0720 	orreq.w	r7, r7, #32
 80298a4:	f10b 0b01 	addeq.w	fp, fp, #1
 80298a8:	f047 0710 	orrne.w	r7, r7, #16
 80298ac:	e6cb      	b.n	8029646 <_svfprintf_r+0xb6>
 80298ae:	f047 0740 	orr.w	r7, r7, #64	; 0x40
 80298b2:	f89b 3000 	ldrb.w	r3, [fp]
 80298b6:	e6c6      	b.n	8029646 <_svfprintf_r+0xb6>
 80298b8:	2a00      	cmp	r2, #0
 80298ba:	f041 8060 	bne.w	802a97e <_svfprintf_r+0x13ee>
 80298be:	06bc      	lsls	r4, r7, #26
 80298c0:	f140 820a 	bpl.w	8029cd8 <_svfprintf_r+0x748>
 80298c4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80298c6:	3507      	adds	r5, #7
 80298c8:	f025 0307 	bic.w	r3, r5, #7
 80298cc:	e9d3 4500 	ldrd	r4, r5, [r3]
 80298d0:	f103 0208 	add.w	r2, r3, #8
 80298d4:	920b      	str	r2, [sp, #44]	; 0x2c
 80298d6:	2c00      	cmp	r4, #0
 80298d8:	f175 0300 	sbcs.w	r3, r5, #0
 80298dc:	f2c0 84af 	blt.w	802a23e <_svfprintf_r+0xcae>
 80298e0:	9b05      	ldr	r3, [sp, #20]
 80298e2:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 80298e6:	3301      	adds	r3, #1
 80298e8:	f000 84b4 	beq.w	802a254 <_svfprintf_r+0xcc4>
 80298ec:	f027 0280 	bic.w	r2, r7, #128	; 0x80
 80298f0:	9203      	str	r2, [sp, #12]
 80298f2:	ea54 0205 	orrs.w	r2, r4, r5
 80298f6:	f04f 0301 	mov.w	r3, #1
 80298fa:	f43f af40 	beq.w	802977e <_svfprintf_r+0x1ee>
 80298fe:	2b01      	cmp	r3, #1
 8029900:	f000 8362 	beq.w	8029fc8 <_svfprintf_r+0xa38>
 8029904:	2b02      	cmp	r3, #2
 8029906:	f000 8382 	beq.w	802a00e <_svfprintf_r+0xa7e>
 802990a:	4641      	mov	r1, r8
 802990c:	e000      	b.n	8029910 <_svfprintf_r+0x380>
 802990e:	4611      	mov	r1, r2
 8029910:	08e2      	lsrs	r2, r4, #3
 8029912:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 8029916:	08e8      	lsrs	r0, r5, #3
 8029918:	f004 0307 	and.w	r3, r4, #7
 802991c:	4605      	mov	r5, r0
 802991e:	4614      	mov	r4, r2
 8029920:	3330      	adds	r3, #48	; 0x30
 8029922:	ea54 0005 	orrs.w	r0, r4, r5
 8029926:	f801 3c01 	strb.w	r3, [r1, #-1]
 802992a:	f101 32ff 	add.w	r2, r1, #4294967295
 802992e:	d1ee      	bne.n	802990e <_svfprintf_r+0x37e>
 8029930:	9803      	ldr	r0, [sp, #12]
 8029932:	920d      	str	r2, [sp, #52]	; 0x34
 8029934:	07c0      	lsls	r0, r0, #31
 8029936:	f100 8459 	bmi.w	802a1ec <_svfprintf_r+0xc5c>
 802993a:	eba8 0302 	sub.w	r3, r8, r2
 802993e:	930a      	str	r3, [sp, #40]	; 0x28
 8029940:	9b05      	ldr	r3, [sp, #20]
 8029942:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029944:	4293      	cmp	r3, r2
 8029946:	bfb8      	it	lt
 8029948:	4613      	movlt	r3, r2
 802994a:	9304      	str	r3, [sp, #16]
 802994c:	2300      	movs	r3, #0
 802994e:	930e      	str	r3, [sp, #56]	; 0x38
 8029950:	e785      	b.n	802985e <_svfprintf_r+0x2ce>
 8029952:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8029954:	2300      	movs	r3, #0
 8029956:	680a      	ldr	r2, [r1, #0]
 8029958:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 802995c:	461e      	mov	r6, r3
 802995e:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
 8029962:	2301      	movs	r3, #1
 8029964:	1d0a      	adds	r2, r1, #4
 8029966:	e9cd 7303 	strd	r7, r3, [sp, #12]
 802996a:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
 802996e:	ab26      	add	r3, sp, #152	; 0x98
 8029970:	9605      	str	r6, [sp, #20]
 8029972:	960e      	str	r6, [sp, #56]	; 0x38
 8029974:	930d      	str	r3, [sp, #52]	; 0x34
 8029976:	9b03      	ldr	r3, [sp, #12]
 8029978:	f013 0702 	ands.w	r7, r3, #2
 802997c:	d002      	beq.n	8029984 <_svfprintf_r+0x3f4>
 802997e:	9b04      	ldr	r3, [sp, #16]
 8029980:	3302      	adds	r3, #2
 8029982:	9304      	str	r3, [sp, #16]
 8029984:	9b03      	ldr	r3, [sp, #12]
 8029986:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8029988:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 802998c:	930c      	str	r3, [sp, #48]	; 0x30
 802998e:	d13f      	bne.n	8029a10 <_svfprintf_r+0x480>
 8029990:	9b07      	ldr	r3, [sp, #28]
 8029992:	9a04      	ldr	r2, [sp, #16]
 8029994:	1a9d      	subs	r5, r3, r2
 8029996:	2d00      	cmp	r5, #0
 8029998:	dd3a      	ble.n	8029a10 <_svfprintf_r+0x480>
 802999a:	2d10      	cmp	r5, #16
 802999c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802999e:	dd29      	ble.n	80299f4 <_svfprintf_r+0x464>
 80299a0:	4652      	mov	r2, sl
 80299a2:	4621      	mov	r1, r4
 80299a4:	46aa      	mov	sl, r5
 80299a6:	2610      	movs	r6, #16
 80299a8:	e9dd 5408 	ldrd	r5, r4, [sp, #32]
 80299ac:	e006      	b.n	80299bc <_svfprintf_r+0x42c>
 80299ae:	f1aa 0a10 	sub.w	sl, sl, #16
 80299b2:	f1ba 0f10 	cmp.w	sl, #16
 80299b6:	f102 0208 	add.w	r2, r2, #8
 80299ba:	dd18      	ble.n	80299ee <_svfprintf_r+0x45e>
 80299bc:	3301      	adds	r3, #1
 80299be:	48bb      	ldr	r0, [pc, #748]	; (8029cac <_svfprintf_r+0x71c>)
 80299c0:	3110      	adds	r1, #16
 80299c2:	2b07      	cmp	r3, #7
 80299c4:	e9cd 3124 	strd	r3, r1, [sp, #144]	; 0x90
 80299c8:	e9c2 0600 	strd	r0, r6, [r2]
 80299cc:	ddef      	ble.n	80299ae <_svfprintf_r+0x41e>
 80299ce:	aa23      	add	r2, sp, #140	; 0x8c
 80299d0:	4629      	mov	r1, r5
 80299d2:	4620      	mov	r0, r4
 80299d4:	f003 fe74 	bl	802d6c0 <__ssprint_r>
 80299d8:	2800      	cmp	r0, #0
 80299da:	f47f aea6 	bne.w	802972a <_svfprintf_r+0x19a>
 80299de:	f1aa 0a10 	sub.w	sl, sl, #16
 80299e2:	f1ba 0f10 	cmp.w	sl, #16
 80299e6:	e9dd 3124 	ldrd	r3, r1, [sp, #144]	; 0x90
 80299ea:	4642      	mov	r2, r8
 80299ec:	dce6      	bgt.n	80299bc <_svfprintf_r+0x42c>
 80299ee:	4655      	mov	r5, sl
 80299f0:	460c      	mov	r4, r1
 80299f2:	4692      	mov	sl, r2
 80299f4:	3301      	adds	r3, #1
 80299f6:	4aad      	ldr	r2, [pc, #692]	; (8029cac <_svfprintf_r+0x71c>)
 80299f8:	442c      	add	r4, r5
 80299fa:	2b07      	cmp	r3, #7
 80299fc:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029a00:	e9ca 2500 	strd	r2, r5, [sl]
 8029a04:	f300 8549 	bgt.w	802a49a <_svfprintf_r+0xf0a>
 8029a08:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 8029a0c:	f10a 0a08 	add.w	sl, sl, #8
 8029a10:	b176      	cbz	r6, 8029a30 <_svfprintf_r+0x4a0>
 8029a12:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029a14:	3301      	adds	r3, #1
 8029a16:	3401      	adds	r4, #1
 8029a18:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
 8029a1c:	2201      	movs	r2, #1
 8029a1e:	2b07      	cmp	r3, #7
 8029a20:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029a24:	e9ca 1200 	strd	r1, r2, [sl]
 8029a28:	f300 82db 	bgt.w	8029fe2 <_svfprintf_r+0xa52>
 8029a2c:	f10a 0a08 	add.w	sl, sl, #8
 8029a30:	b16f      	cbz	r7, 8029a4e <_svfprintf_r+0x4be>
 8029a32:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029a34:	3301      	adds	r3, #1
 8029a36:	3402      	adds	r4, #2
 8029a38:	a91c      	add	r1, sp, #112	; 0x70
 8029a3a:	2202      	movs	r2, #2
 8029a3c:	2b07      	cmp	r3, #7
 8029a3e:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029a42:	e9ca 1200 	strd	r1, r2, [sl]
 8029a46:	f300 82d7 	bgt.w	8029ff8 <_svfprintf_r+0xa68>
 8029a4a:	f10a 0a08 	add.w	sl, sl, #8
 8029a4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8029a50:	2b80      	cmp	r3, #128	; 0x80
 8029a52:	f000 81e7 	beq.w	8029e24 <_svfprintf_r+0x894>
 8029a56:	9b05      	ldr	r3, [sp, #20]
 8029a58:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029a5a:	1a9d      	subs	r5, r3, r2
 8029a5c:	2d00      	cmp	r5, #0
 8029a5e:	dd31      	ble.n	8029ac4 <_svfprintf_r+0x534>
 8029a60:	2d10      	cmp	r5, #16
 8029a62:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8029a64:	4f92      	ldr	r7, [pc, #584]	; (8029cb0 <_svfprintf_r+0x720>)
 8029a66:	dd22      	ble.n	8029aae <_svfprintf_r+0x51e>
 8029a68:	4653      	mov	r3, sl
 8029a6a:	4621      	mov	r1, r4
 8029a6c:	2610      	movs	r6, #16
 8029a6e:	e9dd a408 	ldrd	sl, r4, [sp, #32]
 8029a72:	e004      	b.n	8029a7e <_svfprintf_r+0x4ee>
 8029a74:	3d10      	subs	r5, #16
 8029a76:	2d10      	cmp	r5, #16
 8029a78:	f103 0308 	add.w	r3, r3, #8
 8029a7c:	dd15      	ble.n	8029aaa <_svfprintf_r+0x51a>
 8029a7e:	3201      	adds	r2, #1
 8029a80:	3110      	adds	r1, #16
 8029a82:	2a07      	cmp	r2, #7
 8029a84:	e9cd 2124 	strd	r2, r1, [sp, #144]	; 0x90
 8029a88:	e9c3 7600 	strd	r7, r6, [r3]
 8029a8c:	ddf2      	ble.n	8029a74 <_svfprintf_r+0x4e4>
 8029a8e:	aa23      	add	r2, sp, #140	; 0x8c
 8029a90:	4651      	mov	r1, sl
 8029a92:	4620      	mov	r0, r4
 8029a94:	f003 fe14 	bl	802d6c0 <__ssprint_r>
 8029a98:	2800      	cmp	r0, #0
 8029a9a:	f47f ae46 	bne.w	802972a <_svfprintf_r+0x19a>
 8029a9e:	3d10      	subs	r5, #16
 8029aa0:	2d10      	cmp	r5, #16
 8029aa2:	e9dd 2124 	ldrd	r2, r1, [sp, #144]	; 0x90
 8029aa6:	4643      	mov	r3, r8
 8029aa8:	dce9      	bgt.n	8029a7e <_svfprintf_r+0x4ee>
 8029aaa:	469a      	mov	sl, r3
 8029aac:	460c      	mov	r4, r1
 8029aae:	3201      	adds	r2, #1
 8029ab0:	442c      	add	r4, r5
 8029ab2:	2a07      	cmp	r2, #7
 8029ab4:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 8029ab8:	e9ca 7500 	strd	r7, r5, [sl]
 8029abc:	f300 82bc 	bgt.w	802a038 <_svfprintf_r+0xaa8>
 8029ac0:	f10a 0a08 	add.w	sl, sl, #8
 8029ac4:	9b03      	ldr	r3, [sp, #12]
 8029ac6:	05df      	lsls	r7, r3, #23
 8029ac8:	f100 8150 	bmi.w	8029d6c <_svfprintf_r+0x7dc>
 8029acc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029ace:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8029ad0:	f8ca 2000 	str.w	r2, [sl]
 8029ad4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029ad6:	f8ca 2004 	str.w	r2, [sl, #4]
 8029ada:	3301      	adds	r3, #1
 8029adc:	4414      	add	r4, r2
 8029ade:	2b07      	cmp	r3, #7
 8029ae0:	9425      	str	r4, [sp, #148]	; 0x94
 8029ae2:	9324      	str	r3, [sp, #144]	; 0x90
 8029ae4:	f300 820e 	bgt.w	8029f04 <_svfprintf_r+0x974>
 8029ae8:	f10a 0a08 	add.w	sl, sl, #8
 8029aec:	9b03      	ldr	r3, [sp, #12]
 8029aee:	075a      	lsls	r2, r3, #29
 8029af0:	d531      	bpl.n	8029b56 <_svfprintf_r+0x5c6>
 8029af2:	9b07      	ldr	r3, [sp, #28]
 8029af4:	9a04      	ldr	r2, [sp, #16]
 8029af6:	1a9d      	subs	r5, r3, r2
 8029af8:	2d00      	cmp	r5, #0
 8029afa:	dd2c      	ble.n	8029b56 <_svfprintf_r+0x5c6>
 8029afc:	2d10      	cmp	r5, #16
 8029afe:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029b00:	dd1f      	ble.n	8029b42 <_svfprintf_r+0x5b2>
 8029b02:	2610      	movs	r6, #16
 8029b04:	e9dd 9708 	ldrd	r9, r7, [sp, #32]
 8029b08:	e004      	b.n	8029b14 <_svfprintf_r+0x584>
 8029b0a:	3d10      	subs	r5, #16
 8029b0c:	2d10      	cmp	r5, #16
 8029b0e:	f10a 0a08 	add.w	sl, sl, #8
 8029b12:	dd16      	ble.n	8029b42 <_svfprintf_r+0x5b2>
 8029b14:	3301      	adds	r3, #1
 8029b16:	4a65      	ldr	r2, [pc, #404]	; (8029cac <_svfprintf_r+0x71c>)
 8029b18:	3410      	adds	r4, #16
 8029b1a:	2b07      	cmp	r3, #7
 8029b1c:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029b20:	e9ca 2600 	strd	r2, r6, [sl]
 8029b24:	ddf1      	ble.n	8029b0a <_svfprintf_r+0x57a>
 8029b26:	aa23      	add	r2, sp, #140	; 0x8c
 8029b28:	4649      	mov	r1, r9
 8029b2a:	4638      	mov	r0, r7
 8029b2c:	f003 fdc8 	bl	802d6c0 <__ssprint_r>
 8029b30:	2800      	cmp	r0, #0
 8029b32:	f47f adfa 	bne.w	802972a <_svfprintf_r+0x19a>
 8029b36:	3d10      	subs	r5, #16
 8029b38:	2d10      	cmp	r5, #16
 8029b3a:	e9dd 3424 	ldrd	r3, r4, [sp, #144]	; 0x90
 8029b3e:	46c2      	mov	sl, r8
 8029b40:	dce8      	bgt.n	8029b14 <_svfprintf_r+0x584>
 8029b42:	3301      	adds	r3, #1
 8029b44:	4a59      	ldr	r2, [pc, #356]	; (8029cac <_svfprintf_r+0x71c>)
 8029b46:	442c      	add	r4, r5
 8029b48:	2b07      	cmp	r3, #7
 8029b4a:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029b4e:	e9ca 2500 	strd	r2, r5, [sl]
 8029b52:	f300 835e 	bgt.w	802a212 <_svfprintf_r+0xc82>
 8029b56:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 8029b5a:	9904      	ldr	r1, [sp, #16]
 8029b5c:	428a      	cmp	r2, r1
 8029b5e:	bfac      	ite	ge
 8029b60:	189b      	addge	r3, r3, r2
 8029b62:	185b      	addlt	r3, r3, r1
 8029b64:	9306      	str	r3, [sp, #24]
 8029b66:	2c00      	cmp	r4, #0
 8029b68:	f040 8195 	bne.w	8029e96 <_svfprintf_r+0x906>
 8029b6c:	2300      	movs	r3, #0
 8029b6e:	9324      	str	r3, [sp, #144]	; 0x90
 8029b70:	46c2      	mov	sl, r8
 8029b72:	e535      	b.n	80295e0 <_svfprintf_r+0x50>
 8029b74:	2a00      	cmp	r2, #0
 8029b76:	f040 8710 	bne.w	802a99a <_svfprintf_r+0x140a>
 8029b7a:	4b4e      	ldr	r3, [pc, #312]	; (8029cb4 <_svfprintf_r+0x724>)
 8029b7c:	9312      	str	r3, [sp, #72]	; 0x48
 8029b7e:	06b9      	lsls	r1, r7, #26
 8029b80:	d53d      	bpl.n	8029bfe <_svfprintf_r+0x66e>
 8029b82:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8029b84:	3507      	adds	r5, #7
 8029b86:	f025 0307 	bic.w	r3, r5, #7
 8029b8a:	e9d3 4500 	ldrd	r4, r5, [r3]
 8029b8e:	f103 0208 	add.w	r2, r3, #8
 8029b92:	920b      	str	r2, [sp, #44]	; 0x2c
 8029b94:	07fe      	lsls	r6, r7, #31
 8029b96:	f140 80d1 	bpl.w	8029d3c <_svfprintf_r+0x7ac>
 8029b9a:	ea54 0305 	orrs.w	r3, r4, r5
 8029b9e:	f000 80cd 	beq.w	8029d3c <_svfprintf_r+0x7ac>
 8029ba2:	2330      	movs	r3, #48	; 0x30
 8029ba4:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
 8029ba8:	f88d 9071 	strb.w	r9, [sp, #113]	; 0x71
 8029bac:	f047 0702 	orr.w	r7, r7, #2
 8029bb0:	2302      	movs	r3, #2
 8029bb2:	e5d6      	b.n	8029762 <_svfprintf_r+0x1d2>
 8029bb4:	f89b 3000 	ldrb.w	r3, [fp]
 8029bb8:	2201      	movs	r2, #1
 8029bba:	212b      	movs	r1, #43	; 0x2b
 8029bbc:	e543      	b.n	8029646 <_svfprintf_r+0xb6>
 8029bbe:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8029bc0:	f89b 3000 	ldrb.w	r3, [fp]
 8029bc4:	6804      	ldr	r4, [r0, #0]
 8029bc6:	9407      	str	r4, [sp, #28]
 8029bc8:	2c00      	cmp	r4, #0
 8029bca:	f100 0004 	add.w	r0, r0, #4
 8029bce:	f2c0 840a 	blt.w	802a3e6 <_svfprintf_r+0xe56>
 8029bd2:	900b      	str	r0, [sp, #44]	; 0x2c
 8029bd4:	e537      	b.n	8029646 <_svfprintf_r+0xb6>
 8029bd6:	f047 0701 	orr.w	r7, r7, #1
 8029bda:	f89b 3000 	ldrb.w	r3, [fp]
 8029bde:	e532      	b.n	8029646 <_svfprintf_r+0xb6>
 8029be0:	f89b 3000 	ldrb.w	r3, [fp]
 8029be4:	2900      	cmp	r1, #0
 8029be6:	f47f ad2e 	bne.w	8029646 <_svfprintf_r+0xb6>
 8029bea:	2201      	movs	r2, #1
 8029bec:	2120      	movs	r1, #32
 8029bee:	e52a      	b.n	8029646 <_svfprintf_r+0xb6>
 8029bf0:	2a00      	cmp	r2, #0
 8029bf2:	f040 86e6 	bne.w	802a9c2 <_svfprintf_r+0x1432>
 8029bf6:	4b30      	ldr	r3, [pc, #192]	; (8029cb8 <_svfprintf_r+0x728>)
 8029bf8:	9312      	str	r3, [sp, #72]	; 0x48
 8029bfa:	06b9      	lsls	r1, r7, #26
 8029bfc:	d4c1      	bmi.n	8029b82 <_svfprintf_r+0x5f2>
 8029bfe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8029c00:	06fa      	lsls	r2, r7, #27
 8029c02:	f853 4b04 	ldr.w	r4, [r3], #4
 8029c06:	930b      	str	r3, [sp, #44]	; 0x2c
 8029c08:	f100 8311 	bmi.w	802a22e <_svfprintf_r+0xc9e>
 8029c0c:	067b      	lsls	r3, r7, #25
 8029c0e:	f140 830e 	bpl.w	802a22e <_svfprintf_r+0xc9e>
 8029c12:	b2a4      	uxth	r4, r4
 8029c14:	2500      	movs	r5, #0
 8029c16:	e7bd      	b.n	8029b94 <_svfprintf_r+0x604>
 8029c18:	f047 0708 	orr.w	r7, r7, #8
 8029c1c:	f89b 3000 	ldrb.w	r3, [fp]
 8029c20:	e511      	b.n	8029646 <_svfprintf_r+0xb6>
 8029c22:	2a00      	cmp	r2, #0
 8029c24:	f040 86bd 	bne.w	802a9a2 <_svfprintf_r+0x1412>
 8029c28:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8029c2a:	3507      	adds	r5, #7
 8029c2c:	f025 0507 	bic.w	r5, r5, #7
 8029c30:	ed95 7b00 	vldr	d7, [r5]
 8029c34:	ec52 1b17 	vmov	r1, r2, d7
 8029c38:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8029c3c:	9317      	str	r3, [sp, #92]	; 0x5c
 8029c3e:	ed8d 7a16 	vstr	s14, [sp, #88]	; 0x58
 8029c42:	f105 0408 	add.w	r4, r5, #8
 8029c46:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8029c4a:	f04f 32ff 	mov.w	r2, #4294967295
 8029c4e:	4b1b      	ldr	r3, [pc, #108]	; (8029cbc <_svfprintf_r+0x72c>)
 8029c50:	940b      	str	r4, [sp, #44]	; 0x2c
 8029c52:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8029c56:	f7e2 fed3 	bl	800ca00 <__aeabi_dcmpun>
 8029c5a:	2800      	cmp	r0, #0
 8029c5c:	f040 8331 	bne.w	802a2c2 <_svfprintf_r+0xd32>
 8029c60:	f04f 32ff 	mov.w	r2, #4294967295
 8029c64:	4b15      	ldr	r3, [pc, #84]	; (8029cbc <_svfprintf_r+0x72c>)
 8029c66:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8029c6a:	f7e2 feab 	bl	800c9c4 <__aeabi_dcmple>
 8029c6e:	2800      	cmp	r0, #0
 8029c70:	f040 8327 	bne.w	802a2c2 <_svfprintf_r+0xd32>
 8029c74:	2200      	movs	r2, #0
 8029c76:	2300      	movs	r3, #0
 8029c78:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8029c7c:	f7e2 fe98 	bl	800c9b0 <__aeabi_dcmplt>
 8029c80:	2800      	cmp	r0, #0
 8029c82:	f040 8525 	bne.w	802a6d0 <_svfprintf_r+0x1140>
 8029c86:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 8029c8a:	4a0d      	ldr	r2, [pc, #52]	; (8029cc0 <_svfprintf_r+0x730>)
 8029c8c:	4b0d      	ldr	r3, [pc, #52]	; (8029cc4 <_svfprintf_r+0x734>)
 8029c8e:	2103      	movs	r1, #3
 8029c90:	2000      	movs	r0, #0
 8029c92:	f027 0480 	bic.w	r4, r7, #128	; 0x80
 8029c96:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
 8029c9a:	bfd8      	it	le
 8029c9c:	461a      	movle	r2, r3
 8029c9e:	e9cd 1004 	strd	r1, r0, [sp, #16]
 8029ca2:	9403      	str	r4, [sp, #12]
 8029ca4:	920d      	str	r2, [sp, #52]	; 0x34
 8029ca6:	910a      	str	r1, [sp, #40]	; 0x28
 8029ca8:	900e      	str	r0, [sp, #56]	; 0x38
 8029caa:	e5d8      	b.n	802985e <_svfprintf_r+0x2ce>
 8029cac:	0802ffd0 	.word	0x0802ffd0
 8029cb0:	0802ffe0 	.word	0x0802ffe0
 8029cb4:	0802ff90 	.word	0x0802ff90
 8029cb8:	0802ffa4 	.word	0x0802ffa4
 8029cbc:	7fefffff 	.word	0x7fefffff
 8029cc0:	0802ff84 	.word	0x0802ff84
 8029cc4:	0802ff80 	.word	0x0802ff80
 8029cc8:	2a00      	cmp	r2, #0
 8029cca:	f040 866e 	bne.w	802a9aa <_svfprintf_r+0x141a>
 8029cce:	f047 0710 	orr.w	r7, r7, #16
 8029cd2:	06bc      	lsls	r4, r7, #26
 8029cd4:	f53f adf6 	bmi.w	80298c4 <_svfprintf_r+0x334>
 8029cd8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8029cda:	06f8      	lsls	r0, r7, #27
 8029cdc:	f853 4b04 	ldr.w	r4, [r3], #4
 8029ce0:	930b      	str	r3, [sp, #44]	; 0x2c
 8029ce2:	f100 82a6 	bmi.w	802a232 <_svfprintf_r+0xca2>
 8029ce6:	0679      	lsls	r1, r7, #25
 8029ce8:	f140 82a3 	bpl.w	802a232 <_svfprintf_r+0xca2>
 8029cec:	b224      	sxth	r4, r4
 8029cee:	17e5      	asrs	r5, r4, #31
 8029cf0:	e5f1      	b.n	80298d6 <_svfprintf_r+0x346>
 8029cf2:	f89b 9000 	ldrb.w	r9, [fp]
 8029cf6:	f1b9 0f2a 	cmp.w	r9, #42	; 0x2a
 8029cfa:	f10b 0001 	add.w	r0, fp, #1
 8029cfe:	f000 8618 	beq.w	802a932 <_svfprintf_r+0x13a2>
 8029d02:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 8029d06:	2b09      	cmp	r3, #9
 8029d08:	4683      	mov	fp, r0
 8029d0a:	f200 8507 	bhi.w	802a71c <_svfprintf_r+0x118c>
 8029d0e:	2000      	movs	r0, #0
 8029d10:	f81b 9b01 	ldrb.w	r9, [fp], #1
 8029d14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8029d18:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 8029d1c:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 8029d20:	2b09      	cmp	r3, #9
 8029d22:	d9f5      	bls.n	8029d10 <_svfprintf_r+0x780>
 8029d24:	9005      	str	r0, [sp, #20]
 8029d26:	e491      	b.n	802964c <_svfprintf_r+0xbc>
 8029d28:	f89b 3000 	ldrb.w	r3, [fp]
 8029d2c:	f047 0704 	orr.w	r7, r7, #4
 8029d30:	e489      	b.n	8029646 <_svfprintf_r+0xb6>
 8029d32:	f047 0780 	orr.w	r7, r7, #128	; 0x80
 8029d36:	f89b 3000 	ldrb.w	r3, [fp]
 8029d3a:	e484      	b.n	8029646 <_svfprintf_r+0xb6>
 8029d3c:	2302      	movs	r3, #2
 8029d3e:	e510      	b.n	8029762 <_svfprintf_r+0x1d2>
 8029d40:	2a00      	cmp	r2, #0
 8029d42:	f040 8636 	bne.w	802a9b2 <_svfprintf_r+0x1422>
 8029d46:	f1b9 0f00 	cmp.w	r9, #0
 8029d4a:	f43f ace7 	beq.w	802971c <_svfprintf_r+0x18c>
 8029d4e:	2300      	movs	r3, #0
 8029d50:	2201      	movs	r2, #1
 8029d52:	461e      	mov	r6, r3
 8029d54:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 8029d58:	9305      	str	r3, [sp, #20]
 8029d5a:	930e      	str	r3, [sp, #56]	; 0x38
 8029d5c:	ab26      	add	r3, sp, #152	; 0x98
 8029d5e:	9204      	str	r2, [sp, #16]
 8029d60:	f88d 9098 	strb.w	r9, [sp, #152]	; 0x98
 8029d64:	9703      	str	r7, [sp, #12]
 8029d66:	920a      	str	r2, [sp, #40]	; 0x28
 8029d68:	930d      	str	r3, [sp, #52]	; 0x34
 8029d6a:	e604      	b.n	8029976 <_svfprintf_r+0x3e6>
 8029d6c:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8029d70:	f340 80d3 	ble.w	8029f1a <_svfprintf_r+0x98a>
 8029d74:	2200      	movs	r2, #0
 8029d76:	2300      	movs	r3, #0
 8029d78:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8029d7c:	f7e2 fe0e 	bl	800c99c <__aeabi_dcmpeq>
 8029d80:	2800      	cmp	r0, #0
 8029d82:	f000 8169 	beq.w	802a058 <_svfprintf_r+0xac8>
 8029d86:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029d88:	4ab1      	ldr	r2, [pc, #708]	; (802a050 <_svfprintf_r+0xac0>)
 8029d8a:	f8ca 2000 	str.w	r2, [sl]
 8029d8e:	3301      	adds	r3, #1
 8029d90:	3401      	adds	r4, #1
 8029d92:	2201      	movs	r2, #1
 8029d94:	2b07      	cmp	r3, #7
 8029d96:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029d9a:	f8ca 2004 	str.w	r2, [sl, #4]
 8029d9e:	f300 83ce 	bgt.w	802a53e <_svfprintf_r+0xfae>
 8029da2:	f10a 0a08 	add.w	sl, sl, #8
 8029da6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8029da8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8029daa:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8029dac:	4293      	cmp	r3, r2
 8029dae:	f280 822b 	bge.w	802a208 <_svfprintf_r+0xc78>
 8029db2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029db4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8029db6:	f8ca 2000 	str.w	r2, [sl]
 8029dba:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8029dbc:	f8ca 2004 	str.w	r2, [sl, #4]
 8029dc0:	3301      	adds	r3, #1
 8029dc2:	4414      	add	r4, r2
 8029dc4:	2b07      	cmp	r3, #7
 8029dc6:	e9cd 3424 	strd	r3, r4, [sp, #144]	; 0x90
 8029dca:	f300 8331 	bgt.w	802a430 <_svfprintf_r+0xea0>
 8029dce:	f10a 0a08 	add.w	sl, sl, #8
 8029dd2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8029dd4:	1e5d      	subs	r5, r3, #1
 8029dd6:	2d00      	cmp	r5, #0
 8029dd8:	f77f ae88 	ble.w	8029aec <_svfprintf_r+0x55c>
 8029ddc:	2d10      	cmp	r5, #16
 8029dde:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8029de0:	4f9c      	ldr	r7, [pc, #624]	; (802a054 <_svfprintf_r+0xac4>)
 8029de2:	f340 8385 	ble.w	802a4f0 <_svfprintf_r+0xf60>
 8029de6:	4623      	mov	r3, r4
 8029de8:	2610      	movs	r6, #16
 8029dea:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
 8029dee:	e005      	b.n	8029dfc <_svfprintf_r+0x86c>
 8029df0:	f10a 0a08 	add.w	sl, sl, #8
 8029df4:	3d10      	subs	r5, #16
 8029df6:	2d10      	cmp	r5, #16
 8029df8:	f340 8379 	ble.w	802a4ee <_svfprintf_r+0xf5e>
 8029dfc:	3201      	adds	r2, #1
 8029dfe:	3310      	adds	r3, #16
 8029e00:	2a07      	cmp	r2, #7
 8029e02:	e9cd 2324 	strd	r2, r3, [sp, #144]	; 0x90
 8029e06:	e9ca 7600 	strd	r7, r6, [sl]
 8029e0a:	ddf1      	ble.n	8029df0 <_svfprintf_r+0x860>
 8029e0c:	aa23      	add	r2, sp, #140	; 0x8c
 8029e0e:	4621      	mov	r1, r4
 8029e10:	4648      	mov	r0, r9
 8029e12:	f003 fc55 	bl	802d6c0 <__ssprint_r>
 8029e16:	2800      	cmp	r0, #0
 8029e18:	f47f ac87 	bne.w	802972a <_svfprintf_r+0x19a>
 8029e1c:	e9dd 2324 	ldrd	r2, r3, [sp, #144]	; 0x90
 8029e20:	46c2      	mov	sl, r8
 8029e22:	e7e7      	b.n	8029df4 <_svfprintf_r+0x864>
 8029e24:	9b07      	ldr	r3, [sp, #28]
 8029e26:	9a04      	ldr	r2, [sp, #16]
 8029e28:	1a9d      	subs	r5, r3, r2
 8029e2a:	2d00      	cmp	r5, #0
 8029e2c:	f77f ae13 	ble.w	8029a56 <_svfprintf_r+0x4c6>
 8029e30:	2d10      	cmp	r5, #16
 8029e32:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8029e34:	4f87      	ldr	r7, [pc, #540]	; (802a054 <_svfprintf_r+0xac4>)
 8029e36:	dd22      	ble.n	8029e7e <_svfprintf_r+0x8ee>
 8029e38:	4653      	mov	r3, sl
 8029e3a:	4621      	mov	r1, r4
 8029e3c:	2610      	movs	r6, #16
 8029e3e:	e9dd a408 	ldrd	sl, r4, [sp, #32]
 8029e42:	e004      	b.n	8029e4e <_svfprintf_r+0x8be>
 8029e44:	3d10      	subs	r5, #16
 8029e46:	2d10      	cmp	r5, #16
 8029e48:	f103 0308 	add.w	r3, r3, #8
 8029e4c:	dd15      	ble.n	8029e7a <_svfprintf_r+0x8ea>
 8029e4e:	3201      	adds	r2, #1
 8029e50:	3110      	adds	r1, #16
 8029e52:	2a07      	cmp	r2, #7
 8029e54:	e9cd 2124 	strd	r2, r1, [sp, #144]	; 0x90
 8029e58:	e9c3 7600 	strd	r7, r6, [r3]
 8029e5c:	ddf2      	ble.n	8029e44 <_svfprintf_r+0x8b4>
 8029e5e:	aa23      	add	r2, sp, #140	; 0x8c
 8029e60:	4651      	mov	r1, sl
 8029e62:	4620      	mov	r0, r4
 8029e64:	f003 fc2c 	bl	802d6c0 <__ssprint_r>
 8029e68:	2800      	cmp	r0, #0
 8029e6a:	f47f ac5e 	bne.w	802972a <_svfprintf_r+0x19a>
 8029e6e:	3d10      	subs	r5, #16
 8029e70:	2d10      	cmp	r5, #16
 8029e72:	e9dd 2124 	ldrd	r2, r1, [sp, #144]	; 0x90
 8029e76:	4643      	mov	r3, r8
 8029e78:	dce9      	bgt.n	8029e4e <_svfprintf_r+0x8be>
 8029e7a:	469a      	mov	sl, r3
 8029e7c:	460c      	mov	r4, r1
 8029e7e:	3201      	adds	r2, #1
 8029e80:	442c      	add	r4, r5
 8029e82:	2a07      	cmp	r2, #7
 8029e84:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 8029e88:	e9ca 7500 	strd	r7, r5, [sl]
 8029e8c:	f300 833a 	bgt.w	802a504 <_svfprintf_r+0xf74>
 8029e90:	f10a 0a08 	add.w	sl, sl, #8
 8029e94:	e5df      	b.n	8029a56 <_svfprintf_r+0x4c6>
 8029e96:	aa23      	add	r2, sp, #140	; 0x8c
 8029e98:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029e9c:	f003 fc10 	bl	802d6c0 <__ssprint_r>
 8029ea0:	2800      	cmp	r0, #0
 8029ea2:	f43f ae63 	beq.w	8029b6c <_svfprintf_r+0x5dc>
 8029ea6:	e440      	b.n	802972a <_svfprintf_r+0x19a>
 8029ea8:	aa23      	add	r2, sp, #140	; 0x8c
 8029eaa:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029eae:	f003 fc07 	bl	802d6c0 <__ssprint_r>
 8029eb2:	2800      	cmp	r0, #0
 8029eb4:	f47f ac39 	bne.w	802972a <_svfprintf_r+0x19a>
 8029eb8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8029eba:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8029ebc:	46c2      	mov	sl, r8
 8029ebe:	b91b      	cbnz	r3, 8029ec8 <_svfprintf_r+0x938>
 8029ec0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8029ec2:	2a00      	cmp	r2, #0
 8029ec4:	f000 8375 	beq.w	802a5b2 <_svfprintf_r+0x1022>
 8029ec8:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8029eca:	9914      	ldr	r1, [sp, #80]	; 0x50
 8029ecc:	f8ca 1000 	str.w	r1, [sl]
 8029ed0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8029ed2:	f8ca 1004 	str.w	r1, [sl, #4]
 8029ed6:	3201      	adds	r2, #1
 8029ed8:	440c      	add	r4, r1
 8029eda:	2a07      	cmp	r2, #7
 8029edc:	9425      	str	r4, [sp, #148]	; 0x94
 8029ede:	9224      	str	r2, [sp, #144]	; 0x90
 8029ee0:	f300 8450 	bgt.w	802a784 <_svfprintf_r+0x11f4>
 8029ee4:	f10a 0a08 	add.w	sl, sl, #8
 8029ee8:	2b00      	cmp	r3, #0
 8029eea:	f2c0 8487 	blt.w	802a7fc <_svfprintf_r+0x126c>
 8029eee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8029ef0:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029ef2:	3201      	adds	r2, #1
 8029ef4:	441c      	add	r4, r3
 8029ef6:	2a07      	cmp	r2, #7
 8029ef8:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 8029efc:	e9ca 1300 	strd	r1, r3, [sl]
 8029f00:	f77f adf2 	ble.w	8029ae8 <_svfprintf_r+0x558>
 8029f04:	aa23      	add	r2, sp, #140	; 0x8c
 8029f06:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029f0a:	f003 fbd9 	bl	802d6c0 <__ssprint_r>
 8029f0e:	2800      	cmp	r0, #0
 8029f10:	f47f ac0b 	bne.w	802972a <_svfprintf_r+0x19a>
 8029f14:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8029f16:	46c2      	mov	sl, r8
 8029f18:	e5e8      	b.n	8029aec <_svfprintf_r+0x55c>
 8029f1a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8029f1c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8029f1e:	2a01      	cmp	r2, #1
 8029f20:	f104 0401 	add.w	r4, r4, #1
 8029f24:	f103 0501 	add.w	r5, r3, #1
 8029f28:	f10a 0608 	add.w	r6, sl, #8
 8029f2c:	f340 814a 	ble.w	802a1c4 <_svfprintf_r+0xc34>
 8029f30:	2301      	movs	r3, #1
 8029f32:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8029f34:	f8ca 2000 	str.w	r2, [sl]
 8029f38:	2d07      	cmp	r5, #7
 8029f3a:	e9cd 5424 	strd	r5, r4, [sp, #144]	; 0x90
 8029f3e:	f8ca 3004 	str.w	r3, [sl, #4]
 8029f42:	f300 82b8 	bgt.w	802a4b6 <_svfprintf_r+0xf26>
 8029f46:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8029f48:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8029f4a:	3501      	adds	r5, #1
 8029f4c:	441c      	add	r4, r3
 8029f4e:	2d07      	cmp	r5, #7
 8029f50:	e9cd 5424 	strd	r5, r4, [sp, #144]	; 0x90
 8029f54:	e9c6 2300 	strd	r2, r3, [r6]
 8029f58:	f300 82b9 	bgt.w	802a4ce <_svfprintf_r+0xf3e>
 8029f5c:	3608      	adds	r6, #8
 8029f5e:	1c6b      	adds	r3, r5, #1
 8029f60:	461f      	mov	r7, r3
 8029f62:	46b9      	mov	r9, r7
 8029f64:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8029f66:	930a      	str	r3, [sp, #40]	; 0x28
 8029f68:	3f01      	subs	r7, #1
 8029f6a:	2200      	movs	r2, #0
 8029f6c:	2300      	movs	r3, #0
 8029f6e:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8029f72:	9705      	str	r7, [sp, #20]
 8029f74:	f106 0a08 	add.w	sl, r6, #8
 8029f78:	f7e2 fd10 	bl	800c99c <__aeabi_dcmpeq>
 8029f7c:	2800      	cmp	r0, #0
 8029f7e:	f040 80e1 	bne.w	802a144 <_svfprintf_r+0xbb4>
 8029f82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8029f84:	6077      	str	r7, [r6, #4]
 8029f86:	3301      	adds	r3, #1
 8029f88:	443c      	add	r4, r7
 8029f8a:	f1b9 0f07 	cmp.w	r9, #7
 8029f8e:	6033      	str	r3, [r6, #0]
 8029f90:	9425      	str	r4, [sp, #148]	; 0x94
 8029f92:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
 8029f96:	f300 823b 	bgt.w	802a410 <_svfprintf_r+0xe80>
 8029f9a:	f106 0310 	add.w	r3, r6, #16
 8029f9e:	f105 0902 	add.w	r9, r5, #2
 8029fa2:	4656      	mov	r6, sl
 8029fa4:	469a      	mov	sl, r3
 8029fa6:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8029fa8:	6072      	str	r2, [r6, #4]
 8029faa:	4414      	add	r4, r2
 8029fac:	ab1f      	add	r3, sp, #124	; 0x7c
 8029fae:	f1b9 0f07 	cmp.w	r9, #7
 8029fb2:	9425      	str	r4, [sp, #148]	; 0x94
 8029fb4:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
 8029fb8:	6033      	str	r3, [r6, #0]
 8029fba:	f77f ad97 	ble.w	8029aec <_svfprintf_r+0x55c>
 8029fbe:	e7a1      	b.n	8029f04 <_svfprintf_r+0x974>
 8029fc0:	2b01      	cmp	r3, #1
 8029fc2:	9703      	str	r7, [sp, #12]
 8029fc4:	f47f ac9e 	bne.w	8029904 <_svfprintf_r+0x374>
 8029fc8:	2d00      	cmp	r5, #0
 8029fca:	bf08      	it	eq
 8029fcc:	2c0a      	cmpeq	r4, #10
 8029fce:	f080 8147 	bcs.w	802a260 <_svfprintf_r+0xcd0>
 8029fd2:	ab40      	add	r3, sp, #256	; 0x100
 8029fd4:	3430      	adds	r4, #48	; 0x30
 8029fd6:	f803 4d41 	strb.w	r4, [r3, #-65]!
 8029fda:	930d      	str	r3, [sp, #52]	; 0x34
 8029fdc:	2301      	movs	r3, #1
 8029fde:	930a      	str	r3, [sp, #40]	; 0x28
 8029fe0:	e4ae      	b.n	8029940 <_svfprintf_r+0x3b0>
 8029fe2:	aa23      	add	r2, sp, #140	; 0x8c
 8029fe4:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029fe8:	f003 fb6a 	bl	802d6c0 <__ssprint_r>
 8029fec:	2800      	cmp	r0, #0
 8029fee:	f47f ab9c 	bne.w	802972a <_svfprintf_r+0x19a>
 8029ff2:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8029ff4:	46c2      	mov	sl, r8
 8029ff6:	e51b      	b.n	8029a30 <_svfprintf_r+0x4a0>
 8029ff8:	aa23      	add	r2, sp, #140	; 0x8c
 8029ffa:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 8029ffe:	f003 fb5f 	bl	802d6c0 <__ssprint_r>
 802a002:	2800      	cmp	r0, #0
 802a004:	f47f ab91 	bne.w	802972a <_svfprintf_r+0x19a>
 802a008:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a00a:	46c2      	mov	sl, r8
 802a00c:	e51f      	b.n	8029a4e <_svfprintf_r+0x4be>
 802a00e:	9f12      	ldr	r7, [sp, #72]	; 0x48
 802a010:	4642      	mov	r2, r8
 802a012:	0923      	lsrs	r3, r4, #4
 802a014:	f004 000f 	and.w	r0, r4, #15
 802a018:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 802a01c:	0929      	lsrs	r1, r5, #4
 802a01e:	461c      	mov	r4, r3
 802a020:	460d      	mov	r5, r1
 802a022:	5c3b      	ldrb	r3, [r7, r0]
 802a024:	f802 3d01 	strb.w	r3, [r2, #-1]!
 802a028:	ea54 0305 	orrs.w	r3, r4, r5
 802a02c:	d1f1      	bne.n	802a012 <_svfprintf_r+0xa82>
 802a02e:	eba8 0302 	sub.w	r3, r8, r2
 802a032:	920d      	str	r2, [sp, #52]	; 0x34
 802a034:	930a      	str	r3, [sp, #40]	; 0x28
 802a036:	e483      	b.n	8029940 <_svfprintf_r+0x3b0>
 802a038:	aa23      	add	r2, sp, #140	; 0x8c
 802a03a:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a03e:	f003 fb3f 	bl	802d6c0 <__ssprint_r>
 802a042:	2800      	cmp	r0, #0
 802a044:	f47f ab71 	bne.w	802972a <_svfprintf_r+0x19a>
 802a048:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a04a:	46c2      	mov	sl, r8
 802a04c:	e53a      	b.n	8029ac4 <_svfprintf_r+0x534>
 802a04e:	bf00      	nop
 802a050:	0802ffc0 	.word	0x0802ffc0
 802a054:	0802ffe0 	.word	0x0802ffe0
 802a058:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a05a:	2b00      	cmp	r3, #0
 802a05c:	f340 825e 	ble.w	802a51c <_svfprintf_r+0xf8c>
 802a060:	e9dd 320e 	ldrd	r3, r2, [sp, #56]	; 0x38
 802a064:	4293      	cmp	r3, r2
 802a066:	bfa8      	it	ge
 802a068:	4613      	movge	r3, r2
 802a06a:	2b00      	cmp	r3, #0
 802a06c:	461d      	mov	r5, r3
 802a06e:	dd0e      	ble.n	802a08e <_svfprintf_r+0xafe>
 802a070:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802a072:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a074:	f8ca 2000 	str.w	r2, [sl]
 802a078:	3301      	adds	r3, #1
 802a07a:	442c      	add	r4, r5
 802a07c:	2b07      	cmp	r3, #7
 802a07e:	9425      	str	r4, [sp, #148]	; 0x94
 802a080:	f8ca 5004 	str.w	r5, [sl, #4]
 802a084:	9324      	str	r3, [sp, #144]	; 0x90
 802a086:	f300 8318 	bgt.w	802a6ba <_svfprintf_r+0x112a>
 802a08a:	f10a 0a08 	add.w	sl, sl, #8
 802a08e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a090:	2d00      	cmp	r5, #0
 802a092:	bfa8      	it	ge
 802a094:	1b5b      	subge	r3, r3, r5
 802a096:	2b00      	cmp	r3, #0
 802a098:	461d      	mov	r5, r3
 802a09a:	f300 8180 	bgt.w	802a39e <_svfprintf_r+0xe0e>
 802a09e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a0a0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802a0a2:	4293      	cmp	r3, r2
 802a0a4:	f2c0 81e4 	blt.w	802a470 <_svfprintf_r+0xee0>
 802a0a8:	9a03      	ldr	r2, [sp, #12]
 802a0aa:	07d0      	lsls	r0, r2, #31
 802a0ac:	f100 81e0 	bmi.w	802a470 <_svfprintf_r+0xee0>
 802a0b0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802a0b2:	980e      	ldr	r0, [sp, #56]	; 0x38
 802a0b4:	1ad3      	subs	r3, r2, r3
 802a0b6:	1a15      	subs	r5, r2, r0
 802a0b8:	429d      	cmp	r5, r3
 802a0ba:	bfa8      	it	ge
 802a0bc:	461d      	movge	r5, r3
 802a0be:	2d00      	cmp	r5, #0
 802a0c0:	dd0f      	ble.n	802a0e2 <_svfprintf_r+0xb52>
 802a0c2:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802a0c4:	990d      	ldr	r1, [sp, #52]	; 0x34
 802a0c6:	f8ca 5004 	str.w	r5, [sl, #4]
 802a0ca:	3201      	adds	r2, #1
 802a0cc:	4401      	add	r1, r0
 802a0ce:	442c      	add	r4, r5
 802a0d0:	2a07      	cmp	r2, #7
 802a0d2:	f8ca 1000 	str.w	r1, [sl]
 802a0d6:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a0da:	f300 8323 	bgt.w	802a724 <_svfprintf_r+0x1194>
 802a0de:	f10a 0a08 	add.w	sl, sl, #8
 802a0e2:	2d00      	cmp	r5, #0
 802a0e4:	bfac      	ite	ge
 802a0e6:	1b5d      	subge	r5, r3, r5
 802a0e8:	461d      	movlt	r5, r3
 802a0ea:	2d00      	cmp	r5, #0
 802a0ec:	f77f acfe 	ble.w	8029aec <_svfprintf_r+0x55c>
 802a0f0:	2d10      	cmp	r5, #16
 802a0f2:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802a0f4:	4fc5      	ldr	r7, [pc, #788]	; (802a40c <_svfprintf_r+0xe7c>)
 802a0f6:	f340 81fb 	ble.w	802a4f0 <_svfprintf_r+0xf60>
 802a0fa:	4623      	mov	r3, r4
 802a0fc:	2610      	movs	r6, #16
 802a0fe:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
 802a102:	e005      	b.n	802a110 <_svfprintf_r+0xb80>
 802a104:	f10a 0a08 	add.w	sl, sl, #8
 802a108:	3d10      	subs	r5, #16
 802a10a:	2d10      	cmp	r5, #16
 802a10c:	f340 81ef 	ble.w	802a4ee <_svfprintf_r+0xf5e>
 802a110:	3201      	adds	r2, #1
 802a112:	3310      	adds	r3, #16
 802a114:	2a07      	cmp	r2, #7
 802a116:	e9cd 2324 	strd	r2, r3, [sp, #144]	; 0x90
 802a11a:	e9ca 7600 	strd	r7, r6, [sl]
 802a11e:	ddf1      	ble.n	802a104 <_svfprintf_r+0xb74>
 802a120:	aa23      	add	r2, sp, #140	; 0x8c
 802a122:	4621      	mov	r1, r4
 802a124:	4648      	mov	r0, r9
 802a126:	f003 facb 	bl	802d6c0 <__ssprint_r>
 802a12a:	2800      	cmp	r0, #0
 802a12c:	f47f aafd 	bne.w	802972a <_svfprintf_r+0x19a>
 802a130:	e9dd 2324 	ldrd	r2, r3, [sp, #144]	; 0x90
 802a134:	46c2      	mov	sl, r8
 802a136:	e7e7      	b.n	802a108 <_svfprintf_r+0xb78>
 802a138:	9b05      	ldr	r3, [sp, #20]
 802a13a:	930a      	str	r3, [sp, #40]	; 0x28
 802a13c:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 802a140:	f7ff bbfe 	b.w	8029940 <_svfprintf_r+0x3b0>
 802a144:	9a05      	ldr	r2, [sp, #20]
 802a146:	2a00      	cmp	r2, #0
 802a148:	f77f af2d 	ble.w	8029fa6 <_svfprintf_r+0xa16>
 802a14c:	2a10      	cmp	r2, #16
 802a14e:	4faf      	ldr	r7, [pc, #700]	; (802a40c <_svfprintf_r+0xe7c>)
 802a150:	f340 83ea 	ble.w	802a928 <_svfprintf_r+0x1398>
 802a154:	4633      	mov	r3, r6
 802a156:	4692      	mov	sl, r2
 802a158:	f04f 0910 	mov.w	r9, #16
 802a15c:	4622      	mov	r2, r4
 802a15e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 802a160:	e9dd 6408 	ldrd	r6, r4, [sp, #32]
 802a164:	e007      	b.n	802a176 <_svfprintf_r+0xbe6>
 802a166:	3308      	adds	r3, #8
 802a168:	f1aa 0a10 	sub.w	sl, sl, #16
 802a16c:	f1ba 0f10 	cmp.w	sl, #16
 802a170:	f340 81ef 	ble.w	802a552 <_svfprintf_r+0xfc2>
 802a174:	3501      	adds	r5, #1
 802a176:	3210      	adds	r2, #16
 802a178:	2d07      	cmp	r5, #7
 802a17a:	e9cd 5224 	strd	r5, r2, [sp, #144]	; 0x90
 802a17e:	e9c3 7900 	strd	r7, r9, [r3]
 802a182:	ddf0      	ble.n	802a166 <_svfprintf_r+0xbd6>
 802a184:	aa23      	add	r2, sp, #140	; 0x8c
 802a186:	4631      	mov	r1, r6
 802a188:	4620      	mov	r0, r4
 802a18a:	f003 fa99 	bl	802d6c0 <__ssprint_r>
 802a18e:	2800      	cmp	r0, #0
 802a190:	f47f aacb 	bne.w	802972a <_svfprintf_r+0x19a>
 802a194:	e9dd 5224 	ldrd	r5, r2, [sp, #144]	; 0x90
 802a198:	4643      	mov	r3, r8
 802a19a:	e7e5      	b.n	802a168 <_svfprintf_r+0xbd8>
 802a19c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802a19e:	06fd      	lsls	r5, r7, #27
 802a1a0:	f853 4b04 	ldr.w	r4, [r3], #4
 802a1a4:	930b      	str	r3, [sp, #44]	; 0x2c
 802a1a6:	d576      	bpl.n	802a296 <_svfprintf_r+0xd06>
 802a1a8:	2500      	movs	r5, #0
 802a1aa:	2301      	movs	r3, #1
 802a1ac:	f7ff bad9 	b.w	8029762 <_svfprintf_r+0x1d2>
 802a1b0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802a1b2:	f852 4b04 	ldr.w	r4, [r2], #4
 802a1b6:	920b      	str	r2, [sp, #44]	; 0x2c
 802a1b8:	f017 0210 	ands.w	r2, r7, #16
 802a1bc:	d079      	beq.n	802a2b2 <_svfprintf_r+0xd22>
 802a1be:	2500      	movs	r5, #0
 802a1c0:	f7ff bacf 	b.w	8029762 <_svfprintf_r+0x1d2>
 802a1c4:	9a03      	ldr	r2, [sp, #12]
 802a1c6:	07d1      	lsls	r1, r2, #31
 802a1c8:	f53f aeb2 	bmi.w	8029f30 <_svfprintf_r+0x9a0>
 802a1cc:	2201      	movs	r2, #1
 802a1ce:	990d      	ldr	r1, [sp, #52]	; 0x34
 802a1d0:	f8ca 1000 	str.w	r1, [sl]
 802a1d4:	2d07      	cmp	r5, #7
 802a1d6:	e9cd 5424 	strd	r5, r4, [sp, #144]	; 0x90
 802a1da:	f8ca 2004 	str.w	r2, [sl, #4]
 802a1de:	f300 8117 	bgt.w	802a410 <_svfprintf_r+0xe80>
 802a1e2:	f103 0902 	add.w	r9, r3, #2
 802a1e6:	f10a 0a10 	add.w	sl, sl, #16
 802a1ea:	e6dc      	b.n	8029fa6 <_svfprintf_r+0xa16>
 802a1ec:	2b30      	cmp	r3, #48	; 0x30
 802a1ee:	f000 8139 	beq.w	802a464 <_svfprintf_r+0xed4>
 802a1f2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a1f4:	3902      	subs	r1, #2
 802a1f6:	2330      	movs	r3, #48	; 0x30
 802a1f8:	f802 3c01 	strb.w	r3, [r2, #-1]
 802a1fc:	eba8 0301 	sub.w	r3, r8, r1
 802a200:	930a      	str	r3, [sp, #40]	; 0x28
 802a202:	910d      	str	r1, [sp, #52]	; 0x34
 802a204:	f7ff bb9c 	b.w	8029940 <_svfprintf_r+0x3b0>
 802a208:	9b03      	ldr	r3, [sp, #12]
 802a20a:	07de      	lsls	r6, r3, #31
 802a20c:	f53f add1 	bmi.w	8029db2 <_svfprintf_r+0x822>
 802a210:	e46c      	b.n	8029aec <_svfprintf_r+0x55c>
 802a212:	aa23      	add	r2, sp, #140	; 0x8c
 802a214:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a218:	f003 fa52 	bl	802d6c0 <__ssprint_r>
 802a21c:	2800      	cmp	r0, #0
 802a21e:	f47f aa84 	bne.w	802972a <_svfprintf_r+0x19a>
 802a222:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a224:	e497      	b.n	8029b56 <_svfprintf_r+0x5c6>
 802a226:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 802a22a:	f7ff bb89 	b.w	8029940 <_svfprintf_r+0x3b0>
 802a22e:	2500      	movs	r5, #0
 802a230:	e4b0      	b.n	8029b94 <_svfprintf_r+0x604>
 802a232:	17e5      	asrs	r5, r4, #31
 802a234:	2c00      	cmp	r4, #0
 802a236:	f175 0300 	sbcs.w	r3, r5, #0
 802a23a:	f6bf ab51 	bge.w	80298e0 <_svfprintf_r+0x350>
 802a23e:	9b05      	ldr	r3, [sp, #20]
 802a240:	4264      	negs	r4, r4
 802a242:	f04f 062d 	mov.w	r6, #45	; 0x2d
 802a246:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 802a24a:	3301      	adds	r3, #1
 802a24c:	f88d 606f 	strb.w	r6, [sp, #111]	; 0x6f
 802a250:	f47f ab4c 	bne.w	80298ec <_svfprintf_r+0x35c>
 802a254:	2d00      	cmp	r5, #0
 802a256:	bf08      	it	eq
 802a258:	2c0a      	cmpeq	r4, #10
 802a25a:	9703      	str	r7, [sp, #12]
 802a25c:	f4ff aeb9 	bcc.w	8029fd2 <_svfprintf_r+0xa42>
 802a260:	4647      	mov	r7, r8
 802a262:	4620      	mov	r0, r4
 802a264:	4629      	mov	r1, r5
 802a266:	220a      	movs	r2, #10
 802a268:	2300      	movs	r3, #0
 802a26a:	f7e2 ff49 	bl	800d100 <__aeabi_uldivmod>
 802a26e:	3230      	adds	r2, #48	; 0x30
 802a270:	f807 2d01 	strb.w	r2, [r7, #-1]!
 802a274:	4620      	mov	r0, r4
 802a276:	4629      	mov	r1, r5
 802a278:	2300      	movs	r3, #0
 802a27a:	220a      	movs	r2, #10
 802a27c:	f7e2 ff40 	bl	800d100 <__aeabi_uldivmod>
 802a280:	4604      	mov	r4, r0
 802a282:	460d      	mov	r5, r1
 802a284:	ea54 0305 	orrs.w	r3, r4, r5
 802a288:	d1eb      	bne.n	802a262 <_svfprintf_r+0xcd2>
 802a28a:	eba8 0307 	sub.w	r3, r8, r7
 802a28e:	970d      	str	r7, [sp, #52]	; 0x34
 802a290:	930a      	str	r3, [sp, #40]	; 0x28
 802a292:	f7ff bb55 	b.w	8029940 <_svfprintf_r+0x3b0>
 802a296:	0678      	lsls	r0, r7, #25
 802a298:	bf48      	it	mi
 802a29a:	b2a4      	uxthmi	r4, r4
 802a29c:	2500      	movs	r5, #0
 802a29e:	2301      	movs	r3, #1
 802a2a0:	f7ff ba5f 	b.w	8029762 <_svfprintf_r+0x1d2>
 802a2a4:	9a06      	ldr	r2, [sp, #24]
 802a2a6:	4610      	mov	r0, r2
 802a2a8:	17d1      	asrs	r1, r2, #31
 802a2aa:	e9c3 0100 	strd	r0, r1, [r3]
 802a2ae:	f7ff b997 	b.w	80295e0 <_svfprintf_r+0x50>
 802a2b2:	f017 0340 	ands.w	r3, r7, #64	; 0x40
 802a2b6:	bf1c      	itt	ne
 802a2b8:	4613      	movne	r3, r2
 802a2ba:	b2a4      	uxthne	r4, r4
 802a2bc:	2500      	movs	r5, #0
 802a2be:	f7ff ba50 	b.w	8029762 <_svfprintf_r+0x1d2>
 802a2c2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 802a2c6:	4602      	mov	r2, r0
 802a2c8:	460b      	mov	r3, r1
 802a2ca:	f7e2 fb99 	bl	800ca00 <__aeabi_dcmpun>
 802a2ce:	2800      	cmp	r0, #0
 802a2d0:	f040 8303 	bne.w	802a8da <_svfprintf_r+0x134a>
 802a2d4:	9b05      	ldr	r3, [sp, #20]
 802a2d6:	1c5a      	adds	r2, r3, #1
 802a2d8:	f029 0620 	bic.w	r6, r9, #32
 802a2dc:	f000 8244 	beq.w	802a768 <_svfprintf_r+0x11d8>
 802a2e0:	2e47      	cmp	r6, #71	; 0x47
 802a2e2:	f000 816b 	beq.w	802a5bc <_svfprintf_r+0x102c>
 802a2e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802a2e8:	f447 7280 	orr.w	r2, r7, #256	; 0x100
 802a2ec:	2b00      	cmp	r3, #0
 802a2ee:	9203      	str	r2, [sp, #12]
 802a2f0:	f2c0 820b 	blt.w	802a70a <_svfprintf_r+0x117a>
 802a2f4:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 802a2f8:	ed8d 7b18 	vstr	d7, [sp, #96]	; 0x60
 802a2fc:	2300      	movs	r3, #0
 802a2fe:	930c      	str	r3, [sp, #48]	; 0x30
 802a300:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 802a304:	f000 8220 	beq.w	802a748 <_svfprintf_r+0x11b8>
 802a308:	f1b9 0f46 	cmp.w	r9, #70	; 0x46
 802a30c:	f000 825c 	beq.w	802a7c8 <_svfprintf_r+0x1238>
 802a310:	2e45      	cmp	r6, #69	; 0x45
 802a312:	f000 8158 	beq.w	802a5c6 <_svfprintf_r+0x1036>
 802a316:	aa21      	add	r2, sp, #132	; 0x84
 802a318:	ab1e      	add	r3, sp, #120	; 0x78
 802a31a:	e9cd 3200 	strd	r3, r2, [sp]
 802a31e:	2102      	movs	r1, #2
 802a320:	ab1d      	add	r3, sp, #116	; 0x74
 802a322:	9a05      	ldr	r2, [sp, #20]
 802a324:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a326:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
 802a32a:	f000 fc41 	bl	802abb0 <_dtoa_r>
 802a32e:	f1b9 0f67 	cmp.w	r9, #103	; 0x67
 802a332:	900d      	str	r0, [sp, #52]	; 0x34
 802a334:	f040 832f 	bne.w	802a996 <_svfprintf_r+0x1406>
 802a338:	07fb      	lsls	r3, r7, #31
 802a33a:	f140 8169 	bpl.w	802a610 <_svfprintf_r+0x1080>
 802a33e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802a340:	9a05      	ldr	r2, [sp, #20]
 802a342:	189c      	adds	r4, r3, r2
 802a344:	2200      	movs	r2, #0
 802a346:	2300      	movs	r3, #0
 802a348:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 802a34c:	f7e2 fb26 	bl	800c99c <__aeabi_dcmpeq>
 802a350:	2800      	cmp	r0, #0
 802a352:	f000 81ce 	beq.w	802a6f2 <_svfprintf_r+0x1162>
 802a356:	4623      	mov	r3, r4
 802a358:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a35a:	1a9b      	subs	r3, r3, r2
 802a35c:	930f      	str	r3, [sp, #60]	; 0x3c
 802a35e:	2e47      	cmp	r6, #71	; 0x47
 802a360:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a362:	930e      	str	r3, [sp, #56]	; 0x38
 802a364:	f000 815d 	beq.w	802a622 <_svfprintf_r+0x1092>
 802a368:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 802a36c:	f040 8161 	bne.w	802a632 <_svfprintf_r+0x10a2>
 802a370:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a372:	2b00      	cmp	r3, #0
 802a374:	9b05      	ldr	r3, [sp, #20]
 802a376:	f340 82d0 	ble.w	802a91a <_svfprintf_r+0x138a>
 802a37a:	2b00      	cmp	r3, #0
 802a37c:	f040 82b9 	bne.w	802a8f2 <_svfprintf_r+0x1362>
 802a380:	07fd      	lsls	r5, r7, #31
 802a382:	f100 82b6 	bmi.w	802a8f2 <_svfprintf_r+0x1362>
 802a386:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a388:	9304      	str	r3, [sp, #16]
 802a38a:	930a      	str	r3, [sp, #40]	; 0x28
 802a38c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802a38e:	2b00      	cmp	r3, #0
 802a390:	f040 817a 	bne.w	802a688 <_svfprintf_r+0x10f8>
 802a394:	9305      	str	r3, [sp, #20]
 802a396:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 802a39a:	f7ff ba60 	b.w	802985e <_svfprintf_r+0x2ce>
 802a39e:	2b10      	cmp	r3, #16
 802a3a0:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802a3a2:	4f1a      	ldr	r7, [pc, #104]	; (802a40c <_svfprintf_r+0xe7c>)
 802a3a4:	f340 80ef 	ble.w	802a586 <_svfprintf_r+0xff6>
 802a3a8:	4623      	mov	r3, r4
 802a3aa:	2610      	movs	r6, #16
 802a3ac:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
 802a3b0:	e005      	b.n	802a3be <_svfprintf_r+0xe2e>
 802a3b2:	f10a 0a08 	add.w	sl, sl, #8
 802a3b6:	3d10      	subs	r5, #16
 802a3b8:	2d10      	cmp	r5, #16
 802a3ba:	f340 80e3 	ble.w	802a584 <_svfprintf_r+0xff4>
 802a3be:	3201      	adds	r2, #1
 802a3c0:	3310      	adds	r3, #16
 802a3c2:	2a07      	cmp	r2, #7
 802a3c4:	e9cd 2324 	strd	r2, r3, [sp, #144]	; 0x90
 802a3c8:	e9ca 7600 	strd	r7, r6, [sl]
 802a3cc:	ddf1      	ble.n	802a3b2 <_svfprintf_r+0xe22>
 802a3ce:	aa23      	add	r2, sp, #140	; 0x8c
 802a3d0:	4621      	mov	r1, r4
 802a3d2:	4648      	mov	r0, r9
 802a3d4:	f003 f974 	bl	802d6c0 <__ssprint_r>
 802a3d8:	2800      	cmp	r0, #0
 802a3da:	f47f a9a6 	bne.w	802972a <_svfprintf_r+0x19a>
 802a3de:	e9dd 2324 	ldrd	r2, r3, [sp, #144]	; 0x90
 802a3e2:	46c2      	mov	sl, r8
 802a3e4:	e7e7      	b.n	802a3b6 <_svfprintf_r+0xe26>
 802a3e6:	4264      	negs	r4, r4
 802a3e8:	9407      	str	r4, [sp, #28]
 802a3ea:	900b      	str	r0, [sp, #44]	; 0x2c
 802a3ec:	e49e      	b.n	8029d2c <_svfprintf_r+0x79c>
 802a3ee:	2140      	movs	r1, #64	; 0x40
 802a3f0:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a3f2:	f002 f81d 	bl	802c430 <_malloc_r>
 802a3f6:	9b08      	ldr	r3, [sp, #32]
 802a3f8:	6018      	str	r0, [r3, #0]
 802a3fa:	6118      	str	r0, [r3, #16]
 802a3fc:	2800      	cmp	r0, #0
 802a3fe:	f000 82c2 	beq.w	802a986 <_svfprintf_r+0x13f6>
 802a402:	9a08      	ldr	r2, [sp, #32]
 802a404:	2340      	movs	r3, #64	; 0x40
 802a406:	6153      	str	r3, [r2, #20]
 802a408:	f7ff b8d9 	b.w	80295be <_svfprintf_r+0x2e>
 802a40c:	0802ffe0 	.word	0x0802ffe0
 802a410:	aa23      	add	r2, sp, #140	; 0x8c
 802a412:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a416:	f003 f953 	bl	802d6c0 <__ssprint_r>
 802a41a:	2800      	cmp	r0, #0
 802a41c:	f47f a985 	bne.w	802972a <_svfprintf_r+0x19a>
 802a420:	e9dd 3424 	ldrd	r3, r4, [sp, #144]	; 0x90
 802a424:	f10d 0ac8 	add.w	sl, sp, #200	; 0xc8
 802a428:	f103 0901 	add.w	r9, r3, #1
 802a42c:	4646      	mov	r6, r8
 802a42e:	e5ba      	b.n	8029fa6 <_svfprintf_r+0xa16>
 802a430:	aa23      	add	r2, sp, #140	; 0x8c
 802a432:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a436:	f003 f943 	bl	802d6c0 <__ssprint_r>
 802a43a:	2800      	cmp	r0, #0
 802a43c:	f47f a975 	bne.w	802972a <_svfprintf_r+0x19a>
 802a440:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a442:	46c2      	mov	sl, r8
 802a444:	e4c5      	b.n	8029dd2 <_svfprintf_r+0x842>
 802a446:	9b05      	ldr	r3, [sp, #20]
 802a448:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 802a44a:	9605      	str	r6, [sp, #20]
 802a44c:	2b06      	cmp	r3, #6
 802a44e:	bf28      	it	cs
 802a450:	2306      	movcs	r3, #6
 802a452:	9304      	str	r3, [sp, #16]
 802a454:	930a      	str	r3, [sp, #40]	; 0x28
 802a456:	4bba      	ldr	r3, [pc, #744]	; (802a740 <_svfprintf_r+0x11b0>)
 802a458:	950b      	str	r5, [sp, #44]	; 0x2c
 802a45a:	9703      	str	r7, [sp, #12]
 802a45c:	960e      	str	r6, [sp, #56]	; 0x38
 802a45e:	930d      	str	r3, [sp, #52]	; 0x34
 802a460:	f7ff b9fd 	b.w	802985e <_svfprintf_r+0x2ce>
 802a464:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802a466:	eba8 0303 	sub.w	r3, r8, r3
 802a46a:	930a      	str	r3, [sp, #40]	; 0x28
 802a46c:	f7ff ba68 	b.w	8029940 <_svfprintf_r+0x3b0>
 802a470:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802a472:	9914      	ldr	r1, [sp, #80]	; 0x50
 802a474:	f8ca 1000 	str.w	r1, [sl]
 802a478:	9913      	ldr	r1, [sp, #76]	; 0x4c
 802a47a:	f8ca 1004 	str.w	r1, [sl, #4]
 802a47e:	3201      	adds	r2, #1
 802a480:	440c      	add	r4, r1
 802a482:	2a07      	cmp	r2, #7
 802a484:	9425      	str	r4, [sp, #148]	; 0x94
 802a486:	9224      	str	r2, [sp, #144]	; 0x90
 802a488:	f300 8127 	bgt.w	802a6da <_svfprintf_r+0x114a>
 802a48c:	f10a 0a08 	add.w	sl, sl, #8
 802a490:	e60e      	b.n	802a0b0 <_svfprintf_r+0xb20>
 802a492:	9a06      	ldr	r2, [sp, #24]
 802a494:	601a      	str	r2, [r3, #0]
 802a496:	f7ff b8a3 	b.w	80295e0 <_svfprintf_r+0x50>
 802a49a:	aa23      	add	r2, sp, #140	; 0x8c
 802a49c:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a4a0:	f003 f90e 	bl	802d6c0 <__ssprint_r>
 802a4a4:	2800      	cmp	r0, #0
 802a4a6:	f47f a940 	bne.w	802972a <_svfprintf_r+0x19a>
 802a4aa:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 802a4ae:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a4b0:	46c2      	mov	sl, r8
 802a4b2:	f7ff baad 	b.w	8029a10 <_svfprintf_r+0x480>
 802a4b6:	aa23      	add	r2, sp, #140	; 0x8c
 802a4b8:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a4bc:	f003 f900 	bl	802d6c0 <__ssprint_r>
 802a4c0:	2800      	cmp	r0, #0
 802a4c2:	f47f a932 	bne.w	802972a <_svfprintf_r+0x19a>
 802a4c6:	e9dd 5424 	ldrd	r5, r4, [sp, #144]	; 0x90
 802a4ca:	4646      	mov	r6, r8
 802a4cc:	e53b      	b.n	8029f46 <_svfprintf_r+0x9b6>
 802a4ce:	aa23      	add	r2, sp, #140	; 0x8c
 802a4d0:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a4d4:	f003 f8f4 	bl	802d6c0 <__ssprint_r>
 802a4d8:	2800      	cmp	r0, #0
 802a4da:	f47f a926 	bne.w	802972a <_svfprintf_r+0x19a>
 802a4de:	e9dd 5424 	ldrd	r5, r4, [sp, #144]	; 0x90
 802a4e2:	4646      	mov	r6, r8
 802a4e4:	e53b      	b.n	8029f5e <_svfprintf_r+0x9ce>
 802a4e6:	2b01      	cmp	r3, #1
 802a4e8:	f47f aa0c 	bne.w	8029904 <_svfprintf_r+0x374>
 802a4ec:	e571      	b.n	8029fd2 <_svfprintf_r+0xa42>
 802a4ee:	461c      	mov	r4, r3
 802a4f0:	3201      	adds	r2, #1
 802a4f2:	442c      	add	r4, r5
 802a4f4:	2a07      	cmp	r2, #7
 802a4f6:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a4fa:	e9ca 7500 	strd	r7, r5, [sl]
 802a4fe:	f77f aaf3 	ble.w	8029ae8 <_svfprintf_r+0x558>
 802a502:	e4ff      	b.n	8029f04 <_svfprintf_r+0x974>
 802a504:	aa23      	add	r2, sp, #140	; 0x8c
 802a506:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a50a:	f003 f8d9 	bl	802d6c0 <__ssprint_r>
 802a50e:	2800      	cmp	r0, #0
 802a510:	f47f a90b 	bne.w	802972a <_svfprintf_r+0x19a>
 802a514:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a516:	46c2      	mov	sl, r8
 802a518:	f7ff ba9d 	b.w	8029a56 <_svfprintf_r+0x4c6>
 802a51c:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802a51e:	4989      	ldr	r1, [pc, #548]	; (802a744 <_svfprintf_r+0x11b4>)
 802a520:	f8ca 1000 	str.w	r1, [sl]
 802a524:	3201      	adds	r2, #1
 802a526:	3401      	adds	r4, #1
 802a528:	2101      	movs	r1, #1
 802a52a:	2a07      	cmp	r2, #7
 802a52c:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a530:	f8ca 1004 	str.w	r1, [sl, #4]
 802a534:	f73f acb8 	bgt.w	8029ea8 <_svfprintf_r+0x918>
 802a538:	f10a 0a08 	add.w	sl, sl, #8
 802a53c:	e4bf      	b.n	8029ebe <_svfprintf_r+0x92e>
 802a53e:	aa23      	add	r2, sp, #140	; 0x8c
 802a540:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a544:	f003 f8bc 	bl	802d6c0 <__ssprint_r>
 802a548:	2800      	cmp	r0, #0
 802a54a:	f47f a8ee 	bne.w	802972a <_svfprintf_r+0x19a>
 802a54e:	46c2      	mov	sl, r8
 802a550:	e429      	b.n	8029da6 <_svfprintf_r+0x816>
 802a552:	4614      	mov	r4, r2
 802a554:	461e      	mov	r6, r3
 802a556:	f8cd a014 	str.w	sl, [sp, #20]
 802a55a:	f105 0901 	add.w	r9, r5, #1
 802a55e:	f103 0208 	add.w	r2, r3, #8
 802a562:	9b05      	ldr	r3, [sp, #20]
 802a564:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
 802a568:	441c      	add	r4, r3
 802a56a:	f1b9 0f07 	cmp.w	r9, #7
 802a56e:	9425      	str	r4, [sp, #148]	; 0x94
 802a570:	e9c6 7300 	strd	r7, r3, [r6]
 802a574:	f73f af4c 	bgt.w	802a410 <_svfprintf_r+0xe80>
 802a578:	f109 0901 	add.w	r9, r9, #1
 802a57c:	f102 0a08 	add.w	sl, r2, #8
 802a580:	4616      	mov	r6, r2
 802a582:	e510      	b.n	8029fa6 <_svfprintf_r+0xa16>
 802a584:	461c      	mov	r4, r3
 802a586:	3201      	adds	r2, #1
 802a588:	442c      	add	r4, r5
 802a58a:	2a07      	cmp	r2, #7
 802a58c:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a590:	e9ca 7500 	strd	r7, r5, [sl]
 802a594:	f300 8127 	bgt.w	802a7e6 <_svfprintf_r+0x1256>
 802a598:	f10a 0a08 	add.w	sl, sl, #8
 802a59c:	e57f      	b.n	802a09e <_svfprintf_r+0xb0e>
 802a59e:	980d      	ldr	r0, [sp, #52]	; 0x34
 802a5a0:	9405      	str	r4, [sp, #20]
 802a5a2:	f7e2 fccd 	bl	800cf40 <strlen>
 802a5a6:	9703      	str	r7, [sp, #12]
 802a5a8:	e9cd 050a 	strd	r0, r5, [sp, #40]	; 0x28
 802a5ac:	4603      	mov	r3, r0
 802a5ae:	f7ff b950 	b.w	8029852 <_svfprintf_r+0x2c2>
 802a5b2:	9a03      	ldr	r2, [sp, #12]
 802a5b4:	07d5      	lsls	r5, r2, #31
 802a5b6:	f57f aa99 	bpl.w	8029aec <_svfprintf_r+0x55c>
 802a5ba:	e485      	b.n	8029ec8 <_svfprintf_r+0x938>
 802a5bc:	2b00      	cmp	r3, #0
 802a5be:	bf08      	it	eq
 802a5c0:	2301      	moveq	r3, #1
 802a5c2:	9305      	str	r3, [sp, #20]
 802a5c4:	e68f      	b.n	802a2e6 <_svfprintf_r+0xd56>
 802a5c6:	9b05      	ldr	r3, [sp, #20]
 802a5c8:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a5ca:	1c5d      	adds	r5, r3, #1
 802a5cc:	a921      	add	r1, sp, #132	; 0x84
 802a5ce:	ab1e      	add	r3, sp, #120	; 0x78
 802a5d0:	e9cd 3100 	strd	r3, r1, [sp]
 802a5d4:	462a      	mov	r2, r5
 802a5d6:	ab1d      	add	r3, sp, #116	; 0x74
 802a5d8:	2102      	movs	r1, #2
 802a5da:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
 802a5de:	f000 fae7 	bl	802abb0 <_dtoa_r>
 802a5e2:	900d      	str	r0, [sp, #52]	; 0x34
 802a5e4:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
 802a5e8:	f040 81c3 	bne.w	802a972 <_svfprintf_r+0x13e2>
 802a5ec:	07fb      	lsls	r3, r7, #31
 802a5ee:	f140 81b9 	bpl.w	802a964 <_svfprintf_r+0x13d4>
 802a5f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802a5f4:	f1b9 0f46 	cmp.w	r9, #70	; 0x46
 802a5f8:	eb03 0405 	add.w	r4, r3, r5
 802a5fc:	f47f aea2 	bne.w	802a344 <_svfprintf_r+0xdb4>
 802a600:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802a602:	781b      	ldrb	r3, [r3, #0]
 802a604:	2b30      	cmp	r3, #48	; 0x30
 802a606:	f000 815a 	beq.w	802a8be <_svfprintf_r+0x132e>
 802a60a:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 802a60c:	442c      	add	r4, r5
 802a60e:	e699      	b.n	802a344 <_svfprintf_r+0xdb4>
 802a610:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 802a612:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802a614:	920e      	str	r2, [sp, #56]	; 0x38
 802a616:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a618:	2e47      	cmp	r6, #71	; 0x47
 802a61a:	eba3 0302 	sub.w	r3, r3, r2
 802a61e:	930f      	str	r3, [sp, #60]	; 0x3c
 802a620:	d107      	bne.n	802a632 <_svfprintf_r+0x10a2>
 802a622:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a624:	1cda      	adds	r2, r3, #3
 802a626:	db02      	blt.n	802a62e <_svfprintf_r+0x109e>
 802a628:	9a05      	ldr	r2, [sp, #20]
 802a62a:	429a      	cmp	r2, r3
 802a62c:	da33      	bge.n	802a696 <_svfprintf_r+0x1106>
 802a62e:	f1a9 0902 	sub.w	r9, r9, #2
 802a632:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a634:	f88d 907c 	strb.w	r9, [sp, #124]	; 0x7c
 802a638:	3b01      	subs	r3, #1
 802a63a:	2b00      	cmp	r3, #0
 802a63c:	931d      	str	r3, [sp, #116]	; 0x74
 802a63e:	bfbd      	ittte	lt
 802a640:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
 802a642:	f1c3 0301 	rsblt	r3, r3, #1
 802a646:	222d      	movlt	r2, #45	; 0x2d
 802a648:	222b      	movge	r2, #43	; 0x2b
 802a64a:	2b09      	cmp	r3, #9
 802a64c:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
 802a650:	f300 8101 	bgt.w	802a856 <_svfprintf_r+0x12c6>
 802a654:	3330      	adds	r3, #48	; 0x30
 802a656:	2230      	movs	r2, #48	; 0x30
 802a658:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
 802a65c:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
 802a660:	ab20      	add	r3, sp, #128	; 0x80
 802a662:	aa1f      	add	r2, sp, #124	; 0x7c
 802a664:	1a9b      	subs	r3, r3, r2
 802a666:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802a668:	9315      	str	r3, [sp, #84]	; 0x54
 802a66a:	2a01      	cmp	r2, #1
 802a66c:	4413      	add	r3, r2
 802a66e:	930a      	str	r3, [sp, #40]	; 0x28
 802a670:	f340 8149 	ble.w	802a906 <_svfprintf_r+0x1376>
 802a674:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802a676:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802a678:	4413      	add	r3, r2
 802a67a:	930a      	str	r3, [sp, #40]	; 0x28
 802a67c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 802a680:	9304      	str	r3, [sp, #16]
 802a682:	2300      	movs	r3, #0
 802a684:	930e      	str	r3, [sp, #56]	; 0x38
 802a686:	e681      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a688:	262d      	movs	r6, #45	; 0x2d
 802a68a:	2300      	movs	r3, #0
 802a68c:	f88d 606f 	strb.w	r6, [sp, #111]	; 0x6f
 802a690:	9305      	str	r3, [sp, #20]
 802a692:	f7ff b8e7 	b.w	8029864 <_svfprintf_r+0x2d4>
 802a696:	e9dd 310e 	ldrd	r3, r1, [sp, #56]	; 0x38
 802a69a:	428b      	cmp	r3, r1
 802a69c:	f2c0 8080 	blt.w	802a7a0 <_svfprintf_r+0x1210>
 802a6a0:	07f8      	lsls	r0, r7, #31
 802a6a2:	f140 8105 	bpl.w	802a8b0 <_svfprintf_r+0x1320>
 802a6a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a6a8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802a6aa:	4413      	add	r3, r2
 802a6ac:	930a      	str	r3, [sp, #40]	; 0x28
 802a6ae:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 802a6b2:	9304      	str	r3, [sp, #16]
 802a6b4:	f04f 0967 	mov.w	r9, #103	; 0x67
 802a6b8:	e668      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a6ba:	aa23      	add	r2, sp, #140	; 0x8c
 802a6bc:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a6c0:	f002 fffe 	bl	802d6c0 <__ssprint_r>
 802a6c4:	2800      	cmp	r0, #0
 802a6c6:	f47f a830 	bne.w	802972a <_svfprintf_r+0x19a>
 802a6ca:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a6cc:	46c2      	mov	sl, r8
 802a6ce:	e4de      	b.n	802a08e <_svfprintf_r+0xafe>
 802a6d0:	262d      	movs	r6, #45	; 0x2d
 802a6d2:	f88d 606f 	strb.w	r6, [sp, #111]	; 0x6f
 802a6d6:	f7ff bad8 	b.w	8029c8a <_svfprintf_r+0x6fa>
 802a6da:	aa23      	add	r2, sp, #140	; 0x8c
 802a6dc:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a6e0:	f002 ffee 	bl	802d6c0 <__ssprint_r>
 802a6e4:	2800      	cmp	r0, #0
 802a6e6:	f47f a820 	bne.w	802972a <_svfprintf_r+0x19a>
 802a6ea:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a6ec:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a6ee:	46c2      	mov	sl, r8
 802a6f0:	e4de      	b.n	802a0b0 <_svfprintf_r+0xb20>
 802a6f2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802a6f4:	42a3      	cmp	r3, r4
 802a6f6:	f4bf ae2f 	bcs.w	802a358 <_svfprintf_r+0xdc8>
 802a6fa:	2130      	movs	r1, #48	; 0x30
 802a6fc:	1c5a      	adds	r2, r3, #1
 802a6fe:	9221      	str	r2, [sp, #132]	; 0x84
 802a700:	7019      	strb	r1, [r3, #0]
 802a702:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802a704:	429c      	cmp	r4, r3
 802a706:	d8f9      	bhi.n	802a6fc <_svfprintf_r+0x116c>
 802a708:	e626      	b.n	802a358 <_svfprintf_r+0xdc8>
 802a70a:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
 802a70e:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 802a712:	9319      	str	r3, [sp, #100]	; 0x64
 802a714:	232d      	movs	r3, #45	; 0x2d
 802a716:	9118      	str	r1, [sp, #96]	; 0x60
 802a718:	930c      	str	r3, [sp, #48]	; 0x30
 802a71a:	e5f1      	b.n	802a300 <_svfprintf_r+0xd70>
 802a71c:	2300      	movs	r3, #0
 802a71e:	9305      	str	r3, [sp, #20]
 802a720:	f7fe bf94 	b.w	802964c <_svfprintf_r+0xbc>
 802a724:	aa23      	add	r2, sp, #140	; 0x8c
 802a726:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a72a:	f002 ffc9 	bl	802d6c0 <__ssprint_r>
 802a72e:	2800      	cmp	r0, #0
 802a730:	f47e affb 	bne.w	802972a <_svfprintf_r+0x19a>
 802a734:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a736:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802a738:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a73a:	1ad3      	subs	r3, r2, r3
 802a73c:	46c2      	mov	sl, r8
 802a73e:	e4d0      	b.n	802a0e2 <_svfprintf_r+0xb52>
 802a740:	0802ffb8 	.word	0x0802ffb8
 802a744:	0802ffc0 	.word	0x0802ffc0
 802a748:	9d05      	ldr	r5, [sp, #20]
 802a74a:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a74c:	aa21      	add	r2, sp, #132	; 0x84
 802a74e:	ab1e      	add	r3, sp, #120	; 0x78
 802a750:	e9cd 3200 	strd	r3, r2, [sp]
 802a754:	2103      	movs	r1, #3
 802a756:	ab1d      	add	r3, sp, #116	; 0x74
 802a758:	462a      	mov	r2, r5
 802a75a:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
 802a75e:	f000 fa27 	bl	802abb0 <_dtoa_r>
 802a762:	900d      	str	r0, [sp, #52]	; 0x34
 802a764:	1944      	adds	r4, r0, r5
 802a766:	e74b      	b.n	802a600 <_svfprintf_r+0x1070>
 802a768:	2306      	movs	r3, #6
 802a76a:	9305      	str	r3, [sp, #20]
 802a76c:	e5bb      	b.n	802a2e6 <_svfprintf_r+0xd56>
 802a76e:	9b05      	ldr	r3, [sp, #20]
 802a770:	9304      	str	r3, [sp, #16]
 802a772:	930a      	str	r3, [sp, #40]	; 0x28
 802a774:	9005      	str	r0, [sp, #20]
 802a776:	950b      	str	r5, [sp, #44]	; 0x2c
 802a778:	9703      	str	r7, [sp, #12]
 802a77a:	900e      	str	r0, [sp, #56]	; 0x38
 802a77c:	f89d 606f 	ldrb.w	r6, [sp, #111]	; 0x6f
 802a780:	f7ff b86d 	b.w	802985e <_svfprintf_r+0x2ce>
 802a784:	aa23      	add	r2, sp, #140	; 0x8c
 802a786:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a78a:	f002 ff99 	bl	802d6c0 <__ssprint_r>
 802a78e:	2800      	cmp	r0, #0
 802a790:	f47e afcb 	bne.w	802972a <_svfprintf_r+0x19a>
 802a794:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 802a796:	e9dd 2424 	ldrd	r2, r4, [sp, #144]	; 0x90
 802a79a:	46c2      	mov	sl, r8
 802a79c:	f7ff bba4 	b.w	8029ee8 <_svfprintf_r+0x958>
 802a7a0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802a7a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802a7a4:	4413      	add	r3, r2
 802a7a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802a7a8:	930a      	str	r3, [sp, #40]	; 0x28
 802a7aa:	2a00      	cmp	r2, #0
 802a7ac:	dc06      	bgt.n	802a7bc <_svfprintf_r+0x122c>
 802a7ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a7b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802a7b2:	f1c3 0301 	rsb	r3, r3, #1
 802a7b6:	441a      	add	r2, r3
 802a7b8:	4613      	mov	r3, r2
 802a7ba:	920a      	str	r2, [sp, #40]	; 0x28
 802a7bc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 802a7c0:	9304      	str	r3, [sp, #16]
 802a7c2:	f04f 0967 	mov.w	r9, #103	; 0x67
 802a7c6:	e5e1      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a7c8:	9d05      	ldr	r5, [sp, #20]
 802a7ca:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a7cc:	aa21      	add	r2, sp, #132	; 0x84
 802a7ce:	ab1e      	add	r3, sp, #120	; 0x78
 802a7d0:	e9cd 3200 	strd	r3, r2, [sp]
 802a7d4:	2103      	movs	r1, #3
 802a7d6:	ab1d      	add	r3, sp, #116	; 0x74
 802a7d8:	462a      	mov	r2, r5
 802a7da:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
 802a7de:	f000 f9e7 	bl	802abb0 <_dtoa_r>
 802a7e2:	900d      	str	r0, [sp, #52]	; 0x34
 802a7e4:	e705      	b.n	802a5f2 <_svfprintf_r+0x1062>
 802a7e6:	aa23      	add	r2, sp, #140	; 0x8c
 802a7e8:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a7ec:	f002 ff68 	bl	802d6c0 <__ssprint_r>
 802a7f0:	2800      	cmp	r0, #0
 802a7f2:	f47e af9a 	bne.w	802972a <_svfprintf_r+0x19a>
 802a7f6:	9c25      	ldr	r4, [sp, #148]	; 0x94
 802a7f8:	46c2      	mov	sl, r8
 802a7fa:	e450      	b.n	802a09e <_svfprintf_r+0xb0e>
 802a7fc:	425d      	negs	r5, r3
 802a7fe:	3310      	adds	r3, #16
 802a800:	4f72      	ldr	r7, [pc, #456]	; (802a9cc <_svfprintf_r+0x143c>)
 802a802:	da1c      	bge.n	802a83e <_svfprintf_r+0x12ae>
 802a804:	2610      	movs	r6, #16
 802a806:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 802a80a:	e004      	b.n	802a816 <_svfprintf_r+0x1286>
 802a80c:	f10a 0a08 	add.w	sl, sl, #8
 802a810:	3d10      	subs	r5, #16
 802a812:	2d10      	cmp	r5, #16
 802a814:	dd13      	ble.n	802a83e <_svfprintf_r+0x12ae>
 802a816:	3201      	adds	r2, #1
 802a818:	3410      	adds	r4, #16
 802a81a:	2a07      	cmp	r2, #7
 802a81c:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a820:	e9ca 7600 	strd	r7, r6, [sl]
 802a824:	ddf2      	ble.n	802a80c <_svfprintf_r+0x127c>
 802a826:	aa23      	add	r2, sp, #140	; 0x8c
 802a828:	9908      	ldr	r1, [sp, #32]
 802a82a:	4648      	mov	r0, r9
 802a82c:	f002 ff48 	bl	802d6c0 <__ssprint_r>
 802a830:	2800      	cmp	r0, #0
 802a832:	f47e af7a 	bne.w	802972a <_svfprintf_r+0x19a>
 802a836:	e9dd 2424 	ldrd	r2, r4, [sp, #144]	; 0x90
 802a83a:	46c2      	mov	sl, r8
 802a83c:	e7e8      	b.n	802a810 <_svfprintf_r+0x1280>
 802a83e:	3201      	adds	r2, #1
 802a840:	442c      	add	r4, r5
 802a842:	2a07      	cmp	r2, #7
 802a844:	e9cd 2424 	strd	r2, r4, [sp, #144]	; 0x90
 802a848:	e9ca 7500 	strd	r7, r5, [sl]
 802a84c:	dc7d      	bgt.n	802a94a <_svfprintf_r+0x13ba>
 802a84e:	f10a 0a08 	add.w	sl, sl, #8
 802a852:	f7ff bb4c 	b.w	8029eee <_svfprintf_r+0x95e>
 802a856:	f10d 048b 	add.w	r4, sp, #139	; 0x8b
 802a85a:	4620      	mov	r0, r4
 802a85c:	4d5c      	ldr	r5, [pc, #368]	; (802a9d0 <_svfprintf_r+0x1440>)
 802a85e:	e000      	b.n	802a862 <_svfprintf_r+0x12d2>
 802a860:	4610      	mov	r0, r2
 802a862:	fba5 1203 	umull	r1, r2, r5, r3
 802a866:	08d2      	lsrs	r2, r2, #3
 802a868:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 802a86c:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 802a870:	f103 0130 	add.w	r1, r3, #48	; 0x30
 802a874:	4613      	mov	r3, r2
 802a876:	2b09      	cmp	r3, #9
 802a878:	f800 1c01 	strb.w	r1, [r0, #-1]
 802a87c:	f100 32ff 	add.w	r2, r0, #4294967295
 802a880:	dcee      	bgt.n	802a860 <_svfprintf_r+0x12d0>
 802a882:	3330      	adds	r3, #48	; 0x30
 802a884:	3802      	subs	r0, #2
 802a886:	b2d9      	uxtb	r1, r3
 802a888:	4284      	cmp	r4, r0
 802a88a:	f802 1c01 	strb.w	r1, [r2, #-1]
 802a88e:	d973      	bls.n	802a978 <_svfprintf_r+0x13e8>
 802a890:	f10d 007e 	add.w	r0, sp, #126	; 0x7e
 802a894:	4613      	mov	r3, r2
 802a896:	e001      	b.n	802a89c <_svfprintf_r+0x130c>
 802a898:	f813 1b01 	ldrb.w	r1, [r3], #1
 802a89c:	f800 1b01 	strb.w	r1, [r0], #1
 802a8a0:	429c      	cmp	r4, r3
 802a8a2:	d1f9      	bne.n	802a898 <_svfprintf_r+0x1308>
 802a8a4:	ab23      	add	r3, sp, #140	; 0x8c
 802a8a6:	1a9b      	subs	r3, r3, r2
 802a8a8:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
 802a8ac:	4413      	add	r3, r2
 802a8ae:	e6d8      	b.n	802a662 <_svfprintf_r+0x10d2>
 802a8b0:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
 802a8b4:	9204      	str	r2, [sp, #16]
 802a8b6:	930a      	str	r3, [sp, #40]	; 0x28
 802a8b8:	f04f 0967 	mov.w	r9, #103	; 0x67
 802a8bc:	e566      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a8be:	2200      	movs	r2, #0
 802a8c0:	2300      	movs	r3, #0
 802a8c2:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 802a8c6:	f7e2 f869 	bl	800c99c <__aeabi_dcmpeq>
 802a8ca:	2800      	cmp	r0, #0
 802a8cc:	f47f ae9d 	bne.w	802a60a <_svfprintf_r+0x107a>
 802a8d0:	f1c5 0501 	rsb	r5, r5, #1
 802a8d4:	951d      	str	r5, [sp, #116]	; 0x74
 802a8d6:	442c      	add	r4, r5
 802a8d8:	e534      	b.n	802a344 <_svfprintf_r+0xdb4>
 802a8da:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802a8dc:	4a3d      	ldr	r2, [pc, #244]	; (802a9d4 <_svfprintf_r+0x1444>)
 802a8de:	2b00      	cmp	r3, #0
 802a8e0:	bfb6      	itet	lt
 802a8e2:	262d      	movlt	r6, #45	; 0x2d
 802a8e4:	f89d 606f 	ldrbge.w	r6, [sp, #111]	; 0x6f
 802a8e8:	f88d 606f 	strblt.w	r6, [sp, #111]	; 0x6f
 802a8ec:	4b3a      	ldr	r3, [pc, #232]	; (802a9d8 <_svfprintf_r+0x1448>)
 802a8ee:	f7ff b9ce 	b.w	8029c8e <_svfprintf_r+0x6fe>
 802a8f2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802a8f4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802a8f6:	4413      	add	r3, r2
 802a8f8:	9a05      	ldr	r2, [sp, #20]
 802a8fa:	441a      	add	r2, r3
 802a8fc:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 802a900:	920a      	str	r2, [sp, #40]	; 0x28
 802a902:	9304      	str	r3, [sp, #16]
 802a904:	e542      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a906:	f017 0301 	ands.w	r3, r7, #1
 802a90a:	930e      	str	r3, [sp, #56]	; 0x38
 802a90c:	f47f aeb2 	bne.w	802a674 <_svfprintf_r+0x10e4>
 802a910:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802a912:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 802a916:	9304      	str	r3, [sp, #16]
 802a918:	e538      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a91a:	b93b      	cbnz	r3, 802a92c <_svfprintf_r+0x139c>
 802a91c:	07fc      	lsls	r4, r7, #31
 802a91e:	d405      	bmi.n	802a92c <_svfprintf_r+0x139c>
 802a920:	2301      	movs	r3, #1
 802a922:	9304      	str	r3, [sp, #16]
 802a924:	930a      	str	r3, [sp, #40]	; 0x28
 802a926:	e531      	b.n	802a38c <_svfprintf_r+0xdfc>
 802a928:	4652      	mov	r2, sl
 802a92a:	e61a      	b.n	802a562 <_svfprintf_r+0xfd2>
 802a92c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802a92e:	3301      	adds	r3, #1
 802a930:	e7e2      	b.n	802a8f8 <_svfprintf_r+0x1368>
 802a932:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802a934:	f89b 3001 	ldrb.w	r3, [fp, #1]
 802a938:	682c      	ldr	r4, [r5, #0]
 802a93a:	4683      	mov	fp, r0
 802a93c:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
 802a940:	1d28      	adds	r0, r5, #4
 802a942:	9405      	str	r4, [sp, #20]
 802a944:	900b      	str	r0, [sp, #44]	; 0x2c
 802a946:	f7fe be7e 	b.w	8029646 <_svfprintf_r+0xb6>
 802a94a:	aa23      	add	r2, sp, #140	; 0x8c
 802a94c:	e9dd 1008 	ldrd	r1, r0, [sp, #32]
 802a950:	f002 feb6 	bl	802d6c0 <__ssprint_r>
 802a954:	2800      	cmp	r0, #0
 802a956:	f47e aee8 	bne.w	802972a <_svfprintf_r+0x19a>
 802a95a:	e9dd 2424 	ldrd	r2, r4, [sp, #144]	; 0x90
 802a95e:	46c2      	mov	sl, r8
 802a960:	f7ff bac5 	b.w	8029eee <_svfprintf_r+0x95e>
 802a964:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 802a966:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802a968:	920e      	str	r2, [sp, #56]	; 0x38
 802a96a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a96c:	1a9b      	subs	r3, r3, r2
 802a96e:	930f      	str	r3, [sp, #60]	; 0x3c
 802a970:	e657      	b.n	802a622 <_svfprintf_r+0x1092>
 802a972:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802a974:	195c      	adds	r4, r3, r5
 802a976:	e4e5      	b.n	802a344 <_svfprintf_r+0xdb4>
 802a978:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
 802a97c:	e671      	b.n	802a662 <_svfprintf_r+0x10d2>
 802a97e:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a982:	f7fe bf9c 	b.w	80298be <_svfprintf_r+0x32e>
 802a986:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802a988:	230c      	movs	r3, #12
 802a98a:	6013      	str	r3, [r2, #0]
 802a98c:	f04f 33ff 	mov.w	r3, #4294967295
 802a990:	9306      	str	r3, [sp, #24]
 802a992:	f7fe bed3 	b.w	802973c <_svfprintf_r+0x1ac>
 802a996:	9d05      	ldr	r5, [sp, #20]
 802a998:	e624      	b.n	802a5e4 <_svfprintf_r+0x1054>
 802a99a:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a99e:	f7ff b8ec 	b.w	8029b7a <_svfprintf_r+0x5ea>
 802a9a2:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a9a6:	f7ff b93f 	b.w	8029c28 <_svfprintf_r+0x698>
 802a9aa:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a9ae:	f7ff b98e 	b.w	8029cce <_svfprintf_r+0x73e>
 802a9b2:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a9b6:	f7ff b9c6 	b.w	8029d46 <_svfprintf_r+0x7b6>
 802a9ba:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a9be:	f7fe bf58 	b.w	8029872 <_svfprintf_r+0x2e2>
 802a9c2:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
 802a9c6:	f7ff b916 	b.w	8029bf6 <_svfprintf_r+0x666>
 802a9ca:	bf00      	nop
 802a9cc:	0802ffe0 	.word	0x0802ffe0
 802a9d0:	cccccccd 	.word	0xcccccccd
 802a9d4:	0802ff8c 	.word	0x0802ff8c
 802a9d8:	0802ff88 	.word	0x0802ff88
 802a9dc:	00000000 	.word	0x00000000

0802a9e0 <__submore>:
 802a9e0:	f101 0340 	add.w	r3, r1, #64	; 0x40
 802a9e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a9e8:	460c      	mov	r4, r1
 802a9ea:	6b09      	ldr	r1, [r1, #48]	; 0x30
 802a9ec:	4299      	cmp	r1, r3
 802a9ee:	d014      	beq.n	802aa1a <__submore+0x3a>
 802a9f0:	6b66      	ldr	r6, [r4, #52]	; 0x34
 802a9f2:	0077      	lsls	r7, r6, #1
 802a9f4:	463a      	mov	r2, r7
 802a9f6:	f002 fc63 	bl	802d2c0 <_realloc_r>
 802a9fa:	4605      	mov	r5, r0
 802a9fc:	b340      	cbz	r0, 802aa50 <__submore+0x70>
 802a9fe:	eb00 0806 	add.w	r8, r0, r6
 802aa02:	4632      	mov	r2, r6
 802aa04:	4640      	mov	r0, r8
 802aa06:	4629      	mov	r1, r5
 802aa08:	f7e2 f88a 	bl	800cb20 <memcpy>
 802aa0c:	e9c4 570c 	strd	r5, r7, [r4, #48]	; 0x30
 802aa10:	f8c4 8000 	str.w	r8, [r4]
 802aa14:	2000      	movs	r0, #0
 802aa16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802aa1a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 802aa1e:	f001 fd07 	bl	802c430 <_malloc_r>
 802aa22:	b1a8      	cbz	r0, 802aa50 <__submore+0x70>
 802aa24:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 802aa28:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802aa2c:	e9c4 020c 	strd	r0, r2, [r4, #48]	; 0x30
 802aa30:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 802aa34:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 802aa38:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 802aa3c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 802aa40:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 802aa44:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 802aa48:	6020      	str	r0, [r4, #0]
 802aa4a:	2000      	movs	r0, #0
 802aa4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802aa50:	f04f 30ff 	mov.w	r0, #4294967295
 802aa54:	e7df      	b.n	802aa16 <__submore+0x36>
 802aa56:	bf00      	nop
	...

0802aa60 <__ascii_wctomb>:
 802aa60:	b121      	cbz	r1, 802aa6c <__ascii_wctomb+0xc>
 802aa62:	2aff      	cmp	r2, #255	; 0xff
 802aa64:	d804      	bhi.n	802aa70 <__ascii_wctomb+0x10>
 802aa66:	700a      	strb	r2, [r1, #0]
 802aa68:	2001      	movs	r0, #1
 802aa6a:	4770      	bx	lr
 802aa6c:	4608      	mov	r0, r1
 802aa6e:	4770      	bx	lr
 802aa70:	238a      	movs	r3, #138	; 0x8a
 802aa72:	6003      	str	r3, [r0, #0]
 802aa74:	f04f 30ff 	mov.w	r0, #4294967295
 802aa78:	4770      	bx	lr
 802aa7a:	bf00      	nop
 802aa7c:	0000      	movs	r0, r0
	...

0802aa80 <quorem>:
 802aa80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802aa84:	6903      	ldr	r3, [r0, #16]
 802aa86:	690f      	ldr	r7, [r1, #16]
 802aa88:	42bb      	cmp	r3, r7
 802aa8a:	b083      	sub	sp, #12
 802aa8c:	f2c0 8086 	blt.w	802ab9c <quorem+0x11c>
 802aa90:	3f01      	subs	r7, #1
 802aa92:	f101 0914 	add.w	r9, r1, #20
 802aa96:	f100 0a14 	add.w	sl, r0, #20
 802aa9a:	f859 2027 	ldr.w	r2, [r9, r7, lsl #2]
 802aa9e:	f85a 3027 	ldr.w	r3, [sl, r7, lsl #2]
 802aaa2:	00bc      	lsls	r4, r7, #2
 802aaa4:	3201      	adds	r2, #1
 802aaa6:	fbb3 f8f2 	udiv	r8, r3, r2
 802aaaa:	eb0a 0304 	add.w	r3, sl, r4
 802aaae:	9400      	str	r4, [sp, #0]
 802aab0:	eb09 0b04 	add.w	fp, r9, r4
 802aab4:	9301      	str	r3, [sp, #4]
 802aab6:	f1b8 0f00 	cmp.w	r8, #0
 802aaba:	d038      	beq.n	802ab2e <quorem+0xae>
 802aabc:	2500      	movs	r5, #0
 802aabe:	462e      	mov	r6, r5
 802aac0:	46ce      	mov	lr, r9
 802aac2:	46d4      	mov	ip, sl
 802aac4:	f85e 4b04 	ldr.w	r4, [lr], #4
 802aac8:	f8dc 3000 	ldr.w	r3, [ip]
 802aacc:	b2a2      	uxth	r2, r4
 802aace:	fb08 5502 	mla	r5, r8, r2, r5
 802aad2:	0c22      	lsrs	r2, r4, #16
 802aad4:	0c2c      	lsrs	r4, r5, #16
 802aad6:	fb08 4202 	mla	r2, r8, r2, r4
 802aada:	b2ad      	uxth	r5, r5
 802aadc:	1b75      	subs	r5, r6, r5
 802aade:	b296      	uxth	r6, r2
 802aae0:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
 802aae4:	fa15 f383 	uxtah	r3, r5, r3
 802aae8:	eb06 4623 	add.w	r6, r6, r3, asr #16
 802aaec:	b29b      	uxth	r3, r3
 802aaee:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 802aaf2:	45f3      	cmp	fp, lr
 802aaf4:	ea4f 4512 	mov.w	r5, r2, lsr #16
 802aaf8:	f84c 3b04 	str.w	r3, [ip], #4
 802aafc:	ea4f 4626 	mov.w	r6, r6, asr #16
 802ab00:	d2e0      	bcs.n	802aac4 <quorem+0x44>
 802ab02:	9b00      	ldr	r3, [sp, #0]
 802ab04:	f85a 3003 	ldr.w	r3, [sl, r3]
 802ab08:	b98b      	cbnz	r3, 802ab2e <quorem+0xae>
 802ab0a:	9a01      	ldr	r2, [sp, #4]
 802ab0c:	1f13      	subs	r3, r2, #4
 802ab0e:	459a      	cmp	sl, r3
 802ab10:	d20c      	bcs.n	802ab2c <quorem+0xac>
 802ab12:	f852 3c04 	ldr.w	r3, [r2, #-4]
 802ab16:	b94b      	cbnz	r3, 802ab2c <quorem+0xac>
 802ab18:	f1a2 0308 	sub.w	r3, r2, #8
 802ab1c:	e002      	b.n	802ab24 <quorem+0xa4>
 802ab1e:	681a      	ldr	r2, [r3, #0]
 802ab20:	3b04      	subs	r3, #4
 802ab22:	b91a      	cbnz	r2, 802ab2c <quorem+0xac>
 802ab24:	459a      	cmp	sl, r3
 802ab26:	f107 37ff 	add.w	r7, r7, #4294967295
 802ab2a:	d3f8      	bcc.n	802ab1e <quorem+0x9e>
 802ab2c:	6107      	str	r7, [r0, #16]
 802ab2e:	4604      	mov	r4, r0
 802ab30:	f002 f9ae 	bl	802ce90 <__mcmp>
 802ab34:	2800      	cmp	r0, #0
 802ab36:	db2d      	blt.n	802ab94 <quorem+0x114>
 802ab38:	f108 0801 	add.w	r8, r8, #1
 802ab3c:	4655      	mov	r5, sl
 802ab3e:	2300      	movs	r3, #0
 802ab40:	f859 1b04 	ldr.w	r1, [r9], #4
 802ab44:	6828      	ldr	r0, [r5, #0]
 802ab46:	b28a      	uxth	r2, r1
 802ab48:	1a9a      	subs	r2, r3, r2
 802ab4a:	0c0b      	lsrs	r3, r1, #16
 802ab4c:	fa12 f280 	uxtah	r2, r2, r0
 802ab50:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
 802ab54:	eb03 4322 	add.w	r3, r3, r2, asr #16
 802ab58:	b292      	uxth	r2, r2
 802ab5a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 802ab5e:	45cb      	cmp	fp, r9
 802ab60:	f845 2b04 	str.w	r2, [r5], #4
 802ab64:	ea4f 4323 	mov.w	r3, r3, asr #16
 802ab68:	d2ea      	bcs.n	802ab40 <quorem+0xc0>
 802ab6a:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
 802ab6e:	eb0a 0387 	add.w	r3, sl, r7, lsl #2
 802ab72:	b97a      	cbnz	r2, 802ab94 <quorem+0x114>
 802ab74:	1f1a      	subs	r2, r3, #4
 802ab76:	4592      	cmp	sl, r2
 802ab78:	d20b      	bcs.n	802ab92 <quorem+0x112>
 802ab7a:	f853 2c04 	ldr.w	r2, [r3, #-4]
 802ab7e:	b942      	cbnz	r2, 802ab92 <quorem+0x112>
 802ab80:	3b08      	subs	r3, #8
 802ab82:	e002      	b.n	802ab8a <quorem+0x10a>
 802ab84:	681a      	ldr	r2, [r3, #0]
 802ab86:	3b04      	subs	r3, #4
 802ab88:	b91a      	cbnz	r2, 802ab92 <quorem+0x112>
 802ab8a:	459a      	cmp	sl, r3
 802ab8c:	f107 37ff 	add.w	r7, r7, #4294967295
 802ab90:	d3f8      	bcc.n	802ab84 <quorem+0x104>
 802ab92:	6127      	str	r7, [r4, #16]
 802ab94:	4640      	mov	r0, r8
 802ab96:	b003      	add	sp, #12
 802ab98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ab9c:	2000      	movs	r0, #0
 802ab9e:	b003      	add	sp, #12
 802aba0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0802abb0 <_dtoa_r>:
 802abb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802abb4:	ec55 4b10 	vmov	r4, r5, d0
 802abb8:	b09b      	sub	sp, #108	; 0x6c
 802abba:	6c06      	ldr	r6, [r0, #64]	; 0x40
 802abbc:	9102      	str	r1, [sp, #8]
 802abbe:	4681      	mov	r9, r0
 802abc0:	9207      	str	r2, [sp, #28]
 802abc2:	9305      	str	r3, [sp, #20]
 802abc4:	e9cd 4500 	strd	r4, r5, [sp]
 802abc8:	b156      	cbz	r6, 802abe0 <_dtoa_r+0x30>
 802abca:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802abcc:	6072      	str	r2, [r6, #4]
 802abce:	2301      	movs	r3, #1
 802abd0:	4093      	lsls	r3, r2
 802abd2:	60b3      	str	r3, [r6, #8]
 802abd4:	4631      	mov	r1, r6
 802abd6:	f001 ff0b 	bl	802c9f0 <_Bfree>
 802abda:	2300      	movs	r3, #0
 802abdc:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
 802abe0:	f1b5 0800 	subs.w	r8, r5, #0
 802abe4:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802abe6:	bfb4      	ite	lt
 802abe8:	2301      	movlt	r3, #1
 802abea:	2300      	movge	r3, #0
 802abec:	6013      	str	r3, [r2, #0]
 802abee:	4b76      	ldr	r3, [pc, #472]	; (802adc8 <_dtoa_r+0x218>)
 802abf0:	bfbc      	itt	lt
 802abf2:	f028 4800 	biclt.w	r8, r8, #2147483648	; 0x80000000
 802abf6:	f8cd 8004 	strlt.w	r8, [sp, #4]
 802abfa:	ea33 0308 	bics.w	r3, r3, r8
 802abfe:	f000 80a6 	beq.w	802ad4e <_dtoa_r+0x19e>
 802ac02:	e9dd 6700 	ldrd	r6, r7, [sp]
 802ac06:	2200      	movs	r2, #0
 802ac08:	2300      	movs	r3, #0
 802ac0a:	4630      	mov	r0, r6
 802ac0c:	4639      	mov	r1, r7
 802ac0e:	f7e1 fec5 	bl	800c99c <__aeabi_dcmpeq>
 802ac12:	4605      	mov	r5, r0
 802ac14:	b178      	cbz	r0, 802ac36 <_dtoa_r+0x86>
 802ac16:	9a05      	ldr	r2, [sp, #20]
 802ac18:	2301      	movs	r3, #1
 802ac1a:	6013      	str	r3, [r2, #0]
 802ac1c:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802ac1e:	2b00      	cmp	r3, #0
 802ac20:	f000 80c0 	beq.w	802ada4 <_dtoa_r+0x1f4>
 802ac24:	4b69      	ldr	r3, [pc, #420]	; (802adcc <_dtoa_r+0x21c>)
 802ac26:	9a25      	ldr	r2, [sp, #148]	; 0x94
 802ac28:	f103 3bff 	add.w	fp, r3, #4294967295
 802ac2c:	6013      	str	r3, [r2, #0]
 802ac2e:	4658      	mov	r0, fp
 802ac30:	b01b      	add	sp, #108	; 0x6c
 802ac32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ac36:	aa18      	add	r2, sp, #96	; 0x60
 802ac38:	a919      	add	r1, sp, #100	; 0x64
 802ac3a:	ec47 6b10 	vmov	d0, r6, r7
 802ac3e:	4648      	mov	r0, r9
 802ac40:	f002 fa4e 	bl	802d0e0 <__d2b>
 802ac44:	ea5f 5418 	movs.w	r4, r8, lsr #20
 802ac48:	4682      	mov	sl, r0
 802ac4a:	f040 80a0 	bne.w	802ad8e <_dtoa_r+0x1de>
 802ac4e:	e9dd 5418 	ldrd	r5, r4, [sp, #96]	; 0x60
 802ac52:	442c      	add	r4, r5
 802ac54:	f204 4332 	addw	r3, r4, #1074	; 0x432
 802ac58:	2b20      	cmp	r3, #32
 802ac5a:	f340 842e 	ble.w	802b4ba <_dtoa_r+0x90a>
 802ac5e:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 802ac62:	fa08 f803 	lsl.w	r8, r8, r3
 802ac66:	9b00      	ldr	r3, [sp, #0]
 802ac68:	f204 4012 	addw	r0, r4, #1042	; 0x412
 802ac6c:	fa23 f000 	lsr.w	r0, r3, r0
 802ac70:	ea48 0000 	orr.w	r0, r8, r0
 802ac74:	f7e1 fba6 	bl	800c3c4 <__aeabi_ui2d>
 802ac78:	2301      	movs	r3, #1
 802ac7a:	4606      	mov	r6, r0
 802ac7c:	3c01      	subs	r4, #1
 802ac7e:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 802ac82:	930f      	str	r3, [sp, #60]	; 0x3c
 802ac84:	4630      	mov	r0, r6
 802ac86:	4639      	mov	r1, r7
 802ac88:	2200      	movs	r2, #0
 802ac8a:	4b51      	ldr	r3, [pc, #324]	; (802add0 <_dtoa_r+0x220>)
 802ac8c:	f7e1 fa5c 	bl	800c148 <__aeabi_dsub>
 802ac90:	a347      	add	r3, pc, #284	; (adr r3, 802adb0 <_dtoa_r+0x200>)
 802ac92:	e9d3 2300 	ldrd	r2, r3, [r3]
 802ac96:	f7e1 fc13 	bl	800c4c0 <__aeabi_dmul>
 802ac9a:	a347      	add	r3, pc, #284	; (adr r3, 802adb8 <_dtoa_r+0x208>)
 802ac9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 802aca0:	f7e1 fa54 	bl	800c14c <__adddf3>
 802aca4:	4606      	mov	r6, r0
 802aca6:	4620      	mov	r0, r4
 802aca8:	460f      	mov	r7, r1
 802acaa:	f7e1 fb9b 	bl	800c3e4 <__aeabi_i2d>
 802acae:	a344      	add	r3, pc, #272	; (adr r3, 802adc0 <_dtoa_r+0x210>)
 802acb0:	e9d3 2300 	ldrd	r2, r3, [r3]
 802acb4:	f7e1 fc04 	bl	800c4c0 <__aeabi_dmul>
 802acb8:	4602      	mov	r2, r0
 802acba:	460b      	mov	r3, r1
 802acbc:	4630      	mov	r0, r6
 802acbe:	4639      	mov	r1, r7
 802acc0:	f7e1 fa44 	bl	800c14c <__adddf3>
 802acc4:	4606      	mov	r6, r0
 802acc6:	460f      	mov	r7, r1
 802acc8:	f7e1 feb2 	bl	800ca30 <__aeabi_d2iz>
 802accc:	2200      	movs	r2, #0
 802acce:	9006      	str	r0, [sp, #24]
 802acd0:	2300      	movs	r3, #0
 802acd2:	4630      	mov	r0, r6
 802acd4:	4639      	mov	r1, r7
 802acd6:	f7e1 fe6b 	bl	800c9b0 <__aeabi_dcmplt>
 802acda:	2800      	cmp	r0, #0
 802acdc:	f040 8273 	bne.w	802b1c6 <_dtoa_r+0x616>
 802ace0:	9e06      	ldr	r6, [sp, #24]
 802ace2:	2e16      	cmp	r6, #22
 802ace4:	f200 825d 	bhi.w	802b1a2 <_dtoa_r+0x5f2>
 802ace8:	4b3a      	ldr	r3, [pc, #232]	; (802add4 <_dtoa_r+0x224>)
 802acea:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 802acee:	e9d3 0100 	ldrd	r0, r1, [r3]
 802acf2:	e9dd 2300 	ldrd	r2, r3, [sp]
 802acf6:	f7e1 fe79 	bl	800c9ec <__aeabi_dcmpgt>
 802acfa:	2800      	cmp	r0, #0
 802acfc:	f000 83d9 	beq.w	802b4b2 <_dtoa_r+0x902>
 802ad00:	1e73      	subs	r3, r6, #1
 802ad02:	9306      	str	r3, [sp, #24]
 802ad04:	2300      	movs	r3, #0
 802ad06:	930d      	str	r3, [sp, #52]	; 0x34
 802ad08:	1b2c      	subs	r4, r5, r4
 802ad0a:	f1b4 0801 	subs.w	r8, r4, #1
 802ad0e:	f100 8254 	bmi.w	802b1ba <_dtoa_r+0x60a>
 802ad12:	2300      	movs	r3, #0
 802ad14:	9308      	str	r3, [sp, #32]
 802ad16:	9b06      	ldr	r3, [sp, #24]
 802ad18:	2b00      	cmp	r3, #0
 802ad1a:	f2c0 8245 	blt.w	802b1a8 <_dtoa_r+0x5f8>
 802ad1e:	4498      	add	r8, r3
 802ad20:	930c      	str	r3, [sp, #48]	; 0x30
 802ad22:	2300      	movs	r3, #0
 802ad24:	930b      	str	r3, [sp, #44]	; 0x2c
 802ad26:	9b02      	ldr	r3, [sp, #8]
 802ad28:	2b09      	cmp	r3, #9
 802ad2a:	d85b      	bhi.n	802ade4 <_dtoa_r+0x234>
 802ad2c:	2b05      	cmp	r3, #5
 802ad2e:	f340 83c2 	ble.w	802b4b6 <_dtoa_r+0x906>
 802ad32:	3b04      	subs	r3, #4
 802ad34:	9302      	str	r3, [sp, #8]
 802ad36:	2500      	movs	r5, #0
 802ad38:	9b02      	ldr	r3, [sp, #8]
 802ad3a:	3b02      	subs	r3, #2
 802ad3c:	2b03      	cmp	r3, #3
 802ad3e:	f200 849a 	bhi.w	802b676 <_dtoa_r+0xac6>
 802ad42:	e8df f013 	tbh	[pc, r3, lsl #1]
 802ad46:	03e1      	.short	0x03e1
 802ad48:	03ea03c1 	.word	0x03ea03c1
 802ad4c:	04f7      	.short	0x04f7
 802ad4e:	9a05      	ldr	r2, [sp, #20]
 802ad50:	f242 730f 	movw	r3, #9999	; 0x270f
 802ad54:	6013      	str	r3, [r2, #0]
 802ad56:	9b00      	ldr	r3, [sp, #0]
 802ad58:	b983      	cbnz	r3, 802ad7c <_dtoa_r+0x1cc>
 802ad5a:	f3c8 0313 	ubfx	r3, r8, #0, #20
 802ad5e:	b96b      	cbnz	r3, 802ad7c <_dtoa_r+0x1cc>
 802ad60:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802ad62:	f8df b074 	ldr.w	fp, [pc, #116]	; 802add8 <_dtoa_r+0x228>
 802ad66:	2b00      	cmp	r3, #0
 802ad68:	f43f af61 	beq.w	802ac2e <_dtoa_r+0x7e>
 802ad6c:	f10b 0308 	add.w	r3, fp, #8
 802ad70:	9a25      	ldr	r2, [sp, #148]	; 0x94
 802ad72:	4658      	mov	r0, fp
 802ad74:	6013      	str	r3, [r2, #0]
 802ad76:	b01b      	add	sp, #108	; 0x6c
 802ad78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ad7c:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802ad7e:	f8df b05c 	ldr.w	fp, [pc, #92]	; 802addc <_dtoa_r+0x22c>
 802ad82:	2b00      	cmp	r3, #0
 802ad84:	f43f af53 	beq.w	802ac2e <_dtoa_r+0x7e>
 802ad88:	f10b 0303 	add.w	r3, fp, #3
 802ad8c:	e7f0      	b.n	802ad70 <_dtoa_r+0x1c0>
 802ad8e:	f3c7 0313 	ubfx	r3, r7, #0, #20
 802ad92:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 802ad96:	950f      	str	r5, [sp, #60]	; 0x3c
 802ad98:	f2a4 34ff 	subw	r4, r4, #1023	; 0x3ff
 802ad9c:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 802ada0:	9d18      	ldr	r5, [sp, #96]	; 0x60
 802ada2:	e76f      	b.n	802ac84 <_dtoa_r+0xd4>
 802ada4:	f8df b038 	ldr.w	fp, [pc, #56]	; 802ade0 <_dtoa_r+0x230>
 802ada8:	4658      	mov	r0, fp
 802adaa:	b01b      	add	sp, #108	; 0x6c
 802adac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802adb0:	636f4361 	.word	0x636f4361
 802adb4:	3fd287a7 	.word	0x3fd287a7
 802adb8:	8b60c8b3 	.word	0x8b60c8b3
 802adbc:	3fc68a28 	.word	0x3fc68a28
 802adc0:	509f79fb 	.word	0x509f79fb
 802adc4:	3fd34413 	.word	0x3fd34413
 802adc8:	7ff00000 	.word	0x7ff00000
 802adcc:	0802ffc1 	.word	0x0802ffc1
 802add0:	3ff80000 	.word	0x3ff80000
 802add4:	08030240 	.word	0x08030240
 802add8:	08030100 	.word	0x08030100
 802addc:	0803010c 	.word	0x0803010c
 802ade0:	0802ffc0 	.word	0x0802ffc0
 802ade4:	f04f 34ff 	mov.w	r4, #4294967295
 802ade8:	2501      	movs	r5, #1
 802adea:	e9cd 4509 	strd	r4, r5, [sp, #36]	; 0x24
 802adee:	2300      	movs	r3, #0
 802adf0:	9302      	str	r3, [sp, #8]
 802adf2:	9307      	str	r3, [sp, #28]
 802adf4:	2100      	movs	r1, #0
 802adf6:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 802adfa:	940e      	str	r4, [sp, #56]	; 0x38
 802adfc:	4648      	mov	r0, r9
 802adfe:	f001 fdcf 	bl	802c9a0 <_Balloc>
 802ae02:	2c0e      	cmp	r4, #14
 802ae04:	4683      	mov	fp, r0
 802ae06:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
 802ae0a:	f200 80fb 	bhi.w	802b004 <_dtoa_r+0x454>
 802ae0e:	2d00      	cmp	r5, #0
 802ae10:	f000 80f8 	beq.w	802b004 <_dtoa_r+0x454>
 802ae14:	ed9d 7b00 	vldr	d7, [sp]
 802ae18:	9906      	ldr	r1, [sp, #24]
 802ae1a:	2900      	cmp	r1, #0
 802ae1c:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 802ae20:	f340 83e7 	ble.w	802b5f2 <_dtoa_r+0xa42>
 802ae24:	4b9d      	ldr	r3, [pc, #628]	; (802b09c <_dtoa_r+0x4ec>)
 802ae26:	f001 020f 	and.w	r2, r1, #15
 802ae2a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802ae2e:	ed93 7b00 	vldr	d7, [r3]
 802ae32:	110c      	asrs	r4, r1, #4
 802ae34:	06e2      	lsls	r2, r4, #27
 802ae36:	ed8d 7b00 	vstr	d7, [sp]
 802ae3a:	f140 84a1 	bpl.w	802b780 <_dtoa_r+0xbd0>
 802ae3e:	4b98      	ldr	r3, [pc, #608]	; (802b0a0 <_dtoa_r+0x4f0>)
 802ae40:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 802ae44:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 802ae48:	f7e1 fc64 	bl	800c714 <__aeabi_ddiv>
 802ae4c:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 802ae50:	f004 040f 	and.w	r4, r4, #15
 802ae54:	2603      	movs	r6, #3
 802ae56:	b17c      	cbz	r4, 802ae78 <_dtoa_r+0x2c8>
 802ae58:	e9dd 0100 	ldrd	r0, r1, [sp]
 802ae5c:	4d90      	ldr	r5, [pc, #576]	; (802b0a0 <_dtoa_r+0x4f0>)
 802ae5e:	07e3      	lsls	r3, r4, #31
 802ae60:	d504      	bpl.n	802ae6c <_dtoa_r+0x2bc>
 802ae62:	e9d5 2300 	ldrd	r2, r3, [r5]
 802ae66:	f7e1 fb2b 	bl	800c4c0 <__aeabi_dmul>
 802ae6a:	3601      	adds	r6, #1
 802ae6c:	1064      	asrs	r4, r4, #1
 802ae6e:	f105 0508 	add.w	r5, r5, #8
 802ae72:	d1f4      	bne.n	802ae5e <_dtoa_r+0x2ae>
 802ae74:	e9cd 0100 	strd	r0, r1, [sp]
 802ae78:	e9dd 2300 	ldrd	r2, r3, [sp]
 802ae7c:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 802ae80:	f7e1 fc48 	bl	800c714 <__aeabi_ddiv>
 802ae84:	e9cd 0100 	strd	r0, r1, [sp]
 802ae88:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ae8a:	b143      	cbz	r3, 802ae9e <_dtoa_r+0x2ee>
 802ae8c:	2200      	movs	r2, #0
 802ae8e:	4b85      	ldr	r3, [pc, #532]	; (802b0a4 <_dtoa_r+0x4f4>)
 802ae90:	e9dd 0100 	ldrd	r0, r1, [sp]
 802ae94:	f7e1 fd8c 	bl	800c9b0 <__aeabi_dcmplt>
 802ae98:	2800      	cmp	r0, #0
 802ae9a:	f040 8503 	bne.w	802b8a4 <_dtoa_r+0xcf4>
 802ae9e:	4630      	mov	r0, r6
 802aea0:	f7e1 faa0 	bl	800c3e4 <__aeabi_i2d>
 802aea4:	e9dd 2300 	ldrd	r2, r3, [sp]
 802aea8:	f7e1 fb0a 	bl	800c4c0 <__aeabi_dmul>
 802aeac:	4b7e      	ldr	r3, [pc, #504]	; (802b0a8 <_dtoa_r+0x4f8>)
 802aeae:	2200      	movs	r2, #0
 802aeb0:	f7e1 f94c 	bl	800c14c <__adddf3>
 802aeb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802aeb6:	4606      	mov	r6, r0
 802aeb8:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 802aebc:	2b00      	cmp	r3, #0
 802aebe:	f000 841e 	beq.w	802b6fe <_dtoa_r+0xb4e>
 802aec2:	9b06      	ldr	r3, [sp, #24]
 802aec4:	9316      	str	r3, [sp, #88]	; 0x58
 802aec6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802aec8:	9312      	str	r3, [sp, #72]	; 0x48
 802aeca:	e9dd 0100 	ldrd	r0, r1, [sp]
 802aece:	f7e1 fdaf 	bl	800ca30 <__aeabi_d2iz>
 802aed2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 802aed4:	4b71      	ldr	r3, [pc, #452]	; (802b09c <_dtoa_r+0x4ec>)
 802aed6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802aeda:	ed13 7b02 	vldr	d7, [r3, #-8]
 802aede:	f100 0530 	add.w	r5, r0, #48	; 0x30
 802aee2:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
 802aee6:	f7e1 fa7d 	bl	800c3e4 <__aeabi_i2d>
 802aeea:	460b      	mov	r3, r1
 802aeec:	4602      	mov	r2, r0
 802aeee:	e9dd 0100 	ldrd	r0, r1, [sp]
 802aef2:	e9cd 6700 	strd	r6, r7, [sp]
 802aef6:	f7e1 f927 	bl	800c148 <__aeabi_dsub>
 802aefa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802aefc:	b2ed      	uxtb	r5, r5
 802aefe:	4606      	mov	r6, r0
 802af00:	460f      	mov	r7, r1
 802af02:	f10b 0401 	add.w	r4, fp, #1
 802af06:	2b00      	cmp	r3, #0
 802af08:	f000 845b 	beq.w	802b7c2 <_dtoa_r+0xc12>
 802af0c:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 802af10:	2000      	movs	r0, #0
 802af12:	4966      	ldr	r1, [pc, #408]	; (802b0ac <_dtoa_r+0x4fc>)
 802af14:	f7e1 fbfe 	bl	800c714 <__aeabi_ddiv>
 802af18:	e9dd 2300 	ldrd	r2, r3, [sp]
 802af1c:	f7e1 f914 	bl	800c148 <__aeabi_dsub>
 802af20:	f88b 5000 	strb.w	r5, [fp]
 802af24:	4632      	mov	r2, r6
 802af26:	463b      	mov	r3, r7
 802af28:	e9cd 0100 	strd	r0, r1, [sp]
 802af2c:	f7e1 fd5e 	bl	800c9ec <__aeabi_dcmpgt>
 802af30:	2800      	cmp	r0, #0
 802af32:	f040 8506 	bne.w	802b942 <_dtoa_r+0xd92>
 802af36:	4632      	mov	r2, r6
 802af38:	463b      	mov	r3, r7
 802af3a:	2000      	movs	r0, #0
 802af3c:	4959      	ldr	r1, [pc, #356]	; (802b0a4 <_dtoa_r+0x4f4>)
 802af3e:	f7e1 f903 	bl	800c148 <__aeabi_dsub>
 802af42:	4602      	mov	r2, r0
 802af44:	460b      	mov	r3, r1
 802af46:	e9dd 0100 	ldrd	r0, r1, [sp]
 802af4a:	f7e1 fd4f 	bl	800c9ec <__aeabi_dcmpgt>
 802af4e:	2800      	cmp	r0, #0
 802af50:	f040 84ff 	bne.w	802b952 <_dtoa_r+0xda2>
 802af54:	9a12      	ldr	r2, [sp, #72]	; 0x48
 802af56:	2a01      	cmp	r2, #1
 802af58:	d050      	beq.n	802affc <_dtoa_r+0x44c>
 802af5a:	445a      	add	r2, fp
 802af5c:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
 802af60:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 802af64:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
 802af68:	4692      	mov	sl, r2
 802af6a:	46cb      	mov	fp, r9
 802af6c:	e9dd 8900 	ldrd	r8, r9, [sp]
 802af70:	e00c      	b.n	802af8c <_dtoa_r+0x3dc>
 802af72:	2000      	movs	r0, #0
 802af74:	494b      	ldr	r1, [pc, #300]	; (802b0a4 <_dtoa_r+0x4f4>)
 802af76:	f7e1 f8e7 	bl	800c148 <__aeabi_dsub>
 802af7a:	4642      	mov	r2, r8
 802af7c:	464b      	mov	r3, r9
 802af7e:	f7e1 fd17 	bl	800c9b0 <__aeabi_dcmplt>
 802af82:	2800      	cmp	r0, #0
 802af84:	f040 84e0 	bne.w	802b948 <_dtoa_r+0xd98>
 802af88:	4554      	cmp	r4, sl
 802af8a:	d030      	beq.n	802afee <_dtoa_r+0x43e>
 802af8c:	4640      	mov	r0, r8
 802af8e:	4649      	mov	r1, r9
 802af90:	2200      	movs	r2, #0
 802af92:	4b47      	ldr	r3, [pc, #284]	; (802b0b0 <_dtoa_r+0x500>)
 802af94:	f7e1 fa94 	bl	800c4c0 <__aeabi_dmul>
 802af98:	2200      	movs	r2, #0
 802af9a:	4b45      	ldr	r3, [pc, #276]	; (802b0b0 <_dtoa_r+0x500>)
 802af9c:	4680      	mov	r8, r0
 802af9e:	4689      	mov	r9, r1
 802afa0:	4630      	mov	r0, r6
 802afa2:	4639      	mov	r1, r7
 802afa4:	f7e1 fa8c 	bl	800c4c0 <__aeabi_dmul>
 802afa8:	460f      	mov	r7, r1
 802afaa:	4606      	mov	r6, r0
 802afac:	f7e1 fd40 	bl	800ca30 <__aeabi_d2iz>
 802afb0:	4605      	mov	r5, r0
 802afb2:	f7e1 fa17 	bl	800c3e4 <__aeabi_i2d>
 802afb6:	4602      	mov	r2, r0
 802afb8:	460b      	mov	r3, r1
 802afba:	4630      	mov	r0, r6
 802afbc:	4639      	mov	r1, r7
 802afbe:	f7e1 f8c3 	bl	800c148 <__aeabi_dsub>
 802afc2:	3530      	adds	r5, #48	; 0x30
 802afc4:	b2ed      	uxtb	r5, r5
 802afc6:	4642      	mov	r2, r8
 802afc8:	464b      	mov	r3, r9
 802afca:	f804 5b01 	strb.w	r5, [r4], #1
 802afce:	4606      	mov	r6, r0
 802afd0:	460f      	mov	r7, r1
 802afd2:	f7e1 fced 	bl	800c9b0 <__aeabi_dcmplt>
 802afd6:	4632      	mov	r2, r6
 802afd8:	463b      	mov	r3, r7
 802afda:	2800      	cmp	r0, #0
 802afdc:	d0c9      	beq.n	802af72 <_dtoa_r+0x3c2>
 802afde:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802afe0:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 802afe4:	9306      	str	r3, [sp, #24]
 802afe6:	46d9      	mov	r9, fp
 802afe8:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 802afec:	e238      	b.n	802b460 <_dtoa_r+0x8b0>
 802afee:	46d9      	mov	r9, fp
 802aff0:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
 802aff4:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 802aff8:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 802affc:	e9dd 3410 	ldrd	r3, r4, [sp, #64]	; 0x40
 802b000:	e9cd 3400 	strd	r3, r4, [sp]
 802b004:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802b006:	2b00      	cmp	r3, #0
 802b008:	f2c0 80ae 	blt.w	802b168 <_dtoa_r+0x5b8>
 802b00c:	9a06      	ldr	r2, [sp, #24]
 802b00e:	2a0e      	cmp	r2, #14
 802b010:	f300 80aa 	bgt.w	802b168 <_dtoa_r+0x5b8>
 802b014:	4b21      	ldr	r3, [pc, #132]	; (802b09c <_dtoa_r+0x4ec>)
 802b016:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802b01a:	ed93 7b00 	vldr	d7, [r3]
 802b01e:	9b07      	ldr	r3, [sp, #28]
 802b020:	2b00      	cmp	r3, #0
 802b022:	ed8d 7b02 	vstr	d7, [sp, #8]
 802b026:	f2c0 82c0 	blt.w	802b5aa <_dtoa_r+0x9fa>
 802b02a:	e9dd 6700 	ldrd	r6, r7, [sp]
 802b02e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802b032:	4630      	mov	r0, r6
 802b034:	4639      	mov	r1, r7
 802b036:	f7e1 fb6d 	bl	800c714 <__aeabi_ddiv>
 802b03a:	f7e1 fcf9 	bl	800ca30 <__aeabi_d2iz>
 802b03e:	4605      	mov	r5, r0
 802b040:	f7e1 f9d0 	bl	800c3e4 <__aeabi_i2d>
 802b044:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802b048:	f7e1 fa3a 	bl	800c4c0 <__aeabi_dmul>
 802b04c:	460b      	mov	r3, r1
 802b04e:	4602      	mov	r2, r0
 802b050:	4639      	mov	r1, r7
 802b052:	4630      	mov	r0, r6
 802b054:	f7e1 f878 	bl	800c148 <__aeabi_dsub>
 802b058:	f105 0330 	add.w	r3, r5, #48	; 0x30
 802b05c:	f88b 3000 	strb.w	r3, [fp]
 802b060:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b062:	2b01      	cmp	r3, #1
 802b064:	4606      	mov	r6, r0
 802b066:	460f      	mov	r7, r1
 802b068:	f10b 0401 	add.w	r4, fp, #1
 802b06c:	d053      	beq.n	802b116 <_dtoa_r+0x566>
 802b06e:	2200      	movs	r2, #0
 802b070:	4b0f      	ldr	r3, [pc, #60]	; (802b0b0 <_dtoa_r+0x500>)
 802b072:	f7e1 fa25 	bl	800c4c0 <__aeabi_dmul>
 802b076:	2200      	movs	r2, #0
 802b078:	2300      	movs	r3, #0
 802b07a:	4606      	mov	r6, r0
 802b07c:	460f      	mov	r7, r1
 802b07e:	f7e1 fc8d 	bl	800c99c <__aeabi_dcmpeq>
 802b082:	2800      	cmp	r0, #0
 802b084:	f040 81ec 	bne.w	802b460 <_dtoa_r+0x8b0>
 802b088:	f8cd a000 	str.w	sl, [sp]
 802b08c:	f8cd 901c 	str.w	r9, [sp, #28]
 802b090:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 802b094:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 802b098:	e017      	b.n	802b0ca <_dtoa_r+0x51a>
 802b09a:	bf00      	nop
 802b09c:	08030240 	.word	0x08030240
 802b0a0:	08030210 	.word	0x08030210
 802b0a4:	3ff00000 	.word	0x3ff00000
 802b0a8:	401c0000 	.word	0x401c0000
 802b0ac:	3fe00000 	.word	0x3fe00000
 802b0b0:	40240000 	.word	0x40240000
 802b0b4:	f7e1 fa04 	bl	800c4c0 <__aeabi_dmul>
 802b0b8:	2200      	movs	r2, #0
 802b0ba:	2300      	movs	r3, #0
 802b0bc:	4606      	mov	r6, r0
 802b0be:	460f      	mov	r7, r1
 802b0c0:	f7e1 fc6c 	bl	800c99c <__aeabi_dcmpeq>
 802b0c4:	2800      	cmp	r0, #0
 802b0c6:	f040 833f 	bne.w	802b748 <_dtoa_r+0xb98>
 802b0ca:	464a      	mov	r2, r9
 802b0cc:	4653      	mov	r3, sl
 802b0ce:	4630      	mov	r0, r6
 802b0d0:	4639      	mov	r1, r7
 802b0d2:	f7e1 fb1f 	bl	800c714 <__aeabi_ddiv>
 802b0d6:	f7e1 fcab 	bl	800ca30 <__aeabi_d2iz>
 802b0da:	4605      	mov	r5, r0
 802b0dc:	f7e1 f982 	bl	800c3e4 <__aeabi_i2d>
 802b0e0:	464a      	mov	r2, r9
 802b0e2:	4653      	mov	r3, sl
 802b0e4:	f7e1 f9ec 	bl	800c4c0 <__aeabi_dmul>
 802b0e8:	4602      	mov	r2, r0
 802b0ea:	460b      	mov	r3, r1
 802b0ec:	4630      	mov	r0, r6
 802b0ee:	4639      	mov	r1, r7
 802b0f0:	f7e1 f82a 	bl	800c148 <__aeabi_dsub>
 802b0f4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 802b0f8:	f804 cb01 	strb.w	ip, [r4], #1
 802b0fc:	eba4 0c0b 	sub.w	ip, r4, fp
 802b100:	45e0      	cmp	r8, ip
 802b102:	4606      	mov	r6, r0
 802b104:	460f      	mov	r7, r1
 802b106:	f04f 0200 	mov.w	r2, #0
 802b10a:	4bc2      	ldr	r3, [pc, #776]	; (802b414 <_dtoa_r+0x864>)
 802b10c:	d1d2      	bne.n	802b0b4 <_dtoa_r+0x504>
 802b10e:	f8dd a000 	ldr.w	sl, [sp]
 802b112:	f8dd 901c 	ldr.w	r9, [sp, #28]
 802b116:	4632      	mov	r2, r6
 802b118:	463b      	mov	r3, r7
 802b11a:	4630      	mov	r0, r6
 802b11c:	4639      	mov	r1, r7
 802b11e:	f7e1 f815 	bl	800c14c <__adddf3>
 802b122:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802b126:	4606      	mov	r6, r0
 802b128:	460f      	mov	r7, r1
 802b12a:	f7e1 fc5f 	bl	800c9ec <__aeabi_dcmpgt>
 802b12e:	b958      	cbnz	r0, 802b148 <_dtoa_r+0x598>
 802b130:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802b134:	4630      	mov	r0, r6
 802b136:	4639      	mov	r1, r7
 802b138:	f7e1 fc30 	bl	800c99c <__aeabi_dcmpeq>
 802b13c:	2800      	cmp	r0, #0
 802b13e:	f000 818f 	beq.w	802b460 <_dtoa_r+0x8b0>
 802b142:	07e9      	lsls	r1, r5, #31
 802b144:	f140 818c 	bpl.w	802b460 <_dtoa_r+0x8b0>
 802b148:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 802b14c:	e005      	b.n	802b15a <_dtoa_r+0x5aa>
 802b14e:	459b      	cmp	fp, r3
 802b150:	f000 8376 	beq.w	802b840 <_dtoa_r+0xc90>
 802b154:	f813 5c01 	ldrb.w	r5, [r3, #-1]
 802b158:	461c      	mov	r4, r3
 802b15a:	2d39      	cmp	r5, #57	; 0x39
 802b15c:	f104 33ff 	add.w	r3, r4, #4294967295
 802b160:	d0f5      	beq.n	802b14e <_dtoa_r+0x59e>
 802b162:	3501      	adds	r5, #1
 802b164:	701d      	strb	r5, [r3, #0]
 802b166:	e17b      	b.n	802b460 <_dtoa_r+0x8b0>
 802b168:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802b16a:	2a00      	cmp	r2, #0
 802b16c:	d03b      	beq.n	802b1e6 <_dtoa_r+0x636>
 802b16e:	9a02      	ldr	r2, [sp, #8]
 802b170:	2a01      	cmp	r2, #1
 802b172:	f340 820d 	ble.w	802b590 <_dtoa_r+0x9e0>
 802b176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b178:	1e5f      	subs	r7, r3, #1
 802b17a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802b17c:	42bb      	cmp	r3, r7
 802b17e:	f2c0 82e8 	blt.w	802b752 <_dtoa_r+0xba2>
 802b182:	1bdf      	subs	r7, r3, r7
 802b184:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b186:	2b00      	cmp	r3, #0
 802b188:	f2c0 830e 	blt.w	802b7a8 <_dtoa_r+0xbf8>
 802b18c:	9a08      	ldr	r2, [sp, #32]
 802b18e:	4614      	mov	r4, r2
 802b190:	441a      	add	r2, r3
 802b192:	4498      	add	r8, r3
 802b194:	9208      	str	r2, [sp, #32]
 802b196:	2101      	movs	r1, #1
 802b198:	4648      	mov	r0, r9
 802b19a:	f001 fd19 	bl	802cbd0 <__i2b>
 802b19e:	4605      	mov	r5, r0
 802b1a0:	e024      	b.n	802b1ec <_dtoa_r+0x63c>
 802b1a2:	2301      	movs	r3, #1
 802b1a4:	930d      	str	r3, [sp, #52]	; 0x34
 802b1a6:	e5af      	b.n	802ad08 <_dtoa_r+0x158>
 802b1a8:	9a08      	ldr	r2, [sp, #32]
 802b1aa:	9b06      	ldr	r3, [sp, #24]
 802b1ac:	1ad2      	subs	r2, r2, r3
 802b1ae:	425b      	negs	r3, r3
 802b1b0:	930b      	str	r3, [sp, #44]	; 0x2c
 802b1b2:	2300      	movs	r3, #0
 802b1b4:	9208      	str	r2, [sp, #32]
 802b1b6:	930c      	str	r3, [sp, #48]	; 0x30
 802b1b8:	e5b5      	b.n	802ad26 <_dtoa_r+0x176>
 802b1ba:	f1c4 0301 	rsb	r3, r4, #1
 802b1be:	9308      	str	r3, [sp, #32]
 802b1c0:	f04f 0800 	mov.w	r8, #0
 802b1c4:	e5a7      	b.n	802ad16 <_dtoa_r+0x166>
 802b1c6:	f8dd 8018 	ldr.w	r8, [sp, #24]
 802b1ca:	4640      	mov	r0, r8
 802b1cc:	f7e1 f90a 	bl	800c3e4 <__aeabi_i2d>
 802b1d0:	4632      	mov	r2, r6
 802b1d2:	463b      	mov	r3, r7
 802b1d4:	f7e1 fbe2 	bl	800c99c <__aeabi_dcmpeq>
 802b1d8:	2800      	cmp	r0, #0
 802b1da:	f47f ad81 	bne.w	802ace0 <_dtoa_r+0x130>
 802b1de:	f108 33ff 	add.w	r3, r8, #4294967295
 802b1e2:	9306      	str	r3, [sp, #24]
 802b1e4:	e57c      	b.n	802ace0 <_dtoa_r+0x130>
 802b1e6:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 802b1e8:	9c08      	ldr	r4, [sp, #32]
 802b1ea:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 802b1ec:	2c00      	cmp	r4, #0
 802b1ee:	dd0c      	ble.n	802b20a <_dtoa_r+0x65a>
 802b1f0:	f1b8 0f00 	cmp.w	r8, #0
 802b1f4:	dd09      	ble.n	802b20a <_dtoa_r+0x65a>
 802b1f6:	4544      	cmp	r4, r8
 802b1f8:	9a08      	ldr	r2, [sp, #32]
 802b1fa:	4623      	mov	r3, r4
 802b1fc:	bfa8      	it	ge
 802b1fe:	4643      	movge	r3, r8
 802b200:	1ad2      	subs	r2, r2, r3
 802b202:	9208      	str	r2, [sp, #32]
 802b204:	1ae4      	subs	r4, r4, r3
 802b206:	eba8 0803 	sub.w	r8, r8, r3
 802b20a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802b20c:	b16b      	cbz	r3, 802b22a <_dtoa_r+0x67a>
 802b20e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802b210:	2a00      	cmp	r2, #0
 802b212:	f000 8292 	beq.w	802b73a <_dtoa_r+0xb8a>
 802b216:	1bde      	subs	r6, r3, r7
 802b218:	2f00      	cmp	r7, #0
 802b21a:	f040 819d 	bne.w	802b558 <_dtoa_r+0x9a8>
 802b21e:	4651      	mov	r1, sl
 802b220:	4632      	mov	r2, r6
 802b222:	4648      	mov	r0, r9
 802b224:	f001 fd8c 	bl	802cd40 <__pow5mult>
 802b228:	4682      	mov	sl, r0
 802b22a:	2101      	movs	r1, #1
 802b22c:	4648      	mov	r0, r9
 802b22e:	f001 fccf 	bl	802cbd0 <__i2b>
 802b232:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802b234:	4606      	mov	r6, r0
 802b236:	2a00      	cmp	r2, #0
 802b238:	f040 8127 	bne.w	802b48a <_dtoa_r+0x8da>
 802b23c:	9b02      	ldr	r3, [sp, #8]
 802b23e:	2b01      	cmp	r3, #1
 802b240:	f340 816e 	ble.w	802b520 <_dtoa_r+0x970>
 802b244:	2001      	movs	r0, #1
 802b246:	4440      	add	r0, r8
 802b248:	f010 001f 	ands.w	r0, r0, #31
 802b24c:	f000 811b 	beq.w	802b486 <_dtoa_r+0x8d6>
 802b250:	f1c0 0320 	rsb	r3, r0, #32
 802b254:	2b04      	cmp	r3, #4
 802b256:	f340 83b0 	ble.w	802b9ba <_dtoa_r+0xe0a>
 802b25a:	f1c0 001c 	rsb	r0, r0, #28
 802b25e:	9b08      	ldr	r3, [sp, #32]
 802b260:	4403      	add	r3, r0
 802b262:	9308      	str	r3, [sp, #32]
 802b264:	4404      	add	r4, r0
 802b266:	4480      	add	r8, r0
 802b268:	9b08      	ldr	r3, [sp, #32]
 802b26a:	2b00      	cmp	r3, #0
 802b26c:	dd05      	ble.n	802b27a <_dtoa_r+0x6ca>
 802b26e:	4651      	mov	r1, sl
 802b270:	461a      	mov	r2, r3
 802b272:	4648      	mov	r0, r9
 802b274:	f001 fdb4 	bl	802cde0 <__lshift>
 802b278:	4682      	mov	sl, r0
 802b27a:	f1b8 0f00 	cmp.w	r8, #0
 802b27e:	dd05      	ble.n	802b28c <_dtoa_r+0x6dc>
 802b280:	4631      	mov	r1, r6
 802b282:	4642      	mov	r2, r8
 802b284:	4648      	mov	r0, r9
 802b286:	f001 fdab 	bl	802cde0 <__lshift>
 802b28a:	4606      	mov	r6, r0
 802b28c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802b28e:	2b00      	cmp	r3, #0
 802b290:	d178      	bne.n	802b384 <_dtoa_r+0x7d4>
 802b292:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b294:	2b00      	cmp	r3, #0
 802b296:	f340 820b 	ble.w	802b6b0 <_dtoa_r+0xb00>
 802b29a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802b29c:	2b00      	cmp	r3, #0
 802b29e:	f000 808a 	beq.w	802b3b6 <_dtoa_r+0x806>
 802b2a2:	2c00      	cmp	r4, #0
 802b2a4:	f300 816d 	bgt.w	802b582 <_dtoa_r+0x9d2>
 802b2a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802b2aa:	2b00      	cmp	r3, #0
 802b2ac:	f040 81cf 	bne.w	802b64e <_dtoa_r+0xa9e>
 802b2b0:	46a8      	mov	r8, r5
 802b2b2:	9a00      	ldr	r2, [sp, #0]
 802b2b4:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 802b2b8:	f002 0201 	and.w	r2, r2, #1
 802b2bc:	920a      	str	r2, [sp, #40]	; 0x28
 802b2be:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802b2c0:	f10b 33ff 	add.w	r3, fp, #4294967295
 802b2c4:	441a      	add	r2, r3
 802b2c6:	465f      	mov	r7, fp
 802b2c8:	9209      	str	r2, [sp, #36]	; 0x24
 802b2ca:	46b3      	mov	fp, r6
 802b2cc:	4659      	mov	r1, fp
 802b2ce:	4650      	mov	r0, sl
 802b2d0:	f7ff fbd6 	bl	802aa80 <quorem>
 802b2d4:	4629      	mov	r1, r5
 802b2d6:	4604      	mov	r4, r0
 802b2d8:	4650      	mov	r0, sl
 802b2da:	f001 fdd9 	bl	802ce90 <__mcmp>
 802b2de:	4659      	mov	r1, fp
 802b2e0:	4606      	mov	r6, r0
 802b2e2:	4642      	mov	r2, r8
 802b2e4:	4648      	mov	r0, r9
 802b2e6:	f001 fdf3 	bl	802ced0 <__mdiff>
 802b2ea:	f104 0330 	add.w	r3, r4, #48	; 0x30
 802b2ee:	9300      	str	r3, [sp, #0]
 802b2f0:	68c3      	ldr	r3, [r0, #12]
 802b2f2:	4601      	mov	r1, r0
 802b2f4:	2b00      	cmp	r3, #0
 802b2f6:	f040 81d6 	bne.w	802b6a6 <_dtoa_r+0xaf6>
 802b2fa:	9008      	str	r0, [sp, #32]
 802b2fc:	4650      	mov	r0, sl
 802b2fe:	f001 fdc7 	bl	802ce90 <__mcmp>
 802b302:	9a08      	ldr	r2, [sp, #32]
 802b304:	9007      	str	r0, [sp, #28]
 802b306:	4611      	mov	r1, r2
 802b308:	4648      	mov	r0, r9
 802b30a:	f001 fb71 	bl	802c9f0 <_Bfree>
 802b30e:	9b07      	ldr	r3, [sp, #28]
 802b310:	b933      	cbnz	r3, 802b320 <_dtoa_r+0x770>
 802b312:	9a02      	ldr	r2, [sp, #8]
 802b314:	b922      	cbnz	r2, 802b320 <_dtoa_r+0x770>
 802b316:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802b318:	2b00      	cmp	r3, #0
 802b31a:	f000 831d 	beq.w	802b958 <_dtoa_r+0xda8>
 802b31e:	9b02      	ldr	r3, [sp, #8]
 802b320:	2e00      	cmp	r6, #0
 802b322:	f2c0 821e 	blt.w	802b762 <_dtoa_r+0xbb2>
 802b326:	d105      	bne.n	802b334 <_dtoa_r+0x784>
 802b328:	9a02      	ldr	r2, [sp, #8]
 802b32a:	b91a      	cbnz	r2, 802b334 <_dtoa_r+0x784>
 802b32c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802b32e:	2a00      	cmp	r2, #0
 802b330:	f000 8217 	beq.w	802b762 <_dtoa_r+0xbb2>
 802b334:	2b00      	cmp	r3, #0
 802b336:	f107 0401 	add.w	r4, r7, #1
 802b33a:	f300 8228 	bgt.w	802b78e <_dtoa_r+0xbde>
 802b33e:	f89d 3000 	ldrb.w	r3, [sp]
 802b342:	703b      	strb	r3, [r7, #0]
 802b344:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b346:	42bb      	cmp	r3, r7
 802b348:	f000 8232 	beq.w	802b7b0 <_dtoa_r+0xc00>
 802b34c:	4651      	mov	r1, sl
 802b34e:	2300      	movs	r3, #0
 802b350:	220a      	movs	r2, #10
 802b352:	4648      	mov	r0, r9
 802b354:	f001 fb5c 	bl	802ca10 <__multadd>
 802b358:	4545      	cmp	r5, r8
 802b35a:	4682      	mov	sl, r0
 802b35c:	4629      	mov	r1, r5
 802b35e:	f04f 0300 	mov.w	r3, #0
 802b362:	f04f 020a 	mov.w	r2, #10
 802b366:	4648      	mov	r0, r9
 802b368:	f000 8197 	beq.w	802b69a <_dtoa_r+0xaea>
 802b36c:	f001 fb50 	bl	802ca10 <__multadd>
 802b370:	4641      	mov	r1, r8
 802b372:	4605      	mov	r5, r0
 802b374:	2300      	movs	r3, #0
 802b376:	220a      	movs	r2, #10
 802b378:	4648      	mov	r0, r9
 802b37a:	f001 fb49 	bl	802ca10 <__multadd>
 802b37e:	4627      	mov	r7, r4
 802b380:	4680      	mov	r8, r0
 802b382:	e7a3      	b.n	802b2cc <_dtoa_r+0x71c>
 802b384:	4631      	mov	r1, r6
 802b386:	4650      	mov	r0, sl
 802b388:	f001 fd82 	bl	802ce90 <__mcmp>
 802b38c:	2800      	cmp	r0, #0
 802b38e:	da80      	bge.n	802b292 <_dtoa_r+0x6e2>
 802b390:	9f06      	ldr	r7, [sp, #24]
 802b392:	4651      	mov	r1, sl
 802b394:	2300      	movs	r3, #0
 802b396:	220a      	movs	r2, #10
 802b398:	4648      	mov	r0, r9
 802b39a:	3f01      	subs	r7, #1
 802b39c:	9706      	str	r7, [sp, #24]
 802b39e:	f001 fb37 	bl	802ca10 <__multadd>
 802b3a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802b3a4:	4682      	mov	sl, r0
 802b3a6:	2b00      	cmp	r3, #0
 802b3a8:	f040 82ee 	bne.w	802b988 <_dtoa_r+0xdd8>
 802b3ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b3ae:	2b00      	cmp	r3, #0
 802b3b0:	f340 82f6 	ble.w	802b9a0 <_dtoa_r+0xdf0>
 802b3b4:	9309      	str	r3, [sp, #36]	; 0x24
 802b3b6:	465c      	mov	r4, fp
 802b3b8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 802b3bc:	e002      	b.n	802b3c4 <_dtoa_r+0x814>
 802b3be:	f001 fb27 	bl	802ca10 <__multadd>
 802b3c2:	4682      	mov	sl, r0
 802b3c4:	4631      	mov	r1, r6
 802b3c6:	4650      	mov	r0, sl
 802b3c8:	f7ff fb5a 	bl	802aa80 <quorem>
 802b3cc:	f100 0730 	add.w	r7, r0, #48	; 0x30
 802b3d0:	f804 7b01 	strb.w	r7, [r4], #1
 802b3d4:	eba4 030b 	sub.w	r3, r4, fp
 802b3d8:	4598      	cmp	r8, r3
 802b3da:	f04f 020a 	mov.w	r2, #10
 802b3de:	f04f 0300 	mov.w	r3, #0
 802b3e2:	4651      	mov	r1, sl
 802b3e4:	4648      	mov	r0, r9
 802b3e6:	dcea      	bgt.n	802b3be <_dtoa_r+0x80e>
 802b3e8:	2300      	movs	r3, #0
 802b3ea:	9700      	str	r7, [sp, #0]
 802b3ec:	9302      	str	r3, [sp, #8]
 802b3ee:	4651      	mov	r1, sl
 802b3f0:	2201      	movs	r2, #1
 802b3f2:	4648      	mov	r0, r9
 802b3f4:	f001 fcf4 	bl	802cde0 <__lshift>
 802b3f8:	4631      	mov	r1, r6
 802b3fa:	4682      	mov	sl, r0
 802b3fc:	f001 fd48 	bl	802ce90 <__mcmp>
 802b400:	2800      	cmp	r0, #0
 802b402:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 802b406:	dc15      	bgt.n	802b434 <_dtoa_r+0x884>
 802b408:	d109      	bne.n	802b41e <_dtoa_r+0x86e>
 802b40a:	9b00      	ldr	r3, [sp, #0]
 802b40c:	07db      	lsls	r3, r3, #31
 802b40e:	d411      	bmi.n	802b434 <_dtoa_r+0x884>
 802b410:	e005      	b.n	802b41e <_dtoa_r+0x86e>
 802b412:	bf00      	nop
 802b414:	40240000 	.word	0x40240000
 802b418:	f814 2c02 	ldrb.w	r2, [r4, #-2]
 802b41c:	461c      	mov	r4, r3
 802b41e:	2a30      	cmp	r2, #48	; 0x30
 802b420:	f104 33ff 	add.w	r3, r4, #4294967295
 802b424:	d0f8      	beq.n	802b418 <_dtoa_r+0x868>
 802b426:	e00b      	b.n	802b440 <_dtoa_r+0x890>
 802b428:	459b      	cmp	fp, r3
 802b42a:	f000 814e 	beq.w	802b6ca <_dtoa_r+0xb1a>
 802b42e:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 802b432:	461c      	mov	r4, r3
 802b434:	2a39      	cmp	r2, #57	; 0x39
 802b436:	f104 33ff 	add.w	r3, r4, #4294967295
 802b43a:	d0f5      	beq.n	802b428 <_dtoa_r+0x878>
 802b43c:	3201      	adds	r2, #1
 802b43e:	701a      	strb	r2, [r3, #0]
 802b440:	4631      	mov	r1, r6
 802b442:	4648      	mov	r0, r9
 802b444:	f001 fad4 	bl	802c9f0 <_Bfree>
 802b448:	b155      	cbz	r5, 802b460 <_dtoa_r+0x8b0>
 802b44a:	9902      	ldr	r1, [sp, #8]
 802b44c:	b121      	cbz	r1, 802b458 <_dtoa_r+0x8a8>
 802b44e:	42a9      	cmp	r1, r5
 802b450:	d002      	beq.n	802b458 <_dtoa_r+0x8a8>
 802b452:	4648      	mov	r0, r9
 802b454:	f001 facc 	bl	802c9f0 <_Bfree>
 802b458:	4629      	mov	r1, r5
 802b45a:	4648      	mov	r0, r9
 802b45c:	f001 fac8 	bl	802c9f0 <_Bfree>
 802b460:	4651      	mov	r1, sl
 802b462:	4648      	mov	r0, r9
 802b464:	f001 fac4 	bl	802c9f0 <_Bfree>
 802b468:	2200      	movs	r2, #0
 802b46a:	9b06      	ldr	r3, [sp, #24]
 802b46c:	7022      	strb	r2, [r4, #0]
 802b46e:	9a05      	ldr	r2, [sp, #20]
 802b470:	3301      	adds	r3, #1
 802b472:	6013      	str	r3, [r2, #0]
 802b474:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802b476:	2b00      	cmp	r3, #0
 802b478:	f43f abd9 	beq.w	802ac2e <_dtoa_r+0x7e>
 802b47c:	4658      	mov	r0, fp
 802b47e:	601c      	str	r4, [r3, #0]
 802b480:	b01b      	add	sp, #108	; 0x6c
 802b482:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802b486:	201c      	movs	r0, #28
 802b488:	e6e9      	b.n	802b25e <_dtoa_r+0x6ae>
 802b48a:	4601      	mov	r1, r0
 802b48c:	4648      	mov	r0, r9
 802b48e:	f001 fc57 	bl	802cd40 <__pow5mult>
 802b492:	9b02      	ldr	r3, [sp, #8]
 802b494:	2b01      	cmp	r3, #1
 802b496:	4606      	mov	r6, r0
 802b498:	f340 80d4 	ble.w	802b644 <_dtoa_r+0xa94>
 802b49c:	2300      	movs	r3, #0
 802b49e:	930c      	str	r3, [sp, #48]	; 0x30
 802b4a0:	6933      	ldr	r3, [r6, #16]
 802b4a2:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 802b4a6:	6918      	ldr	r0, [r3, #16]
 802b4a8:	f001 fb42 	bl	802cb30 <__hi0bits>
 802b4ac:	f1c0 0020 	rsb	r0, r0, #32
 802b4b0:	e6c9      	b.n	802b246 <_dtoa_r+0x696>
 802b4b2:	900d      	str	r0, [sp, #52]	; 0x34
 802b4b4:	e428      	b.n	802ad08 <_dtoa_r+0x158>
 802b4b6:	2501      	movs	r5, #1
 802b4b8:	e43e      	b.n	802ad38 <_dtoa_r+0x188>
 802b4ba:	f1c3 0820 	rsb	r8, r3, #32
 802b4be:	9b00      	ldr	r3, [sp, #0]
 802b4c0:	fa03 f008 	lsl.w	r0, r3, r8
 802b4c4:	f7ff bbd6 	b.w	802ac74 <_dtoa_r+0xc4>
 802b4c8:	2300      	movs	r3, #0
 802b4ca:	930a      	str	r3, [sp, #40]	; 0x28
 802b4cc:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 802b4d0:	4413      	add	r3, r2
 802b4d2:	930e      	str	r3, [sp, #56]	; 0x38
 802b4d4:	3301      	adds	r3, #1
 802b4d6:	2b01      	cmp	r3, #1
 802b4d8:	461e      	mov	r6, r3
 802b4da:	9309      	str	r3, [sp, #36]	; 0x24
 802b4dc:	bfb8      	it	lt
 802b4de:	2601      	movlt	r6, #1
 802b4e0:	2100      	movs	r1, #0
 802b4e2:	2e17      	cmp	r6, #23
 802b4e4:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 802b4e8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802b4ea:	f77f ac87 	ble.w	802adfc <_dtoa_r+0x24c>
 802b4ee:	2201      	movs	r2, #1
 802b4f0:	2304      	movs	r3, #4
 802b4f2:	005b      	lsls	r3, r3, #1
 802b4f4:	f103 0014 	add.w	r0, r3, #20
 802b4f8:	42b0      	cmp	r0, r6
 802b4fa:	4611      	mov	r1, r2
 802b4fc:	f102 0201 	add.w	r2, r2, #1
 802b500:	d9f7      	bls.n	802b4f2 <_dtoa_r+0x942>
 802b502:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
 802b506:	e479      	b.n	802adfc <_dtoa_r+0x24c>
 802b508:	2300      	movs	r3, #0
 802b50a:	930a      	str	r3, [sp, #40]	; 0x28
 802b50c:	9e07      	ldr	r6, [sp, #28]
 802b50e:	2e00      	cmp	r6, #0
 802b510:	f340 80e2 	ble.w	802b6d8 <_dtoa_r+0xb28>
 802b514:	960e      	str	r6, [sp, #56]	; 0x38
 802b516:	9609      	str	r6, [sp, #36]	; 0x24
 802b518:	e7e2      	b.n	802b4e0 <_dtoa_r+0x930>
 802b51a:	2301      	movs	r3, #1
 802b51c:	930a      	str	r3, [sp, #40]	; 0x28
 802b51e:	e7f5      	b.n	802b50c <_dtoa_r+0x95c>
 802b520:	9b00      	ldr	r3, [sp, #0]
 802b522:	2b00      	cmp	r3, #0
 802b524:	f47f ae8e 	bne.w	802b244 <_dtoa_r+0x694>
 802b528:	e9dd 1200 	ldrd	r1, r2, [sp]
 802b52c:	f3c2 0313 	ubfx	r3, r2, #0, #20
 802b530:	2b00      	cmp	r3, #0
 802b532:	f040 8193 	bne.w	802b85c <_dtoa_r+0xcac>
 802b536:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802b53a:	0d1b      	lsrs	r3, r3, #20
 802b53c:	051b      	lsls	r3, r3, #20
 802b53e:	b12b      	cbz	r3, 802b54c <_dtoa_r+0x99c>
 802b540:	9b08      	ldr	r3, [sp, #32]
 802b542:	3301      	adds	r3, #1
 802b544:	9308      	str	r3, [sp, #32]
 802b546:	f108 0801 	add.w	r8, r8, #1
 802b54a:	2301      	movs	r3, #1
 802b54c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802b54e:	930c      	str	r3, [sp, #48]	; 0x30
 802b550:	2a00      	cmp	r2, #0
 802b552:	f43f ae77 	beq.w	802b244 <_dtoa_r+0x694>
 802b556:	e7a3      	b.n	802b4a0 <_dtoa_r+0x8f0>
 802b558:	463a      	mov	r2, r7
 802b55a:	4629      	mov	r1, r5
 802b55c:	4648      	mov	r0, r9
 802b55e:	f001 fbef 	bl	802cd40 <__pow5mult>
 802b562:	4652      	mov	r2, sl
 802b564:	4601      	mov	r1, r0
 802b566:	4605      	mov	r5, r0
 802b568:	4648      	mov	r0, r9
 802b56a:	f001 fb41 	bl	802cbf0 <__multiply>
 802b56e:	4651      	mov	r1, sl
 802b570:	4607      	mov	r7, r0
 802b572:	4648      	mov	r0, r9
 802b574:	f001 fa3c 	bl	802c9f0 <_Bfree>
 802b578:	46ba      	mov	sl, r7
 802b57a:	2e00      	cmp	r6, #0
 802b57c:	f43f ae55 	beq.w	802b22a <_dtoa_r+0x67a>
 802b580:	e64d      	b.n	802b21e <_dtoa_r+0x66e>
 802b582:	4629      	mov	r1, r5
 802b584:	4622      	mov	r2, r4
 802b586:	4648      	mov	r0, r9
 802b588:	f001 fc2a 	bl	802cde0 <__lshift>
 802b58c:	4605      	mov	r5, r0
 802b58e:	e68b      	b.n	802b2a8 <_dtoa_r+0x6f8>
 802b590:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802b592:	2a00      	cmp	r2, #0
 802b594:	f000 815e 	beq.w	802b854 <_dtoa_r+0xca4>
 802b598:	f203 4333 	addw	r3, r3, #1075	; 0x433
 802b59c:	9a08      	ldr	r2, [sp, #32]
 802b59e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 802b5a0:	4614      	mov	r4, r2
 802b5a2:	441a      	add	r2, r3
 802b5a4:	4498      	add	r8, r3
 802b5a6:	9208      	str	r2, [sp, #32]
 802b5a8:	e5f5      	b.n	802b196 <_dtoa_r+0x5e6>
 802b5aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b5ac:	2b00      	cmp	r3, #0
 802b5ae:	f73f ad3c 	bgt.w	802b02a <_dtoa_r+0x47a>
 802b5b2:	f040 80bc 	bne.w	802b72e <_dtoa_r+0xb7e>
 802b5b6:	ec51 0b17 	vmov	r0, r1, d7
 802b5ba:	2200      	movs	r2, #0
 802b5bc:	4bb3      	ldr	r3, [pc, #716]	; (802b88c <_dtoa_r+0xcdc>)
 802b5be:	f7e0 ff7f 	bl	800c4c0 <__aeabi_dmul>
 802b5c2:	e9dd 2300 	ldrd	r2, r3, [sp]
 802b5c6:	f7e1 fa07 	bl	800c9d8 <__aeabi_dcmpge>
 802b5ca:	9e09      	ldr	r6, [sp, #36]	; 0x24
 802b5cc:	4635      	mov	r5, r6
 802b5ce:	2800      	cmp	r0, #0
 802b5d0:	d176      	bne.n	802b6c0 <_dtoa_r+0xb10>
 802b5d2:	9a06      	ldr	r2, [sp, #24]
 802b5d4:	2331      	movs	r3, #49	; 0x31
 802b5d6:	3201      	adds	r2, #1
 802b5d8:	9206      	str	r2, [sp, #24]
 802b5da:	f88b 3000 	strb.w	r3, [fp]
 802b5de:	f10b 0401 	add.w	r4, fp, #1
 802b5e2:	4631      	mov	r1, r6
 802b5e4:	4648      	mov	r0, r9
 802b5e6:	f001 fa03 	bl	802c9f0 <_Bfree>
 802b5ea:	2d00      	cmp	r5, #0
 802b5ec:	f47f af34 	bne.w	802b458 <_dtoa_r+0x8a8>
 802b5f0:	e736      	b.n	802b460 <_dtoa_r+0x8b0>
 802b5f2:	f000 8143 	beq.w	802b87c <_dtoa_r+0xccc>
 802b5f6:	9b06      	ldr	r3, [sp, #24]
 802b5f8:	425c      	negs	r4, r3
 802b5fa:	4ba5      	ldr	r3, [pc, #660]	; (802b890 <_dtoa_r+0xce0>)
 802b5fc:	f004 020f 	and.w	r2, r4, #15
 802b600:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802b604:	e9d3 2300 	ldrd	r2, r3, [r3]
 802b608:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 802b60c:	f7e0 ff58 	bl	800c4c0 <__aeabi_dmul>
 802b610:	1124      	asrs	r4, r4, #4
 802b612:	e9cd 0100 	strd	r0, r1, [sp]
 802b616:	f000 81c8 	beq.w	802b9aa <_dtoa_r+0xdfa>
 802b61a:	4d9e      	ldr	r5, [pc, #632]	; (802b894 <_dtoa_r+0xce4>)
 802b61c:	2300      	movs	r3, #0
 802b61e:	2602      	movs	r6, #2
 802b620:	07e7      	lsls	r7, r4, #31
 802b622:	d505      	bpl.n	802b630 <_dtoa_r+0xa80>
 802b624:	e9d5 2300 	ldrd	r2, r3, [r5]
 802b628:	f7e0 ff4a 	bl	800c4c0 <__aeabi_dmul>
 802b62c:	3601      	adds	r6, #1
 802b62e:	2301      	movs	r3, #1
 802b630:	1064      	asrs	r4, r4, #1
 802b632:	f105 0508 	add.w	r5, r5, #8
 802b636:	d1f3      	bne.n	802b620 <_dtoa_r+0xa70>
 802b638:	2b00      	cmp	r3, #0
 802b63a:	f43f ac25 	beq.w	802ae88 <_dtoa_r+0x2d8>
 802b63e:	e9cd 0100 	strd	r0, r1, [sp]
 802b642:	e421      	b.n	802ae88 <_dtoa_r+0x2d8>
 802b644:	9b00      	ldr	r3, [sp, #0]
 802b646:	2b00      	cmp	r3, #0
 802b648:	f43f af6e 	beq.w	802b528 <_dtoa_r+0x978>
 802b64c:	e726      	b.n	802b49c <_dtoa_r+0x8ec>
 802b64e:	6869      	ldr	r1, [r5, #4]
 802b650:	4648      	mov	r0, r9
 802b652:	f001 f9a5 	bl	802c9a0 <_Balloc>
 802b656:	692b      	ldr	r3, [r5, #16]
 802b658:	3302      	adds	r3, #2
 802b65a:	009a      	lsls	r2, r3, #2
 802b65c:	4604      	mov	r4, r0
 802b65e:	f105 010c 	add.w	r1, r5, #12
 802b662:	300c      	adds	r0, #12
 802b664:	f7e1 fa5c 	bl	800cb20 <memcpy>
 802b668:	4621      	mov	r1, r4
 802b66a:	2201      	movs	r2, #1
 802b66c:	4648      	mov	r0, r9
 802b66e:	f001 fbb7 	bl	802cde0 <__lshift>
 802b672:	4680      	mov	r8, r0
 802b674:	e61d      	b.n	802b2b2 <_dtoa_r+0x702>
 802b676:	2400      	movs	r4, #0
 802b678:	f8c9 4044 	str.w	r4, [r9, #68]	; 0x44
 802b67c:	4621      	mov	r1, r4
 802b67e:	4648      	mov	r0, r9
 802b680:	f001 f98e 	bl	802c9a0 <_Balloc>
 802b684:	f04f 33ff 	mov.w	r3, #4294967295
 802b688:	930e      	str	r3, [sp, #56]	; 0x38
 802b68a:	9309      	str	r3, [sp, #36]	; 0x24
 802b68c:	2301      	movs	r3, #1
 802b68e:	4683      	mov	fp, r0
 802b690:	9407      	str	r4, [sp, #28]
 802b692:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
 802b696:	930a      	str	r3, [sp, #40]	; 0x28
 802b698:	e4b4      	b.n	802b004 <_dtoa_r+0x454>
 802b69a:	f001 f9b9 	bl	802ca10 <__multadd>
 802b69e:	4627      	mov	r7, r4
 802b6a0:	4605      	mov	r5, r0
 802b6a2:	4680      	mov	r8, r0
 802b6a4:	e612      	b.n	802b2cc <_dtoa_r+0x71c>
 802b6a6:	4648      	mov	r0, r9
 802b6a8:	f001 f9a2 	bl	802c9f0 <_Bfree>
 802b6ac:	2301      	movs	r3, #1
 802b6ae:	e637      	b.n	802b320 <_dtoa_r+0x770>
 802b6b0:	9b02      	ldr	r3, [sp, #8]
 802b6b2:	2b02      	cmp	r3, #2
 802b6b4:	f77f adf1 	ble.w	802b29a <_dtoa_r+0x6ea>
 802b6b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b6ba:	2b00      	cmp	r3, #0
 802b6bc:	f000 80d0 	beq.w	802b860 <_dtoa_r+0xcb0>
 802b6c0:	9b07      	ldr	r3, [sp, #28]
 802b6c2:	43db      	mvns	r3, r3
 802b6c4:	9306      	str	r3, [sp, #24]
 802b6c6:	465c      	mov	r4, fp
 802b6c8:	e78b      	b.n	802b5e2 <_dtoa_r+0xa32>
 802b6ca:	9a06      	ldr	r2, [sp, #24]
 802b6cc:	2331      	movs	r3, #49	; 0x31
 802b6ce:	3201      	adds	r2, #1
 802b6d0:	9206      	str	r2, [sp, #24]
 802b6d2:	f88b 3000 	strb.w	r3, [fp]
 802b6d6:	e6b3      	b.n	802b440 <_dtoa_r+0x890>
 802b6d8:	2401      	movs	r4, #1
 802b6da:	9409      	str	r4, [sp, #36]	; 0x24
 802b6dc:	9407      	str	r4, [sp, #28]
 802b6de:	f7ff bb89 	b.w	802adf4 <_dtoa_r+0x244>
 802b6e2:	4630      	mov	r0, r6
 802b6e4:	f7e0 fe7e 	bl	800c3e4 <__aeabi_i2d>
 802b6e8:	e9dd 2300 	ldrd	r2, r3, [sp]
 802b6ec:	f7e0 fee8 	bl	800c4c0 <__aeabi_dmul>
 802b6f0:	2200      	movs	r2, #0
 802b6f2:	4b69      	ldr	r3, [pc, #420]	; (802b898 <_dtoa_r+0xce8>)
 802b6f4:	f7e0 fd2a 	bl	800c14c <__adddf3>
 802b6f8:	4606      	mov	r6, r0
 802b6fa:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 802b6fe:	2200      	movs	r2, #0
 802b700:	4b62      	ldr	r3, [pc, #392]	; (802b88c <_dtoa_r+0xcdc>)
 802b702:	e9dd 0100 	ldrd	r0, r1, [sp]
 802b706:	f7e0 fd1f 	bl	800c148 <__aeabi_dsub>
 802b70a:	4632      	mov	r2, r6
 802b70c:	463b      	mov	r3, r7
 802b70e:	4604      	mov	r4, r0
 802b710:	460d      	mov	r5, r1
 802b712:	f7e1 f96b 	bl	800c9ec <__aeabi_dcmpgt>
 802b716:	2800      	cmp	r0, #0
 802b718:	d150      	bne.n	802b7bc <_dtoa_r+0xc0c>
 802b71a:	4632      	mov	r2, r6
 802b71c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 802b720:	4620      	mov	r0, r4
 802b722:	4629      	mov	r1, r5
 802b724:	f7e1 f944 	bl	800c9b0 <__aeabi_dcmplt>
 802b728:	2800      	cmp	r0, #0
 802b72a:	f43f ac67 	beq.w	802affc <_dtoa_r+0x44c>
 802b72e:	2600      	movs	r6, #0
 802b730:	4635      	mov	r5, r6
 802b732:	e7c5      	b.n	802b6c0 <_dtoa_r+0xb10>
 802b734:	2301      	movs	r3, #1
 802b736:	930a      	str	r3, [sp, #40]	; 0x28
 802b738:	e6c8      	b.n	802b4cc <_dtoa_r+0x91c>
 802b73a:	4651      	mov	r1, sl
 802b73c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802b73e:	4648      	mov	r0, r9
 802b740:	f001 fafe 	bl	802cd40 <__pow5mult>
 802b744:	4682      	mov	sl, r0
 802b746:	e570      	b.n	802b22a <_dtoa_r+0x67a>
 802b748:	f8dd a000 	ldr.w	sl, [sp]
 802b74c:	f8dd 901c 	ldr.w	r9, [sp, #28]
 802b750:	e686      	b.n	802b460 <_dtoa_r+0x8b0>
 802b752:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802b754:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802b756:	1afb      	subs	r3, r7, r3
 802b758:	441a      	add	r2, r3
 802b75a:	e9cd 720b 	strd	r7, r2, [sp, #44]	; 0x2c
 802b75e:	2700      	movs	r7, #0
 802b760:	e510      	b.n	802b184 <_dtoa_r+0x5d4>
 802b762:	2b00      	cmp	r3, #0
 802b764:	9402      	str	r4, [sp, #8]
 802b766:	465e      	mov	r6, fp
 802b768:	f107 0401 	add.w	r4, r7, #1
 802b76c:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 802b770:	f300 80bc 	bgt.w	802b8ec <_dtoa_r+0xd3c>
 802b774:	f89d 3000 	ldrb.w	r3, [sp]
 802b778:	9502      	str	r5, [sp, #8]
 802b77a:	703b      	strb	r3, [r7, #0]
 802b77c:	4645      	mov	r5, r8
 802b77e:	e65f      	b.n	802b440 <_dtoa_r+0x890>
 802b780:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 802b784:	2602      	movs	r6, #2
 802b786:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
 802b78a:	f7ff bb64 	b.w	802ae56 <_dtoa_r+0x2a6>
 802b78e:	9b00      	ldr	r3, [sp, #0]
 802b790:	2b39      	cmp	r3, #57	; 0x39
 802b792:	465e      	mov	r6, fp
 802b794:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 802b798:	f000 80ba 	beq.w	802b910 <_dtoa_r+0xd60>
 802b79c:	9b00      	ldr	r3, [sp, #0]
 802b79e:	9502      	str	r5, [sp, #8]
 802b7a0:	3301      	adds	r3, #1
 802b7a2:	703b      	strb	r3, [r7, #0]
 802b7a4:	4645      	mov	r5, r8
 802b7a6:	e64b      	b.n	802b440 <_dtoa_r+0x890>
 802b7a8:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 802b7ac:	1a9c      	subs	r4, r3, r2
 802b7ae:	e4f2      	b.n	802b196 <_dtoa_r+0x5e6>
 802b7b0:	465e      	mov	r6, fp
 802b7b2:	9502      	str	r5, [sp, #8]
 802b7b4:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 802b7b8:	4645      	mov	r5, r8
 802b7ba:	e618      	b.n	802b3ee <_dtoa_r+0x83e>
 802b7bc:	2600      	movs	r6, #0
 802b7be:	4635      	mov	r5, r6
 802b7c0:	e707      	b.n	802b5d2 <_dtoa_r+0xa22>
 802b7c2:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 802b7c6:	e9dd 0100 	ldrd	r0, r1, [sp]
 802b7ca:	f7e0 fe79 	bl	800c4c0 <__aeabi_dmul>
 802b7ce:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802b7d0:	f88b 5000 	strb.w	r5, [fp]
 802b7d4:	2b01      	cmp	r3, #1
 802b7d6:	e9cd 0100 	strd	r0, r1, [sp]
 802b7da:	d020      	beq.n	802b81e <_dtoa_r+0xc6e>
 802b7dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802b7de:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
 802b7e2:	445b      	add	r3, fp
 802b7e4:	4698      	mov	r8, r3
 802b7e6:	2200      	movs	r2, #0
 802b7e8:	4b2c      	ldr	r3, [pc, #176]	; (802b89c <_dtoa_r+0xcec>)
 802b7ea:	4630      	mov	r0, r6
 802b7ec:	4639      	mov	r1, r7
 802b7ee:	f7e0 fe67 	bl	800c4c0 <__aeabi_dmul>
 802b7f2:	460f      	mov	r7, r1
 802b7f4:	4606      	mov	r6, r0
 802b7f6:	f7e1 f91b 	bl	800ca30 <__aeabi_d2iz>
 802b7fa:	4605      	mov	r5, r0
 802b7fc:	f7e0 fdf2 	bl	800c3e4 <__aeabi_i2d>
 802b800:	3530      	adds	r5, #48	; 0x30
 802b802:	4602      	mov	r2, r0
 802b804:	460b      	mov	r3, r1
 802b806:	4630      	mov	r0, r6
 802b808:	4639      	mov	r1, r7
 802b80a:	f7e0 fc9d 	bl	800c148 <__aeabi_dsub>
 802b80e:	f804 5b01 	strb.w	r5, [r4], #1
 802b812:	4544      	cmp	r4, r8
 802b814:	4606      	mov	r6, r0
 802b816:	460f      	mov	r7, r1
 802b818:	d1e5      	bne.n	802b7e6 <_dtoa_r+0xc36>
 802b81a:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
 802b81e:	4b20      	ldr	r3, [pc, #128]	; (802b8a0 <_dtoa_r+0xcf0>)
 802b820:	2200      	movs	r2, #0
 802b822:	e9dd 0100 	ldrd	r0, r1, [sp]
 802b826:	f7e0 fc91 	bl	800c14c <__adddf3>
 802b82a:	4632      	mov	r2, r6
 802b82c:	463b      	mov	r3, r7
 802b82e:	f7e1 f8bf 	bl	800c9b0 <__aeabi_dcmplt>
 802b832:	2800      	cmp	r0, #0
 802b834:	d071      	beq.n	802b91a <_dtoa_r+0xd6a>
 802b836:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b838:	9306      	str	r3, [sp, #24]
 802b83a:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 802b83e:	e48c      	b.n	802b15a <_dtoa_r+0x5aa>
 802b840:	2330      	movs	r3, #48	; 0x30
 802b842:	f88b 3000 	strb.w	r3, [fp]
 802b846:	9b06      	ldr	r3, [sp, #24]
 802b848:	f814 5c01 	ldrb.w	r5, [r4, #-1]
 802b84c:	3301      	adds	r3, #1
 802b84e:	9306      	str	r3, [sp, #24]
 802b850:	465b      	mov	r3, fp
 802b852:	e486      	b.n	802b162 <_dtoa_r+0x5b2>
 802b854:	9b18      	ldr	r3, [sp, #96]	; 0x60
 802b856:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 802b85a:	e69f      	b.n	802b59c <_dtoa_r+0x9ec>
 802b85c:	2300      	movs	r3, #0
 802b85e:	e675      	b.n	802b54c <_dtoa_r+0x99c>
 802b860:	4631      	mov	r1, r6
 802b862:	2205      	movs	r2, #5
 802b864:	4648      	mov	r0, r9
 802b866:	f001 f8d3 	bl	802ca10 <__multadd>
 802b86a:	4601      	mov	r1, r0
 802b86c:	4606      	mov	r6, r0
 802b86e:	4650      	mov	r0, sl
 802b870:	f001 fb0e 	bl	802ce90 <__mcmp>
 802b874:	2800      	cmp	r0, #0
 802b876:	f73f aeac 	bgt.w	802b5d2 <_dtoa_r+0xa22>
 802b87a:	e721      	b.n	802b6c0 <_dtoa_r+0xb10>
 802b87c:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 802b880:	2602      	movs	r6, #2
 802b882:	ed8d 7b00 	vstr	d7, [sp]
 802b886:	f7ff baff 	b.w	802ae88 <_dtoa_r+0x2d8>
 802b88a:	bf00      	nop
 802b88c:	40140000 	.word	0x40140000
 802b890:	08030240 	.word	0x08030240
 802b894:	08030210 	.word	0x08030210
 802b898:	401c0000 	.word	0x401c0000
 802b89c:	40240000 	.word	0x40240000
 802b8a0:	3fe00000 	.word	0x3fe00000
 802b8a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b8a6:	2b00      	cmp	r3, #0
 802b8a8:	f43f af1b 	beq.w	802b6e2 <_dtoa_r+0xb32>
 802b8ac:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 802b8ae:	2c00      	cmp	r4, #0
 802b8b0:	f77f aba4 	ble.w	802affc <_dtoa_r+0x44c>
 802b8b4:	2200      	movs	r2, #0
 802b8b6:	4b45      	ldr	r3, [pc, #276]	; (802b9cc <_dtoa_r+0xe1c>)
 802b8b8:	e9dd 0100 	ldrd	r0, r1, [sp]
 802b8bc:	f7e0 fe00 	bl	800c4c0 <__aeabi_dmul>
 802b8c0:	e9cd 0100 	strd	r0, r1, [sp]
 802b8c4:	1c70      	adds	r0, r6, #1
 802b8c6:	f7e0 fd8d 	bl	800c3e4 <__aeabi_i2d>
 802b8ca:	e9dd 2300 	ldrd	r2, r3, [sp]
 802b8ce:	f7e0 fdf7 	bl	800c4c0 <__aeabi_dmul>
 802b8d2:	4b3f      	ldr	r3, [pc, #252]	; (802b9d0 <_dtoa_r+0xe20>)
 802b8d4:	2200      	movs	r2, #0
 802b8d6:	f7e0 fc39 	bl	800c14c <__adddf3>
 802b8da:	9b06      	ldr	r3, [sp, #24]
 802b8dc:	9412      	str	r4, [sp, #72]	; 0x48
 802b8de:	3b01      	subs	r3, #1
 802b8e0:	4606      	mov	r6, r0
 802b8e2:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 802b8e6:	9316      	str	r3, [sp, #88]	; 0x58
 802b8e8:	f7ff baef 	b.w	802aeca <_dtoa_r+0x31a>
 802b8ec:	4651      	mov	r1, sl
 802b8ee:	2201      	movs	r2, #1
 802b8f0:	4648      	mov	r0, r9
 802b8f2:	f001 fa75 	bl	802cde0 <__lshift>
 802b8f6:	4631      	mov	r1, r6
 802b8f8:	4682      	mov	sl, r0
 802b8fa:	f001 fac9 	bl	802ce90 <__mcmp>
 802b8fe:	2800      	cmp	r0, #0
 802b900:	dd3b      	ble.n	802b97a <_dtoa_r+0xdca>
 802b902:	9b00      	ldr	r3, [sp, #0]
 802b904:	2b39      	cmp	r3, #57	; 0x39
 802b906:	d003      	beq.n	802b910 <_dtoa_r+0xd60>
 802b908:	9b02      	ldr	r3, [sp, #8]
 802b90a:	3331      	adds	r3, #49	; 0x31
 802b90c:	9300      	str	r3, [sp, #0]
 802b90e:	e731      	b.n	802b774 <_dtoa_r+0xbc4>
 802b910:	2239      	movs	r2, #57	; 0x39
 802b912:	9502      	str	r5, [sp, #8]
 802b914:	703a      	strb	r2, [r7, #0]
 802b916:	4645      	mov	r5, r8
 802b918:	e58c      	b.n	802b434 <_dtoa_r+0x884>
 802b91a:	e9dd 2300 	ldrd	r2, r3, [sp]
 802b91e:	2000      	movs	r0, #0
 802b920:	492c      	ldr	r1, [pc, #176]	; (802b9d4 <_dtoa_r+0xe24>)
 802b922:	f7e0 fc11 	bl	800c148 <__aeabi_dsub>
 802b926:	4632      	mov	r2, r6
 802b928:	463b      	mov	r3, r7
 802b92a:	f7e1 f85f 	bl	800c9ec <__aeabi_dcmpgt>
 802b92e:	b910      	cbnz	r0, 802b936 <_dtoa_r+0xd86>
 802b930:	f7ff bb64 	b.w	802affc <_dtoa_r+0x44c>
 802b934:	4614      	mov	r4, r2
 802b936:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 802b93a:	2b30      	cmp	r3, #48	; 0x30
 802b93c:	f104 32ff 	add.w	r2, r4, #4294967295
 802b940:	d0f8      	beq.n	802b934 <_dtoa_r+0xd84>
 802b942:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b944:	9306      	str	r3, [sp, #24]
 802b946:	e58b      	b.n	802b460 <_dtoa_r+0x8b0>
 802b948:	46d9      	mov	r9, fp
 802b94a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 802b94e:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
 802b952:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b954:	9306      	str	r3, [sp, #24]
 802b956:	e400      	b.n	802b15a <_dtoa_r+0x5aa>
 802b958:	9b00      	ldr	r3, [sp, #0]
 802b95a:	2b39      	cmp	r3, #57	; 0x39
 802b95c:	4621      	mov	r1, r4
 802b95e:	4632      	mov	r2, r6
 802b960:	f107 0401 	add.w	r4, r7, #1
 802b964:	465e      	mov	r6, fp
 802b966:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 802b96a:	d0d1      	beq.n	802b910 <_dtoa_r+0xd60>
 802b96c:	2a00      	cmp	r2, #0
 802b96e:	f77f af01 	ble.w	802b774 <_dtoa_r+0xbc4>
 802b972:	460b      	mov	r3, r1
 802b974:	3331      	adds	r3, #49	; 0x31
 802b976:	9300      	str	r3, [sp, #0]
 802b978:	e6fc      	b.n	802b774 <_dtoa_r+0xbc4>
 802b97a:	f47f aefb 	bne.w	802b774 <_dtoa_r+0xbc4>
 802b97e:	9b00      	ldr	r3, [sp, #0]
 802b980:	07da      	lsls	r2, r3, #31
 802b982:	f57f aef7 	bpl.w	802b774 <_dtoa_r+0xbc4>
 802b986:	e7bc      	b.n	802b902 <_dtoa_r+0xd52>
 802b988:	4629      	mov	r1, r5
 802b98a:	2300      	movs	r3, #0
 802b98c:	220a      	movs	r2, #10
 802b98e:	4648      	mov	r0, r9
 802b990:	f001 f83e 	bl	802ca10 <__multadd>
 802b994:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b996:	2b00      	cmp	r3, #0
 802b998:	4605      	mov	r5, r0
 802b99a:	dd09      	ble.n	802b9b0 <_dtoa_r+0xe00>
 802b99c:	9309      	str	r3, [sp, #36]	; 0x24
 802b99e:	e480      	b.n	802b2a2 <_dtoa_r+0x6f2>
 802b9a0:	9b02      	ldr	r3, [sp, #8]
 802b9a2:	2b02      	cmp	r3, #2
 802b9a4:	dc0e      	bgt.n	802b9c4 <_dtoa_r+0xe14>
 802b9a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b9a8:	e504      	b.n	802b3b4 <_dtoa_r+0x804>
 802b9aa:	2602      	movs	r6, #2
 802b9ac:	f7ff ba6c 	b.w	802ae88 <_dtoa_r+0x2d8>
 802b9b0:	9b02      	ldr	r3, [sp, #8]
 802b9b2:	2b02      	cmp	r3, #2
 802b9b4:	dc06      	bgt.n	802b9c4 <_dtoa_r+0xe14>
 802b9b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b9b8:	e7f0      	b.n	802b99c <_dtoa_r+0xdec>
 802b9ba:	f43f ac55 	beq.w	802b268 <_dtoa_r+0x6b8>
 802b9be:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 802b9c2:	e44c      	b.n	802b25e <_dtoa_r+0x6ae>
 802b9c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b9c6:	9309      	str	r3, [sp, #36]	; 0x24
 802b9c8:	e676      	b.n	802b6b8 <_dtoa_r+0xb08>
 802b9ca:	bf00      	nop
 802b9cc:	40240000 	.word	0x40240000
 802b9d0:	401c0000 	.word	0x401c0000
 802b9d4:	3fe00000 	.word	0x3fe00000
	...

0802b9e0 <_malloc_trim_r>:
 802b9e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b9e2:	4f24      	ldr	r7, [pc, #144]	; (802ba74 <_malloc_trim_r+0x94>)
 802b9e4:	460c      	mov	r4, r1
 802b9e6:	4606      	mov	r6, r0
 802b9e8:	f000 ffca 	bl	802c980 <__malloc_lock>
 802b9ec:	68bb      	ldr	r3, [r7, #8]
 802b9ee:	685d      	ldr	r5, [r3, #4]
 802b9f0:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
 802b9f4:	310f      	adds	r1, #15
 802b9f6:	f025 0503 	bic.w	r5, r5, #3
 802b9fa:	4429      	add	r1, r5
 802b9fc:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 802ba00:	f021 010f 	bic.w	r1, r1, #15
 802ba04:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 802ba08:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 802ba0c:	db07      	blt.n	802ba1e <_malloc_trim_r+0x3e>
 802ba0e:	2100      	movs	r1, #0
 802ba10:	4630      	mov	r0, r6
 802ba12:	f7e5 febd 	bl	8011790 <_sbrk_r>
 802ba16:	68bb      	ldr	r3, [r7, #8]
 802ba18:	442b      	add	r3, r5
 802ba1a:	4298      	cmp	r0, r3
 802ba1c:	d004      	beq.n	802ba28 <_malloc_trim_r+0x48>
 802ba1e:	4630      	mov	r0, r6
 802ba20:	f000 ffb6 	bl	802c990 <__malloc_unlock>
 802ba24:	2000      	movs	r0, #0
 802ba26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802ba28:	4261      	negs	r1, r4
 802ba2a:	4630      	mov	r0, r6
 802ba2c:	f7e5 feb0 	bl	8011790 <_sbrk_r>
 802ba30:	3001      	adds	r0, #1
 802ba32:	d00d      	beq.n	802ba50 <_malloc_trim_r+0x70>
 802ba34:	4b10      	ldr	r3, [pc, #64]	; (802ba78 <_malloc_trim_r+0x98>)
 802ba36:	68ba      	ldr	r2, [r7, #8]
 802ba38:	6819      	ldr	r1, [r3, #0]
 802ba3a:	1b2d      	subs	r5, r5, r4
 802ba3c:	f045 0501 	orr.w	r5, r5, #1
 802ba40:	4630      	mov	r0, r6
 802ba42:	1b09      	subs	r1, r1, r4
 802ba44:	6055      	str	r5, [r2, #4]
 802ba46:	6019      	str	r1, [r3, #0]
 802ba48:	f000 ffa2 	bl	802c990 <__malloc_unlock>
 802ba4c:	2001      	movs	r0, #1
 802ba4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802ba50:	2100      	movs	r1, #0
 802ba52:	4630      	mov	r0, r6
 802ba54:	f7e5 fe9c 	bl	8011790 <_sbrk_r>
 802ba58:	68ba      	ldr	r2, [r7, #8]
 802ba5a:	1a83      	subs	r3, r0, r2
 802ba5c:	2b0f      	cmp	r3, #15
 802ba5e:	ddde      	ble.n	802ba1e <_malloc_trim_r+0x3e>
 802ba60:	4c06      	ldr	r4, [pc, #24]	; (802ba7c <_malloc_trim_r+0x9c>)
 802ba62:	4905      	ldr	r1, [pc, #20]	; (802ba78 <_malloc_trim_r+0x98>)
 802ba64:	6824      	ldr	r4, [r4, #0]
 802ba66:	f043 0301 	orr.w	r3, r3, #1
 802ba6a:	1b00      	subs	r0, r0, r4
 802ba6c:	6053      	str	r3, [r2, #4]
 802ba6e:	6008      	str	r0, [r1, #0]
 802ba70:	e7d5      	b.n	802ba1e <_malloc_trim_r+0x3e>
 802ba72:	bf00      	nop
 802ba74:	20001634 	.word	0x20001634
 802ba78:	20011c90 	.word	0x20011c90
 802ba7c:	20001a3c 	.word	0x20001a3c

0802ba80 <_free_r>:
 802ba80:	2900      	cmp	r1, #0
 802ba82:	d053      	beq.n	802bb2c <_free_r+0xac>
 802ba84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802ba86:	460c      	mov	r4, r1
 802ba88:	4606      	mov	r6, r0
 802ba8a:	f000 ff79 	bl	802c980 <__malloc_lock>
 802ba8e:	f854 cc04 	ldr.w	ip, [r4, #-4]
 802ba92:	4f71      	ldr	r7, [pc, #452]	; (802bc58 <_free_r+0x1d8>)
 802ba94:	f02c 0101 	bic.w	r1, ip, #1
 802ba98:	f1a4 0508 	sub.w	r5, r4, #8
 802ba9c:	186b      	adds	r3, r5, r1
 802ba9e:	68b8      	ldr	r0, [r7, #8]
 802baa0:	685a      	ldr	r2, [r3, #4]
 802baa2:	4298      	cmp	r0, r3
 802baa4:	f022 0203 	bic.w	r2, r2, #3
 802baa8:	d053      	beq.n	802bb52 <_free_r+0xd2>
 802baaa:	f01c 0f01 	tst.w	ip, #1
 802baae:	605a      	str	r2, [r3, #4]
 802bab0:	eb03 0002 	add.w	r0, r3, r2
 802bab4:	d13b      	bne.n	802bb2e <_free_r+0xae>
 802bab6:	f854 cc08 	ldr.w	ip, [r4, #-8]
 802baba:	6840      	ldr	r0, [r0, #4]
 802babc:	eba5 050c 	sub.w	r5, r5, ip
 802bac0:	f107 0e08 	add.w	lr, r7, #8
 802bac4:	68ac      	ldr	r4, [r5, #8]
 802bac6:	4574      	cmp	r4, lr
 802bac8:	4461      	add	r1, ip
 802baca:	f000 0001 	and.w	r0, r0, #1
 802bace:	d075      	beq.n	802bbbc <_free_r+0x13c>
 802bad0:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 802bad4:	f8c4 c00c 	str.w	ip, [r4, #12]
 802bad8:	f8cc 4008 	str.w	r4, [ip, #8]
 802badc:	b360      	cbz	r0, 802bb38 <_free_r+0xb8>
 802bade:	f041 0301 	orr.w	r3, r1, #1
 802bae2:	606b      	str	r3, [r5, #4]
 802bae4:	5069      	str	r1, [r5, r1]
 802bae6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 802baea:	d350      	bcc.n	802bb8e <_free_r+0x10e>
 802baec:	0a4b      	lsrs	r3, r1, #9
 802baee:	2b04      	cmp	r3, #4
 802baf0:	d870      	bhi.n	802bbd4 <_free_r+0x154>
 802baf2:	098b      	lsrs	r3, r1, #6
 802baf4:	f103 0439 	add.w	r4, r3, #57	; 0x39
 802baf8:	00e4      	lsls	r4, r4, #3
 802bafa:	f103 0238 	add.w	r2, r3, #56	; 0x38
 802bafe:	1938      	adds	r0, r7, r4
 802bb00:	593b      	ldr	r3, [r7, r4]
 802bb02:	3808      	subs	r0, #8
 802bb04:	4298      	cmp	r0, r3
 802bb06:	d078      	beq.n	802bbfa <_free_r+0x17a>
 802bb08:	685a      	ldr	r2, [r3, #4]
 802bb0a:	f022 0203 	bic.w	r2, r2, #3
 802bb0e:	428a      	cmp	r2, r1
 802bb10:	d971      	bls.n	802bbf6 <_free_r+0x176>
 802bb12:	689b      	ldr	r3, [r3, #8]
 802bb14:	4298      	cmp	r0, r3
 802bb16:	d1f7      	bne.n	802bb08 <_free_r+0x88>
 802bb18:	68c3      	ldr	r3, [r0, #12]
 802bb1a:	e9c5 0302 	strd	r0, r3, [r5, #8]
 802bb1e:	609d      	str	r5, [r3, #8]
 802bb20:	60c5      	str	r5, [r0, #12]
 802bb22:	4630      	mov	r0, r6
 802bb24:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802bb28:	f000 bf32 	b.w	802c990 <__malloc_unlock>
 802bb2c:	4770      	bx	lr
 802bb2e:	6840      	ldr	r0, [r0, #4]
 802bb30:	f000 0001 	and.w	r0, r0, #1
 802bb34:	2800      	cmp	r0, #0
 802bb36:	d1d2      	bne.n	802bade <_free_r+0x5e>
 802bb38:	6898      	ldr	r0, [r3, #8]
 802bb3a:	4c48      	ldr	r4, [pc, #288]	; (802bc5c <_free_r+0x1dc>)
 802bb3c:	4411      	add	r1, r2
 802bb3e:	42a0      	cmp	r0, r4
 802bb40:	f041 0201 	orr.w	r2, r1, #1
 802bb44:	d062      	beq.n	802bc0c <_free_r+0x18c>
 802bb46:	68db      	ldr	r3, [r3, #12]
 802bb48:	60c3      	str	r3, [r0, #12]
 802bb4a:	6098      	str	r0, [r3, #8]
 802bb4c:	606a      	str	r2, [r5, #4]
 802bb4e:	5069      	str	r1, [r5, r1]
 802bb50:	e7c9      	b.n	802bae6 <_free_r+0x66>
 802bb52:	f01c 0f01 	tst.w	ip, #1
 802bb56:	440a      	add	r2, r1
 802bb58:	d107      	bne.n	802bb6a <_free_r+0xea>
 802bb5a:	f854 3c08 	ldr.w	r3, [r4, #-8]
 802bb5e:	1aed      	subs	r5, r5, r3
 802bb60:	441a      	add	r2, r3
 802bb62:	e9d5 1302 	ldrd	r1, r3, [r5, #8]
 802bb66:	60cb      	str	r3, [r1, #12]
 802bb68:	6099      	str	r1, [r3, #8]
 802bb6a:	4b3d      	ldr	r3, [pc, #244]	; (802bc60 <_free_r+0x1e0>)
 802bb6c:	681b      	ldr	r3, [r3, #0]
 802bb6e:	f042 0101 	orr.w	r1, r2, #1
 802bb72:	4293      	cmp	r3, r2
 802bb74:	6069      	str	r1, [r5, #4]
 802bb76:	60bd      	str	r5, [r7, #8]
 802bb78:	d804      	bhi.n	802bb84 <_free_r+0x104>
 802bb7a:	4b3a      	ldr	r3, [pc, #232]	; (802bc64 <_free_r+0x1e4>)
 802bb7c:	4630      	mov	r0, r6
 802bb7e:	6819      	ldr	r1, [r3, #0]
 802bb80:	f7ff ff2e 	bl	802b9e0 <_malloc_trim_r>
 802bb84:	4630      	mov	r0, r6
 802bb86:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802bb8a:	f000 bf01 	b.w	802c990 <__malloc_unlock>
 802bb8e:	08c9      	lsrs	r1, r1, #3
 802bb90:	6878      	ldr	r0, [r7, #4]
 802bb92:	1c4a      	adds	r2, r1, #1
 802bb94:	2301      	movs	r3, #1
 802bb96:	1089      	asrs	r1, r1, #2
 802bb98:	408b      	lsls	r3, r1
 802bb9a:	4303      	orrs	r3, r0
 802bb9c:	eb07 01c2 	add.w	r1, r7, r2, lsl #3
 802bba0:	f857 0032 	ldr.w	r0, [r7, r2, lsl #3]
 802bba4:	607b      	str	r3, [r7, #4]
 802bba6:	3908      	subs	r1, #8
 802bba8:	e9c5 0102 	strd	r0, r1, [r5, #8]
 802bbac:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
 802bbb0:	60c5      	str	r5, [r0, #12]
 802bbb2:	4630      	mov	r0, r6
 802bbb4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802bbb8:	f000 beea 	b.w	802c990 <__malloc_unlock>
 802bbbc:	2800      	cmp	r0, #0
 802bbbe:	d145      	bne.n	802bc4c <_free_r+0x1cc>
 802bbc0:	440a      	add	r2, r1
 802bbc2:	e9d3 1302 	ldrd	r1, r3, [r3, #8]
 802bbc6:	f042 0001 	orr.w	r0, r2, #1
 802bbca:	60cb      	str	r3, [r1, #12]
 802bbcc:	6099      	str	r1, [r3, #8]
 802bbce:	6068      	str	r0, [r5, #4]
 802bbd0:	50aa      	str	r2, [r5, r2]
 802bbd2:	e7d7      	b.n	802bb84 <_free_r+0x104>
 802bbd4:	2b14      	cmp	r3, #20
 802bbd6:	d908      	bls.n	802bbea <_free_r+0x16a>
 802bbd8:	2b54      	cmp	r3, #84	; 0x54
 802bbda:	d81e      	bhi.n	802bc1a <_free_r+0x19a>
 802bbdc:	0b0b      	lsrs	r3, r1, #12
 802bbde:	f103 046f 	add.w	r4, r3, #111	; 0x6f
 802bbe2:	00e4      	lsls	r4, r4, #3
 802bbe4:	f103 026e 	add.w	r2, r3, #110	; 0x6e
 802bbe8:	e789      	b.n	802bafe <_free_r+0x7e>
 802bbea:	f103 045c 	add.w	r4, r3, #92	; 0x5c
 802bbee:	00e4      	lsls	r4, r4, #3
 802bbf0:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 802bbf4:	e783      	b.n	802bafe <_free_r+0x7e>
 802bbf6:	4618      	mov	r0, r3
 802bbf8:	e78e      	b.n	802bb18 <_free_r+0x98>
 802bbfa:	1093      	asrs	r3, r2, #2
 802bbfc:	6879      	ldr	r1, [r7, #4]
 802bbfe:	2201      	movs	r2, #1
 802bc00:	fa02 f303 	lsl.w	r3, r2, r3
 802bc04:	430b      	orrs	r3, r1
 802bc06:	607b      	str	r3, [r7, #4]
 802bc08:	4603      	mov	r3, r0
 802bc0a:	e786      	b.n	802bb1a <_free_r+0x9a>
 802bc0c:	e9c7 5504 	strd	r5, r5, [r7, #16]
 802bc10:	e9c5 0002 	strd	r0, r0, [r5, #8]
 802bc14:	606a      	str	r2, [r5, #4]
 802bc16:	5069      	str	r1, [r5, r1]
 802bc18:	e7b4      	b.n	802bb84 <_free_r+0x104>
 802bc1a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 802bc1e:	d806      	bhi.n	802bc2e <_free_r+0x1ae>
 802bc20:	0bcb      	lsrs	r3, r1, #15
 802bc22:	f103 0478 	add.w	r4, r3, #120	; 0x78
 802bc26:	00e4      	lsls	r4, r4, #3
 802bc28:	f103 0277 	add.w	r2, r3, #119	; 0x77
 802bc2c:	e767      	b.n	802bafe <_free_r+0x7e>
 802bc2e:	f240 5254 	movw	r2, #1364	; 0x554
 802bc32:	4293      	cmp	r3, r2
 802bc34:	d806      	bhi.n	802bc44 <_free_r+0x1c4>
 802bc36:	0c8b      	lsrs	r3, r1, #18
 802bc38:	f103 047d 	add.w	r4, r3, #125	; 0x7d
 802bc3c:	00e4      	lsls	r4, r4, #3
 802bc3e:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 802bc42:	e75c      	b.n	802bafe <_free_r+0x7e>
 802bc44:	f44f 747e 	mov.w	r4, #1016	; 0x3f8
 802bc48:	227e      	movs	r2, #126	; 0x7e
 802bc4a:	e758      	b.n	802bafe <_free_r+0x7e>
 802bc4c:	f041 0201 	orr.w	r2, r1, #1
 802bc50:	606a      	str	r2, [r5, #4]
 802bc52:	6019      	str	r1, [r3, #0]
 802bc54:	e796      	b.n	802bb84 <_free_r+0x104>
 802bc56:	bf00      	nop
 802bc58:	20001634 	.word	0x20001634
 802bc5c:	2000163c 	.word	0x2000163c
 802bc60:	20001a40 	.word	0x20001a40
 802bc64:	20011cc0 	.word	0x20011cc0
	...

0802bc70 <rshift>:
 802bc70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802bc74:	6904      	ldr	r4, [r0, #16]
 802bc76:	114b      	asrs	r3, r1, #5
 802bc78:	429c      	cmp	r4, r3
 802bc7a:	dd2e      	ble.n	802bcda <rshift+0x6a>
 802bc7c:	f100 0c14 	add.w	ip, r0, #20
 802bc80:	f011 011f 	ands.w	r1, r1, #31
 802bc84:	4667      	mov	r7, ip
 802bc86:	eb0c 0484 	add.w	r4, ip, r4, lsl #2
 802bc8a:	eb0c 0583 	add.w	r5, ip, r3, lsl #2
 802bc8e:	d02a      	beq.n	802bce6 <rshift+0x76>
 802bc90:	f85c 2023 	ldr.w	r2, [ip, r3, lsl #2]
 802bc94:	1d2e      	adds	r6, r5, #4
 802bc96:	42b4      	cmp	r4, r6
 802bc98:	fa22 f201 	lsr.w	r2, r2, r1
 802bc9c:	f1c1 0820 	rsb	r8, r1, #32
 802bca0:	d913      	bls.n	802bcca <rshift+0x5a>
 802bca2:	f100 0e10 	add.w	lr, r0, #16
 802bca6:	6833      	ldr	r3, [r6, #0]
 802bca8:	fa03 f308 	lsl.w	r3, r3, r8
 802bcac:	4313      	orrs	r3, r2
 802bcae:	f84e 3f04 	str.w	r3, [lr, #4]!
 802bcb2:	f856 2b04 	ldr.w	r2, [r6], #4
 802bcb6:	42a6      	cmp	r6, r4
 802bcb8:	fa22 f201 	lsr.w	r2, r2, r1
 802bcbc:	d3f3      	bcc.n	802bca6 <rshift+0x36>
 802bcbe:	1b63      	subs	r3, r4, r5
 802bcc0:	3b05      	subs	r3, #5
 802bcc2:	f023 0303 	bic.w	r3, r3, #3
 802bcc6:	3304      	adds	r3, #4
 802bcc8:	449c      	add	ip, r3
 802bcca:	f8cc 2000 	str.w	r2, [ip]
 802bcce:	b312      	cbz	r2, 802bd16 <rshift+0xa6>
 802bcd0:	f10c 0304 	add.w	r3, ip, #4
 802bcd4:	1bda      	subs	r2, r3, r7
 802bcd6:	1092      	asrs	r2, r2, #2
 802bcd8:	e018      	b.n	802bd0c <rshift+0x9c>
 802bcda:	2300      	movs	r3, #0
 802bcdc:	6103      	str	r3, [r0, #16]
 802bcde:	2300      	movs	r3, #0
 802bce0:	6143      	str	r3, [r0, #20]
 802bce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802bce6:	42ac      	cmp	r4, r5
 802bce8:	d9f7      	bls.n	802bcda <rshift+0x6a>
 802bcea:	f100 0210 	add.w	r2, r0, #16
 802bcee:	462b      	mov	r3, r5
 802bcf0:	f853 1b04 	ldr.w	r1, [r3], #4
 802bcf4:	f842 1f04 	str.w	r1, [r2, #4]!
 802bcf8:	429c      	cmp	r4, r3
 802bcfa:	d8f9      	bhi.n	802bcf0 <rshift+0x80>
 802bcfc:	43ea      	mvns	r2, r5
 802bcfe:	4422      	add	r2, r4
 802bd00:	f022 0203 	bic.w	r2, r2, #3
 802bd04:	3204      	adds	r2, #4
 802bd06:	eb0c 0302 	add.w	r3, ip, r2
 802bd0a:	1092      	asrs	r2, r2, #2
 802bd0c:	42bb      	cmp	r3, r7
 802bd0e:	6102      	str	r2, [r0, #16]
 802bd10:	d0e5      	beq.n	802bcde <rshift+0x6e>
 802bd12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802bd16:	4663      	mov	r3, ip
 802bd18:	1bda      	subs	r2, r3, r7
 802bd1a:	1092      	asrs	r2, r2, #2
 802bd1c:	e7f6      	b.n	802bd0c <rshift+0x9c>
 802bd1e:	bf00      	nop

0802bd20 <__gethex>:
 802bd20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802bd24:	b08d      	sub	sp, #52	; 0x34
 802bd26:	4689      	mov	r9, r1
 802bd28:	9007      	str	r0, [sp, #28]
 802bd2a:	9818      	ldr	r0, [sp, #96]	; 0x60
 802bd2c:	9204      	str	r2, [sp, #16]
 802bd2e:	930a      	str	r3, [sp, #40]	; 0x28
 802bd30:	f7fb ffae 	bl	8027c90 <__localeconv_l>
 802bd34:	6803      	ldr	r3, [r0, #0]
 802bd36:	9305      	str	r3, [sp, #20]
 802bd38:	4618      	mov	r0, r3
 802bd3a:	461c      	mov	r4, r3
 802bd3c:	f7e1 f900 	bl	800cf40 <strlen>
 802bd40:	f8d9 3000 	ldr.w	r3, [r9]
 802bd44:	9003      	str	r0, [sp, #12]
 802bd46:	1821      	adds	r1, r4, r0
 802bd48:	789a      	ldrb	r2, [r3, #2]
 802bd4a:	f811 1c01 	ldrb.w	r1, [r1, #-1]
 802bd4e:	9101      	str	r1, [sp, #4]
 802bd50:	2a30      	cmp	r2, #48	; 0x30
 802bd52:	f040 8187 	bne.w	802c064 <__gethex+0x344>
 802bd56:	3303      	adds	r3, #3
 802bd58:	f04f 0800 	mov.w	r8, #0
 802bd5c:	461c      	mov	r4, r3
 802bd5e:	f813 2b01 	ldrb.w	r2, [r3], #1
 802bd62:	2a30      	cmp	r2, #48	; 0x30
 802bd64:	f108 0801 	add.w	r8, r8, #1
 802bd68:	d0f8      	beq.n	802bd5c <__gethex+0x3c>
 802bd6a:	4ebd      	ldr	r6, [pc, #756]	; (802c060 <__gethex+0x340>)
 802bd6c:	5cb3      	ldrb	r3, [r6, r2]
 802bd6e:	2b00      	cmp	r3, #0
 802bd70:	f000 80f0 	beq.w	802bf54 <__gethex+0x234>
 802bd74:	7823      	ldrb	r3, [r4, #0]
 802bd76:	f04f 0a00 	mov.w	sl, #0
 802bd7a:	5cf3      	ldrb	r3, [r6, r3]
 802bd7c:	4655      	mov	r5, sl
 802bd7e:	4627      	mov	r7, r4
 802bd80:	b123      	cbz	r3, 802bd8c <__gethex+0x6c>
 802bd82:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 802bd86:	5cf3      	ldrb	r3, [r6, r3]
 802bd88:	2b00      	cmp	r3, #0
 802bd8a:	d1fa      	bne.n	802bd82 <__gethex+0x62>
 802bd8c:	9a03      	ldr	r2, [sp, #12]
 802bd8e:	9905      	ldr	r1, [sp, #20]
 802bd90:	4638      	mov	r0, r7
 802bd92:	f001 fc45 	bl	802d620 <strncmp>
 802bd96:	2800      	cmp	r0, #0
 802bd98:	f000 8090 	beq.w	802bebc <__gethex+0x19c>
 802bd9c:	783b      	ldrb	r3, [r7, #0]
 802bd9e:	2d00      	cmp	r5, #0
 802bda0:	f040 8090 	bne.w	802bec4 <__gethex+0x1a4>
 802bda4:	2b50      	cmp	r3, #80	; 0x50
 802bda6:	9502      	str	r5, [sp, #8]
 802bda8:	f000 8092 	beq.w	802bed0 <__gethex+0x1b0>
 802bdac:	2b70      	cmp	r3, #112	; 0x70
 802bdae:	f000 808f 	beq.w	802bed0 <__gethex+0x1b0>
 802bdb2:	463d      	mov	r5, r7
 802bdb4:	f8c9 7000 	str.w	r7, [r9]
 802bdb8:	f1ba 0f00 	cmp.w	sl, #0
 802bdbc:	f040 80b7 	bne.w	802bf2e <__gethex+0x20e>
 802bdc0:	1b2b      	subs	r3, r5, r4
 802bdc2:	3b01      	subs	r3, #1
 802bdc4:	2b07      	cmp	r3, #7
 802bdc6:	4651      	mov	r1, sl
 802bdc8:	dd04      	ble.n	802bdd4 <__gethex+0xb4>
 802bdca:	105b      	asrs	r3, r3, #1
 802bdcc:	2b07      	cmp	r3, #7
 802bdce:	f101 0101 	add.w	r1, r1, #1
 802bdd2:	dcfa      	bgt.n	802bdca <__gethex+0xaa>
 802bdd4:	9807      	ldr	r0, [sp, #28]
 802bdd6:	f000 fde3 	bl	802c9a0 <_Balloc>
 802bdda:	4603      	mov	r3, r0
 802bddc:	3314      	adds	r3, #20
 802bdde:	42ac      	cmp	r4, r5
 802bde0:	9006      	str	r0, [sp, #24]
 802bde2:	9308      	str	r3, [sp, #32]
 802bde4:	f080 81af 	bcs.w	802c146 <__gethex+0x426>
 802bde8:	469b      	mov	fp, r3
 802bdea:	9b03      	ldr	r3, [sp, #12]
 802bdec:	f04f 0800 	mov.w	r8, #0
 802bdf0:	f1c3 0301 	rsb	r3, r3, #1
 802bdf4:	46c1      	mov	r9, r8
 802bdf6:	9309      	str	r3, [sp, #36]	; 0x24
 802bdf8:	e011      	b.n	802be1e <__gethex+0xfe>
 802bdfa:	f1b8 0f20 	cmp.w	r8, #32
 802bdfe:	f000 809f 	beq.w	802bf40 <__gethex+0x220>
 802be02:	4642      	mov	r2, r8
 802be04:	f108 0804 	add.w	r8, r8, #4
 802be08:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 802be0c:	5cf3      	ldrb	r3, [r6, r3]
 802be0e:	4655      	mov	r5, sl
 802be10:	f003 030f 	and.w	r3, r3, #15
 802be14:	4093      	lsls	r3, r2
 802be16:	42a5      	cmp	r5, r4
 802be18:	ea49 0903 	orr.w	r9, r9, r3
 802be1c:	d918      	bls.n	802be50 <__gethex+0x130>
 802be1e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 802be22:	9a01      	ldr	r2, [sp, #4]
 802be24:	4293      	cmp	r3, r2
 802be26:	f105 3aff 	add.w	sl, r5, #4294967295
 802be2a:	f10b 0704 	add.w	r7, fp, #4
 802be2e:	d1e4      	bne.n	802bdfa <__gethex+0xda>
 802be30:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802be32:	4453      	add	r3, sl
 802be34:	42a3      	cmp	r3, r4
 802be36:	d3e0      	bcc.n	802bdfa <__gethex+0xda>
 802be38:	4618      	mov	r0, r3
 802be3a:	9a03      	ldr	r2, [sp, #12]
 802be3c:	9905      	ldr	r1, [sp, #20]
 802be3e:	930b      	str	r3, [sp, #44]	; 0x2c
 802be40:	f001 fbee 	bl	802d620 <strncmp>
 802be44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802be46:	2800      	cmp	r0, #0
 802be48:	d1d7      	bne.n	802bdfa <__gethex+0xda>
 802be4a:	461d      	mov	r5, r3
 802be4c:	42a5      	cmp	r5, r4
 802be4e:	d8e6      	bhi.n	802be1e <__gethex+0xfe>
 802be50:	9b08      	ldr	r3, [sp, #32]
 802be52:	f8cb 9000 	str.w	r9, [fp]
 802be56:	1aff      	subs	r7, r7, r3
 802be58:	9b06      	ldr	r3, [sp, #24]
 802be5a:	10bf      	asrs	r7, r7, #2
 802be5c:	611f      	str	r7, [r3, #16]
 802be5e:	4648      	mov	r0, r9
 802be60:	f000 fe66 	bl	802cb30 <__hi0bits>
 802be64:	9b04      	ldr	r3, [sp, #16]
 802be66:	017f      	lsls	r7, r7, #5
 802be68:	681e      	ldr	r6, [r3, #0]
 802be6a:	1a3f      	subs	r7, r7, r0
 802be6c:	42b7      	cmp	r7, r6
 802be6e:	f300 80d8 	bgt.w	802c022 <__gethex+0x302>
 802be72:	f2c0 810e 	blt.w	802c092 <__gethex+0x372>
 802be76:	2500      	movs	r5, #0
 802be78:	9b04      	ldr	r3, [sp, #16]
 802be7a:	9a02      	ldr	r2, [sp, #8]
 802be7c:	689b      	ldr	r3, [r3, #8]
 802be7e:	4293      	cmp	r3, r2
 802be80:	f2c0 8132 	blt.w	802c0e8 <__gethex+0x3c8>
 802be84:	9804      	ldr	r0, [sp, #16]
 802be86:	9a02      	ldr	r2, [sp, #8]
 802be88:	6843      	ldr	r3, [r0, #4]
 802be8a:	4293      	cmp	r3, r2
 802be8c:	dd73      	ble.n	802bf76 <__gethex+0x256>
 802be8e:	1a9c      	subs	r4, r3, r2
 802be90:	42a6      	cmp	r6, r4
 802be92:	f300 80a4 	bgt.w	802bfde <__gethex+0x2be>
 802be96:	68c2      	ldr	r2, [r0, #12]
 802be98:	2a02      	cmp	r2, #2
 802be9a:	f000 818b 	beq.w	802c1b4 <__gethex+0x494>
 802be9e:	2a03      	cmp	r2, #3
 802bea0:	f000 8183 	beq.w	802c1aa <__gethex+0x48a>
 802bea4:	2a01      	cmp	r2, #1
 802bea6:	f000 815e 	beq.w	802c166 <__gethex+0x446>
 802beaa:	e9dd 1006 	ldrd	r1, r0, [sp, #24]
 802beae:	f000 fd9f 	bl	802c9f0 <_Bfree>
 802beb2:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802beb4:	2300      	movs	r3, #0
 802beb6:	6013      	str	r3, [r2, #0]
 802beb8:	2450      	movs	r4, #80	; 0x50
 802beba:	e03d      	b.n	802bf38 <__gethex+0x218>
 802bebc:	2d00      	cmp	r5, #0
 802bebe:	f000 80da 	beq.w	802c076 <__gethex+0x356>
 802bec2:	783b      	ldrb	r3, [r7, #0]
 802bec4:	1bed      	subs	r5, r5, r7
 802bec6:	00aa      	lsls	r2, r5, #2
 802bec8:	2b50      	cmp	r3, #80	; 0x50
 802beca:	9202      	str	r2, [sp, #8]
 802becc:	f47f af6e 	bne.w	802bdac <__gethex+0x8c>
 802bed0:	787b      	ldrb	r3, [r7, #1]
 802bed2:	2b2b      	cmp	r3, #43	; 0x2b
 802bed4:	f000 80a3 	beq.w	802c01e <__gethex+0x2fe>
 802bed8:	2b2d      	cmp	r3, #45	; 0x2d
 802beda:	d067      	beq.n	802bfac <__gethex+0x28c>
 802bedc:	1c7a      	adds	r2, r7, #1
 802bede:	2500      	movs	r5, #0
 802bee0:	5cf3      	ldrb	r3, [r6, r3]
 802bee2:	1e59      	subs	r1, r3, #1
 802bee4:	2918      	cmp	r1, #24
 802bee6:	f63f af64 	bhi.w	802bdb2 <__gethex+0x92>
 802beea:	7851      	ldrb	r1, [r2, #1]
 802beec:	5c71      	ldrb	r1, [r6, r1]
 802beee:	1e48      	subs	r0, r1, #1
 802bef0:	2818      	cmp	r0, #24
 802bef2:	f1a3 0310 	sub.w	r3, r3, #16
 802bef6:	f102 0201 	add.w	r2, r2, #1
 802befa:	d80b      	bhi.n	802bf14 <__gethex+0x1f4>
 802befc:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 802bf00:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 802bf04:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 802bf08:	5c31      	ldrb	r1, [r6, r0]
 802bf0a:	1e48      	subs	r0, r1, #1
 802bf0c:	2818      	cmp	r0, #24
 802bf0e:	f1a3 0310 	sub.w	r3, r3, #16
 802bf12:	d9f3      	bls.n	802befc <__gethex+0x1dc>
 802bf14:	b105      	cbz	r5, 802bf18 <__gethex+0x1f8>
 802bf16:	425b      	negs	r3, r3
 802bf18:	9902      	ldr	r1, [sp, #8]
 802bf1a:	463d      	mov	r5, r7
 802bf1c:	4419      	add	r1, r3
 802bf1e:	4617      	mov	r7, r2
 802bf20:	9102      	str	r1, [sp, #8]
 802bf22:	f8c9 7000 	str.w	r7, [r9]
 802bf26:	f1ba 0f00 	cmp.w	sl, #0
 802bf2a:	f43f af49 	beq.w	802bdc0 <__gethex+0xa0>
 802bf2e:	f1b8 0f00 	cmp.w	r8, #0
 802bf32:	bf0c      	ite	eq
 802bf34:	2406      	moveq	r4, #6
 802bf36:	2400      	movne	r4, #0
 802bf38:	4620      	mov	r0, r4
 802bf3a:	b00d      	add	sp, #52	; 0x34
 802bf3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802bf40:	465b      	mov	r3, fp
 802bf42:	2200      	movs	r2, #0
 802bf44:	f843 9b08 	str.w	r9, [r3], #8
 802bf48:	46bb      	mov	fp, r7
 802bf4a:	4691      	mov	r9, r2
 802bf4c:	461f      	mov	r7, r3
 802bf4e:	f04f 0804 	mov.w	r8, #4
 802bf52:	e759      	b.n	802be08 <__gethex+0xe8>
 802bf54:	9d03      	ldr	r5, [sp, #12]
 802bf56:	9905      	ldr	r1, [sp, #20]
 802bf58:	462a      	mov	r2, r5
 802bf5a:	4620      	mov	r0, r4
 802bf5c:	f001 fb60 	bl	802d620 <strncmp>
 802bf60:	b340      	cbz	r0, 802bfb4 <__gethex+0x294>
 802bf62:	7822      	ldrb	r2, [r4, #0]
 802bf64:	4627      	mov	r7, r4
 802bf66:	2a50      	cmp	r2, #80	; 0x50
 802bf68:	f000 8080 	beq.w	802c06c <__gethex+0x34c>
 802bf6c:	2a70      	cmp	r2, #112	; 0x70
 802bf6e:	d07d      	beq.n	802c06c <__gethex+0x34c>
 802bf70:	f8c9 7000 	str.w	r7, [r9]
 802bf74:	e7db      	b.n	802bf2e <__gethex+0x20e>
 802bf76:	2401      	movs	r4, #1
 802bf78:	b165      	cbz	r5, 802bf94 <__gethex+0x274>
 802bf7a:	9b04      	ldr	r3, [sp, #16]
 802bf7c:	68db      	ldr	r3, [r3, #12]
 802bf7e:	2b02      	cmp	r3, #2
 802bf80:	f000 80bb 	beq.w	802c0fa <__gethex+0x3da>
 802bf84:	2b03      	cmp	r3, #3
 802bf86:	f000 80bc 	beq.w	802c102 <__gethex+0x3e2>
 802bf8a:	2b01      	cmp	r3, #1
 802bf8c:	f000 8104 	beq.w	802c198 <__gethex+0x478>
 802bf90:	f044 0410 	orr.w	r4, r4, #16
 802bf94:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802bf96:	461a      	mov	r2, r3
 802bf98:	9b06      	ldr	r3, [sp, #24]
 802bf9a:	6013      	str	r3, [r2, #0]
 802bf9c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802bf9e:	461a      	mov	r2, r3
 802bfa0:	9b02      	ldr	r3, [sp, #8]
 802bfa2:	6013      	str	r3, [r2, #0]
 802bfa4:	4620      	mov	r0, r4
 802bfa6:	b00d      	add	sp, #52	; 0x34
 802bfa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802bfac:	2501      	movs	r5, #1
 802bfae:	78bb      	ldrb	r3, [r7, #2]
 802bfb0:	1cba      	adds	r2, r7, #2
 802bfb2:	e795      	b.n	802bee0 <__gethex+0x1c0>
 802bfb4:	5d62      	ldrb	r2, [r4, r5]
 802bfb6:	5cb3      	ldrb	r3, [r6, r2]
 802bfb8:	1967      	adds	r7, r4, r5
 802bfba:	2b00      	cmp	r3, #0
 802bfbc:	d0d3      	beq.n	802bf66 <__gethex+0x246>
 802bfbe:	2a30      	cmp	r2, #48	; 0x30
 802bfc0:	463c      	mov	r4, r7
 802bfc2:	d104      	bne.n	802bfce <__gethex+0x2ae>
 802bfc4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802bfc8:	2b30      	cmp	r3, #48	; 0x30
 802bfca:	d0fb      	beq.n	802bfc4 <__gethex+0x2a4>
 802bfcc:	5cf3      	ldrb	r3, [r6, r3]
 802bfce:	fab3 fa83 	clz	sl, r3
 802bfd2:	463d      	mov	r5, r7
 802bfd4:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
 802bfd8:	f04f 0801 	mov.w	r8, #1
 802bfdc:	e6cf      	b.n	802bd7e <__gethex+0x5e>
 802bfde:	1e67      	subs	r7, r4, #1
 802bfe0:	2d00      	cmp	r5, #0
 802bfe2:	f040 80b8 	bne.w	802c156 <__gethex+0x436>
 802bfe6:	2f00      	cmp	r7, #0
 802bfe8:	f040 80b7 	bne.w	802c15a <__gethex+0x43a>
 802bfec:	117b      	asrs	r3, r7, #5
 802bfee:	9a08      	ldr	r2, [sp, #32]
 802bff0:	9806      	ldr	r0, [sp, #24]
 802bff2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802bff6:	f007 071f 	and.w	r7, r7, #31
 802bffa:	2301      	movs	r3, #1
 802bffc:	fa03 f707 	lsl.w	r7, r3, r7
 802c000:	4217      	tst	r7, r2
 802c002:	4621      	mov	r1, r4
 802c004:	bf18      	it	ne
 802c006:	f045 0502 	orrne.w	r5, r5, #2
 802c00a:	f7ff fe31 	bl	802bc70 <rshift>
 802c00e:	9b04      	ldr	r3, [sp, #16]
 802c010:	685b      	ldr	r3, [r3, #4]
 802c012:	9302      	str	r3, [sp, #8]
 802c014:	1b36      	subs	r6, r6, r4
 802c016:	2402      	movs	r4, #2
 802c018:	2d00      	cmp	r5, #0
 802c01a:	d0bb      	beq.n	802bf94 <__gethex+0x274>
 802c01c:	e7ad      	b.n	802bf7a <__gethex+0x25a>
 802c01e:	2500      	movs	r5, #0
 802c020:	e7c5      	b.n	802bfae <__gethex+0x28e>
 802c022:	1bbf      	subs	r7, r7, r6
 802c024:	4639      	mov	r1, r7
 802c026:	9806      	ldr	r0, [sp, #24]
 802c028:	f001 f91a 	bl	802d260 <__any_on>
 802c02c:	4605      	mov	r5, r0
 802c02e:	b178      	cbz	r0, 802c050 <__gethex+0x330>
 802c030:	1e7a      	subs	r2, r7, #1
 802c032:	1151      	asrs	r1, r2, #5
 802c034:	9808      	ldr	r0, [sp, #32]
 802c036:	f002 031f 	and.w	r3, r2, #31
 802c03a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 802c03e:	2501      	movs	r5, #1
 802c040:	fa05 f303 	lsl.w	r3, r5, r3
 802c044:	420b      	tst	r3, r1
 802c046:	d003      	beq.n	802c050 <__gethex+0x330>
 802c048:	42aa      	cmp	r2, r5
 802c04a:	f300 80b7 	bgt.w	802c1bc <__gethex+0x49c>
 802c04e:	2502      	movs	r5, #2
 802c050:	9b02      	ldr	r3, [sp, #8]
 802c052:	9806      	ldr	r0, [sp, #24]
 802c054:	443b      	add	r3, r7
 802c056:	4639      	mov	r1, r7
 802c058:	9302      	str	r3, [sp, #8]
 802c05a:	f7ff fe09 	bl	802bc70 <rshift>
 802c05e:	e70b      	b.n	802be78 <__gethex+0x158>
 802c060:	08030110 	.word	0x08030110
 802c064:	1c9c      	adds	r4, r3, #2
 802c066:	f04f 0800 	mov.w	r8, #0
 802c06a:	e67e      	b.n	802bd6a <__gethex+0x4a>
 802c06c:	2300      	movs	r3, #0
 802c06e:	9302      	str	r3, [sp, #8]
 802c070:	f04f 0a01 	mov.w	sl, #1
 802c074:	e72c      	b.n	802bed0 <__gethex+0x1b0>
 802c076:	9903      	ldr	r1, [sp, #12]
 802c078:	5c7b      	ldrb	r3, [r7, r1]
 802c07a:	5cf2      	ldrb	r2, [r6, r3]
 802c07c:	187d      	adds	r5, r7, r1
 802c07e:	462f      	mov	r7, r5
 802c080:	2a00      	cmp	r2, #0
 802c082:	f43f af1f 	beq.w	802bec4 <__gethex+0x1a4>
 802c086:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 802c08a:	5cf2      	ldrb	r2, [r6, r3]
 802c08c:	2a00      	cmp	r2, #0
 802c08e:	d1fa      	bne.n	802c086 <__gethex+0x366>
 802c090:	e718      	b.n	802bec4 <__gethex+0x1a4>
 802c092:	1bf7      	subs	r7, r6, r7
 802c094:	9906      	ldr	r1, [sp, #24]
 802c096:	9807      	ldr	r0, [sp, #28]
 802c098:	463a      	mov	r2, r7
 802c09a:	f000 fea1 	bl	802cde0 <__lshift>
 802c09e:	9b02      	ldr	r3, [sp, #8]
 802c0a0:	9006      	str	r0, [sp, #24]
 802c0a2:	1bdb      	subs	r3, r3, r7
 802c0a4:	9302      	str	r3, [sp, #8]
 802c0a6:	4603      	mov	r3, r0
 802c0a8:	3314      	adds	r3, #20
 802c0aa:	9308      	str	r3, [sp, #32]
 802c0ac:	2500      	movs	r5, #0
 802c0ae:	e6e3      	b.n	802be78 <__gethex+0x158>
 802c0b0:	9b06      	ldr	r3, [sp, #24]
 802c0b2:	689b      	ldr	r3, [r3, #8]
 802c0b4:	429d      	cmp	r5, r3
 802c0b6:	f280 8091 	bge.w	802c1dc <__gethex+0x4bc>
 802c0ba:	462b      	mov	r3, r5
 802c0bc:	9806      	ldr	r0, [sp, #24]
 802c0be:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 802c0c2:	2101      	movs	r1, #1
 802c0c4:	3301      	adds	r3, #1
 802c0c6:	2c02      	cmp	r4, #2
 802c0c8:	6103      	str	r3, [r0, #16]
 802c0ca:	6151      	str	r1, [r2, #20]
 802c0cc:	d07f      	beq.n	802c1ce <__gethex+0x4ae>
 802c0ce:	429d      	cmp	r5, r3
 802c0d0:	da34      	bge.n	802c13c <__gethex+0x41c>
 802c0d2:	2101      	movs	r1, #1
 802c0d4:	9806      	ldr	r0, [sp, #24]
 802c0d6:	f7ff fdcb 	bl	802bc70 <rshift>
 802c0da:	9b04      	ldr	r3, [sp, #16]
 802c0dc:	9a02      	ldr	r2, [sp, #8]
 802c0de:	689b      	ldr	r3, [r3, #8]
 802c0e0:	3201      	adds	r2, #1
 802c0e2:	4293      	cmp	r3, r2
 802c0e4:	9202      	str	r2, [sp, #8]
 802c0e6:	da2c      	bge.n	802c142 <__gethex+0x422>
 802c0e8:	e9dd 1006 	ldrd	r1, r0, [sp, #24]
 802c0ec:	f000 fc80 	bl	802c9f0 <_Bfree>
 802c0f0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802c0f2:	2300      	movs	r3, #0
 802c0f4:	6013      	str	r3, [r2, #0]
 802c0f6:	24a3      	movs	r4, #163	; 0xa3
 802c0f8:	e71e      	b.n	802bf38 <__gethex+0x218>
 802c0fa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802c0fc:	f1c3 0301 	rsb	r3, r3, #1
 802c100:	9317      	str	r3, [sp, #92]	; 0x5c
 802c102:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802c104:	2b00      	cmp	r3, #0
 802c106:	f43f af43 	beq.w	802bf90 <__gethex+0x270>
 802c10a:	9b06      	ldr	r3, [sp, #24]
 802c10c:	f8dd c020 	ldr.w	ip, [sp, #32]
 802c110:	691d      	ldr	r5, [r3, #16]
 802c112:	00af      	lsls	r7, r5, #2
 802c114:	eb0c 0007 	add.w	r0, ip, r7
 802c118:	4663      	mov	r3, ip
 802c11a:	2100      	movs	r1, #0
 802c11c:	e003      	b.n	802c126 <__gethex+0x406>
 802c11e:	4298      	cmp	r0, r3
 802c120:	f843 1c04 	str.w	r1, [r3, #-4]
 802c124:	d9c4      	bls.n	802c0b0 <__gethex+0x390>
 802c126:	469e      	mov	lr, r3
 802c128:	f853 2b04 	ldr.w	r2, [r3], #4
 802c12c:	f1b2 3fff 	cmp.w	r2, #4294967295
 802c130:	d0f5      	beq.n	802c11e <__gethex+0x3fe>
 802c132:	3201      	adds	r2, #1
 802c134:	2c02      	cmp	r4, #2
 802c136:	f8ce 2000 	str.w	r2, [lr]
 802c13a:	d048      	beq.n	802c1ce <__gethex+0x4ae>
 802c13c:	f016 061f 	ands.w	r6, r6, #31
 802c140:	d168      	bne.n	802c214 <__gethex+0x4f4>
 802c142:	2421      	movs	r4, #33	; 0x21
 802c144:	e726      	b.n	802bf94 <__gethex+0x274>
 802c146:	9b06      	ldr	r3, [sp, #24]
 802c148:	f8dd b020 	ldr.w	fp, [sp, #32]
 802c14c:	f103 0718 	add.w	r7, r3, #24
 802c150:	f04f 0900 	mov.w	r9, #0
 802c154:	e67c      	b.n	802be50 <__gethex+0x130>
 802c156:	2501      	movs	r5, #1
 802c158:	e748      	b.n	802bfec <__gethex+0x2cc>
 802c15a:	4639      	mov	r1, r7
 802c15c:	9806      	ldr	r0, [sp, #24]
 802c15e:	f001 f87f 	bl	802d260 <__any_on>
 802c162:	4605      	mov	r5, r0
 802c164:	e742      	b.n	802bfec <__gethex+0x2cc>
 802c166:	42a6      	cmp	r6, r4
 802c168:	f47f ae9f 	bne.w	802beaa <__gethex+0x18a>
 802c16c:	2e01      	cmp	r6, #1
 802c16e:	dd08      	ble.n	802c182 <__gethex+0x462>
 802c170:	1e71      	subs	r1, r6, #1
 802c172:	9806      	ldr	r0, [sp, #24]
 802c174:	f001 f874 	bl	802d260 <__any_on>
 802c178:	2800      	cmp	r0, #0
 802c17a:	f43f ae96 	beq.w	802beaa <__gethex+0x18a>
 802c17e:	9b04      	ldr	r3, [sp, #16]
 802c180:	685b      	ldr	r3, [r3, #4]
 802c182:	990a      	ldr	r1, [sp, #40]	; 0x28
 802c184:	600b      	str	r3, [r1, #0]
 802c186:	9b06      	ldr	r3, [sp, #24]
 802c188:	9908      	ldr	r1, [sp, #32]
 802c18a:	2201      	movs	r2, #1
 802c18c:	611a      	str	r2, [r3, #16]
 802c18e:	600a      	str	r2, [r1, #0]
 802c190:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802c192:	2462      	movs	r4, #98	; 0x62
 802c194:	6013      	str	r3, [r2, #0]
 802c196:	e6cf      	b.n	802bf38 <__gethex+0x218>
 802c198:	07aa      	lsls	r2, r5, #30
 802c19a:	f57f aef9 	bpl.w	802bf90 <__gethex+0x270>
 802c19e:	9b08      	ldr	r3, [sp, #32]
 802c1a0:	681b      	ldr	r3, [r3, #0]
 802c1a2:	431d      	orrs	r5, r3
 802c1a4:	07eb      	lsls	r3, r5, #31
 802c1a6:	d4b0      	bmi.n	802c10a <__gethex+0x3ea>
 802c1a8:	e6f2      	b.n	802bf90 <__gethex+0x270>
 802c1aa:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 802c1ac:	2a00      	cmp	r2, #0
 802c1ae:	f43f ae7c 	beq.w	802beaa <__gethex+0x18a>
 802c1b2:	e7e6      	b.n	802c182 <__gethex+0x462>
 802c1b4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 802c1b6:	2a00      	cmp	r2, #0
 802c1b8:	d0e3      	beq.n	802c182 <__gethex+0x462>
 802c1ba:	e676      	b.n	802beaa <__gethex+0x18a>
 802c1bc:	1eb9      	subs	r1, r7, #2
 802c1be:	9806      	ldr	r0, [sp, #24]
 802c1c0:	f001 f84e 	bl	802d260 <__any_on>
 802c1c4:	2800      	cmp	r0, #0
 802c1c6:	f43f af42 	beq.w	802c04e <__gethex+0x32e>
 802c1ca:	2503      	movs	r5, #3
 802c1cc:	e740      	b.n	802c050 <__gethex+0x330>
 802c1ce:	9b04      	ldr	r3, [sp, #16]
 802c1d0:	681b      	ldr	r3, [r3, #0]
 802c1d2:	3b01      	subs	r3, #1
 802c1d4:	42b3      	cmp	r3, r6
 802c1d6:	d027      	beq.n	802c228 <__gethex+0x508>
 802c1d8:	2422      	movs	r4, #34	; 0x22
 802c1da:	e6db      	b.n	802bf94 <__gethex+0x274>
 802c1dc:	9b06      	ldr	r3, [sp, #24]
 802c1de:	f8dd 901c 	ldr.w	r9, [sp, #28]
 802c1e2:	6859      	ldr	r1, [r3, #4]
 802c1e4:	4648      	mov	r0, r9
 802c1e6:	3101      	adds	r1, #1
 802c1e8:	f000 fbda 	bl	802c9a0 <_Balloc>
 802c1ec:	9906      	ldr	r1, [sp, #24]
 802c1ee:	690b      	ldr	r3, [r1, #16]
 802c1f0:	3302      	adds	r3, #2
 802c1f2:	4680      	mov	r8, r0
 802c1f4:	009a      	lsls	r2, r3, #2
 802c1f6:	310c      	adds	r1, #12
 802c1f8:	300c      	adds	r0, #12
 802c1fa:	f7e0 fc91 	bl	800cb20 <memcpy>
 802c1fe:	9906      	ldr	r1, [sp, #24]
 802c200:	4648      	mov	r0, r9
 802c202:	f000 fbf5 	bl	802c9f0 <_Bfree>
 802c206:	f8cd 8018 	str.w	r8, [sp, #24]
 802c20a:	f108 0c14 	add.w	ip, r8, #20
 802c20e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 802c212:	e753      	b.n	802c0bc <__gethex+0x39c>
 802c214:	4467      	add	r7, ip
 802c216:	f1c6 0620 	rsb	r6, r6, #32
 802c21a:	f857 0c04 	ldr.w	r0, [r7, #-4]
 802c21e:	f000 fc87 	bl	802cb30 <__hi0bits>
 802c222:	42b0      	cmp	r0, r6
 802c224:	da8d      	bge.n	802c142 <__gethex+0x422>
 802c226:	e754      	b.n	802c0d2 <__gethex+0x3b2>
 802c228:	1173      	asrs	r3, r6, #5
 802c22a:	f006 061f 	and.w	r6, r6, #31
 802c22e:	f85c 2023 	ldr.w	r2, [ip, r3, lsl #2]
 802c232:	2301      	movs	r3, #1
 802c234:	40b3      	lsls	r3, r6
 802c236:	4213      	tst	r3, r2
 802c238:	bf14      	ite	ne
 802c23a:	2421      	movne	r4, #33	; 0x21
 802c23c:	2422      	moveq	r4, #34	; 0x22
 802c23e:	e6a9      	b.n	802bf94 <__gethex+0x274>

0802c240 <__match>:
 802c240:	b430      	push	{r4, r5}
 802c242:	6804      	ldr	r4, [r0, #0]
 802c244:	3401      	adds	r4, #1
 802c246:	e008      	b.n	802c25a <__match+0x1a>
 802c248:	f814 3b01 	ldrb.w	r3, [r4], #1
 802c24c:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
 802c250:	2d19      	cmp	r5, #25
 802c252:	bf98      	it	ls
 802c254:	3320      	addls	r3, #32
 802c256:	4293      	cmp	r3, r2
 802c258:	d107      	bne.n	802c26a <__match+0x2a>
 802c25a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802c25e:	2a00      	cmp	r2, #0
 802c260:	d1f2      	bne.n	802c248 <__match+0x8>
 802c262:	6004      	str	r4, [r0, #0]
 802c264:	2001      	movs	r0, #1
 802c266:	bc30      	pop	{r4, r5}
 802c268:	4770      	bx	lr
 802c26a:	2000      	movs	r0, #0
 802c26c:	bc30      	pop	{r4, r5}
 802c26e:	4770      	bx	lr

0802c270 <__hexnan>:
 802c270:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c274:	680b      	ldr	r3, [r1, #0]
 802c276:	f8df e194 	ldr.w	lr, [pc, #404]	; 802c40c <__hexnan+0x19c>
 802c27a:	1159      	asrs	r1, r3, #5
 802c27c:	eb02 0981 	add.w	r9, r2, r1, lsl #2
 802c280:	b085      	sub	sp, #20
 802c282:	f013 031f 	ands.w	r3, r3, #31
 802c286:	bf18      	it	ne
 802c288:	f109 0904 	addne.w	r9, r9, #4
 802c28c:	9001      	str	r0, [sp, #4]
 802c28e:	9303      	str	r3, [sp, #12]
 802c290:	2300      	movs	r3, #0
 802c292:	f849 3c04 	str.w	r3, [r9, #-4]
 802c296:	4698      	mov	r8, r3
 802c298:	469a      	mov	sl, r3
 802c29a:	461c      	mov	r4, r3
 802c29c:	9b01      	ldr	r3, [sp, #4]
 802c29e:	f8cd 9008 	str.w	r9, [sp, #8]
 802c2a2:	681b      	ldr	r3, [r3, #0]
 802c2a4:	785f      	ldrb	r7, [r3, #1]
 802c2a6:	f1a9 0604 	sub.w	r6, r9, #4
 802c2aa:	46b4      	mov	ip, r6
 802c2ac:	4631      	mov	r1, r6
 802c2ae:	46b3      	mov	fp, r6
 802c2b0:	4691      	mov	r9, r2
 802c2b2:	1c58      	adds	r0, r3, #1
 802c2b4:	b1df      	cbz	r7, 802c2ee <__hexnan+0x7e>
 802c2b6:	f81e 5007 	ldrb.w	r5, [lr, r7]
 802c2ba:	2d00      	cmp	r5, #0
 802c2bc:	d140      	bne.n	802c340 <__hexnan+0xd0>
 802c2be:	2f20      	cmp	r7, #32
 802c2c0:	d85b      	bhi.n	802c37a <__hexnan+0x10a>
 802c2c2:	4554      	cmp	r4, sl
 802c2c4:	dd0e      	ble.n	802c2e4 <__hexnan+0x74>
 802c2c6:	4561      	cmp	r1, ip
 802c2c8:	d202      	bcs.n	802c2d0 <__hexnan+0x60>
 802c2ca:	f1b8 0f07 	cmp.w	r8, #7
 802c2ce:	dd5e      	ble.n	802c38e <__hexnan+0x11e>
 802c2d0:	4549      	cmp	r1, r9
 802c2d2:	d94e      	bls.n	802c372 <__hexnan+0x102>
 802c2d4:	2300      	movs	r3, #0
 802c2d6:	f1a1 0c04 	sub.w	ip, r1, #4
 802c2da:	f841 3c04 	str.w	r3, [r1, #-4]
 802c2de:	46a2      	mov	sl, r4
 802c2e0:	4661      	mov	r1, ip
 802c2e2:	4698      	mov	r8, r3
 802c2e4:	4603      	mov	r3, r0
 802c2e6:	785f      	ldrb	r7, [r3, #1]
 802c2e8:	1c58      	adds	r0, r3, #1
 802c2ea:	2f00      	cmp	r7, #0
 802c2ec:	d1e3      	bne.n	802c2b6 <__hexnan+0x46>
 802c2ee:	464a      	mov	r2, r9
 802c2f0:	465e      	mov	r6, fp
 802c2f2:	f8dd 9008 	ldr.w	r9, [sp, #8]
 802c2f6:	2c00      	cmp	r4, #0
 802c2f8:	d045      	beq.n	802c386 <__hexnan+0x116>
 802c2fa:	4561      	cmp	r1, ip
 802c2fc:	d202      	bcs.n	802c304 <__hexnan+0x94>
 802c2fe:	f1b8 0f07 	cmp.w	r8, #7
 802c302:	dd70      	ble.n	802c3e6 <__hexnan+0x176>
 802c304:	4291      	cmp	r1, r2
 802c306:	d959      	bls.n	802c3bc <__hexnan+0x14c>
 802c308:	4613      	mov	r3, r2
 802c30a:	f851 0b04 	ldr.w	r0, [r1], #4
 802c30e:	f843 0b04 	str.w	r0, [r3], #4
 802c312:	428e      	cmp	r6, r1
 802c314:	d2f9      	bcs.n	802c30a <__hexnan+0x9a>
 802c316:	2100      	movs	r1, #0
 802c318:	f843 1b04 	str.w	r1, [r3], #4
 802c31c:	429e      	cmp	r6, r3
 802c31e:	d2fb      	bcs.n	802c318 <__hexnan+0xa8>
 802c320:	f859 1c04 	ldr.w	r1, [r9, #-4]
 802c324:	b121      	cbz	r1, 802c330 <__hexnan+0xc0>
 802c326:	e045      	b.n	802c3b4 <__hexnan+0x144>
 802c328:	f856 3d04 	ldr.w	r3, [r6, #-4]!
 802c32c:	2b00      	cmp	r3, #0
 802c32e:	d141      	bne.n	802c3b4 <__hexnan+0x144>
 802c330:	42b2      	cmp	r2, r6
 802c332:	d1f9      	bne.n	802c328 <__hexnan+0xb8>
 802c334:	2301      	movs	r3, #1
 802c336:	2005      	movs	r0, #5
 802c338:	6013      	str	r3, [r2, #0]
 802c33a:	b005      	add	sp, #20
 802c33c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c340:	f108 0801 	add.w	r8, r8, #1
 802c344:	f1b8 0f08 	cmp.w	r8, #8
 802c348:	f104 0401 	add.w	r4, r4, #1
 802c34c:	dc07      	bgt.n	802c35e <__hexnan+0xee>
 802c34e:	680a      	ldr	r2, [r1, #0]
 802c350:	0112      	lsls	r2, r2, #4
 802c352:	f005 050f 	and.w	r5, r5, #15
 802c356:	4315      	orrs	r5, r2
 802c358:	600d      	str	r5, [r1, #0]
 802c35a:	4603      	mov	r3, r0
 802c35c:	e7c3      	b.n	802c2e6 <__hexnan+0x76>
 802c35e:	4549      	cmp	r1, r9
 802c360:	d9c0      	bls.n	802c2e4 <__hexnan+0x74>
 802c362:	2300      	movs	r3, #0
 802c364:	f841 3c04 	str.w	r3, [r1, #-4]
 802c368:	461a      	mov	r2, r3
 802c36a:	3904      	subs	r1, #4
 802c36c:	f04f 0801 	mov.w	r8, #1
 802c370:	e7ef      	b.n	802c352 <__hexnan+0xe2>
 802c372:	f04f 0808 	mov.w	r8, #8
 802c376:	4603      	mov	r3, r0
 802c378:	e7b5      	b.n	802c2e6 <__hexnan+0x76>
 802c37a:	2f29      	cmp	r7, #41	; 0x29
 802c37c:	464a      	mov	r2, r9
 802c37e:	465e      	mov	r6, fp
 802c380:	f8dd 9008 	ldr.w	r9, [sp, #8]
 802c384:	d029      	beq.n	802c3da <__hexnan+0x16a>
 802c386:	2004      	movs	r0, #4
 802c388:	b005      	add	sp, #20
 802c38a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c38e:	f1c8 0308 	rsb	r3, r8, #8
 802c392:	009b      	lsls	r3, r3, #2
 802c394:	680a      	ldr	r2, [r1, #0]
 802c396:	f1c3 0820 	rsb	r8, r3, #32
 802c39a:	460d      	mov	r5, r1
 802c39c:	686f      	ldr	r7, [r5, #4]
 802c39e:	fa07 f608 	lsl.w	r6, r7, r8
 802c3a2:	4316      	orrs	r6, r2
 802c3a4:	fa27 f203 	lsr.w	r2, r7, r3
 802c3a8:	602e      	str	r6, [r5, #0]
 802c3aa:	f845 2f04 	str.w	r2, [r5, #4]!
 802c3ae:	45ac      	cmp	ip, r5
 802c3b0:	d8f4      	bhi.n	802c39c <__hexnan+0x12c>
 802c3b2:	e78d      	b.n	802c2d0 <__hexnan+0x60>
 802c3b4:	2005      	movs	r0, #5
 802c3b6:	b005      	add	sp, #20
 802c3b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c3bc:	9b03      	ldr	r3, [sp, #12]
 802c3be:	f859 1c04 	ldr.w	r1, [r9, #-4]
 802c3c2:	2b00      	cmp	r3, #0
 802c3c4:	d0ae      	beq.n	802c324 <__hexnan+0xb4>
 802c3c6:	f1c3 0320 	rsb	r3, r3, #32
 802c3ca:	f04f 30ff 	mov.w	r0, #4294967295
 802c3ce:	fa20 f303 	lsr.w	r3, r0, r3
 802c3d2:	4019      	ands	r1, r3
 802c3d4:	f849 1c04 	str.w	r1, [r9, #-4]
 802c3d8:	e7a4      	b.n	802c324 <__hexnan+0xb4>
 802c3da:	9801      	ldr	r0, [sp, #4]
 802c3dc:	3302      	adds	r3, #2
 802c3de:	6003      	str	r3, [r0, #0]
 802c3e0:	2c00      	cmp	r4, #0
 802c3e2:	d18a      	bne.n	802c2fa <__hexnan+0x8a>
 802c3e4:	e7cf      	b.n	802c386 <__hexnan+0x116>
 802c3e6:	f1c8 0308 	rsb	r3, r8, #8
 802c3ea:	009b      	lsls	r3, r3, #2
 802c3ec:	680d      	ldr	r5, [r1, #0]
 802c3ee:	f1c3 0e20 	rsb	lr, r3, #32
 802c3f2:	4608      	mov	r0, r1
 802c3f4:	6847      	ldr	r7, [r0, #4]
 802c3f6:	fa07 f40e 	lsl.w	r4, r7, lr
 802c3fa:	432c      	orrs	r4, r5
 802c3fc:	fa27 f503 	lsr.w	r5, r7, r3
 802c400:	6004      	str	r4, [r0, #0]
 802c402:	f840 5f04 	str.w	r5, [r0, #4]!
 802c406:	4584      	cmp	ip, r0
 802c408:	d8f4      	bhi.n	802c3f4 <__hexnan+0x184>
 802c40a:	e77b      	b.n	802c304 <__hexnan+0x94>
 802c40c:	08030110 	.word	0x08030110

0802c410 <__retarget_lock_acquire_recursive>:
 802c410:	4770      	bx	lr
 802c412:	bf00      	nop
	...

0802c420 <__retarget_lock_release_recursive>:
 802c420:	4770      	bx	lr
 802c422:	bf00      	nop
	...

0802c430 <_malloc_r>:
 802c430:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c434:	f101 050b 	add.w	r5, r1, #11
 802c438:	2d16      	cmp	r5, #22
 802c43a:	b083      	sub	sp, #12
 802c43c:	4606      	mov	r6, r0
 802c43e:	d823      	bhi.n	802c488 <_malloc_r+0x58>
 802c440:	2910      	cmp	r1, #16
 802c442:	f200 80b9 	bhi.w	802c5b8 <_malloc_r+0x188>
 802c446:	f000 fa9b 	bl	802c980 <__malloc_lock>
 802c44a:	2510      	movs	r5, #16
 802c44c:	2318      	movs	r3, #24
 802c44e:	2002      	movs	r0, #2
 802c450:	4fc5      	ldr	r7, [pc, #788]	; (802c768 <_malloc_r+0x338>)
 802c452:	443b      	add	r3, r7
 802c454:	f1a3 0208 	sub.w	r2, r3, #8
 802c458:	685c      	ldr	r4, [r3, #4]
 802c45a:	4294      	cmp	r4, r2
 802c45c:	f000 8166 	beq.w	802c72c <_malloc_r+0x2fc>
 802c460:	6863      	ldr	r3, [r4, #4]
 802c462:	f023 0303 	bic.w	r3, r3, #3
 802c466:	4423      	add	r3, r4
 802c468:	e9d4 5102 	ldrd	r5, r1, [r4, #8]
 802c46c:	685a      	ldr	r2, [r3, #4]
 802c46e:	60e9      	str	r1, [r5, #12]
 802c470:	f042 0201 	orr.w	r2, r2, #1
 802c474:	608d      	str	r5, [r1, #8]
 802c476:	4630      	mov	r0, r6
 802c478:	605a      	str	r2, [r3, #4]
 802c47a:	f000 fa89 	bl	802c990 <__malloc_unlock>
 802c47e:	3408      	adds	r4, #8
 802c480:	4620      	mov	r0, r4
 802c482:	b003      	add	sp, #12
 802c484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c488:	f035 0507 	bics.w	r5, r5, #7
 802c48c:	f100 8094 	bmi.w	802c5b8 <_malloc_r+0x188>
 802c490:	42a9      	cmp	r1, r5
 802c492:	f200 8091 	bhi.w	802c5b8 <_malloc_r+0x188>
 802c496:	f000 fa73 	bl	802c980 <__malloc_lock>
 802c49a:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 802c49e:	f0c0 8183 	bcc.w	802c7a8 <_malloc_r+0x378>
 802c4a2:	0a6b      	lsrs	r3, r5, #9
 802c4a4:	f000 808f 	beq.w	802c5c6 <_malloc_r+0x196>
 802c4a8:	2b04      	cmp	r3, #4
 802c4aa:	f200 8146 	bhi.w	802c73a <_malloc_r+0x30a>
 802c4ae:	09ab      	lsrs	r3, r5, #6
 802c4b0:	f103 0039 	add.w	r0, r3, #57	; 0x39
 802c4b4:	f103 0c38 	add.w	ip, r3, #56	; 0x38
 802c4b8:	00c3      	lsls	r3, r0, #3
 802c4ba:	4fab      	ldr	r7, [pc, #684]	; (802c768 <_malloc_r+0x338>)
 802c4bc:	443b      	add	r3, r7
 802c4be:	f1a3 0108 	sub.w	r1, r3, #8
 802c4c2:	685c      	ldr	r4, [r3, #4]
 802c4c4:	42a1      	cmp	r1, r4
 802c4c6:	d106      	bne.n	802c4d6 <_malloc_r+0xa6>
 802c4c8:	e00c      	b.n	802c4e4 <_malloc_r+0xb4>
 802c4ca:	2a00      	cmp	r2, #0
 802c4cc:	f280 811d 	bge.w	802c70a <_malloc_r+0x2da>
 802c4d0:	68e4      	ldr	r4, [r4, #12]
 802c4d2:	42a1      	cmp	r1, r4
 802c4d4:	d006      	beq.n	802c4e4 <_malloc_r+0xb4>
 802c4d6:	6863      	ldr	r3, [r4, #4]
 802c4d8:	f023 0303 	bic.w	r3, r3, #3
 802c4dc:	1b5a      	subs	r2, r3, r5
 802c4de:	2a0f      	cmp	r2, #15
 802c4e0:	ddf3      	ble.n	802c4ca <_malloc_r+0x9a>
 802c4e2:	4660      	mov	r0, ip
 802c4e4:	693c      	ldr	r4, [r7, #16]
 802c4e6:	f8df c294 	ldr.w	ip, [pc, #660]	; 802c77c <_malloc_r+0x34c>
 802c4ea:	4564      	cmp	r4, ip
 802c4ec:	d071      	beq.n	802c5d2 <_malloc_r+0x1a2>
 802c4ee:	6863      	ldr	r3, [r4, #4]
 802c4f0:	f023 0303 	bic.w	r3, r3, #3
 802c4f4:	1b5a      	subs	r2, r3, r5
 802c4f6:	2a0f      	cmp	r2, #15
 802c4f8:	f300 8144 	bgt.w	802c784 <_malloc_r+0x354>
 802c4fc:	2a00      	cmp	r2, #0
 802c4fe:	e9c7 cc04 	strd	ip, ip, [r7, #16]
 802c502:	f280 8126 	bge.w	802c752 <_malloc_r+0x322>
 802c506:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802c50a:	f080 8169 	bcs.w	802c7e0 <_malloc_r+0x3b0>
 802c50e:	08db      	lsrs	r3, r3, #3
 802c510:	1c59      	adds	r1, r3, #1
 802c512:	687a      	ldr	r2, [r7, #4]
 802c514:	f857 8031 	ldr.w	r8, [r7, r1, lsl #3]
 802c518:	f8c4 8008 	str.w	r8, [r4, #8]
 802c51c:	f04f 0e01 	mov.w	lr, #1
 802c520:	109b      	asrs	r3, r3, #2
 802c522:	fa0e f303 	lsl.w	r3, lr, r3
 802c526:	eb07 0ec1 	add.w	lr, r7, r1, lsl #3
 802c52a:	4313      	orrs	r3, r2
 802c52c:	f1ae 0208 	sub.w	r2, lr, #8
 802c530:	60e2      	str	r2, [r4, #12]
 802c532:	607b      	str	r3, [r7, #4]
 802c534:	f847 4031 	str.w	r4, [r7, r1, lsl #3]
 802c538:	f8c8 400c 	str.w	r4, [r8, #12]
 802c53c:	1082      	asrs	r2, r0, #2
 802c53e:	2401      	movs	r4, #1
 802c540:	4094      	lsls	r4, r2
 802c542:	429c      	cmp	r4, r3
 802c544:	d84b      	bhi.n	802c5de <_malloc_r+0x1ae>
 802c546:	421c      	tst	r4, r3
 802c548:	d106      	bne.n	802c558 <_malloc_r+0x128>
 802c54a:	f020 0003 	bic.w	r0, r0, #3
 802c54e:	0064      	lsls	r4, r4, #1
 802c550:	421c      	tst	r4, r3
 802c552:	f100 0004 	add.w	r0, r0, #4
 802c556:	d0fa      	beq.n	802c54e <_malloc_r+0x11e>
 802c558:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 802c55c:	46ce      	mov	lr, r9
 802c55e:	4680      	mov	r8, r0
 802c560:	f8de 300c 	ldr.w	r3, [lr, #12]
 802c564:	459e      	cmp	lr, r3
 802c566:	d107      	bne.n	802c578 <_malloc_r+0x148>
 802c568:	e122      	b.n	802c7b0 <_malloc_r+0x380>
 802c56a:	2a00      	cmp	r2, #0
 802c56c:	f280 8129 	bge.w	802c7c2 <_malloc_r+0x392>
 802c570:	68db      	ldr	r3, [r3, #12]
 802c572:	459e      	cmp	lr, r3
 802c574:	f000 811c 	beq.w	802c7b0 <_malloc_r+0x380>
 802c578:	6859      	ldr	r1, [r3, #4]
 802c57a:	f021 0103 	bic.w	r1, r1, #3
 802c57e:	1b4a      	subs	r2, r1, r5
 802c580:	2a0f      	cmp	r2, #15
 802c582:	ddf2      	ble.n	802c56a <_malloc_r+0x13a>
 802c584:	e9d3 8e02 	ldrd	r8, lr, [r3, #8]
 802c588:	195c      	adds	r4, r3, r5
 802c58a:	f045 0501 	orr.w	r5, r5, #1
 802c58e:	605d      	str	r5, [r3, #4]
 802c590:	f042 0501 	orr.w	r5, r2, #1
 802c594:	f8c8 e00c 	str.w	lr, [r8, #12]
 802c598:	4630      	mov	r0, r6
 802c59a:	f8ce 8008 	str.w	r8, [lr, #8]
 802c59e:	e9c7 4404 	strd	r4, r4, [r7, #16]
 802c5a2:	e9c4 cc02 	strd	ip, ip, [r4, #8]
 802c5a6:	6065      	str	r5, [r4, #4]
 802c5a8:	505a      	str	r2, [r3, r1]
 802c5aa:	9301      	str	r3, [sp, #4]
 802c5ac:	f000 f9f0 	bl	802c990 <__malloc_unlock>
 802c5b0:	9b01      	ldr	r3, [sp, #4]
 802c5b2:	f103 0408 	add.w	r4, r3, #8
 802c5b6:	e763      	b.n	802c480 <_malloc_r+0x50>
 802c5b8:	2400      	movs	r4, #0
 802c5ba:	230c      	movs	r3, #12
 802c5bc:	4620      	mov	r0, r4
 802c5be:	6033      	str	r3, [r6, #0]
 802c5c0:	b003      	add	sp, #12
 802c5c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c5c6:	f44f 7300 	mov.w	r3, #512	; 0x200
 802c5ca:	2040      	movs	r0, #64	; 0x40
 802c5cc:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 802c5d0:	e773      	b.n	802c4ba <_malloc_r+0x8a>
 802c5d2:	687b      	ldr	r3, [r7, #4]
 802c5d4:	1082      	asrs	r2, r0, #2
 802c5d6:	2401      	movs	r4, #1
 802c5d8:	4094      	lsls	r4, r2
 802c5da:	429c      	cmp	r4, r3
 802c5dc:	d9b3      	bls.n	802c546 <_malloc_r+0x116>
 802c5de:	68bc      	ldr	r4, [r7, #8]
 802c5e0:	6863      	ldr	r3, [r4, #4]
 802c5e2:	f023 0903 	bic.w	r9, r3, #3
 802c5e6:	45a9      	cmp	r9, r5
 802c5e8:	d303      	bcc.n	802c5f2 <_malloc_r+0x1c2>
 802c5ea:	eba9 0305 	sub.w	r3, r9, r5
 802c5ee:	2b0f      	cmp	r3, #15
 802c5f0:	dc7b      	bgt.n	802c6ea <_malloc_r+0x2ba>
 802c5f2:	4b5e      	ldr	r3, [pc, #376]	; (802c76c <_malloc_r+0x33c>)
 802c5f4:	f8df a188 	ldr.w	sl, [pc, #392]	; 802c780 <_malloc_r+0x350>
 802c5f8:	681a      	ldr	r2, [r3, #0]
 802c5fa:	f8da 3000 	ldr.w	r3, [sl]
 802c5fe:	3301      	adds	r3, #1
 802c600:	eb05 0802 	add.w	r8, r5, r2
 802c604:	f000 8148 	beq.w	802c898 <_malloc_r+0x468>
 802c608:	f508 5880 	add.w	r8, r8, #4096	; 0x1000
 802c60c:	f108 080f 	add.w	r8, r8, #15
 802c610:	f428 687f 	bic.w	r8, r8, #4080	; 0xff0
 802c614:	f028 080f 	bic.w	r8, r8, #15
 802c618:	4641      	mov	r1, r8
 802c61a:	4630      	mov	r0, r6
 802c61c:	f7e5 f8b8 	bl	8011790 <_sbrk_r>
 802c620:	f1b0 3fff 	cmp.w	r0, #4294967295
 802c624:	4683      	mov	fp, r0
 802c626:	f000 8104 	beq.w	802c832 <_malloc_r+0x402>
 802c62a:	eb04 0009 	add.w	r0, r4, r9
 802c62e:	4558      	cmp	r0, fp
 802c630:	f200 80fd 	bhi.w	802c82e <_malloc_r+0x3fe>
 802c634:	4a4e      	ldr	r2, [pc, #312]	; (802c770 <_malloc_r+0x340>)
 802c636:	6813      	ldr	r3, [r2, #0]
 802c638:	4443      	add	r3, r8
 802c63a:	6013      	str	r3, [r2, #0]
 802c63c:	f000 814d 	beq.w	802c8da <_malloc_r+0x4aa>
 802c640:	f8da 1000 	ldr.w	r1, [sl]
 802c644:	3101      	adds	r1, #1
 802c646:	bf1b      	ittet	ne
 802c648:	ebab 0000 	subne.w	r0, fp, r0
 802c64c:	181b      	addne	r3, r3, r0
 802c64e:	f8ca b000 	streq.w	fp, [sl]
 802c652:	6013      	strne	r3, [r2, #0]
 802c654:	f01b 0307 	ands.w	r3, fp, #7
 802c658:	f000 8134 	beq.w	802c8c4 <_malloc_r+0x494>
 802c65c:	f1c3 0108 	rsb	r1, r3, #8
 802c660:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 802c664:	448b      	add	fp, r1
 802c666:	3308      	adds	r3, #8
 802c668:	44d8      	add	r8, fp
 802c66a:	f3c8 080b 	ubfx	r8, r8, #0, #12
 802c66e:	eba3 0808 	sub.w	r8, r3, r8
 802c672:	4641      	mov	r1, r8
 802c674:	4630      	mov	r0, r6
 802c676:	9201      	str	r2, [sp, #4]
 802c678:	f7e5 f88a 	bl	8011790 <_sbrk_r>
 802c67c:	1c43      	adds	r3, r0, #1
 802c67e:	9a01      	ldr	r2, [sp, #4]
 802c680:	f000 8146 	beq.w	802c910 <_malloc_r+0x4e0>
 802c684:	eba0 010b 	sub.w	r1, r0, fp
 802c688:	4441      	add	r1, r8
 802c68a:	f041 0101 	orr.w	r1, r1, #1
 802c68e:	6813      	ldr	r3, [r2, #0]
 802c690:	f8c7 b008 	str.w	fp, [r7, #8]
 802c694:	4443      	add	r3, r8
 802c696:	42bc      	cmp	r4, r7
 802c698:	f8cb 1004 	str.w	r1, [fp, #4]
 802c69c:	6013      	str	r3, [r2, #0]
 802c69e:	d015      	beq.n	802c6cc <_malloc_r+0x29c>
 802c6a0:	f1b9 0f0f 	cmp.w	r9, #15
 802c6a4:	f240 8130 	bls.w	802c908 <_malloc_r+0x4d8>
 802c6a8:	6860      	ldr	r0, [r4, #4]
 802c6aa:	f1a9 010c 	sub.w	r1, r9, #12
 802c6ae:	f021 0107 	bic.w	r1, r1, #7
 802c6b2:	f000 0001 	and.w	r0, r0, #1
 802c6b6:	eb04 0c01 	add.w	ip, r4, r1
 802c6ba:	4308      	orrs	r0, r1
 802c6bc:	f04f 0e05 	mov.w	lr, #5
 802c6c0:	290f      	cmp	r1, #15
 802c6c2:	6060      	str	r0, [r4, #4]
 802c6c4:	e9cc ee01 	strd	lr, lr, [ip, #4]
 802c6c8:	f200 813a 	bhi.w	802c940 <_malloc_r+0x510>
 802c6cc:	4a29      	ldr	r2, [pc, #164]	; (802c774 <_malloc_r+0x344>)
 802c6ce:	482a      	ldr	r0, [pc, #168]	; (802c778 <_malloc_r+0x348>)
 802c6d0:	6811      	ldr	r1, [r2, #0]
 802c6d2:	68bc      	ldr	r4, [r7, #8]
 802c6d4:	428b      	cmp	r3, r1
 802c6d6:	6801      	ldr	r1, [r0, #0]
 802c6d8:	bf88      	it	hi
 802c6da:	6013      	strhi	r3, [r2, #0]
 802c6dc:	6862      	ldr	r2, [r4, #4]
 802c6de:	428b      	cmp	r3, r1
 802c6e0:	f022 0203 	bic.w	r2, r2, #3
 802c6e4:	bf88      	it	hi
 802c6e6:	6003      	strhi	r3, [r0, #0]
 802c6e8:	e0a7      	b.n	802c83a <_malloc_r+0x40a>
 802c6ea:	1962      	adds	r2, r4, r5
 802c6ec:	f043 0301 	orr.w	r3, r3, #1
 802c6f0:	f045 0501 	orr.w	r5, r5, #1
 802c6f4:	6065      	str	r5, [r4, #4]
 802c6f6:	4630      	mov	r0, r6
 802c6f8:	60ba      	str	r2, [r7, #8]
 802c6fa:	6053      	str	r3, [r2, #4]
 802c6fc:	f000 f948 	bl	802c990 <__malloc_unlock>
 802c700:	3408      	adds	r4, #8
 802c702:	4620      	mov	r0, r4
 802c704:	b003      	add	sp, #12
 802c706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c70a:	4423      	add	r3, r4
 802c70c:	68e1      	ldr	r1, [r4, #12]
 802c70e:	685a      	ldr	r2, [r3, #4]
 802c710:	68a5      	ldr	r5, [r4, #8]
 802c712:	f042 0201 	orr.w	r2, r2, #1
 802c716:	60e9      	str	r1, [r5, #12]
 802c718:	4630      	mov	r0, r6
 802c71a:	608d      	str	r5, [r1, #8]
 802c71c:	605a      	str	r2, [r3, #4]
 802c71e:	f000 f937 	bl	802c990 <__malloc_unlock>
 802c722:	3408      	adds	r4, #8
 802c724:	4620      	mov	r0, r4
 802c726:	b003      	add	sp, #12
 802c728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c72c:	68dc      	ldr	r4, [r3, #12]
 802c72e:	42a3      	cmp	r3, r4
 802c730:	bf08      	it	eq
 802c732:	3002      	addeq	r0, #2
 802c734:	f43f aed6 	beq.w	802c4e4 <_malloc_r+0xb4>
 802c738:	e692      	b.n	802c460 <_malloc_r+0x30>
 802c73a:	2b14      	cmp	r3, #20
 802c73c:	d971      	bls.n	802c822 <_malloc_r+0x3f2>
 802c73e:	2b54      	cmp	r3, #84	; 0x54
 802c740:	f200 80ad 	bhi.w	802c89e <_malloc_r+0x46e>
 802c744:	0b2b      	lsrs	r3, r5, #12
 802c746:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 802c74a:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
 802c74e:	00c3      	lsls	r3, r0, #3
 802c750:	e6b3      	b.n	802c4ba <_malloc_r+0x8a>
 802c752:	4423      	add	r3, r4
 802c754:	4630      	mov	r0, r6
 802c756:	685a      	ldr	r2, [r3, #4]
 802c758:	f042 0201 	orr.w	r2, r2, #1
 802c75c:	605a      	str	r2, [r3, #4]
 802c75e:	3408      	adds	r4, #8
 802c760:	f000 f916 	bl	802c990 <__malloc_unlock>
 802c764:	e68c      	b.n	802c480 <_malloc_r+0x50>
 802c766:	bf00      	nop
 802c768:	20001634 	.word	0x20001634
 802c76c:	20011cc0 	.word	0x20011cc0
 802c770:	20011c90 	.word	0x20011c90
 802c774:	20011cb8 	.word	0x20011cb8
 802c778:	20011cbc 	.word	0x20011cbc
 802c77c:	2000163c 	.word	0x2000163c
 802c780:	20001a3c 	.word	0x20001a3c
 802c784:	1961      	adds	r1, r4, r5
 802c786:	f045 0e01 	orr.w	lr, r5, #1
 802c78a:	f042 0501 	orr.w	r5, r2, #1
 802c78e:	f8c4 e004 	str.w	lr, [r4, #4]
 802c792:	4630      	mov	r0, r6
 802c794:	e9c7 1104 	strd	r1, r1, [r7, #16]
 802c798:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 802c79c:	604d      	str	r5, [r1, #4]
 802c79e:	50e2      	str	r2, [r4, r3]
 802c7a0:	f000 f8f6 	bl	802c990 <__malloc_unlock>
 802c7a4:	3408      	adds	r4, #8
 802c7a6:	e66b      	b.n	802c480 <_malloc_r+0x50>
 802c7a8:	08e8      	lsrs	r0, r5, #3
 802c7aa:	f105 0308 	add.w	r3, r5, #8
 802c7ae:	e64f      	b.n	802c450 <_malloc_r+0x20>
 802c7b0:	f108 0801 	add.w	r8, r8, #1
 802c7b4:	f018 0f03 	tst.w	r8, #3
 802c7b8:	f10e 0e08 	add.w	lr, lr, #8
 802c7bc:	f47f aed0 	bne.w	802c560 <_malloc_r+0x130>
 802c7c0:	e052      	b.n	802c868 <_malloc_r+0x438>
 802c7c2:	4419      	add	r1, r3
 802c7c4:	461c      	mov	r4, r3
 802c7c6:	684a      	ldr	r2, [r1, #4]
 802c7c8:	68db      	ldr	r3, [r3, #12]
 802c7ca:	f854 5f08 	ldr.w	r5, [r4, #8]!
 802c7ce:	f042 0201 	orr.w	r2, r2, #1
 802c7d2:	604a      	str	r2, [r1, #4]
 802c7d4:	4630      	mov	r0, r6
 802c7d6:	60eb      	str	r3, [r5, #12]
 802c7d8:	609d      	str	r5, [r3, #8]
 802c7da:	f000 f8d9 	bl	802c990 <__malloc_unlock>
 802c7de:	e64f      	b.n	802c480 <_malloc_r+0x50>
 802c7e0:	0a5a      	lsrs	r2, r3, #9
 802c7e2:	2a04      	cmp	r2, #4
 802c7e4:	d935      	bls.n	802c852 <_malloc_r+0x422>
 802c7e6:	2a14      	cmp	r2, #20
 802c7e8:	d86f      	bhi.n	802c8ca <_malloc_r+0x49a>
 802c7ea:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 802c7ee:	00c9      	lsls	r1, r1, #3
 802c7f0:	325b      	adds	r2, #91	; 0x5b
 802c7f2:	eb07 0e01 	add.w	lr, r7, r1
 802c7f6:	5879      	ldr	r1, [r7, r1]
 802c7f8:	f1ae 0e08 	sub.w	lr, lr, #8
 802c7fc:	458e      	cmp	lr, r1
 802c7fe:	d058      	beq.n	802c8b2 <_malloc_r+0x482>
 802c800:	684a      	ldr	r2, [r1, #4]
 802c802:	f022 0203 	bic.w	r2, r2, #3
 802c806:	429a      	cmp	r2, r3
 802c808:	d902      	bls.n	802c810 <_malloc_r+0x3e0>
 802c80a:	6889      	ldr	r1, [r1, #8]
 802c80c:	458e      	cmp	lr, r1
 802c80e:	d1f7      	bne.n	802c800 <_malloc_r+0x3d0>
 802c810:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 802c814:	687b      	ldr	r3, [r7, #4]
 802c816:	e9c4 1e02 	strd	r1, lr, [r4, #8]
 802c81a:	f8ce 4008 	str.w	r4, [lr, #8]
 802c81e:	60cc      	str	r4, [r1, #12]
 802c820:	e68c      	b.n	802c53c <_malloc_r+0x10c>
 802c822:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 802c826:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
 802c82a:	00c3      	lsls	r3, r0, #3
 802c82c:	e645      	b.n	802c4ba <_malloc_r+0x8a>
 802c82e:	42bc      	cmp	r4, r7
 802c830:	d072      	beq.n	802c918 <_malloc_r+0x4e8>
 802c832:	68bc      	ldr	r4, [r7, #8]
 802c834:	6862      	ldr	r2, [r4, #4]
 802c836:	f022 0203 	bic.w	r2, r2, #3
 802c83a:	4295      	cmp	r5, r2
 802c83c:	eba2 0305 	sub.w	r3, r2, r5
 802c840:	d802      	bhi.n	802c848 <_malloc_r+0x418>
 802c842:	2b0f      	cmp	r3, #15
 802c844:	f73f af51 	bgt.w	802c6ea <_malloc_r+0x2ba>
 802c848:	4630      	mov	r0, r6
 802c84a:	f000 f8a1 	bl	802c990 <__malloc_unlock>
 802c84e:	2400      	movs	r4, #0
 802c850:	e616      	b.n	802c480 <_malloc_r+0x50>
 802c852:	099a      	lsrs	r2, r3, #6
 802c854:	f102 0139 	add.w	r1, r2, #57	; 0x39
 802c858:	00c9      	lsls	r1, r1, #3
 802c85a:	3238      	adds	r2, #56	; 0x38
 802c85c:	e7c9      	b.n	802c7f2 <_malloc_r+0x3c2>
 802c85e:	f8d9 9000 	ldr.w	r9, [r9]
 802c862:	4599      	cmp	r9, r3
 802c864:	f040 8083 	bne.w	802c96e <_malloc_r+0x53e>
 802c868:	f010 0f03 	tst.w	r0, #3
 802c86c:	f1a9 0308 	sub.w	r3, r9, #8
 802c870:	f100 30ff 	add.w	r0, r0, #4294967295
 802c874:	d1f3      	bne.n	802c85e <_malloc_r+0x42e>
 802c876:	687b      	ldr	r3, [r7, #4]
 802c878:	ea23 0304 	bic.w	r3, r3, r4
 802c87c:	607b      	str	r3, [r7, #4]
 802c87e:	0064      	lsls	r4, r4, #1
 802c880:	429c      	cmp	r4, r3
 802c882:	f63f aeac 	bhi.w	802c5de <_malloc_r+0x1ae>
 802c886:	b91c      	cbnz	r4, 802c890 <_malloc_r+0x460>
 802c888:	e6a9      	b.n	802c5de <_malloc_r+0x1ae>
 802c88a:	0064      	lsls	r4, r4, #1
 802c88c:	f108 0804 	add.w	r8, r8, #4
 802c890:	421c      	tst	r4, r3
 802c892:	d0fa      	beq.n	802c88a <_malloc_r+0x45a>
 802c894:	4640      	mov	r0, r8
 802c896:	e65f      	b.n	802c558 <_malloc_r+0x128>
 802c898:	f108 0810 	add.w	r8, r8, #16
 802c89c:	e6bc      	b.n	802c618 <_malloc_r+0x1e8>
 802c89e:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 802c8a2:	d826      	bhi.n	802c8f2 <_malloc_r+0x4c2>
 802c8a4:	0beb      	lsrs	r3, r5, #15
 802c8a6:	f103 0078 	add.w	r0, r3, #120	; 0x78
 802c8aa:	f103 0c77 	add.w	ip, r3, #119	; 0x77
 802c8ae:	00c3      	lsls	r3, r0, #3
 802c8b0:	e603      	b.n	802c4ba <_malloc_r+0x8a>
 802c8b2:	687b      	ldr	r3, [r7, #4]
 802c8b4:	1092      	asrs	r2, r2, #2
 802c8b6:	f04f 0801 	mov.w	r8, #1
 802c8ba:	fa08 f202 	lsl.w	r2, r8, r2
 802c8be:	4313      	orrs	r3, r2
 802c8c0:	607b      	str	r3, [r7, #4]
 802c8c2:	e7a8      	b.n	802c816 <_malloc_r+0x3e6>
 802c8c4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 802c8c8:	e6ce      	b.n	802c668 <_malloc_r+0x238>
 802c8ca:	2a54      	cmp	r2, #84	; 0x54
 802c8cc:	d829      	bhi.n	802c922 <_malloc_r+0x4f2>
 802c8ce:	0b1a      	lsrs	r2, r3, #12
 802c8d0:	f102 016f 	add.w	r1, r2, #111	; 0x6f
 802c8d4:	00c9      	lsls	r1, r1, #3
 802c8d6:	326e      	adds	r2, #110	; 0x6e
 802c8d8:	e78b      	b.n	802c7f2 <_malloc_r+0x3c2>
 802c8da:	f3c0 010b 	ubfx	r1, r0, #0, #12
 802c8de:	2900      	cmp	r1, #0
 802c8e0:	f47f aeae 	bne.w	802c640 <_malloc_r+0x210>
 802c8e4:	eb09 0208 	add.w	r2, r9, r8
 802c8e8:	68b9      	ldr	r1, [r7, #8]
 802c8ea:	f042 0201 	orr.w	r2, r2, #1
 802c8ee:	604a      	str	r2, [r1, #4]
 802c8f0:	e6ec      	b.n	802c6cc <_malloc_r+0x29c>
 802c8f2:	f240 5254 	movw	r2, #1364	; 0x554
 802c8f6:	4293      	cmp	r3, r2
 802c8f8:	d81c      	bhi.n	802c934 <_malloc_r+0x504>
 802c8fa:	0cab      	lsrs	r3, r5, #18
 802c8fc:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 802c900:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
 802c904:	00c3      	lsls	r3, r0, #3
 802c906:	e5d8      	b.n	802c4ba <_malloc_r+0x8a>
 802c908:	2301      	movs	r3, #1
 802c90a:	f8cb 3004 	str.w	r3, [fp, #4]
 802c90e:	e79b      	b.n	802c848 <_malloc_r+0x418>
 802c910:	2101      	movs	r1, #1
 802c912:	f04f 0800 	mov.w	r8, #0
 802c916:	e6ba      	b.n	802c68e <_malloc_r+0x25e>
 802c918:	4a16      	ldr	r2, [pc, #88]	; (802c974 <_malloc_r+0x544>)
 802c91a:	6813      	ldr	r3, [r2, #0]
 802c91c:	4443      	add	r3, r8
 802c91e:	6013      	str	r3, [r2, #0]
 802c920:	e68e      	b.n	802c640 <_malloc_r+0x210>
 802c922:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 802c926:	d814      	bhi.n	802c952 <_malloc_r+0x522>
 802c928:	0bda      	lsrs	r2, r3, #15
 802c92a:	f102 0178 	add.w	r1, r2, #120	; 0x78
 802c92e:	00c9      	lsls	r1, r1, #3
 802c930:	3277      	adds	r2, #119	; 0x77
 802c932:	e75e      	b.n	802c7f2 <_malloc_r+0x3c2>
 802c934:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 802c938:	207f      	movs	r0, #127	; 0x7f
 802c93a:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 802c93e:	e5bc      	b.n	802c4ba <_malloc_r+0x8a>
 802c940:	f104 0108 	add.w	r1, r4, #8
 802c944:	4630      	mov	r0, r6
 802c946:	9201      	str	r2, [sp, #4]
 802c948:	f7ff f89a 	bl	802ba80 <_free_r>
 802c94c:	9a01      	ldr	r2, [sp, #4]
 802c94e:	6813      	ldr	r3, [r2, #0]
 802c950:	e6bc      	b.n	802c6cc <_malloc_r+0x29c>
 802c952:	f240 5154 	movw	r1, #1364	; 0x554
 802c956:	428a      	cmp	r2, r1
 802c958:	d805      	bhi.n	802c966 <_malloc_r+0x536>
 802c95a:	0c9a      	lsrs	r2, r3, #18
 802c95c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
 802c960:	00c9      	lsls	r1, r1, #3
 802c962:	327c      	adds	r2, #124	; 0x7c
 802c964:	e745      	b.n	802c7f2 <_malloc_r+0x3c2>
 802c966:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
 802c96a:	227e      	movs	r2, #126	; 0x7e
 802c96c:	e741      	b.n	802c7f2 <_malloc_r+0x3c2>
 802c96e:	687b      	ldr	r3, [r7, #4]
 802c970:	e785      	b.n	802c87e <_malloc_r+0x44e>
 802c972:	bf00      	nop
 802c974:	20011c90 	.word	0x20011c90
	...

0802c980 <__malloc_lock>:
 802c980:	4801      	ldr	r0, [pc, #4]	; (802c988 <__malloc_lock+0x8>)
 802c982:	f7ff bd45 	b.w	802c410 <__retarget_lock_acquire_recursive>
 802c986:	bf00      	nop
 802c988:	20011cd4 	.word	0x20011cd4
 802c98c:	00000000 	.word	0x00000000

0802c990 <__malloc_unlock>:
 802c990:	4801      	ldr	r0, [pc, #4]	; (802c998 <__malloc_unlock+0x8>)
 802c992:	f7ff bd45 	b.w	802c420 <__retarget_lock_release_recursive>
 802c996:	bf00      	nop
 802c998:	20011cd4 	.word	0x20011cd4
 802c99c:	00000000 	.word	0x00000000

0802c9a0 <_Balloc>:
 802c9a0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802c9a2:	b570      	push	{r4, r5, r6, lr}
 802c9a4:	4605      	mov	r5, r0
 802c9a6:	460c      	mov	r4, r1
 802c9a8:	b14b      	cbz	r3, 802c9be <_Balloc+0x1e>
 802c9aa:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 802c9ae:	b180      	cbz	r0, 802c9d2 <_Balloc+0x32>
 802c9b0:	6802      	ldr	r2, [r0, #0]
 802c9b2:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 802c9b6:	2300      	movs	r3, #0
 802c9b8:	e9c0 3303 	strd	r3, r3, [r0, #12]
 802c9bc:	bd70      	pop	{r4, r5, r6, pc}
 802c9be:	2221      	movs	r2, #33	; 0x21
 802c9c0:	2104      	movs	r1, #4
 802c9c2:	f000 fefd 	bl	802d7c0 <_calloc_r>
 802c9c6:	4603      	mov	r3, r0
 802c9c8:	64e8      	str	r0, [r5, #76]	; 0x4c
 802c9ca:	2800      	cmp	r0, #0
 802c9cc:	d1ed      	bne.n	802c9aa <_Balloc+0xa>
 802c9ce:	2000      	movs	r0, #0
 802c9d0:	bd70      	pop	{r4, r5, r6, pc}
 802c9d2:	2101      	movs	r1, #1
 802c9d4:	fa01 f604 	lsl.w	r6, r1, r4
 802c9d8:	1d72      	adds	r2, r6, #5
 802c9da:	4628      	mov	r0, r5
 802c9dc:	0092      	lsls	r2, r2, #2
 802c9de:	f000 feef 	bl	802d7c0 <_calloc_r>
 802c9e2:	2800      	cmp	r0, #0
 802c9e4:	d0f3      	beq.n	802c9ce <_Balloc+0x2e>
 802c9e6:	e9c0 4601 	strd	r4, r6, [r0, #4]
 802c9ea:	e7e4      	b.n	802c9b6 <_Balloc+0x16>
 802c9ec:	0000      	movs	r0, r0
	...

0802c9f0 <_Bfree>:
 802c9f0:	b131      	cbz	r1, 802ca00 <_Bfree+0x10>
 802c9f2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802c9f4:	684a      	ldr	r2, [r1, #4]
 802c9f6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 802c9fa:	6008      	str	r0, [r1, #0]
 802c9fc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 802ca00:	4770      	bx	lr
 802ca02:	bf00      	nop
	...

0802ca10 <__multadd>:
 802ca10:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ca12:	690c      	ldr	r4, [r1, #16]
 802ca14:	b083      	sub	sp, #12
 802ca16:	460d      	mov	r5, r1
 802ca18:	4606      	mov	r6, r0
 802ca1a:	f101 0c14 	add.w	ip, r1, #20
 802ca1e:	2700      	movs	r7, #0
 802ca20:	f8dc 0000 	ldr.w	r0, [ip]
 802ca24:	b281      	uxth	r1, r0
 802ca26:	fb02 3301 	mla	r3, r2, r1, r3
 802ca2a:	0c01      	lsrs	r1, r0, #16
 802ca2c:	0c18      	lsrs	r0, r3, #16
 802ca2e:	fb02 0101 	mla	r1, r2, r1, r0
 802ca32:	b29b      	uxth	r3, r3
 802ca34:	3701      	adds	r7, #1
 802ca36:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 802ca3a:	42bc      	cmp	r4, r7
 802ca3c:	f84c 3b04 	str.w	r3, [ip], #4
 802ca40:	ea4f 4311 	mov.w	r3, r1, lsr #16
 802ca44:	dcec      	bgt.n	802ca20 <__multadd+0x10>
 802ca46:	b13b      	cbz	r3, 802ca58 <__multadd+0x48>
 802ca48:	68aa      	ldr	r2, [r5, #8]
 802ca4a:	42a2      	cmp	r2, r4
 802ca4c:	dd07      	ble.n	802ca5e <__multadd+0x4e>
 802ca4e:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 802ca52:	3401      	adds	r4, #1
 802ca54:	6153      	str	r3, [r2, #20]
 802ca56:	612c      	str	r4, [r5, #16]
 802ca58:	4628      	mov	r0, r5
 802ca5a:	b003      	add	sp, #12
 802ca5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ca5e:	6869      	ldr	r1, [r5, #4]
 802ca60:	9301      	str	r3, [sp, #4]
 802ca62:	3101      	adds	r1, #1
 802ca64:	4630      	mov	r0, r6
 802ca66:	f7ff ff9b 	bl	802c9a0 <_Balloc>
 802ca6a:	692a      	ldr	r2, [r5, #16]
 802ca6c:	3202      	adds	r2, #2
 802ca6e:	f105 010c 	add.w	r1, r5, #12
 802ca72:	4607      	mov	r7, r0
 802ca74:	0092      	lsls	r2, r2, #2
 802ca76:	300c      	adds	r0, #12
 802ca78:	f7e0 f852 	bl	800cb20 <memcpy>
 802ca7c:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 802ca7e:	6869      	ldr	r1, [r5, #4]
 802ca80:	9b01      	ldr	r3, [sp, #4]
 802ca82:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 802ca86:	6028      	str	r0, [r5, #0]
 802ca88:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 802ca8c:	463d      	mov	r5, r7
 802ca8e:	e7de      	b.n	802ca4e <__multadd+0x3e>

0802ca90 <__s2b>:
 802ca90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802ca94:	4c23      	ldr	r4, [pc, #140]	; (802cb24 <__s2b+0x94>)
 802ca96:	9d08      	ldr	r5, [sp, #32]
 802ca98:	461e      	mov	r6, r3
 802ca9a:	3308      	adds	r3, #8
 802ca9c:	fb84 4c03 	smull	r4, ip, r4, r3
 802caa0:	17db      	asrs	r3, r3, #31
 802caa2:	ebc3 0c6c 	rsb	ip, r3, ip, asr #1
 802caa6:	f1bc 0f01 	cmp.w	ip, #1
 802caaa:	4607      	mov	r7, r0
 802caac:	460c      	mov	r4, r1
 802caae:	4690      	mov	r8, r2
 802cab0:	dd35      	ble.n	802cb1e <__s2b+0x8e>
 802cab2:	2301      	movs	r3, #1
 802cab4:	2100      	movs	r1, #0
 802cab6:	005b      	lsls	r3, r3, #1
 802cab8:	459c      	cmp	ip, r3
 802caba:	f101 0101 	add.w	r1, r1, #1
 802cabe:	dcfa      	bgt.n	802cab6 <__s2b+0x26>
 802cac0:	4638      	mov	r0, r7
 802cac2:	f7ff ff6d 	bl	802c9a0 <_Balloc>
 802cac6:	2301      	movs	r3, #1
 802cac8:	f1b8 0f09 	cmp.w	r8, #9
 802cacc:	e9c0 3504 	strd	r3, r5, [r0, #16]
 802cad0:	dd21      	ble.n	802cb16 <__s2b+0x86>
 802cad2:	f104 0909 	add.w	r9, r4, #9
 802cad6:	464d      	mov	r5, r9
 802cad8:	4444      	add	r4, r8
 802cada:	f815 3b01 	ldrb.w	r3, [r5], #1
 802cade:	4601      	mov	r1, r0
 802cae0:	3b30      	subs	r3, #48	; 0x30
 802cae2:	220a      	movs	r2, #10
 802cae4:	4638      	mov	r0, r7
 802cae6:	f7ff ff93 	bl	802ca10 <__multadd>
 802caea:	42ac      	cmp	r4, r5
 802caec:	d1f5      	bne.n	802cada <__s2b+0x4a>
 802caee:	eb09 0408 	add.w	r4, r9, r8
 802caf2:	3c08      	subs	r4, #8
 802caf4:	4546      	cmp	r6, r8
 802caf6:	dd0c      	ble.n	802cb12 <__s2b+0x82>
 802caf8:	eba6 0608 	sub.w	r6, r6, r8
 802cafc:	4426      	add	r6, r4
 802cafe:	f814 3b01 	ldrb.w	r3, [r4], #1
 802cb02:	4601      	mov	r1, r0
 802cb04:	3b30      	subs	r3, #48	; 0x30
 802cb06:	220a      	movs	r2, #10
 802cb08:	4638      	mov	r0, r7
 802cb0a:	f7ff ff81 	bl	802ca10 <__multadd>
 802cb0e:	42a6      	cmp	r6, r4
 802cb10:	d1f5      	bne.n	802cafe <__s2b+0x6e>
 802cb12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802cb16:	340a      	adds	r4, #10
 802cb18:	f04f 0809 	mov.w	r8, #9
 802cb1c:	e7ea      	b.n	802caf4 <__s2b+0x64>
 802cb1e:	2100      	movs	r1, #0
 802cb20:	e7ce      	b.n	802cac0 <__s2b+0x30>
 802cb22:	bf00      	nop
 802cb24:	38e38e39 	.word	0x38e38e39
	...

0802cb30 <__hi0bits>:
 802cb30:	0c02      	lsrs	r2, r0, #16
 802cb32:	0412      	lsls	r2, r2, #16
 802cb34:	4603      	mov	r3, r0
 802cb36:	b9c2      	cbnz	r2, 802cb6a <__hi0bits+0x3a>
 802cb38:	0403      	lsls	r3, r0, #16
 802cb3a:	2010      	movs	r0, #16
 802cb3c:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 802cb40:	bf04      	itt	eq
 802cb42:	021b      	lsleq	r3, r3, #8
 802cb44:	3008      	addeq	r0, #8
 802cb46:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 802cb4a:	bf04      	itt	eq
 802cb4c:	011b      	lsleq	r3, r3, #4
 802cb4e:	3004      	addeq	r0, #4
 802cb50:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 802cb54:	bf04      	itt	eq
 802cb56:	009b      	lsleq	r3, r3, #2
 802cb58:	3002      	addeq	r0, #2
 802cb5a:	2b00      	cmp	r3, #0
 802cb5c:	db04      	blt.n	802cb68 <__hi0bits+0x38>
 802cb5e:	005b      	lsls	r3, r3, #1
 802cb60:	d501      	bpl.n	802cb66 <__hi0bits+0x36>
 802cb62:	3001      	adds	r0, #1
 802cb64:	4770      	bx	lr
 802cb66:	2020      	movs	r0, #32
 802cb68:	4770      	bx	lr
 802cb6a:	2000      	movs	r0, #0
 802cb6c:	e7e6      	b.n	802cb3c <__hi0bits+0xc>
 802cb6e:	bf00      	nop

0802cb70 <__lo0bits>:
 802cb70:	6803      	ldr	r3, [r0, #0]
 802cb72:	f013 0207 	ands.w	r2, r3, #7
 802cb76:	4601      	mov	r1, r0
 802cb78:	d007      	beq.n	802cb8a <__lo0bits+0x1a>
 802cb7a:	07da      	lsls	r2, r3, #31
 802cb7c:	d41f      	bmi.n	802cbbe <__lo0bits+0x4e>
 802cb7e:	0798      	lsls	r0, r3, #30
 802cb80:	d51f      	bpl.n	802cbc2 <__lo0bits+0x52>
 802cb82:	085b      	lsrs	r3, r3, #1
 802cb84:	600b      	str	r3, [r1, #0]
 802cb86:	2001      	movs	r0, #1
 802cb88:	4770      	bx	lr
 802cb8a:	b298      	uxth	r0, r3
 802cb8c:	b1a0      	cbz	r0, 802cbb8 <__lo0bits+0x48>
 802cb8e:	4610      	mov	r0, r2
 802cb90:	f013 0fff 	tst.w	r3, #255	; 0xff
 802cb94:	bf04      	itt	eq
 802cb96:	0a1b      	lsreq	r3, r3, #8
 802cb98:	3008      	addeq	r0, #8
 802cb9a:	071a      	lsls	r2, r3, #28
 802cb9c:	bf04      	itt	eq
 802cb9e:	091b      	lsreq	r3, r3, #4
 802cba0:	3004      	addeq	r0, #4
 802cba2:	079a      	lsls	r2, r3, #30
 802cba4:	bf04      	itt	eq
 802cba6:	089b      	lsreq	r3, r3, #2
 802cba8:	3002      	addeq	r0, #2
 802cbaa:	07da      	lsls	r2, r3, #31
 802cbac:	d402      	bmi.n	802cbb4 <__lo0bits+0x44>
 802cbae:	085b      	lsrs	r3, r3, #1
 802cbb0:	d00b      	beq.n	802cbca <__lo0bits+0x5a>
 802cbb2:	3001      	adds	r0, #1
 802cbb4:	600b      	str	r3, [r1, #0]
 802cbb6:	4770      	bx	lr
 802cbb8:	0c1b      	lsrs	r3, r3, #16
 802cbba:	2010      	movs	r0, #16
 802cbbc:	e7e8      	b.n	802cb90 <__lo0bits+0x20>
 802cbbe:	2000      	movs	r0, #0
 802cbc0:	4770      	bx	lr
 802cbc2:	089b      	lsrs	r3, r3, #2
 802cbc4:	600b      	str	r3, [r1, #0]
 802cbc6:	2002      	movs	r0, #2
 802cbc8:	4770      	bx	lr
 802cbca:	2020      	movs	r0, #32
 802cbcc:	4770      	bx	lr
 802cbce:	bf00      	nop

0802cbd0 <__i2b>:
 802cbd0:	b510      	push	{r4, lr}
 802cbd2:	460c      	mov	r4, r1
 802cbd4:	2101      	movs	r1, #1
 802cbd6:	f7ff fee3 	bl	802c9a0 <_Balloc>
 802cbda:	2201      	movs	r2, #1
 802cbdc:	e9c0 2404 	strd	r2, r4, [r0, #16]
 802cbe0:	bd10      	pop	{r4, pc}
 802cbe2:	bf00      	nop
	...

0802cbf0 <__multiply>:
 802cbf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802cbf4:	690e      	ldr	r6, [r1, #16]
 802cbf6:	6914      	ldr	r4, [r2, #16]
 802cbf8:	42a6      	cmp	r6, r4
 802cbfa:	b083      	sub	sp, #12
 802cbfc:	460f      	mov	r7, r1
 802cbfe:	4615      	mov	r5, r2
 802cc00:	da04      	bge.n	802cc0c <__multiply+0x1c>
 802cc02:	4632      	mov	r2, r6
 802cc04:	462f      	mov	r7, r5
 802cc06:	4626      	mov	r6, r4
 802cc08:	460d      	mov	r5, r1
 802cc0a:	4614      	mov	r4, r2
 802cc0c:	e9d7 1301 	ldrd	r1, r3, [r7, #4]
 802cc10:	eb06 0804 	add.w	r8, r6, r4
 802cc14:	4543      	cmp	r3, r8
 802cc16:	bfb8      	it	lt
 802cc18:	3101      	addlt	r1, #1
 802cc1a:	f7ff fec1 	bl	802c9a0 <_Balloc>
 802cc1e:	f100 0914 	add.w	r9, r0, #20
 802cc22:	eb09 0e88 	add.w	lr, r9, r8, lsl #2
 802cc26:	45f1      	cmp	r9, lr
 802cc28:	9000      	str	r0, [sp, #0]
 802cc2a:	d205      	bcs.n	802cc38 <__multiply+0x48>
 802cc2c:	464b      	mov	r3, r9
 802cc2e:	2200      	movs	r2, #0
 802cc30:	f843 2b04 	str.w	r2, [r3], #4
 802cc34:	459e      	cmp	lr, r3
 802cc36:	d8fb      	bhi.n	802cc30 <__multiply+0x40>
 802cc38:	f105 0a14 	add.w	sl, r5, #20
 802cc3c:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
 802cc40:	f107 0314 	add.w	r3, r7, #20
 802cc44:	45a2      	cmp	sl, r4
 802cc46:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 802cc4a:	d261      	bcs.n	802cd10 <__multiply+0x120>
 802cc4c:	1b64      	subs	r4, r4, r5
 802cc4e:	3c15      	subs	r4, #21
 802cc50:	f024 0403 	bic.w	r4, r4, #3
 802cc54:	f8cd e004 	str.w	lr, [sp, #4]
 802cc58:	44a2      	add	sl, r4
 802cc5a:	f105 0210 	add.w	r2, r5, #16
 802cc5e:	469e      	mov	lr, r3
 802cc60:	e005      	b.n	802cc6e <__multiply+0x7e>
 802cc62:	0c2d      	lsrs	r5, r5, #16
 802cc64:	d12b      	bne.n	802ccbe <__multiply+0xce>
 802cc66:	4592      	cmp	sl, r2
 802cc68:	f109 0904 	add.w	r9, r9, #4
 802cc6c:	d04e      	beq.n	802cd0c <__multiply+0x11c>
 802cc6e:	f852 5f04 	ldr.w	r5, [r2, #4]!
 802cc72:	fa1f fb85 	uxth.w	fp, r5
 802cc76:	f1bb 0f00 	cmp.w	fp, #0
 802cc7a:	d0f2      	beq.n	802cc62 <__multiply+0x72>
 802cc7c:	4677      	mov	r7, lr
 802cc7e:	464e      	mov	r6, r9
 802cc80:	2000      	movs	r0, #0
 802cc82:	e000      	b.n	802cc86 <__multiply+0x96>
 802cc84:	4626      	mov	r6, r4
 802cc86:	f857 1b04 	ldr.w	r1, [r7], #4
 802cc8a:	6834      	ldr	r4, [r6, #0]
 802cc8c:	b28b      	uxth	r3, r1
 802cc8e:	b2a5      	uxth	r5, r4
 802cc90:	0c09      	lsrs	r1, r1, #16
 802cc92:	0c24      	lsrs	r4, r4, #16
 802cc94:	fb0b 5303 	mla	r3, fp, r3, r5
 802cc98:	4403      	add	r3, r0
 802cc9a:	fb0b 4001 	mla	r0, fp, r1, r4
 802cc9e:	eb00 4013 	add.w	r0, r0, r3, lsr #16
 802cca2:	4634      	mov	r4, r6
 802cca4:	b29b      	uxth	r3, r3
 802cca6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 802ccaa:	45bc      	cmp	ip, r7
 802ccac:	ea4f 4010 	mov.w	r0, r0, lsr #16
 802ccb0:	f844 3b04 	str.w	r3, [r4], #4
 802ccb4:	d8e6      	bhi.n	802cc84 <__multiply+0x94>
 802ccb6:	6070      	str	r0, [r6, #4]
 802ccb8:	6815      	ldr	r5, [r2, #0]
 802ccba:	0c2d      	lsrs	r5, r5, #16
 802ccbc:	d0d3      	beq.n	802cc66 <__multiply+0x76>
 802ccbe:	f8d9 3000 	ldr.w	r3, [r9]
 802ccc2:	4676      	mov	r6, lr
 802ccc4:	4618      	mov	r0, r3
 802ccc6:	46cb      	mov	fp, r9
 802ccc8:	2100      	movs	r1, #0
 802ccca:	e000      	b.n	802ccce <__multiply+0xde>
 802cccc:	46a3      	mov	fp, r4
 802ccce:	8834      	ldrh	r4, [r6, #0]
 802ccd0:	0c00      	lsrs	r0, r0, #16
 802ccd2:	fb05 0004 	mla	r0, r5, r4, r0
 802ccd6:	4401      	add	r1, r0
 802ccd8:	b29b      	uxth	r3, r3
 802ccda:	465c      	mov	r4, fp
 802ccdc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 802cce0:	f844 3b04 	str.w	r3, [r4], #4
 802cce4:	f856 3b04 	ldr.w	r3, [r6], #4
 802cce8:	f8db 0004 	ldr.w	r0, [fp, #4]
 802ccec:	0c1b      	lsrs	r3, r3, #16
 802ccee:	b287      	uxth	r7, r0
 802ccf0:	fb05 7303 	mla	r3, r5, r3, r7
 802ccf4:	eb03 4311 	add.w	r3, r3, r1, lsr #16
 802ccf8:	45b4      	cmp	ip, r6
 802ccfa:	ea4f 4113 	mov.w	r1, r3, lsr #16
 802ccfe:	d8e5      	bhi.n	802cccc <__multiply+0xdc>
 802cd00:	4592      	cmp	sl, r2
 802cd02:	f8cb 3004 	str.w	r3, [fp, #4]
 802cd06:	f109 0904 	add.w	r9, r9, #4
 802cd0a:	d1b0      	bne.n	802cc6e <__multiply+0x7e>
 802cd0c:	f8dd e004 	ldr.w	lr, [sp, #4]
 802cd10:	f1b8 0f00 	cmp.w	r8, #0
 802cd14:	dd0b      	ble.n	802cd2e <__multiply+0x13e>
 802cd16:	f85e 3c04 	ldr.w	r3, [lr, #-4]
 802cd1a:	f1ae 0e04 	sub.w	lr, lr, #4
 802cd1e:	b11b      	cbz	r3, 802cd28 <__multiply+0x138>
 802cd20:	e005      	b.n	802cd2e <__multiply+0x13e>
 802cd22:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
 802cd26:	b913      	cbnz	r3, 802cd2e <__multiply+0x13e>
 802cd28:	f1b8 0801 	subs.w	r8, r8, #1
 802cd2c:	d1f9      	bne.n	802cd22 <__multiply+0x132>
 802cd2e:	9800      	ldr	r0, [sp, #0]
 802cd30:	f8c0 8010 	str.w	r8, [r0, #16]
 802cd34:	b003      	add	sp, #12
 802cd36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cd3a:	bf00      	nop
 802cd3c:	0000      	movs	r0, r0
	...

0802cd40 <__pow5mult>:
 802cd40:	f012 0303 	ands.w	r3, r2, #3
 802cd44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802cd48:	4614      	mov	r4, r2
 802cd4a:	4607      	mov	r7, r0
 802cd4c:	d12e      	bne.n	802cdac <__pow5mult+0x6c>
 802cd4e:	460d      	mov	r5, r1
 802cd50:	10a4      	asrs	r4, r4, #2
 802cd52:	d01c      	beq.n	802cd8e <__pow5mult+0x4e>
 802cd54:	6cbe      	ldr	r6, [r7, #72]	; 0x48
 802cd56:	b396      	cbz	r6, 802cdbe <__pow5mult+0x7e>
 802cd58:	07e3      	lsls	r3, r4, #31
 802cd5a:	f04f 0800 	mov.w	r8, #0
 802cd5e:	d406      	bmi.n	802cd6e <__pow5mult+0x2e>
 802cd60:	1064      	asrs	r4, r4, #1
 802cd62:	d014      	beq.n	802cd8e <__pow5mult+0x4e>
 802cd64:	6830      	ldr	r0, [r6, #0]
 802cd66:	b1a8      	cbz	r0, 802cd94 <__pow5mult+0x54>
 802cd68:	4606      	mov	r6, r0
 802cd6a:	07e3      	lsls	r3, r4, #31
 802cd6c:	d5f8      	bpl.n	802cd60 <__pow5mult+0x20>
 802cd6e:	4632      	mov	r2, r6
 802cd70:	4629      	mov	r1, r5
 802cd72:	4638      	mov	r0, r7
 802cd74:	f7ff ff3c 	bl	802cbf0 <__multiply>
 802cd78:	b1b5      	cbz	r5, 802cda8 <__pow5mult+0x68>
 802cd7a:	686a      	ldr	r2, [r5, #4]
 802cd7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802cd7e:	1064      	asrs	r4, r4, #1
 802cd80:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 802cd84:	6029      	str	r1, [r5, #0]
 802cd86:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 802cd8a:	4605      	mov	r5, r0
 802cd8c:	d1ea      	bne.n	802cd64 <__pow5mult+0x24>
 802cd8e:	4628      	mov	r0, r5
 802cd90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802cd94:	4632      	mov	r2, r6
 802cd96:	4631      	mov	r1, r6
 802cd98:	4638      	mov	r0, r7
 802cd9a:	f7ff ff29 	bl	802cbf0 <__multiply>
 802cd9e:	6030      	str	r0, [r6, #0]
 802cda0:	f8c0 8000 	str.w	r8, [r0]
 802cda4:	4606      	mov	r6, r0
 802cda6:	e7e0      	b.n	802cd6a <__pow5mult+0x2a>
 802cda8:	4605      	mov	r5, r0
 802cdaa:	e7d9      	b.n	802cd60 <__pow5mult+0x20>
 802cdac:	3b01      	subs	r3, #1
 802cdae:	4a0b      	ldr	r2, [pc, #44]	; (802cddc <__pow5mult+0x9c>)
 802cdb0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802cdb4:	2300      	movs	r3, #0
 802cdb6:	f7ff fe2b 	bl	802ca10 <__multadd>
 802cdba:	4605      	mov	r5, r0
 802cdbc:	e7c8      	b.n	802cd50 <__pow5mult+0x10>
 802cdbe:	2101      	movs	r1, #1
 802cdc0:	4638      	mov	r0, r7
 802cdc2:	f7ff fded 	bl	802c9a0 <_Balloc>
 802cdc6:	f240 2371 	movw	r3, #625	; 0x271
 802cdca:	6143      	str	r3, [r0, #20]
 802cdcc:	2201      	movs	r2, #1
 802cdce:	2300      	movs	r3, #0
 802cdd0:	6102      	str	r2, [r0, #16]
 802cdd2:	4606      	mov	r6, r0
 802cdd4:	64b8      	str	r0, [r7, #72]	; 0x48
 802cdd6:	6003      	str	r3, [r0, #0]
 802cdd8:	e7be      	b.n	802cd58 <__pow5mult+0x18>
 802cdda:	bf00      	nop
 802cddc:	08030310 	.word	0x08030310

0802cde0 <__lshift>:
 802cde0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802cde4:	4691      	mov	r9, r2
 802cde6:	690a      	ldr	r2, [r1, #16]
 802cde8:	460e      	mov	r6, r1
 802cdea:	ea4f 1469 	mov.w	r4, r9, asr #5
 802cdee:	e9d1 1301 	ldrd	r1, r3, [r1, #4]
 802cdf2:	eb04 0802 	add.w	r8, r4, r2
 802cdf6:	f108 0501 	add.w	r5, r8, #1
 802cdfa:	429d      	cmp	r5, r3
 802cdfc:	4607      	mov	r7, r0
 802cdfe:	dd04      	ble.n	802ce0a <__lshift+0x2a>
 802ce00:	005b      	lsls	r3, r3, #1
 802ce02:	429d      	cmp	r5, r3
 802ce04:	f101 0101 	add.w	r1, r1, #1
 802ce08:	dcfa      	bgt.n	802ce00 <__lshift+0x20>
 802ce0a:	4638      	mov	r0, r7
 802ce0c:	f7ff fdc8 	bl	802c9a0 <_Balloc>
 802ce10:	2c00      	cmp	r4, #0
 802ce12:	f100 0314 	add.w	r3, r0, #20
 802ce16:	dd37      	ble.n	802ce88 <__lshift+0xa8>
 802ce18:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 802ce1c:	2200      	movs	r2, #0
 802ce1e:	f843 2b04 	str.w	r2, [r3], #4
 802ce22:	428b      	cmp	r3, r1
 802ce24:	d1fb      	bne.n	802ce1e <__lshift+0x3e>
 802ce26:	6934      	ldr	r4, [r6, #16]
 802ce28:	f106 0314 	add.w	r3, r6, #20
 802ce2c:	f019 091f 	ands.w	r9, r9, #31
 802ce30:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
 802ce34:	d020      	beq.n	802ce78 <__lshift+0x98>
 802ce36:	f1c9 0e20 	rsb	lr, r9, #32
 802ce3a:	2200      	movs	r2, #0
 802ce3c:	e000      	b.n	802ce40 <__lshift+0x60>
 802ce3e:	4651      	mov	r1, sl
 802ce40:	681c      	ldr	r4, [r3, #0]
 802ce42:	468a      	mov	sl, r1
 802ce44:	fa04 f409 	lsl.w	r4, r4, r9
 802ce48:	4314      	orrs	r4, r2
 802ce4a:	f84a 4b04 	str.w	r4, [sl], #4
 802ce4e:	f853 2b04 	ldr.w	r2, [r3], #4
 802ce52:	4563      	cmp	r3, ip
 802ce54:	fa22 f20e 	lsr.w	r2, r2, lr
 802ce58:	d3f1      	bcc.n	802ce3e <__lshift+0x5e>
 802ce5a:	604a      	str	r2, [r1, #4]
 802ce5c:	b10a      	cbz	r2, 802ce62 <__lshift+0x82>
 802ce5e:	f108 0502 	add.w	r5, r8, #2
 802ce62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802ce64:	6872      	ldr	r2, [r6, #4]
 802ce66:	3d01      	subs	r5, #1
 802ce68:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 802ce6c:	6105      	str	r5, [r0, #16]
 802ce6e:	6031      	str	r1, [r6, #0]
 802ce70:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 802ce74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802ce78:	3904      	subs	r1, #4
 802ce7a:	f853 2b04 	ldr.w	r2, [r3], #4
 802ce7e:	f841 2f04 	str.w	r2, [r1, #4]!
 802ce82:	459c      	cmp	ip, r3
 802ce84:	d8f9      	bhi.n	802ce7a <__lshift+0x9a>
 802ce86:	e7ec      	b.n	802ce62 <__lshift+0x82>
 802ce88:	4619      	mov	r1, r3
 802ce8a:	e7cc      	b.n	802ce26 <__lshift+0x46>
 802ce8c:	0000      	movs	r0, r0
	...

0802ce90 <__mcmp>:
 802ce90:	b430      	push	{r4, r5}
 802ce92:	690b      	ldr	r3, [r1, #16]
 802ce94:	4605      	mov	r5, r0
 802ce96:	6900      	ldr	r0, [r0, #16]
 802ce98:	1ac0      	subs	r0, r0, r3
 802ce9a:	d10f      	bne.n	802cebc <__mcmp+0x2c>
 802ce9c:	009b      	lsls	r3, r3, #2
 802ce9e:	3514      	adds	r5, #20
 802cea0:	3114      	adds	r1, #20
 802cea2:	4419      	add	r1, r3
 802cea4:	442b      	add	r3, r5
 802cea6:	e001      	b.n	802ceac <__mcmp+0x1c>
 802cea8:	429d      	cmp	r5, r3
 802ceaa:	d207      	bcs.n	802cebc <__mcmp+0x2c>
 802ceac:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 802ceb0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 802ceb4:	4294      	cmp	r4, r2
 802ceb6:	d0f7      	beq.n	802cea8 <__mcmp+0x18>
 802ceb8:	d302      	bcc.n	802cec0 <__mcmp+0x30>
 802ceba:	2001      	movs	r0, #1
 802cebc:	bc30      	pop	{r4, r5}
 802cebe:	4770      	bx	lr
 802cec0:	f04f 30ff 	mov.w	r0, #4294967295
 802cec4:	e7fa      	b.n	802cebc <__mcmp+0x2c>
 802cec6:	bf00      	nop
	...

0802ced0 <__mdiff>:
 802ced0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ced4:	6913      	ldr	r3, [r2, #16]
 802ced6:	690d      	ldr	r5, [r1, #16]
 802ced8:	1aed      	subs	r5, r5, r3
 802ceda:	2d00      	cmp	r5, #0
 802cedc:	460e      	mov	r6, r1
 802cede:	4690      	mov	r8, r2
 802cee0:	f101 0414 	add.w	r4, r1, #20
 802cee4:	f102 0714 	add.w	r7, r2, #20
 802cee8:	d114      	bne.n	802cf14 <__mdiff+0x44>
 802ceea:	009b      	lsls	r3, r3, #2
 802ceec:	18e2      	adds	r2, r4, r3
 802ceee:	443b      	add	r3, r7
 802cef0:	e001      	b.n	802cef6 <__mdiff+0x26>
 802cef2:	42a2      	cmp	r2, r4
 802cef4:	d959      	bls.n	802cfaa <__mdiff+0xda>
 802cef6:	f852 cd04 	ldr.w	ip, [r2, #-4]!
 802cefa:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 802cefe:	458c      	cmp	ip, r1
 802cf00:	d0f7      	beq.n	802cef2 <__mdiff+0x22>
 802cf02:	d209      	bcs.n	802cf18 <__mdiff+0x48>
 802cf04:	4622      	mov	r2, r4
 802cf06:	4633      	mov	r3, r6
 802cf08:	463c      	mov	r4, r7
 802cf0a:	4646      	mov	r6, r8
 802cf0c:	4617      	mov	r7, r2
 802cf0e:	4698      	mov	r8, r3
 802cf10:	2501      	movs	r5, #1
 802cf12:	e001      	b.n	802cf18 <__mdiff+0x48>
 802cf14:	dbf6      	blt.n	802cf04 <__mdiff+0x34>
 802cf16:	2500      	movs	r5, #0
 802cf18:	6871      	ldr	r1, [r6, #4]
 802cf1a:	f7ff fd41 	bl	802c9a0 <_Balloc>
 802cf1e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 802cf22:	6936      	ldr	r6, [r6, #16]
 802cf24:	60c5      	str	r5, [r0, #12]
 802cf26:	eb07 0e83 	add.w	lr, r7, r3, lsl #2
 802cf2a:	46bc      	mov	ip, r7
 802cf2c:	f100 0514 	add.w	r5, r0, #20
 802cf30:	eb04 0786 	add.w	r7, r4, r6, lsl #2
 802cf34:	2300      	movs	r3, #0
 802cf36:	f85c 1b04 	ldr.w	r1, [ip], #4
 802cf3a:	f854 8b04 	ldr.w	r8, [r4], #4
 802cf3e:	b28a      	uxth	r2, r1
 802cf40:	fa13 f388 	uxtah	r3, r3, r8
 802cf44:	0c09      	lsrs	r1, r1, #16
 802cf46:	1a9a      	subs	r2, r3, r2
 802cf48:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
 802cf4c:	eb03 4322 	add.w	r3, r3, r2, asr #16
 802cf50:	b292      	uxth	r2, r2
 802cf52:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 802cf56:	45e6      	cmp	lr, ip
 802cf58:	f845 2b04 	str.w	r2, [r5], #4
 802cf5c:	ea4f 4323 	mov.w	r3, r3, asr #16
 802cf60:	d8e9      	bhi.n	802cf36 <__mdiff+0x66>
 802cf62:	42a7      	cmp	r7, r4
 802cf64:	d917      	bls.n	802cf96 <__mdiff+0xc6>
 802cf66:	46ae      	mov	lr, r5
 802cf68:	46a4      	mov	ip, r4
 802cf6a:	f85c 2b04 	ldr.w	r2, [ip], #4
 802cf6e:	fa13 f382 	uxtah	r3, r3, r2
 802cf72:	1419      	asrs	r1, r3, #16
 802cf74:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 802cf78:	b29b      	uxth	r3, r3
 802cf7a:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
 802cf7e:	4567      	cmp	r7, ip
 802cf80:	f84e 2b04 	str.w	r2, [lr], #4
 802cf84:	ea4f 4321 	mov.w	r3, r1, asr #16
 802cf88:	d8ef      	bhi.n	802cf6a <__mdiff+0x9a>
 802cf8a:	43e4      	mvns	r4, r4
 802cf8c:	4427      	add	r7, r4
 802cf8e:	f027 0703 	bic.w	r7, r7, #3
 802cf92:	3704      	adds	r7, #4
 802cf94:	443d      	add	r5, r7
 802cf96:	3d04      	subs	r5, #4
 802cf98:	b922      	cbnz	r2, 802cfa4 <__mdiff+0xd4>
 802cf9a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 802cf9e:	3e01      	subs	r6, #1
 802cfa0:	2b00      	cmp	r3, #0
 802cfa2:	d0fa      	beq.n	802cf9a <__mdiff+0xca>
 802cfa4:	6106      	str	r6, [r0, #16]
 802cfa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802cfaa:	2100      	movs	r1, #0
 802cfac:	f7ff fcf8 	bl	802c9a0 <_Balloc>
 802cfb0:	2201      	movs	r2, #1
 802cfb2:	2300      	movs	r3, #0
 802cfb4:	e9c0 2304 	strd	r2, r3, [r0, #16]
 802cfb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802cfbc:	0000      	movs	r0, r0
	...

0802cfc0 <__ulp>:
 802cfc0:	4b13      	ldr	r3, [pc, #76]	; (802d010 <__ulp+0x50>)
 802cfc2:	ee10 2a90 	vmov	r2, s1
 802cfc6:	401a      	ands	r2, r3
 802cfc8:	f1a2 7350 	sub.w	r3, r2, #54525952	; 0x3400000
 802cfcc:	2b00      	cmp	r3, #0
 802cfce:	dd04      	ble.n	802cfda <__ulp+0x1a>
 802cfd0:	2000      	movs	r0, #0
 802cfd2:	4619      	mov	r1, r3
 802cfd4:	ec41 0b10 	vmov	d0, r0, r1
 802cfd8:	4770      	bx	lr
 802cfda:	425b      	negs	r3, r3
 802cfdc:	151b      	asrs	r3, r3, #20
 802cfde:	2b13      	cmp	r3, #19
 802cfe0:	dd0d      	ble.n	802cffe <__ulp+0x3e>
 802cfe2:	3b14      	subs	r3, #20
 802cfe4:	2b1e      	cmp	r3, #30
 802cfe6:	bfdd      	ittte	le
 802cfe8:	f1c3 031f 	rsble	r3, r3, #31
 802cfec:	2201      	movle	r2, #1
 802cfee:	fa02 f303 	lslle.w	r3, r2, r3
 802cff2:	2301      	movgt	r3, #1
 802cff4:	2100      	movs	r1, #0
 802cff6:	4618      	mov	r0, r3
 802cff8:	ec41 0b10 	vmov	d0, r0, r1
 802cffc:	4770      	bx	lr
 802cffe:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 802d002:	2000      	movs	r0, #0
 802d004:	fa42 f103 	asr.w	r1, r2, r3
 802d008:	ec41 0b10 	vmov	d0, r0, r1
 802d00c:	4770      	bx	lr
 802d00e:	bf00      	nop
 802d010:	7ff00000 	.word	0x7ff00000
	...

0802d020 <__b2d>:
 802d020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d022:	6904      	ldr	r4, [r0, #16]
 802d024:	f100 0614 	add.w	r6, r0, #20
 802d028:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 802d02c:	f854 5c04 	ldr.w	r5, [r4, #-4]
 802d030:	4628      	mov	r0, r5
 802d032:	f7ff fd7d 	bl	802cb30 <__hi0bits>
 802d036:	f1c0 0320 	rsb	r3, r0, #32
 802d03a:	280a      	cmp	r0, #10
 802d03c:	600b      	str	r3, [r1, #0]
 802d03e:	f1a4 0104 	sub.w	r1, r4, #4
 802d042:	dc17      	bgt.n	802d074 <__b2d+0x54>
 802d044:	428e      	cmp	r6, r1
 802d046:	f1c0 070b 	rsb	r7, r0, #11
 802d04a:	bf38      	it	cc
 802d04c:	f854 1c08 	ldrcc.w	r1, [r4, #-8]
 802d050:	fa25 fc07 	lsr.w	ip, r5, r7
 802d054:	f100 0015 	add.w	r0, r0, #21
 802d058:	f04c 537f 	orr.w	r3, ip, #1069547520	; 0x3fc00000
 802d05c:	bf34      	ite	cc
 802d05e:	40f9      	lsrcc	r1, r7
 802d060:	2100      	movcs	r1, #0
 802d062:	fa05 f000 	lsl.w	r0, r5, r0
 802d066:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 802d06a:	ea40 0201 	orr.w	r2, r0, r1
 802d06e:	ec43 2b10 	vmov	d0, r2, r3
 802d072:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802d074:	428e      	cmp	r6, r1
 802d076:	f1a0 000b 	sub.w	r0, r0, #11
 802d07a:	d21c      	bcs.n	802d0b6 <__b2d+0x96>
 802d07c:	f854 1c08 	ldr.w	r1, [r4, #-8]
 802d080:	b1d8      	cbz	r0, 802d0ba <__b2d+0x9a>
 802d082:	4085      	lsls	r5, r0
 802d084:	f1c0 0c20 	rsb	ip, r0, #32
 802d088:	f045 557f 	orr.w	r5, r5, #1069547520	; 0x3fc00000
 802d08c:	f1a4 0708 	sub.w	r7, r4, #8
 802d090:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
 802d094:	fa21 fe0c 	lsr.w	lr, r1, ip
 802d098:	42be      	cmp	r6, r7
 802d09a:	fa01 f000 	lsl.w	r0, r1, r0
 802d09e:	ea45 030e 	orr.w	r3, r5, lr
 802d0a2:	d204      	bcs.n	802d0ae <__b2d+0x8e>
 802d0a4:	f854 1c0c 	ldr.w	r1, [r4, #-12]
 802d0a8:	fa21 f10c 	lsr.w	r1, r1, ip
 802d0ac:	4308      	orrs	r0, r1
 802d0ae:	4602      	mov	r2, r0
 802d0b0:	ec43 2b10 	vmov	d0, r2, r3
 802d0b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802d0b6:	b940      	cbnz	r0, 802d0ca <__b2d+0xaa>
 802d0b8:	4601      	mov	r1, r0
 802d0ba:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
 802d0be:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 802d0c2:	460a      	mov	r2, r1
 802d0c4:	ec43 2b10 	vmov	d0, r2, r3
 802d0c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802d0ca:	fa05 f000 	lsl.w	r0, r5, r0
 802d0ce:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
 802d0d2:	2000      	movs	r0, #0
 802d0d4:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 802d0d8:	4602      	mov	r2, r0
 802d0da:	e7e9      	b.n	802d0b0 <__b2d+0x90>
 802d0dc:	0000      	movs	r0, r0
	...

0802d0e0 <__d2b>:
 802d0e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802d0e4:	460f      	mov	r7, r1
 802d0e6:	b083      	sub	sp, #12
 802d0e8:	2101      	movs	r1, #1
 802d0ea:	ec55 4b10 	vmov	r4, r5, d0
 802d0ee:	4616      	mov	r6, r2
 802d0f0:	f7ff fc56 	bl	802c9a0 <_Balloc>
 802d0f4:	f3c5 580a 	ubfx	r8, r5, #20, #11
 802d0f8:	4681      	mov	r9, r0
 802d0fa:	f3c5 0313 	ubfx	r3, r5, #0, #20
 802d0fe:	f1b8 0f00 	cmp.w	r8, #0
 802d102:	d001      	beq.n	802d108 <__d2b+0x28>
 802d104:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802d108:	2c00      	cmp	r4, #0
 802d10a:	9301      	str	r3, [sp, #4]
 802d10c:	d024      	beq.n	802d158 <__d2b+0x78>
 802d10e:	a802      	add	r0, sp, #8
 802d110:	f840 4d08 	str.w	r4, [r0, #-8]!
 802d114:	f7ff fd2c 	bl	802cb70 <__lo0bits>
 802d118:	2800      	cmp	r0, #0
 802d11a:	d136      	bne.n	802d18a <__d2b+0xaa>
 802d11c:	e9dd 2300 	ldrd	r2, r3, [sp]
 802d120:	f8c9 2014 	str.w	r2, [r9, #20]
 802d124:	2b00      	cmp	r3, #0
 802d126:	bf0c      	ite	eq
 802d128:	2101      	moveq	r1, #1
 802d12a:	2102      	movne	r1, #2
 802d12c:	f8c9 3018 	str.w	r3, [r9, #24]
 802d130:	f8c9 1010 	str.w	r1, [r9, #16]
 802d134:	f1b8 0f00 	cmp.w	r8, #0
 802d138:	d11b      	bne.n	802d172 <__d2b+0x92>
 802d13a:	eb09 0381 	add.w	r3, r9, r1, lsl #2
 802d13e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 802d142:	6038      	str	r0, [r7, #0]
 802d144:	6918      	ldr	r0, [r3, #16]
 802d146:	f7ff fcf3 	bl	802cb30 <__hi0bits>
 802d14a:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 802d14e:	6030      	str	r0, [r6, #0]
 802d150:	4648      	mov	r0, r9
 802d152:	b003      	add	sp, #12
 802d154:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802d158:	a801      	add	r0, sp, #4
 802d15a:	f7ff fd09 	bl	802cb70 <__lo0bits>
 802d15e:	9b01      	ldr	r3, [sp, #4]
 802d160:	f8c9 3014 	str.w	r3, [r9, #20]
 802d164:	2101      	movs	r1, #1
 802d166:	3020      	adds	r0, #32
 802d168:	f8c9 1010 	str.w	r1, [r9, #16]
 802d16c:	f1b8 0f00 	cmp.w	r8, #0
 802d170:	d0e3      	beq.n	802d13a <__d2b+0x5a>
 802d172:	f2a8 4833 	subw	r8, r8, #1075	; 0x433
 802d176:	eb08 0300 	add.w	r3, r8, r0
 802d17a:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 802d17e:	603b      	str	r3, [r7, #0]
 802d180:	6030      	str	r0, [r6, #0]
 802d182:	4648      	mov	r0, r9
 802d184:	b003      	add	sp, #12
 802d186:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802d18a:	e9dd 1300 	ldrd	r1, r3, [sp]
 802d18e:	f1c0 0220 	rsb	r2, r0, #32
 802d192:	fa03 f202 	lsl.w	r2, r3, r2
 802d196:	430a      	orrs	r2, r1
 802d198:	40c3      	lsrs	r3, r0
 802d19a:	9301      	str	r3, [sp, #4]
 802d19c:	f8c9 2014 	str.w	r2, [r9, #20]
 802d1a0:	e7c0      	b.n	802d124 <__d2b+0x44>
 802d1a2:	bf00      	nop
	...

0802d1b0 <__ratio>:
 802d1b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802d1b4:	b083      	sub	sp, #12
 802d1b6:	4688      	mov	r8, r1
 802d1b8:	4669      	mov	r1, sp
 802d1ba:	4681      	mov	r9, r0
 802d1bc:	f7ff ff30 	bl	802d020 <__b2d>
 802d1c0:	4640      	mov	r0, r8
 802d1c2:	a901      	add	r1, sp, #4
 802d1c4:	ec55 4b10 	vmov	r4, r5, d0
 802d1c8:	f7ff ff2a 	bl	802d020 <__b2d>
 802d1cc:	e9dd 1300 	ldrd	r1, r3, [sp]
 802d1d0:	f8d9 2010 	ldr.w	r2, [r9, #16]
 802d1d4:	f8d8 0010 	ldr.w	r0, [r8, #16]
 802d1d8:	1acb      	subs	r3, r1, r3
 802d1da:	1a12      	subs	r2, r2, r0
 802d1dc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 802d1e0:	2b00      	cmp	r3, #0
 802d1e2:	ec57 6b10 	vmov	r6, r7, d0
 802d1e6:	dd0d      	ble.n	802d204 <__ratio+0x54>
 802d1e8:	eb05 5903 	add.w	r9, r5, r3, lsl #20
 802d1ec:	464d      	mov	r5, r9
 802d1ee:	4632      	mov	r2, r6
 802d1f0:	463b      	mov	r3, r7
 802d1f2:	4620      	mov	r0, r4
 802d1f4:	4629      	mov	r1, r5
 802d1f6:	f7df fa8d 	bl	800c714 <__aeabi_ddiv>
 802d1fa:	ec41 0b10 	vmov	d0, r0, r1
 802d1fe:	b003      	add	sp, #12
 802d200:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802d204:	ebc3 3303 	rsb	r3, r3, r3, lsl #12
 802d208:	eb07 5103 	add.w	r1, r7, r3, lsl #20
 802d20c:	460f      	mov	r7, r1
 802d20e:	e7ee      	b.n	802d1ee <__ratio+0x3e>

0802d210 <__copybits>:
 802d210:	b470      	push	{r4, r5, r6}
 802d212:	6914      	ldr	r4, [r2, #16]
 802d214:	1e4d      	subs	r5, r1, #1
 802d216:	f102 0314 	add.w	r3, r2, #20
 802d21a:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 802d21e:	116d      	asrs	r5, r5, #5
 802d220:	3501      	adds	r5, #1
 802d222:	428b      	cmp	r3, r1
 802d224:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 802d228:	d20c      	bcs.n	802d244 <__copybits+0x34>
 802d22a:	1f05      	subs	r5, r0, #4
 802d22c:	f853 6b04 	ldr.w	r6, [r3], #4
 802d230:	f845 6f04 	str.w	r6, [r5, #4]!
 802d234:	4299      	cmp	r1, r3
 802d236:	d8f9      	bhi.n	802d22c <__copybits+0x1c>
 802d238:	1a8b      	subs	r3, r1, r2
 802d23a:	3b15      	subs	r3, #21
 802d23c:	f023 0303 	bic.w	r3, r3, #3
 802d240:	3304      	adds	r3, #4
 802d242:	4418      	add	r0, r3
 802d244:	4284      	cmp	r4, r0
 802d246:	d904      	bls.n	802d252 <__copybits+0x42>
 802d248:	2300      	movs	r3, #0
 802d24a:	f840 3b04 	str.w	r3, [r0], #4
 802d24e:	4284      	cmp	r4, r0
 802d250:	d8fb      	bhi.n	802d24a <__copybits+0x3a>
 802d252:	bc70      	pop	{r4, r5, r6}
 802d254:	4770      	bx	lr
 802d256:	bf00      	nop
	...

0802d260 <__any_on>:
 802d260:	6903      	ldr	r3, [r0, #16]
 802d262:	b410      	push	{r4}
 802d264:	114c      	asrs	r4, r1, #5
 802d266:	42a3      	cmp	r3, r4
 802d268:	f100 0214 	add.w	r2, r0, #20
 802d26c:	da10      	bge.n	802d290 <__any_on+0x30>
 802d26e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802d272:	429a      	cmp	r2, r3
 802d274:	d21e      	bcs.n	802d2b4 <__any_on+0x54>
 802d276:	f853 0c04 	ldr.w	r0, [r3, #-4]
 802d27a:	3b04      	subs	r3, #4
 802d27c:	b118      	cbz	r0, 802d286 <__any_on+0x26>
 802d27e:	e015      	b.n	802d2ac <__any_on+0x4c>
 802d280:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 802d284:	b991      	cbnz	r1, 802d2ac <__any_on+0x4c>
 802d286:	429a      	cmp	r2, r3
 802d288:	d3fa      	bcc.n	802d280 <__any_on+0x20>
 802d28a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802d28e:	4770      	bx	lr
 802d290:	eb02 0384 	add.w	r3, r2, r4, lsl #2
 802d294:	dded      	ble.n	802d272 <__any_on+0x12>
 802d296:	f011 011f 	ands.w	r1, r1, #31
 802d29a:	d0ea      	beq.n	802d272 <__any_on+0x12>
 802d29c:	f852 4024 	ldr.w	r4, [r2, r4, lsl #2]
 802d2a0:	fa24 f001 	lsr.w	r0, r4, r1
 802d2a4:	fa00 f101 	lsl.w	r1, r0, r1
 802d2a8:	428c      	cmp	r4, r1
 802d2aa:	d0e2      	beq.n	802d272 <__any_on+0x12>
 802d2ac:	2001      	movs	r0, #1
 802d2ae:	f85d 4b04 	ldr.w	r4, [sp], #4
 802d2b2:	4770      	bx	lr
 802d2b4:	2000      	movs	r0, #0
 802d2b6:	e7e8      	b.n	802d28a <__any_on+0x2a>
	...

0802d2c0 <_realloc_r>:
 802d2c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802d2c4:	4692      	mov	sl, r2
 802d2c6:	b083      	sub	sp, #12
 802d2c8:	2900      	cmp	r1, #0
 802d2ca:	f000 80a1 	beq.w	802d410 <_realloc_r+0x150>
 802d2ce:	460d      	mov	r5, r1
 802d2d0:	4680      	mov	r8, r0
 802d2d2:	f10a 040b 	add.w	r4, sl, #11
 802d2d6:	f7ff fb53 	bl	802c980 <__malloc_lock>
 802d2da:	f855 2c04 	ldr.w	r2, [r5, #-4]
 802d2de:	2c16      	cmp	r4, #22
 802d2e0:	f022 0603 	bic.w	r6, r2, #3
 802d2e4:	f1a5 0708 	sub.w	r7, r5, #8
 802d2e8:	d83e      	bhi.n	802d368 <_realloc_r+0xa8>
 802d2ea:	2410      	movs	r4, #16
 802d2ec:	4621      	mov	r1, r4
 802d2ee:	45a2      	cmp	sl, r4
 802d2f0:	d83f      	bhi.n	802d372 <_realloc_r+0xb2>
 802d2f2:	428e      	cmp	r6, r1
 802d2f4:	eb07 0906 	add.w	r9, r7, r6
 802d2f8:	da74      	bge.n	802d3e4 <_realloc_r+0x124>
 802d2fa:	4bc7      	ldr	r3, [pc, #796]	; (802d618 <_realloc_r+0x358>)
 802d2fc:	6898      	ldr	r0, [r3, #8]
 802d2fe:	4548      	cmp	r0, r9
 802d300:	f000 80aa 	beq.w	802d458 <_realloc_r+0x198>
 802d304:	f8d9 0004 	ldr.w	r0, [r9, #4]
 802d308:	f020 0301 	bic.w	r3, r0, #1
 802d30c:	444b      	add	r3, r9
 802d30e:	685b      	ldr	r3, [r3, #4]
 802d310:	07db      	lsls	r3, r3, #31
 802d312:	f140 8083 	bpl.w	802d41c <_realloc_r+0x15c>
 802d316:	07d2      	lsls	r2, r2, #31
 802d318:	d534      	bpl.n	802d384 <_realloc_r+0xc4>
 802d31a:	4651      	mov	r1, sl
 802d31c:	4640      	mov	r0, r8
 802d31e:	f7ff f887 	bl	802c430 <_malloc_r>
 802d322:	4682      	mov	sl, r0
 802d324:	b1e0      	cbz	r0, 802d360 <_realloc_r+0xa0>
 802d326:	f855 3c04 	ldr.w	r3, [r5, #-4]
 802d32a:	f023 0301 	bic.w	r3, r3, #1
 802d32e:	443b      	add	r3, r7
 802d330:	f1a0 0208 	sub.w	r2, r0, #8
 802d334:	4293      	cmp	r3, r2
 802d336:	f000 80f9 	beq.w	802d52c <_realloc_r+0x26c>
 802d33a:	1f32      	subs	r2, r6, #4
 802d33c:	2a24      	cmp	r2, #36	; 0x24
 802d33e:	f200 8107 	bhi.w	802d550 <_realloc_r+0x290>
 802d342:	2a13      	cmp	r2, #19
 802d344:	6829      	ldr	r1, [r5, #0]
 802d346:	f200 80e6 	bhi.w	802d516 <_realloc_r+0x256>
 802d34a:	4603      	mov	r3, r0
 802d34c:	462a      	mov	r2, r5
 802d34e:	6019      	str	r1, [r3, #0]
 802d350:	6851      	ldr	r1, [r2, #4]
 802d352:	6059      	str	r1, [r3, #4]
 802d354:	6892      	ldr	r2, [r2, #8]
 802d356:	609a      	str	r2, [r3, #8]
 802d358:	4629      	mov	r1, r5
 802d35a:	4640      	mov	r0, r8
 802d35c:	f7fe fb90 	bl	802ba80 <_free_r>
 802d360:	4640      	mov	r0, r8
 802d362:	f7ff fb15 	bl	802c990 <__malloc_unlock>
 802d366:	e04f      	b.n	802d408 <_realloc_r+0x148>
 802d368:	f024 0407 	bic.w	r4, r4, #7
 802d36c:	2c00      	cmp	r4, #0
 802d36e:	4621      	mov	r1, r4
 802d370:	dabd      	bge.n	802d2ee <_realloc_r+0x2e>
 802d372:	f04f 0a00 	mov.w	sl, #0
 802d376:	230c      	movs	r3, #12
 802d378:	4650      	mov	r0, sl
 802d37a:	f8c8 3000 	str.w	r3, [r8]
 802d37e:	b003      	add	sp, #12
 802d380:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802d384:	f855 3c08 	ldr.w	r3, [r5, #-8]
 802d388:	eba7 0b03 	sub.w	fp, r7, r3
 802d38c:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d390:	f022 0203 	bic.w	r2, r2, #3
 802d394:	18b3      	adds	r3, r6, r2
 802d396:	428b      	cmp	r3, r1
 802d398:	dbbf      	blt.n	802d31a <_realloc_r+0x5a>
 802d39a:	46da      	mov	sl, fp
 802d39c:	f8db 100c 	ldr.w	r1, [fp, #12]
 802d3a0:	f85a 0f08 	ldr.w	r0, [sl, #8]!
 802d3a4:	1f32      	subs	r2, r6, #4
 802d3a6:	2a24      	cmp	r2, #36	; 0x24
 802d3a8:	60c1      	str	r1, [r0, #12]
 802d3aa:	eb0b 0903 	add.w	r9, fp, r3
 802d3ae:	6088      	str	r0, [r1, #8]
 802d3b0:	f200 80c6 	bhi.w	802d540 <_realloc_r+0x280>
 802d3b4:	2a13      	cmp	r2, #19
 802d3b6:	6829      	ldr	r1, [r5, #0]
 802d3b8:	f240 80c0 	bls.w	802d53c <_realloc_r+0x27c>
 802d3bc:	f8cb 1008 	str.w	r1, [fp, #8]
 802d3c0:	6869      	ldr	r1, [r5, #4]
 802d3c2:	f8cb 100c 	str.w	r1, [fp, #12]
 802d3c6:	2a1b      	cmp	r2, #27
 802d3c8:	68a9      	ldr	r1, [r5, #8]
 802d3ca:	f200 80d8 	bhi.w	802d57e <_realloc_r+0x2be>
 802d3ce:	f10b 0210 	add.w	r2, fp, #16
 802d3d2:	3508      	adds	r5, #8
 802d3d4:	6011      	str	r1, [r2, #0]
 802d3d6:	6869      	ldr	r1, [r5, #4]
 802d3d8:	6051      	str	r1, [r2, #4]
 802d3da:	68a9      	ldr	r1, [r5, #8]
 802d3dc:	6091      	str	r1, [r2, #8]
 802d3de:	461e      	mov	r6, r3
 802d3e0:	465f      	mov	r7, fp
 802d3e2:	4655      	mov	r5, sl
 802d3e4:	687b      	ldr	r3, [r7, #4]
 802d3e6:	1b32      	subs	r2, r6, r4
 802d3e8:	2a0f      	cmp	r2, #15
 802d3ea:	f003 0301 	and.w	r3, r3, #1
 802d3ee:	d822      	bhi.n	802d436 <_realloc_r+0x176>
 802d3f0:	4333      	orrs	r3, r6
 802d3f2:	607b      	str	r3, [r7, #4]
 802d3f4:	f8d9 3004 	ldr.w	r3, [r9, #4]
 802d3f8:	f043 0301 	orr.w	r3, r3, #1
 802d3fc:	f8c9 3004 	str.w	r3, [r9, #4]
 802d400:	4640      	mov	r0, r8
 802d402:	f7ff fac5 	bl	802c990 <__malloc_unlock>
 802d406:	46aa      	mov	sl, r5
 802d408:	4650      	mov	r0, sl
 802d40a:	b003      	add	sp, #12
 802d40c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802d410:	4611      	mov	r1, r2
 802d412:	b003      	add	sp, #12
 802d414:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802d418:	f7ff b80a 	b.w	802c430 <_malloc_r>
 802d41c:	f020 0003 	bic.w	r0, r0, #3
 802d420:	1833      	adds	r3, r6, r0
 802d422:	428b      	cmp	r3, r1
 802d424:	db61      	blt.n	802d4ea <_realloc_r+0x22a>
 802d426:	e9d9 1202 	ldrd	r1, r2, [r9, #8]
 802d42a:	461e      	mov	r6, r3
 802d42c:	60ca      	str	r2, [r1, #12]
 802d42e:	eb07 0903 	add.w	r9, r7, r3
 802d432:	6091      	str	r1, [r2, #8]
 802d434:	e7d6      	b.n	802d3e4 <_realloc_r+0x124>
 802d436:	1939      	adds	r1, r7, r4
 802d438:	4323      	orrs	r3, r4
 802d43a:	f042 0201 	orr.w	r2, r2, #1
 802d43e:	607b      	str	r3, [r7, #4]
 802d440:	604a      	str	r2, [r1, #4]
 802d442:	f8d9 3004 	ldr.w	r3, [r9, #4]
 802d446:	f043 0301 	orr.w	r3, r3, #1
 802d44a:	3108      	adds	r1, #8
 802d44c:	f8c9 3004 	str.w	r3, [r9, #4]
 802d450:	4640      	mov	r0, r8
 802d452:	f7fe fb15 	bl	802ba80 <_free_r>
 802d456:	e7d3      	b.n	802d400 <_realloc_r+0x140>
 802d458:	6840      	ldr	r0, [r0, #4]
 802d45a:	f020 0903 	bic.w	r9, r0, #3
 802d45e:	44b1      	add	r9, r6
 802d460:	f104 0010 	add.w	r0, r4, #16
 802d464:	4581      	cmp	r9, r0
 802d466:	da77      	bge.n	802d558 <_realloc_r+0x298>
 802d468:	07d2      	lsls	r2, r2, #31
 802d46a:	f53f af56 	bmi.w	802d31a <_realloc_r+0x5a>
 802d46e:	f855 2c08 	ldr.w	r2, [r5, #-8]
 802d472:	eba7 0b02 	sub.w	fp, r7, r2
 802d476:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d47a:	f022 0203 	bic.w	r2, r2, #3
 802d47e:	4491      	add	r9, r2
 802d480:	4548      	cmp	r0, r9
 802d482:	dc87      	bgt.n	802d394 <_realloc_r+0xd4>
 802d484:	46da      	mov	sl, fp
 802d486:	f8db 100c 	ldr.w	r1, [fp, #12]
 802d48a:	f85a 0f08 	ldr.w	r0, [sl, #8]!
 802d48e:	1f32      	subs	r2, r6, #4
 802d490:	2a24      	cmp	r2, #36	; 0x24
 802d492:	60c1      	str	r1, [r0, #12]
 802d494:	6088      	str	r0, [r1, #8]
 802d496:	f200 80a1 	bhi.w	802d5dc <_realloc_r+0x31c>
 802d49a:	2a13      	cmp	r2, #19
 802d49c:	6829      	ldr	r1, [r5, #0]
 802d49e:	f240 809b 	bls.w	802d5d8 <_realloc_r+0x318>
 802d4a2:	f8cb 1008 	str.w	r1, [fp, #8]
 802d4a6:	6869      	ldr	r1, [r5, #4]
 802d4a8:	f8cb 100c 	str.w	r1, [fp, #12]
 802d4ac:	2a1b      	cmp	r2, #27
 802d4ae:	68a9      	ldr	r1, [r5, #8]
 802d4b0:	f200 809b 	bhi.w	802d5ea <_realloc_r+0x32a>
 802d4b4:	f10b 0210 	add.w	r2, fp, #16
 802d4b8:	3508      	adds	r5, #8
 802d4ba:	6011      	str	r1, [r2, #0]
 802d4bc:	6869      	ldr	r1, [r5, #4]
 802d4be:	6051      	str	r1, [r2, #4]
 802d4c0:	68a9      	ldr	r1, [r5, #8]
 802d4c2:	6091      	str	r1, [r2, #8]
 802d4c4:	eb0b 0104 	add.w	r1, fp, r4
 802d4c8:	eba9 0204 	sub.w	r2, r9, r4
 802d4cc:	f042 0201 	orr.w	r2, r2, #1
 802d4d0:	6099      	str	r1, [r3, #8]
 802d4d2:	604a      	str	r2, [r1, #4]
 802d4d4:	f8db 3004 	ldr.w	r3, [fp, #4]
 802d4d8:	f003 0301 	and.w	r3, r3, #1
 802d4dc:	431c      	orrs	r4, r3
 802d4de:	4640      	mov	r0, r8
 802d4e0:	f8cb 4004 	str.w	r4, [fp, #4]
 802d4e4:	f7ff fa54 	bl	802c990 <__malloc_unlock>
 802d4e8:	e78e      	b.n	802d408 <_realloc_r+0x148>
 802d4ea:	07d3      	lsls	r3, r2, #31
 802d4ec:	f53f af15 	bmi.w	802d31a <_realloc_r+0x5a>
 802d4f0:	f855 3c08 	ldr.w	r3, [r5, #-8]
 802d4f4:	eba7 0b03 	sub.w	fp, r7, r3
 802d4f8:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d4fc:	f022 0203 	bic.w	r2, r2, #3
 802d500:	4410      	add	r0, r2
 802d502:	1983      	adds	r3, r0, r6
 802d504:	428b      	cmp	r3, r1
 802d506:	f6ff af45 	blt.w	802d394 <_realloc_r+0xd4>
 802d50a:	e9d9 1202 	ldrd	r1, r2, [r9, #8]
 802d50e:	46da      	mov	sl, fp
 802d510:	60ca      	str	r2, [r1, #12]
 802d512:	6091      	str	r1, [r2, #8]
 802d514:	e742      	b.n	802d39c <_realloc_r+0xdc>
 802d516:	6001      	str	r1, [r0, #0]
 802d518:	686b      	ldr	r3, [r5, #4]
 802d51a:	6043      	str	r3, [r0, #4]
 802d51c:	2a1b      	cmp	r2, #27
 802d51e:	d83a      	bhi.n	802d596 <_realloc_r+0x2d6>
 802d520:	f105 0208 	add.w	r2, r5, #8
 802d524:	f100 0308 	add.w	r3, r0, #8
 802d528:	68a9      	ldr	r1, [r5, #8]
 802d52a:	e710      	b.n	802d34e <_realloc_r+0x8e>
 802d52c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 802d530:	f023 0303 	bic.w	r3, r3, #3
 802d534:	441e      	add	r6, r3
 802d536:	eb07 0906 	add.w	r9, r7, r6
 802d53a:	e753      	b.n	802d3e4 <_realloc_r+0x124>
 802d53c:	4652      	mov	r2, sl
 802d53e:	e749      	b.n	802d3d4 <_realloc_r+0x114>
 802d540:	4629      	mov	r1, r5
 802d542:	4650      	mov	r0, sl
 802d544:	461e      	mov	r6, r3
 802d546:	465f      	mov	r7, fp
 802d548:	f000 f972 	bl	802d830 <memmove>
 802d54c:	4655      	mov	r5, sl
 802d54e:	e749      	b.n	802d3e4 <_realloc_r+0x124>
 802d550:	4629      	mov	r1, r5
 802d552:	f000 f96d 	bl	802d830 <memmove>
 802d556:	e6ff      	b.n	802d358 <_realloc_r+0x98>
 802d558:	4427      	add	r7, r4
 802d55a:	eba9 0904 	sub.w	r9, r9, r4
 802d55e:	f049 0201 	orr.w	r2, r9, #1
 802d562:	609f      	str	r7, [r3, #8]
 802d564:	607a      	str	r2, [r7, #4]
 802d566:	f855 3c04 	ldr.w	r3, [r5, #-4]
 802d56a:	f003 0301 	and.w	r3, r3, #1
 802d56e:	431c      	orrs	r4, r3
 802d570:	4640      	mov	r0, r8
 802d572:	f845 4c04 	str.w	r4, [r5, #-4]
 802d576:	f7ff fa0b 	bl	802c990 <__malloc_unlock>
 802d57a:	46aa      	mov	sl, r5
 802d57c:	e744      	b.n	802d408 <_realloc_r+0x148>
 802d57e:	f8cb 1010 	str.w	r1, [fp, #16]
 802d582:	68e9      	ldr	r1, [r5, #12]
 802d584:	f8cb 1014 	str.w	r1, [fp, #20]
 802d588:	2a24      	cmp	r2, #36	; 0x24
 802d58a:	d010      	beq.n	802d5ae <_realloc_r+0x2ee>
 802d58c:	6929      	ldr	r1, [r5, #16]
 802d58e:	f10b 0218 	add.w	r2, fp, #24
 802d592:	3510      	adds	r5, #16
 802d594:	e71e      	b.n	802d3d4 <_realloc_r+0x114>
 802d596:	68ab      	ldr	r3, [r5, #8]
 802d598:	6083      	str	r3, [r0, #8]
 802d59a:	68eb      	ldr	r3, [r5, #12]
 802d59c:	60c3      	str	r3, [r0, #12]
 802d59e:	2a24      	cmp	r2, #36	; 0x24
 802d5a0:	d010      	beq.n	802d5c4 <_realloc_r+0x304>
 802d5a2:	f105 0210 	add.w	r2, r5, #16
 802d5a6:	f100 0310 	add.w	r3, r0, #16
 802d5aa:	6929      	ldr	r1, [r5, #16]
 802d5ac:	e6cf      	b.n	802d34e <_realloc_r+0x8e>
 802d5ae:	692a      	ldr	r2, [r5, #16]
 802d5b0:	f8cb 2018 	str.w	r2, [fp, #24]
 802d5b4:	696a      	ldr	r2, [r5, #20]
 802d5b6:	f8cb 201c 	str.w	r2, [fp, #28]
 802d5ba:	69a9      	ldr	r1, [r5, #24]
 802d5bc:	f10b 0220 	add.w	r2, fp, #32
 802d5c0:	3518      	adds	r5, #24
 802d5c2:	e707      	b.n	802d3d4 <_realloc_r+0x114>
 802d5c4:	692b      	ldr	r3, [r5, #16]
 802d5c6:	6103      	str	r3, [r0, #16]
 802d5c8:	696b      	ldr	r3, [r5, #20]
 802d5ca:	6143      	str	r3, [r0, #20]
 802d5cc:	69a9      	ldr	r1, [r5, #24]
 802d5ce:	f105 0218 	add.w	r2, r5, #24
 802d5d2:	f100 0318 	add.w	r3, r0, #24
 802d5d6:	e6ba      	b.n	802d34e <_realloc_r+0x8e>
 802d5d8:	4652      	mov	r2, sl
 802d5da:	e76e      	b.n	802d4ba <_realloc_r+0x1fa>
 802d5dc:	4629      	mov	r1, r5
 802d5de:	4650      	mov	r0, sl
 802d5e0:	9301      	str	r3, [sp, #4]
 802d5e2:	f000 f925 	bl	802d830 <memmove>
 802d5e6:	9b01      	ldr	r3, [sp, #4]
 802d5e8:	e76c      	b.n	802d4c4 <_realloc_r+0x204>
 802d5ea:	f8cb 1010 	str.w	r1, [fp, #16]
 802d5ee:	68e9      	ldr	r1, [r5, #12]
 802d5f0:	f8cb 1014 	str.w	r1, [fp, #20]
 802d5f4:	2a24      	cmp	r2, #36	; 0x24
 802d5f6:	d004      	beq.n	802d602 <_realloc_r+0x342>
 802d5f8:	6929      	ldr	r1, [r5, #16]
 802d5fa:	f10b 0218 	add.w	r2, fp, #24
 802d5fe:	3510      	adds	r5, #16
 802d600:	e75b      	b.n	802d4ba <_realloc_r+0x1fa>
 802d602:	692a      	ldr	r2, [r5, #16]
 802d604:	f8cb 2018 	str.w	r2, [fp, #24]
 802d608:	696a      	ldr	r2, [r5, #20]
 802d60a:	f8cb 201c 	str.w	r2, [fp, #28]
 802d60e:	69a9      	ldr	r1, [r5, #24]
 802d610:	f10b 0220 	add.w	r2, fp, #32
 802d614:	3518      	adds	r5, #24
 802d616:	e750      	b.n	802d4ba <_realloc_r+0x1fa>
 802d618:	20001634 	.word	0x20001634
 802d61c:	00000000 	.word	0x00000000

0802d620 <strncmp>:
 802d620:	2a00      	cmp	r2, #0
 802d622:	d041      	beq.n	802d6a8 <strncmp+0x88>
 802d624:	ea40 0301 	orr.w	r3, r0, r1
 802d628:	f013 0303 	ands.w	r3, r3, #3
 802d62c:	b4f0      	push	{r4, r5, r6, r7}
 802d62e:	d125      	bne.n	802d67c <strncmp+0x5c>
 802d630:	2a03      	cmp	r2, #3
 802d632:	d923      	bls.n	802d67c <strncmp+0x5c>
 802d634:	6804      	ldr	r4, [r0, #0]
 802d636:	680d      	ldr	r5, [r1, #0]
 802d638:	42ac      	cmp	r4, r5
 802d63a:	d11f      	bne.n	802d67c <strncmp+0x5c>
 802d63c:	3a04      	subs	r2, #4
 802d63e:	d035      	beq.n	802d6ac <strncmp+0x8c>
 802d640:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 802d644:	ea25 0404 	bic.w	r4, r5, r4
 802d648:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 802d64c:	d131      	bne.n	802d6b2 <strncmp+0x92>
 802d64e:	1d07      	adds	r7, r0, #4
 802d650:	1d0d      	adds	r5, r1, #4
 802d652:	e00d      	b.n	802d670 <strncmp+0x50>
 802d654:	f857 3b04 	ldr.w	r3, [r7], #4
 802d658:	680e      	ldr	r6, [r1, #0]
 802d65a:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 802d65e:	42b3      	cmp	r3, r6
 802d660:	ea24 0403 	bic.w	r4, r4, r3
 802d664:	d10a      	bne.n	802d67c <strncmp+0x5c>
 802d666:	3a04      	subs	r2, #4
 802d668:	d020      	beq.n	802d6ac <strncmp+0x8c>
 802d66a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 802d66e:	d11d      	bne.n	802d6ac <strncmp+0x8c>
 802d670:	2a03      	cmp	r2, #3
 802d672:	4629      	mov	r1, r5
 802d674:	4638      	mov	r0, r7
 802d676:	f105 0504 	add.w	r5, r5, #4
 802d67a:	d8eb      	bhi.n	802d654 <strncmp+0x34>
 802d67c:	7803      	ldrb	r3, [r0, #0]
 802d67e:	780c      	ldrb	r4, [r1, #0]
 802d680:	429c      	cmp	r4, r3
 802d682:	f102 32ff 	add.w	r2, r2, #4294967295
 802d686:	d10c      	bne.n	802d6a2 <strncmp+0x82>
 802d688:	b182      	cbz	r2, 802d6ac <strncmp+0x8c>
 802d68a:	b914      	cbnz	r4, 802d692 <strncmp+0x72>
 802d68c:	e00e      	b.n	802d6ac <strncmp+0x8c>
 802d68e:	b16a      	cbz	r2, 802d6ac <strncmp+0x8c>
 802d690:	b17b      	cbz	r3, 802d6b2 <strncmp+0x92>
 802d692:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 802d696:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802d69a:	42a3      	cmp	r3, r4
 802d69c:	f102 32ff 	add.w	r2, r2, #4294967295
 802d6a0:	d0f5      	beq.n	802d68e <strncmp+0x6e>
 802d6a2:	1b18      	subs	r0, r3, r4
 802d6a4:	bcf0      	pop	{r4, r5, r6, r7}
 802d6a6:	4770      	bx	lr
 802d6a8:	4610      	mov	r0, r2
 802d6aa:	4770      	bx	lr
 802d6ac:	2000      	movs	r0, #0
 802d6ae:	bcf0      	pop	{r4, r5, r6, r7}
 802d6b0:	4770      	bx	lr
 802d6b2:	4618      	mov	r0, r3
 802d6b4:	e7f6      	b.n	802d6a4 <strncmp+0x84>
 802d6b6:	bf00      	nop
	...

0802d6c0 <__ssprint_r>:
 802d6c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802d6c4:	6893      	ldr	r3, [r2, #8]
 802d6c6:	b083      	sub	sp, #12
 802d6c8:	4690      	mov	r8, r2
 802d6ca:	2b00      	cmp	r3, #0
 802d6cc:	d06c      	beq.n	802d7a8 <__ssprint_r+0xe8>
 802d6ce:	6817      	ldr	r7, [r2, #0]
 802d6d0:	688d      	ldr	r5, [r1, #8]
 802d6d2:	4682      	mov	sl, r0
 802d6d4:	460c      	mov	r4, r1
 802d6d6:	6808      	ldr	r0, [r1, #0]
 802d6d8:	3708      	adds	r7, #8
 802d6da:	e042      	b.n	802d762 <__ssprint_r+0xa2>
 802d6dc:	89a3      	ldrh	r3, [r4, #12]
 802d6de:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802d6e2:	d02d      	beq.n	802d740 <__ssprint_r+0x80>
 802d6e4:	e9d4 1504 	ldrd	r1, r5, [r4, #16]
 802d6e8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802d6ec:	eba0 0b01 	sub.w	fp, r0, r1
 802d6f0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802d6f4:	1c70      	adds	r0, r6, #1
 802d6f6:	106d      	asrs	r5, r5, #1
 802d6f8:	4458      	add	r0, fp
 802d6fa:	42a8      	cmp	r0, r5
 802d6fc:	462a      	mov	r2, r5
 802d6fe:	bf84      	itt	hi
 802d700:	4605      	movhi	r5, r0
 802d702:	462a      	movhi	r2, r5
 802d704:	055b      	lsls	r3, r3, #21
 802d706:	d536      	bpl.n	802d776 <__ssprint_r+0xb6>
 802d708:	4611      	mov	r1, r2
 802d70a:	4650      	mov	r0, sl
 802d70c:	f7fe fe90 	bl	802c430 <_malloc_r>
 802d710:	2800      	cmp	r0, #0
 802d712:	d03a      	beq.n	802d78a <__ssprint_r+0xca>
 802d714:	465a      	mov	r2, fp
 802d716:	6921      	ldr	r1, [r4, #16]
 802d718:	9001      	str	r0, [sp, #4]
 802d71a:	f7df fa01 	bl	800cb20 <memcpy>
 802d71e:	89a2      	ldrh	r2, [r4, #12]
 802d720:	9b01      	ldr	r3, [sp, #4]
 802d722:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 802d726:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802d72a:	81a2      	strh	r2, [r4, #12]
 802d72c:	eba5 020b 	sub.w	r2, r5, fp
 802d730:	eb03 000b 	add.w	r0, r3, fp
 802d734:	6165      	str	r5, [r4, #20]
 802d736:	6123      	str	r3, [r4, #16]
 802d738:	6020      	str	r0, [r4, #0]
 802d73a:	60a2      	str	r2, [r4, #8]
 802d73c:	4635      	mov	r5, r6
 802d73e:	46b3      	mov	fp, r6
 802d740:	465a      	mov	r2, fp
 802d742:	4649      	mov	r1, r9
 802d744:	f000 f874 	bl	802d830 <memmove>
 802d748:	f8d8 3008 	ldr.w	r3, [r8, #8]
 802d74c:	68a2      	ldr	r2, [r4, #8]
 802d74e:	6820      	ldr	r0, [r4, #0]
 802d750:	1b55      	subs	r5, r2, r5
 802d752:	4458      	add	r0, fp
 802d754:	1b9e      	subs	r6, r3, r6
 802d756:	60a5      	str	r5, [r4, #8]
 802d758:	6020      	str	r0, [r4, #0]
 802d75a:	f8c8 6008 	str.w	r6, [r8, #8]
 802d75e:	b31e      	cbz	r6, 802d7a8 <__ssprint_r+0xe8>
 802d760:	3708      	adds	r7, #8
 802d762:	e957 9602 	ldrd	r9, r6, [r7, #-8]
 802d766:	46ab      	mov	fp, r5
 802d768:	2e00      	cmp	r6, #0
 802d76a:	d0f9      	beq.n	802d760 <__ssprint_r+0xa0>
 802d76c:	42ae      	cmp	r6, r5
 802d76e:	d2b5      	bcs.n	802d6dc <__ssprint_r+0x1c>
 802d770:	4635      	mov	r5, r6
 802d772:	46b3      	mov	fp, r6
 802d774:	e7e4      	b.n	802d740 <__ssprint_r+0x80>
 802d776:	4650      	mov	r0, sl
 802d778:	f7ff fda2 	bl	802d2c0 <_realloc_r>
 802d77c:	4603      	mov	r3, r0
 802d77e:	2800      	cmp	r0, #0
 802d780:	d1d4      	bne.n	802d72c <__ssprint_r+0x6c>
 802d782:	6921      	ldr	r1, [r4, #16]
 802d784:	4650      	mov	r0, sl
 802d786:	f7fe f97b 	bl	802ba80 <_free_r>
 802d78a:	230c      	movs	r3, #12
 802d78c:	f8ca 3000 	str.w	r3, [sl]
 802d790:	89a3      	ldrh	r3, [r4, #12]
 802d792:	2200      	movs	r2, #0
 802d794:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802d798:	f04f 30ff 	mov.w	r0, #4294967295
 802d79c:	81a3      	strh	r3, [r4, #12]
 802d79e:	e9c8 2201 	strd	r2, r2, [r8, #4]
 802d7a2:	b003      	add	sp, #12
 802d7a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802d7a8:	2000      	movs	r0, #0
 802d7aa:	f8c8 0004 	str.w	r0, [r8, #4]
 802d7ae:	b003      	add	sp, #12
 802d7b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0802d7c0 <_calloc_r>:
 802d7c0:	b510      	push	{r4, lr}
 802d7c2:	fb02 f101 	mul.w	r1, r2, r1
 802d7c6:	f7fe fe33 	bl	802c430 <_malloc_r>
 802d7ca:	4604      	mov	r4, r0
 802d7cc:	b1d8      	cbz	r0, 802d806 <_calloc_r+0x46>
 802d7ce:	f850 2c04 	ldr.w	r2, [r0, #-4]
 802d7d2:	f022 0203 	bic.w	r2, r2, #3
 802d7d6:	3a04      	subs	r2, #4
 802d7d8:	2a24      	cmp	r2, #36	; 0x24
 802d7da:	d81d      	bhi.n	802d818 <_calloc_r+0x58>
 802d7dc:	2a13      	cmp	r2, #19
 802d7de:	d914      	bls.n	802d80a <_calloc_r+0x4a>
 802d7e0:	2300      	movs	r3, #0
 802d7e2:	2a1b      	cmp	r2, #27
 802d7e4:	e9c0 3300 	strd	r3, r3, [r0]
 802d7e8:	d91b      	bls.n	802d822 <_calloc_r+0x62>
 802d7ea:	2a24      	cmp	r2, #36	; 0x24
 802d7ec:	e9c0 3302 	strd	r3, r3, [r0, #8]
 802d7f0:	bf0a      	itet	eq
 802d7f2:	e9c0 3304 	strdeq	r3, r3, [r0, #16]
 802d7f6:	f100 0210 	addne.w	r2, r0, #16
 802d7fa:	f100 0218 	addeq.w	r2, r0, #24
 802d7fe:	2300      	movs	r3, #0
 802d800:	e9c2 3300 	strd	r3, r3, [r2]
 802d804:	6093      	str	r3, [r2, #8]
 802d806:	4620      	mov	r0, r4
 802d808:	bd10      	pop	{r4, pc}
 802d80a:	4602      	mov	r2, r0
 802d80c:	2300      	movs	r3, #0
 802d80e:	e9c2 3300 	strd	r3, r3, [r2]
 802d812:	6093      	str	r3, [r2, #8]
 802d814:	4620      	mov	r0, r4
 802d816:	bd10      	pop	{r4, pc}
 802d818:	2100      	movs	r1, #0
 802d81a:	f7f9 fa01 	bl	8026c20 <memset>
 802d81e:	4620      	mov	r0, r4
 802d820:	bd10      	pop	{r4, pc}
 802d822:	f100 0208 	add.w	r2, r0, #8
 802d826:	e7f1      	b.n	802d80c <_calloc_r+0x4c>
	...

0802d830 <memmove>:
 802d830:	4288      	cmp	r0, r1
 802d832:	b4f0      	push	{r4, r5, r6, r7}
 802d834:	d90d      	bls.n	802d852 <memmove+0x22>
 802d836:	188b      	adds	r3, r1, r2
 802d838:	4283      	cmp	r3, r0
 802d83a:	d90a      	bls.n	802d852 <memmove+0x22>
 802d83c:	1884      	adds	r4, r0, r2
 802d83e:	b132      	cbz	r2, 802d84e <memmove+0x1e>
 802d840:	4622      	mov	r2, r4
 802d842:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802d846:	f802 4d01 	strb.w	r4, [r2, #-1]!
 802d84a:	4299      	cmp	r1, r3
 802d84c:	d1f9      	bne.n	802d842 <memmove+0x12>
 802d84e:	bcf0      	pop	{r4, r5, r6, r7}
 802d850:	4770      	bx	lr
 802d852:	2a0f      	cmp	r2, #15
 802d854:	d949      	bls.n	802d8ea <memmove+0xba>
 802d856:	ea40 0301 	orr.w	r3, r0, r1
 802d85a:	079b      	lsls	r3, r3, #30
 802d85c:	d147      	bne.n	802d8ee <memmove+0xbe>
 802d85e:	f1a2 0310 	sub.w	r3, r2, #16
 802d862:	091b      	lsrs	r3, r3, #4
 802d864:	f101 0720 	add.w	r7, r1, #32
 802d868:	eb07 1703 	add.w	r7, r7, r3, lsl #4
 802d86c:	f101 0410 	add.w	r4, r1, #16
 802d870:	f100 0510 	add.w	r5, r0, #16
 802d874:	f854 6c10 	ldr.w	r6, [r4, #-16]
 802d878:	f845 6c10 	str.w	r6, [r5, #-16]
 802d87c:	f854 6c0c 	ldr.w	r6, [r4, #-12]
 802d880:	f845 6c0c 	str.w	r6, [r5, #-12]
 802d884:	f854 6c08 	ldr.w	r6, [r4, #-8]
 802d888:	f845 6c08 	str.w	r6, [r5, #-8]
 802d88c:	f854 6c04 	ldr.w	r6, [r4, #-4]
 802d890:	f845 6c04 	str.w	r6, [r5, #-4]
 802d894:	3410      	adds	r4, #16
 802d896:	42bc      	cmp	r4, r7
 802d898:	f105 0510 	add.w	r5, r5, #16
 802d89c:	d1ea      	bne.n	802d874 <memmove+0x44>
 802d89e:	3301      	adds	r3, #1
 802d8a0:	f002 050f 	and.w	r5, r2, #15
 802d8a4:	011b      	lsls	r3, r3, #4
 802d8a6:	2d03      	cmp	r5, #3
 802d8a8:	4419      	add	r1, r3
 802d8aa:	4403      	add	r3, r0
 802d8ac:	d921      	bls.n	802d8f2 <memmove+0xc2>
 802d8ae:	1f1f      	subs	r7, r3, #4
 802d8b0:	460e      	mov	r6, r1
 802d8b2:	462c      	mov	r4, r5
 802d8b4:	3c04      	subs	r4, #4
 802d8b6:	f856 cb04 	ldr.w	ip, [r6], #4
 802d8ba:	f847 cf04 	str.w	ip, [r7, #4]!
 802d8be:	2c03      	cmp	r4, #3
 802d8c0:	d8f8      	bhi.n	802d8b4 <memmove+0x84>
 802d8c2:	1f2c      	subs	r4, r5, #4
 802d8c4:	f024 0403 	bic.w	r4, r4, #3
 802d8c8:	3404      	adds	r4, #4
 802d8ca:	4423      	add	r3, r4
 802d8cc:	4421      	add	r1, r4
 802d8ce:	f002 0203 	and.w	r2, r2, #3
 802d8d2:	2a00      	cmp	r2, #0
 802d8d4:	d0bb      	beq.n	802d84e <memmove+0x1e>
 802d8d6:	3b01      	subs	r3, #1
 802d8d8:	440a      	add	r2, r1
 802d8da:	f811 4b01 	ldrb.w	r4, [r1], #1
 802d8de:	f803 4f01 	strb.w	r4, [r3, #1]!
 802d8e2:	4291      	cmp	r1, r2
 802d8e4:	d1f9      	bne.n	802d8da <memmove+0xaa>
 802d8e6:	bcf0      	pop	{r4, r5, r6, r7}
 802d8e8:	4770      	bx	lr
 802d8ea:	4603      	mov	r3, r0
 802d8ec:	e7f1      	b.n	802d8d2 <memmove+0xa2>
 802d8ee:	4603      	mov	r3, r0
 802d8f0:	e7f1      	b.n	802d8d6 <memmove+0xa6>
 802d8f2:	462a      	mov	r2, r5
 802d8f4:	e7ed      	b.n	802d8d2 <memmove+0xa2>
 802d8f6:	bf00      	nop
	...
 802d900:	ffffffff 	.word	0xffffffff
 802d904:	00000001 	.word	0x00000001
 802d908:	00000006 	.word	0x00000006
 802d90c:	00000005 	.word	0x00000005
 802d910:	00000004 	.word	0x00000004
 802d914:	00000003 	.word	0x00000003
 802d918:	00000002 	.word	0x00000002
 802d91c:	00000000 	.word	0x00000000
 802d920:	00f34112 	.word	0x00f34112
	...
 802d930:	656c6469 	.word	0x656c6469
	...

0802d940 <ch_debug>:
 802d940:	6e69616d 18011600 08480404 1814100c     main......H.....
 802d950:	1e1d1c00 0000201f 00000000 00000000     ..... ..........

0802d960 <vmt>:
 802d960:	0800e7e1 0800e7c1 0800e821 0800e801     ........!.......
 802d970:	0800e811 0800e7f1 0800e7d1 0800e7b1     ................

0802d980 <active_status>:
	...

0802d990 <halted_status>:
 802d990:	00000001 00000000 00000000 00000000     ................

0802d9a0 <zero_status>:
	...

0802d9b0 <_stm32_dma_streams>:
 802d9b0:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 802d9c0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 802d9d0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 802d9e0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 802d9f0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 802da00:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 802da10:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 802da20:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 802da30:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 802da40:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 802da50:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 802da60:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.
 802da70:	20414d44 6c696166 00657275 00000000     DMA failure.....

0802da80 <ep0config>:
 802da80:	00000000 0800ec61 0800efa1 0800f091     ....a...........
 802da90:	00400040 20002038 20002038 00000001     @.@.8 . 8 . ....
 802daa0:	2000204c 00000000 00000000 00000000     L . ............

0802dab0 <fsparams>:
 802dab0:	00000080 00000140 00000003 00000000     ....@...........
 802dac0:	5f627375 5f646c6c 706d7570 00000000     usb_lld_pump....

0802dad0 <pal_default_config>:
 802dad0:	28000000 00000000 ffffffff 00000000     ...(............
 802dae0:	0000ffff 55560000 000aaa00 00000000     ......VU........
 802daf0:	00000240 ffffffff 00000000 0000ffff     @...............
 802db00:	04000000 00000040 00000000 00000000     ....@...........
 802db10:	ffffffff 00000000 0000ffff 60000000     ...............`
 802db20:	00060600 00000000 00000000 ffffffff     ................
 802db30:	00000000 0000ffff 00000000 00000000     ................
	...
 802db48:	ffffffff 00000000 0000ffff 00000000     ................
	...
 802db64:	ffffffff 00000000 0000ffff 00000000     ................
	...
 802db80:	ffffffff 00000000 0000ffff 00000000     ................
	...
 802db9c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 802dbb8:	ffffffff 00000000 0000ffff 00000000     ................
	...
 802dbd0:	6e69614d 72657020 69646f69 00000063     Main periodic...
 802dbe0:	6365736d 6d69745f 00007265 00000000     msec_timer......

0802dbf0 <ep1config>:
 802dbf0:	00000002 00000000 0800e961 0800e9d1     ........a.......
 802dc00:	00400040 20002ae0 20002af4 00000002     @.@..*. .*. ....
	...

0802dc20 <ep2config>:
 802dc20:	00000003 00000000 0800ea41 00000000     ........A.......
 802dc30:	00000010 20002b08 00000000 00000001     .....+. ........
	...

0802dc50 <serusbcfg>:
 802dc50:	20001db8 00020101 00000000 00000000     ... ............

0802dc60 <usbcfg>:
 802dc60:	080119f1 080119c1 0800e921 00000000     ........!.......

0802dc70 <vcom_configuration_descriptor>:
 802dc70:	00000043 0802dc80 00000000 00000000     C...............

0802dc80 <vcom_configuration_descriptor_data>:
 802dc80:	00430209 c0000102 00040932 02020100     ..C.....2.......
 802dc90:	24050001 05011000 01000124 02022404     ...$....$....$..
 802dca0:	00062405 82050701 ff000803 00010409     .$..............
 802dcb0:	00000a02 01050700 00004002 02810507     .........@......
 802dcc0:	00000040 00000000 00000000 00000000     @...............

0802dcd0 <vcom_device_descriptor>:
 802dcd0:	00000012 0802dce0 00000000 00000000     ................

0802dce0 <vcom_device_descriptor_data>:
 802dce0:	01100112 40000002 57400483 02010200     .......@..@W....
 802dcf0:	00000103 00000000 00000000 00000000     ................

0802dd00 <vcom_string0>:
 802dd00:	04090304 00000000 00000000 00000000     ................

0802dd10 <vcom_string1>:
 802dd10:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 802dd20:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 802dd30:	00630069 00000073 00000000 00000000     i.c.s...........

0802dd40 <vcom_string2>:
 802dd40:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 802dd50:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 802dd60:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 802dd70:	006f0050 00740072 00000000 00000000     P.o.r.t.........

0802dd80 <vcom_string3>:
 802dd80:	00330308 00310030 00000000 00000000     ..3.0.1.........

0802dd90 <vcom_strings>:
 802dd90:	00000004 0802dd00 00000026 0802dd10     ........&.......
 802dda0:	00000038 0802dd40 00000008 0802dd80     8...@...........
 802ddb0:	2d425355 69726553 70206c61 65636f72     USB-Serial proce
 802ddc0:	00007373 00000000 00000000 00000000     ss..............
 802ddd0:	2d425355 69726553 72206c61 00646165     USB-Serial read.

0802dde0 <crc16_tab>:
 802dde0:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
 802ddf0:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
 802de00:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
 802de10:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
 802de20:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
 802de30:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
 802de40:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
 802de50:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
 802de60:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
 802de70:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
 802de80:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
 802de90:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
 802dea0:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
 802deb0:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
 802dec0:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
 802ded0:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
 802dee0:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
 802def0:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
 802df00:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
 802df10:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
 802df20:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
 802df30:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
 802df40:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
 802df50:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
 802df60:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
 802df70:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
 802df80:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
 802df90:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
 802dfa0:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
 802dfb0:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
 802dfc0:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
 802dfd0:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....
 802dfe0:	206d7072 656d6974 00000072 00000000     rpm timer.......
 802dff0:	7770636d 6974206d 0072656d 00000000     mcpwm timer.....

0802e000 <states.12814>:
 802e000:	0802e040 0802f378 0802e048 0802e050     @...x...H...P...
 802e010:	0802e05c 0802e064 0802e06c 0802e074     \...d...l...t...
 802e020:	0802e07c 0802e088 0802e090 0802e098     |...............
 802e030:	0802e0a4 0802e0ac 0802e0b4 0802e0bc     ................
 802e040:	44414552 00000059 54535457 00545241     READY...WTSTART.
 802e050:	50535553 45444e45 00000044 55455551     SUSPENDED...QUEU
 802e060:	00004445 45535457 0000004d 544d5457     ED..WTSEM...WTMT
 802e070:	00000058 4f435457 0000444e 45454c53     X...WTCOND..SLEE
 802e080:	474e4950 00000000 58455457 00005449     PING....WTEXIT..
 802e090:	524f5457 00545645 4e415457 54564544     WTOREVT.WTANDEVT
 802e0a0:	00000000 4d444e53 00514753 4d444e53     ....SNDMSGQ.SNDM
 802e0b0:	00004753 534d5457 00000047 414e4946     SG..WTMSG...FINA
 802e0c0:	0000004c 00000000 00000000 00000000     L...............
 802e0d0:	65757274 00000000 736c6166 00000065     true....false...
 802e0e0:	00736559 00006f4e 63206f4e 616d6d6f     Yes.No..No comma
 802e0f0:	7220646e 69656365 0a646576 00000000     nd received.....
 802e100:	676e6970 00000000 676e6f70 0000000a     ping....pong....
 802e110:	706f7473 00000000 6f746f4d 74732072     stop....Motor st
 802e120:	6570706f 00000a64 7473616c 6364615f     opped...last_adc
 802e130:	7275645f 6f697461 0000006e 6574614c     _duration...Late
 802e140:	41207473 64204344 74617275 3a6e6f69     st ADC duration:
 802e150:	342e2520 736d2066 00000000 6574614c      %.4f ms....Late
 802e160:	69207473 63656a6e 20646574 20434441     st injected ADC 
 802e170:	61727564 6e6f6974 2e25203a 6d206634     duration: %.4f m
 802e180:	00000073 6574614c 73207473 6c706d61     s...Latest sampl
 802e190:	44412065 75642043 69746172 203a6e6f     e ADC duration: 
 802e1a0:	66342e25 0a736d20 00000000 0000766b     %.4f ms.....kv..
 802e1b0:	636c6143 74616c75 4b206465 25203a56     Calculated KV: %
 802e1c0:	2066322e 2f6d7072 746c6f76 0000000a     .2f rpm/volt....
 802e1d0:	006d656d 65726f63 65726620 656d2065     mem.core free me
 802e1e0:	79726f6d 25203a20 79622075 00736574     mory : %u bytes.
 802e1f0:	70616568 61726620 6e656d67 20207374     heap fragments  
 802e200:	25203a20 00000075 70616568 65726620      : %u...heap fre
 802e210:	6f742065 206c6174 25203a20 79622075     e total  : %u by
 802e220:	0a736574 00000000 65726874 00736461     tes.....threads.
 802e230:	20202020 72646461 20202020 63617473         addr    stac
 802e240:	7270206b 72206f69 20736665 20202020     k prio refs     
 802e250:	74617473 20202065 20202020 20202020     state           
 802e260:	656d616e 6d697420 20202065 00000020     name time    ...
 802e270:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 802e280:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 802e290:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 802e2a0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0000002d     -------------...
 802e2b0:	6c382e25 2e252078 20786c38 756c3425     %.8lx %.8lx %4lu
 802e2c0:	6c342520 39252075 31252073 25207334      %4lu %9s %14s %
 802e2d0:	0000756c 6c756166 00000074 000a7325     lu..fault...%s..
 802e2e0:	6c756166 00007374 66206f4e 746c7561     faults..No fault
 802e2f0:	65722073 74736967 64657265 6e697320     s registered sin
 802e300:	73206563 74726174 000a7075 20656854     ce startup..The 
 802e310:	6c6c6f66 6e69776f 61662067 73746c75     following faults
 802e320:	72657720 65722065 74736967 64657265      were registered
 802e330:	6e697320 73206563 74726174 00000a3a      since start:...
 802e340:	6c756146 20202074 20202020 20202020     Fault           
 802e350:	25203a20 00000073 72727543 20746e65      : %s...Current 
 802e360:	20202020 20202020 25203a20 0066312e              : %.1f.
 802e370:	72727543 20746e65 746c6966 64657265     Current filtered
 802e380:	25203a20 0066312e 746c6f56 20656761      : %.1f.Voltage 
 802e390:	20202020 20202020 25203a20 0066322e              : %.2f.
 802e3a0:	79747544 20202020 20202020 20202020     Duty            
 802e3b0:	25203a20 0066332e 204d5052 20202020      : %.3f.RPM     
 802e3c0:	20202020 20202020 25203a20 0066312e              : %.1f.
 802e3d0:	68636154 2020206f 20202020 20202020     Tacho           
 802e3e0:	25203a20 00000064 6c637943 72207365      : %d...Cycles r
 802e3f0:	696e6e75 2020676e 25203a20 00000064     unning   : %d...
 802e400:	204d4954 79747564 20202020 20202020     TIM duty        
 802e410:	25203a20 00000064 204d4954 206c6176      : %d...TIM val 
 802e420:	706d6173 20202020 25203a20 00000064     samp     : %d...
 802e430:	204d4954 72727563 20746e65 706d6173     TIM current samp
 802e440:	25203a20 00000064 204d4954 20706f74      : %d...TIM top 
 802e450:	20202020 20202020 25203a20 00000064              : %d...
 802e460:	6d6d6f43 65747320 20202070 20202020     Comm step       
 802e470:	25203a20 00000064 706d6554 74617265      : %d...Temperat
 802e480:	20657275 20202020 25203a20 0066322e     ure      : %.2f.
 802e490:	006d7072 63656c45 63697274 52206c61     rpm.Electrical R
 802e4a0:	203a4d50 66322e25 6d707220 0000000a     PM: %.2f rpm....
 802e4b0:	68636174 0000006f 68636154 74656d6f     tacho...Tachomet
 802e4c0:	63207265 746e756f 25203a73 00000a69     er counts: %i...
 802e4d0:	006d6974 316d6954 544e4320 6925203a     tim.Tim1 CNT: %i
 802e4e0:	00000000 386d6954 544e4320 7525203a     ....Tim8 CNT: %u
 802e4f0:	00000000 79747544 63796320 3a31656c     ....Duty cycle1:
 802e500:	00752520 79747544 63796320 3a32656c      %u.Duty cycle2:
 802e510:	00752520 79747544 63796320 3a33656c      %u.Duty cycle3:
 802e520:	00752520 3a706f54 00752520 31726944      %u.Top: %u.Dir1
 802e530:	7525203a 00000000 38726944 7525203a     : %u....Dir8: %u
 802e540:	00000000 746c6f56 20656761 706d6173     ....Voltage samp
 802e550:	203a656c 00007525 72727543 20746e65     le: %u..Current 
 802e560:	61732031 656c706d 7525203a 00000000     1 sample: %u....
 802e570:	72727543 20746e65 61732032 656c706d     Current 2 sample
 802e580:	7525203a 0000000a 746c6f76 00000000     : %u....volt....
 802e590:	75706e49 6f762074 6761746c 25203a65     Input voltage: %
 802e5a0:	0a66322e 00000000 61726170 65645f6d     .2f.....param_de
 802e5b0:	74636574 00000000 00006625 6c637943     tect....%f..Cycl
 802e5c0:	6e692065 72676574 726f7461 6d696c20     e integrator lim
 802e5d0:	203a7469 66322e25 00000000 70756f43     it: %.2f....Coup
 802e5e0:	676e696c 63616620 3a726f74 322e2520     ling factor: %.2
 802e5f0:	00000066 65746544 64657463 6c616820     f...Detected hal
 802e600:	6573206c 726f736e 62617420 003a656c     l sensor table:.
 802e610:	202c6925 202c6925 202c6925 202c6925     %i, %i, %i, %i, 
 802e620:	202c6925 202c6925 202c6925 000a6925     %i, %i, %i, %i..
 802e630:	6c6c6148 6e657320 20726f73 65746564     Hall sensor dete
 802e640:	6f697463 6166206e 64656c69 0000003a     ction failed:...
 802e650:	38325357 65203131 6c62616e 202e6465     WS2811 enabled. 
 802e660:	6c6c6148 6e657320 73726f73 6e616320     Hall sensors can
 802e670:	20746f6e 75206562 2e646573 0000000a     not be used.....
 802e680:	6f636e45 20726564 62616e65 2e64656c     Encoder enabled.
 802e690:	6c614820 6573206c 726f736e 61632073      Hall sensors ca
 802e6a0:	746f6e6e 20656220 64657375 00000a2e     nnot be used....
 802e6b0:	65746544 6f697463 6166206e 64656c69     Detection failed
 802e6c0:	7254202e 67612079 206e6961 68746977     . Try again with
 802e6d0:	66696420 65726566 7020746e 6d617261      different param
 802e6e0:	72657465 000a2e73 61766e49 2064696c     eters...Invalid 
 802e6f0:	75677261 746e656d 2e297328 0000000a     argument(s).....
 802e700:	73696854 6d6f6320 646e616d 71657220     This command req
 802e710:	65726975 68742073 20656572 75677261     uires three argu
 802e720:	746e656d 000a2e73 5f6d7072 00706564     ments...rpm_dep.
 802e730:	6c637943 6e692065 696c2074 3a74696d     Cycle int limit:
 802e740:	322e2520 00000066 6c637943 6e692065      %.2f...Cycle in
 802e750:	696c2074 2074696d 6e6e7572 3a676e69     t limit running:
 802e760:	322e2520 00000066 6c637943 6e692065      %.2f...Cycle in
 802e770:	696c2074 2074696d 3a78616d 322e2520     t limit max: %.2
 802e780:	00000a66 5f6e6163 73766564 00000000     f...can_devs....
 802e790:	204e4143 69766564 20736563 6e656573     CAN devices seen
 802e7a0:	206e6f20 20656874 20737562 20656874      on the bus the 
 802e7b0:	74736170 63657320 3a646e6f 0000000a     past second:....
 802e7c0:	20204449 20202020 20202020 20202020     ID              
 802e7d0:	3a202020 00692520 54205852 20656d69        : %i.RX Time 
 802e7e0:	20202020 20202020 3a202020 00692520                : %i.
 802e7f0:	20656741 6c696d28 6573696c 646e6f63     Age (millisecond
 802e800:	3a202973 322e2520 00000066 204d5052     s) : %.2f...RPM 
 802e810:	20202020 20202020 20202020 3a202020                    :
 802e820:	322e2520 00000066 72727543 20746e65      %.2f...Current 
 802e830:	20202020 20202020 3a202020 322e2520                : %.2
 802e840:	00000066 79747544 20202020 20202020     f...Duty        
 802e850:	20202020 3a202020 322e2520 00000a66            : %.2f...
 802e860:	5f636f66 6f636e65 5f726564 65746564     foc_encoder_dete
 802e870:	00007463 7366664f 20207465 25203a20     ct..Offset   : %
 802e880:	0066322e 69746152 2020206f 25203a20     .2f.Ratio    : %
 802e890:	0066322e 65766e49 64657472 25203a20     .2f.Inverted : %
 802e8a0:	00000a73 6f636e45 20726564 20746f6e     s...Encoder not 
 802e8b0:	62616e65 2e64656c 0000000a 73696854     enabled.....This
 802e8c0:	6d6f6320 646e616d 71657220 65726975      command require
 802e8d0:	6e6f2073 72612065 656d7567 0a2e746e     s one argument..
 802e8e0:	00000000 7361656d 5f657275 00736572     ....measure_res.
 802e8f0:	69736552 6e617473 203a6563 66362e25     Resistance: %.6f
 802e900:	6d686f20 0000000a 7361656d 5f657275      ohm....measure_
 802e910:	00646e69 75646e49 6e617463 203a6563     ind.Inductance: 
 802e920:	66322e25 63696d20 65686f72 2079726e     %.2f microhenry 
 802e930:	322e2528 29412066 0000000a 7361656d     (%.2f A)....meas
 802e940:	5f657275 6b6e696c 00656761 78756c46     ure_linkage.Flux
 802e950:	6e696c20 6567616b 2e25203a 000a6637      linkage: %.7f..
 802e960:	7361656d 5f657275 5f736572 00646e69     measure_res_ind.
 802e970:	69736552 6e617473 203a6563 66362e25     Resistance: %.6f
 802e980:	6d686f20 00000000 75646e49 6e617463      ohm....Inductan
 802e990:	203a6563 66322e25 63696d20 65686f72     ce: %.2f microhe
 802e9a0:	0a79726e 00000000 7361656d 5f657275     nry.....measure_
 802e9b0:	6b6e696c 5f656761 00636f66 5f636f66     linkage_foc.foc_
 802e9c0:	74617473 00000065 735f7768 75746174     state...hw_statu
 802e9d0:	00000073 6d726946 65726177 6425203a     s...Firmware: %d
 802e9e0:	0064252e 00004643 64726148 65726177     .%d.CF..Hardware
 802e9f0:	7325203a 00000000 44495555 3025203a     : %s....UUID: %0
 802ea00:	25205832 20583230 58323025 32302520     2X %02X %02X %02
 802ea10:	30252058 25205832 20583230 58323025     X %02X %02X %02X
 802ea20:	32302520 30252058 25205832 20583230      %02X %02X %02X 
 802ea30:	58323025 32302520 00000058 6d726550     %02X %02X...Perm
 802ea40:	6e656e61 524e2074 6f662046 3a646e75     anent NRF found:
 802ea50:	00732520 38767264 5f313033 64616572      %s.drv8301_read
 802ea60:	6765725f 00000000 73696854 72616820     _reg....This har
 802ea70:	72617764 6f642065 6e207365 6820746f     dware does not h
 802ea80:	20657661 52442061 30333856 000a2e31     ave a DRV8301...
 802ea90:	38767264 5f313033 74697277 65725f65     drv8301_write_re
 802eaa0:	00000067 38767264 5f313033 5f746573     g...drv8301_set_
 802eab0:	615f636f 00006a64 38767264 5f313033     oc_adj..drv8301_
 802eac0:	6e697270 61665f74 73746c75 00000000     print_faults....
 802ead0:	38767264 5f313033 65736572 61665f74     drv8301_reset_fa
 802eae0:	73746c75 00000000 38767264 5f353033     ults....drv8305_
 802eaf0:	64616572 6765725f 00000000 73696854     read_reg....This
 802eb00:	72616820 72617764 6f642065 6e207365      hardware does n
 802eb10:	6820746f 20657661 52442061 30333856     ot have a DRV830
 802eb20:	000a2e35 38767264 5f353033 74697277     5...drv8305_writ
 802eb30:	65725f65 00000067 5f636f66 6e65706f     e_reg...foc_open
 802eb40:	706f6f6c 00000000 73696854 6d6f6320     loop....This com
 802eb50:	646e616d 71657220 65726975 77742073     mand requires tw
 802eb60:	7261206f 656d7567 2e73746e 0000000a     o arguments.....
 802eb70:	696c6156 6f632064 6e616d6d 61207364     Valid commands a
 802eb80:	003a6572 68532020 7420776f 20736968     re:.  Show this 
 802eb90:	706c6568 00000000 72502020 20746e69     help....  Print 
 802eba0:	676e6f70 72656820 6f742065 65657320     pong here to see
 802ebb0:	20666920 20656874 6c706572 6f772079      if the reply wo
 802ebc0:	00736b72 74532020 7420706f 6d206568     rks.  Stop the m
 802ebd0:	726f746f 00000000 68542020 69742065     otor....  The ti
 802ebe0:	7420656d 6c206568 73657461 44412074     me the latest AD
 802ebf0:	6e692043 72726574 20747075 736e6f63     C interrupt cons
 802ec00:	64656d75 00000000 68542020 61632065     umed....  The ca
 802ec10:	6c75636c 64657461 20766b20 7420666f     lculated kv of t
 802ec20:	6d206568 726f746f 00000000 68532020     he motor....  Sh
 802ec30:	6d20776f 726f6d65 73752079 00656761     ow memory usage.
 802ec40:	694c2020 61207473 74206c6c 61657268       List all threa
 802ec50:	00007364 72502020 73746e69 65687420     ds..  Prints the
 802ec60:	72756320 746e6572 75616620 6320746c      current fault c
 802ec70:	0065646f 72502020 73746e69 6c6c6120     ode.  Prints all
 802ec80:	6f747320 20646572 6c756166 6f632074      stored fault co
 802ec90:	20736564 20646e61 646e6f63 6f697469     des and conditio
 802eca0:	7720736e 206e6568 79656874 72726120     ns when they arr
 802ecb0:	64657669 00000000 72502020 73746e69     ived....  Prints
 802ecc0:	65687420 72756320 746e6572 656c6520      the current ele
 802ecd0:	69727463 206c6163 004d5052 72502020     ctrical RPM.  Pr
 802ece0:	73746e69 63617420 656d6f68 20726574     ints tachometer 
 802ecf0:	756c6176 00000065 72502020 73746e69     value...  Prints
 802ed00:	6d697420 6e612031 69742064 7320386d      tim1 and tim8 s
 802ed10:	69747465 0073676e 72502020 73746e69     ettings.  Prints
 802ed20:	66696420 65726566 7620746e 61746c6f      different volta
 802ed30:	00736567 61726170 65645f6d 74636574     ges.param_detect
 802ed40:	75635b20 6e657272 5b205d74 5f6e696d      [current] [min_
 802ed50:	5d6d7072 6f6c5b20 75645f77 005d7974     rpm] [low_duty].
 802ed60:	70532020 75206e69 68742070 6f6d2065       Spin up the mo
 802ed70:	20726f74 43206e69 5f4d4d4f 45444f4d     tor in COMM_MODE
 802ed80:	4c45445f 61205941 6320646e 75706d6f     _DELAY and compu
 802ed90:	69206574 70207374 6d617261 72657465     te its parameter
 802eda0:	00002e73 68542020 74207369 20747365     s...  This test 
 802edb0:	756f6873 6220646c 65702065 726f6672     should be perfor
 802edc0:	2064656d 68746977 2074756f 64616f6c     med without load
 802edd0:	206e6f20 20656874 6f746f6d 00002e72      on the motor...
 802ede0:	78452020 6c706d61 70203a65 6d617261       Example: param
 802edf0:	7465645f 20746365 20302e35 20303036     _detect 5.0 600 
 802ee00:	36302e30 00000000 72502020 73746e69     0.06....  Prints
 802ee10:	6d6f7320 70722065 65642d6d 61762070      some rpm-dep va
 802ee20:	7365756c 00000000 72502020 73746e69     lues....  Prints
 802ee30:	6c6c6120 4e414320 76656420 73656369      all CAN devices
 802ee40:	65657320 6e6f206e 65687420 73756220      seen on the bus
 802ee50:	65687420 73617020 65732074 646e6f63      the past second
 802ee60:	00000000 5f636f66 6f636e65 5f726564     ....foc_encoder_
 802ee70:	65746564 5b207463 72727563 5d746e65     detect [current]
 802ee80:	00000000 75522020 6874206e 6f6d2065     ....  Run the mo
 802ee90:	20726f74 31207461 6f207a48 706f206e     tor at 1Hz on op
 802eea0:	6c206e65 20706f6f 20646e61 706d6f63     en loop and comp
 802eeb0:	20657475 6f636e65 20726564 74746573     ute encoder sett
 802eec0:	73676e69 00000000 7361656d 5f657275     ings....measure_
 802eed0:	20736572 7275635b 746e6572 0000005d     res [current]...
 802eee0:	6f4c2020 74206b63 6d206568 726f746f       Lock the motor
 802eef0:	74697720 20612068 72727563 20746e65      with a current 
 802ef00:	20646e61 636c6163 74616c75 74692065     and calculate it
 802ef10:	65722073 74736973 65636e61 00000000     s resistance....
 802ef20:	7361656d 5f657275 20646e69 7475645b     measure_ind [dut
 802ef30:	00005d79 65532020 7320646e 74726f68     y]..  Send short
 802ef40:	6c6f7620 65676174 6c757020 2c736573      voltage pulses,
 802ef50:	61656d20 65727573 65687420 72756320      measure the cur
 802ef60:	746e6572 646e6120 6c616320 616c7563     rent and calcula
 802ef70:	74206574 6d206568 726f746f 646e6920     te the motor ind
 802ef80:	61746375 0065636e 7361656d 5f657275     uctance.measure_
 802ef90:	6b6e696c 20656761 7275635b 746e6572     linkage [current
 802efa0:	645b205d 5d797475 696d5b20 70725f6e     ] [duty] [min_rp
 802efb0:	5b205d6d 6f746f6d 65725f72 00005d73     m] [motor_res]..
 802efc0:	75522020 6874206e 6f6d2065 20726f74       Run the motor 
 802efd0:	42206e69 2043444c 616c6564 6f6d2079     in BLDC delay mo
 802efe0:	61206564 6d20646e 75736165 74206572     de and measure t
 802eff0:	66206568 2078756c 6b6e696c 00656761     he flux linkage.
 802f000:	78652020 6c706d61 656d2065 72757361       example measur
 802f010:	696c5f65 67616b6e 20352065 20352e30     e_linkage 5 0.5 
 802f020:	20303037 37302e30 00000036 69742020     700 0.076...  ti
 802f030:	6d203a70 75736165 74206572 72206568     p: measure the r
 802f040:	73697365 636e6174 69772065 6d206874     esistance with m
 802f050:	75736165 725f6572 66207365 74737269     easure_res first
 802f060:	00000000 654d2020 72757361 68742065     ....  Measure th
 802f070:	6f6d2065 20726f74 69736572 6e617473     e motor resistan
 802f080:	61206563 6920646e 6375646e 636e6174     ce and inductanc
 802f090:	69772065 61206874 6e69206e 6d657263     e with an increm
 802f0a0:	61746e65 6461206c 69747061 61206576     ental adaptive a
 802f0b0:	726f676c 6d687469 0000002e 7361656d     lgorithm....meas
 802f0c0:	5f657275 6b6e696c 5f656761 20636f66     ure_linkage_foc 
 802f0d0:	7475645b 00005d79 75522020 6874206e     [duty]..  Run th
 802f0e0:	6f6d2065 20726f74 68746977 434f4620     e motor with FOC
 802f0f0:	646e6120 61656d20 65727573 65687420      and measure the
 802f100:	756c6620 696c2078 67616b6e 00002e65      flux linkage...
 802f110:	72502020 20746e69 656d6f73 434f4620       Print some FOC
 802f120:	61747320 76206574 61697261 73656c62      state variables
 802f130:	0000002e 72502020 20746e69 656d6f73     ....  Print some
 802f140:	72616820 72617764 74732065 73757461      hardware status
 802f150:	666e6920 616d726f 6e6f6974 0000002e      information....
 802f160:	5f636f66 6e65706f 706f6f6c 75635b20     foc_openloop [cu
 802f170:	6e657272 5b205d74 6d707265 0000005d     rrent] [erpm]...
 802f180:	72432020 65746165 206e6120 6e65706f       Create an open
 802f190:	6f6f6c20 6f722070 69746174 6320676e      loop rotating c
 802f1a0:	65727275 7620746e 6f746365 00002e72     urrent vector...
 802f1b0:	25207325 00000073 73252020 00000000     %s %s...  %s....
 802f1c0:	68542020 20657265 6e207369 6568206f       There is no he
 802f1d0:	6120706c 6c696176 656c6261 726f6620     lp available for
 802f1e0:	69687420 6f632073 6e616d6d 00002e64      this command...
 802f1f0:	61766e49 2064696c 6d6d6f63 3a646e61     Invalid command:
 802f200:	0a732520 65707974 6c656820 6f742070      %s.type help to
 802f210:	73696c20 6c612074 7661206c 616c6961      list all availa
 802f220:	20656c62 6d6d6f63 73646e61 0000000a     ble commands....
 802f230:	65746544 00007463 00000000 00000000     Detect..........
 802f240:	656d6954 0074756f 00000000 00000000     Timeout.........
 802f250:	636e6143 70206d6f 65636f72 00007373     Cancom process..
 802f260:	004e4143 00000000 00000000 00000000     CAN.............
 802f270:	204e4143 74617473 00007375 00000000     CAN status......

0802f280 <flash_addr>:
 802f280:	08000000 08004000 08008000 0800c000     .....@..........
 802f290:	08010000 08020000 08040000 08060000     ................
 802f2a0:	08080000 080a0000 080c0000 080e0000     ................

0802f2b0 <flash_sector>:
 802f2b0:	00080000 00180010 00280020 00380030     ........ .(.0.8.
 802f2c0:	00480040 00580050 00000000 00000000     @.H.P.X.........

0802f2d0 <CSWTCH.177>:
 802f2d0:	0802f310 0802f320 0802f338 0802f354     .... ...8...T...
 802f2e0:	0802f364 0802f380 0802f39c 00000000     d...............
 802f2f0:	4c554146 4e555f54 574f4e4b 0000004e     FAULT_UNKNOWN...
 802f300:	706d6153 6553656c 7265646e 00000000     SampleSender....
 802f310:	4c554146 4f435f54 4e5f4544 00454e4f     FAULT_CODE_NONE.
 802f320:	4c554146 4f435f54 4f5f4544 5f524556     FAULT_CODE_OVER_
 802f330:	544c4f56 00454741 4c554146 4f435f54     VOLTAGE.FAULT_CO
 802f340:	555f4544 5245444e 4c4f565f 45474154     DE_UNDER_VOLTAGE
 802f350:	00000000 4c554146 4f435f54 445f4544     ....FAULT_CODE_D
 802f360:	00005652 4c554146 4f435f54 415f4544     RV..FAULT_CODE_A
 802f370:	4f5f5342 5f524556 52525543 00544e45     BS_OVER_CURRENT.
 802f380:	4c554146 4f435f54 4f5f4544 5f524556     FAULT_CODE_OVER_
 802f390:	504d4554 5445465f 00000000 4c554146     TEMP_FET....FAUL
 802f3a0:	4f435f54 4f5f4544 5f524556 504d4554     T_CODE_OVER_TEMP
 802f3b0:	544f4d5f 0000524f 00000000 00000000     _MOTOR..........
 802f3c0:	6669636d 6d697420 00007265 00000000     mcif timer......
 802f3d0:	65646e49 6f662078 00646e75 61746f52     Index found.Rota
 802f3e0:	20646574 20726f66 636e7973 00000000     ted for sync....
 802f3f0:	65766e49 6f697372 6e61206e 61722064     Inversion and ra
 802f400:	206f6974 65746564 64657463 00000000     tio detected....
 802f410:	3a636e45 322e2520 00000066 3a677641     Enc: %.2f...Avg:
 802f420:	322e2520 00000066 7366664f 64207465      %.2f...Offset d
 802f430:	63657465 00646574 00000000 00000000     etected.........
 802f440:	20646f4d 20203a64 20202020 2e252020     Mod d:        %.
 802f450:	00006632 20646f4d 20203a71 20202020     2f..Mod q:      
 802f460:	2e252020 00006632 79747544 2020203a       %.2f..Duty:   
 802f470:	20202020 2e252020 00006632 203a6456           %.2f..Vd: 
 802f480:	20202020 20202020 2e252020 00006632               %.2f..
 802f490:	203a7156 20202020 20202020 2e252020     Vq:           %.
 802f4a0:	00006632 73616850 20203a65 20202020     2f..Phase:      
 802f4b0:	2e252020 00006632 6c615f56 3a616870       %.2f..V_alpha:
 802f4c0:	20202020 2e252020 00006632 65625f56           %.2f..V_be
 802f4d0:	203a6174 20202020 2e252020 00006632     ta:       %.2f..
 802f4e0:	203a6469 20202020 20202020 2e252020     id:           %.
 802f4f0:	00006632 203a7169 20202020 20202020     2f..iq:         
 802f500:	2e252020 00006632 665f6469 65746c69       %.2f..id_filte
 802f510:	20203a72 2e252020 00006632 665f7169     r:    %.2f..iq_f
 802f520:	65746c69 20203a72 2e252020 00006632     ilter:    %.2f..
 802f530:	745f6469 65677261 20203a74 2e252020     id_target:    %.
 802f540:	00006632 745f7169 65677261 20203a74     2f..iq_target:  
 802f550:	2e252020 00006632 62615f69 20203a73       %.2f..i_abs:  
 802f560:	20202020 2e252020 00006632 62615f69           %.2f..i_ab
 802f570:	69665f73 7265746c 2e25203a 00006632     s_filter: %.2f..
 802f580:	5f73624f 203a3178 20202020 2e252020     Obs_x1:       %.
 802f590:	00006632 5f73624f 203a3278 20202020     2f..Obs_x2:     
 802f5a0:	2e252020 00006632 00000000 00000000       %.2f..........
 802f5b0:	7770636d 6f665f6d 69742063 0072656d     mcpwm_foc timer.

0802f5c0 <i2cfg>:
 802f5c0:	00000001 000186a0 00000001 00000000     ................
 802f5d0:	5f505041 004d5050 00000000 00000000     APP_PPM.........
 802f5e0:	5f505041 00434441 00000000 00000000     APP_ADC.........
 802f5f0:	74726175 6d6d6f63 6f727020 73736563     uartcomm process
	...
 802f610:	6e697250 68742074 74732065 73757461     Print the status
 802f620:	20666f20 20656874 636e756e 206b7568      of the nunchuk 
 802f630:	00707061 636e756e 5f6b7568 74617473     app.nunchuk_stat
 802f640:	00007375 00000000 00000000 00000000     us..............
 802f650:	636e754e 206b7568 00633269 00000000     Nunchuk i2c.....
 802f660:	636e754e 206b7568 7074756f 00007475     Nunchuk output..
 802f670:	00006e4f 0066664f 636e754e 206b7568     On..Off.Nunchuk 
 802f680:	74617453 00007375 7074754f 203a7475     Status..Output: 
 802f690:	00007325 00000000 00000000 00000000     %s..............
 802f6a0:	2066724e 00005852 00000000 00000000     Nrf RX..........
 802f6b0:	2066724e 00005854 00000000 00000000     Nrf TX..........

0802f6c0 <__exp2f_data>:
 802f6c0:	00000000 3ff00000 d3158574 3fefd9b0     .......?t......?
 802f6d0:	6cf9890f 3fefb558 d0125b51 3fef9301     ...lX..?Q[.....?
 802f6e0:	3c7d517b 3fef72b8 3168b9aa 3fef5487     {Q}<.r.?..h1.T.?
 802f6f0:	6e756238 3fef387a f51fdee1 3fef1e9d     8bunz8.?.......?
 802f700:	0a31b715 3fef06fe 373aa9cb 3feef1a7     ..1....?..:7...?
 802f710:	4c123422 3feedea6 6061892d 3feece08     "4.L...?-.a`...?
 802f720:	d5362a27 3feebfda 569d4f82 3feeb42b     '*6....?.O.V+..?
 802f730:	dd485429 3feeab07 b03a5585 3feea47e     )TH....?.U:.~..?
 802f740:	667f3bcd 3feea09e e8ec5f74 3fee9f75     .;.f...?t_..u..?
 802f750:	73eb0187 3feea114 994cce13 3feea589     ...s...?..L....?
 802f760:	422aa0db 3feeace5 b0cdc5e5 3feeb737     ..*B...?....7..?
 802f770:	82a3f090 3feec491 b23e255d 3feed503     .......?]%>....?
 802f780:	995ad3ad 3feee89f f2fb5e47 3feeff76     ..Z....?G^..v..?
 802f790:	dd85529c 3fef199b dcef9069 3fef3720     .R.....?i... 7.?
 802f7a0:	dcfba487 3fef5818 337b9b5f 3fef7c97     .....X.?_.{3.|.?
 802f7b0:	a2a490da 3fefa4af 5b6e4540 3fefd076     .......?@En[v..?
 802f7c0:	00000000 42e80000 4b912394 3fac6af8     .......B.#.K.j.?
 802f7d0:	50fac4f3 3fcebfce ff0c52d6 3fe62e42     ...P...?.R..B..?
 802f7e0:	00000000 43380000 652b82fe 40471547     ......8C..+eG.G@
 802f7f0:	4b912394 3ebc6af8 50fac4f3 3f2ebfce     .#.K.j.>...P...?
 802f800:	ff0c52d6 3f962e42 00000000 00000000     .R..B..?........

0802f810 <__logf_data>:
 802f810:	79f8f3be 3ff661ec 808caade bfd57bf7     ...y.a.?.....{..
 802f820:	4aaf883d 3ff571ed a7c06ddb bfd2bef0     =..J.q.?.m......
 802f830:	f0f010b0 3ff49539 7f513a67 bfd01eae     ....9..?g:Q.....
 802f840:	b0b80385 3ff3c995 a68224e9 bfcb31d8     .......?.$...1..
 802f850:	0c8864a5 3ff30d19 0ac07758 bfc6574f     .d.....?Xw..OW..
 802f860:	7b0b8ea0 3ff25e22 c79c8100 bfc1aa2b     ...{"^.?....+...
 802f870:	4a1a343f 3ff1bb4a ce8c0e5e bfba4e76     ?4.JJ..?^...vN..
 802f880:	f08ae5ba 3ff12358 5a611ccc bfb1973c     ....X#.?..aZ<...
 802f890:	419900a7 3ff0953f 38e10c1e bfa252f4     ...A?..?...8.R..
 802f8a0:	00000000 3ff00000 00000000 00000000     .......?........
 802f8b0:	fd9a47ac 3fee608c 5df25984 3faaa5aa     .G...`.?.Y.]...?
 802f8c0:	1f026aa0 3feca4b3 aa362eb4 3fbc5e53     .j.....?..6.S^.?
 802f8d0:	576afce6 3feb2036 7720db08 3fc526e5     ..jW6 .?.. w.&.?
 802f8e0:	63a1aa2d 3fe9c2d1 0d224770 3fcbc286     -..c...?pG"....?
 802f8f0:	037841ed 3fe886e6 c8a07ee1 3fd1058b     .Ax....?.~.....?
 802f900:	f5534862 3fe767dc 57b6ee09 3fd40430     bHS..g.?...W0..?
 802f910:	fefa39ef 3fe62e42 48b88334 bfd00ea3     .9..B..?4..H....
 802f920:	0be00b6a 3fd5575b f20a4123 bfdffffe     j...[W.?#A......

0802f930 <__powf_log2_data>:
 802f930:	79f8f3be 3ff661ec 5b963019 bfdefec6     ...y.a.?.0.[....
 802f940:	4aaf883d 3ff571ed 32d4fca4 bfdb0b68     =..J.q.?...2h...
 802f950:	f0f010b0 3ff49539 0a1fb77b bfd7418b     ....9..?{....A..
 802f960:	b0b80385 3ff3c995 1a6dcf7b bfd39de9     .......?{.m.....
 802f970:	0c8864a5 3ff30d19 f3f2b631 bfd01d9b     .d.....?1.......
 802f980:	7b0b8ea0 3ff25e22 1b3b7af0 bfc97c1d     ...{"^.?.z;..|..
 802f990:	4a1a343f 3ff1bb4a 93af3c9f bfc2f9e3     ?4.JJ..?.<......
 802f9a0:	f08ae5ba 3ff12358 bf788d5c bfb960cb     ....X#.?\.x..`..
 802f9b0:	419900a7 3ff0953f b6475fce bfaa6f9d     ...A?..?._G..o..
 802f9c0:	00000000 3ff00000 00000000 00000000     .......?........
 802f9d0:	fd9a47ac 3fee608c 9f24f53d 3fb338ca     .G...`.?=.$..8.?
 802f9e0:	1f026aa0 3feca4b3 543891ba 3fc476a9     .j.....?..8T.v.?
 802f9f0:	576afce6 3feb2036 4ac4e4d2 3fce840b     ..jW6 .?...J...?
 802fa00:	63a1aa2d 3fe9c2d1 f0c6651c 3fd40645     -..c...?.e..E..?
 802fa10:	037841ed 3fe886e6 2c1b9ff8 3fd88e9c     .Ax....?...,...?
 802fa20:	f5534862 3fe767dc 4eb17bcc 3fdce0a4     bHS..g.?.{.N...?
 802fa30:	c9496e0b 3fd27616 a075c67a bfd71969     .nI..v.?z.u.i...
 802fa40:	6ca7badd 3fdec70a 48bef6c8 bfe71547     ...l...?...HG...
 802fa50:	652ab82b 3ff71547 00000000 00000000     +.*eG..?........
 802fa60:	74727173 00000000 00000000 00000000     sqrt............
 802fa70:	6e697361 00000066 00000000 00000000     asinf...........
 802fa80:	646f6d66 00000066 00000000 00000000     fmodf...........
 802fa90:	74727173 00000066 00000000 00000000     sqrtf...........

0802faa0 <Zero>:
 802faa0:	00000000 80000000 00000000 00000000     ................

0802fab0 <npio2_hw>:
 802fab0:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
 802fac0:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
 802fad0:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
 802fae0:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
 802faf0:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
 802fb00:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
 802fb10:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
 802fb20:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

0802fb30 <two_over_pi>:
 802fb30:	000000a2 000000f9 00000083 0000006e     ............n...
 802fb40:	0000004e 00000044 00000015 00000029     N...D.......)...
 802fb50:	000000fc 00000027 00000057 000000d1     ....'...W.......
 802fb60:	000000f5 00000034 000000dd 000000c0     ....4...........
 802fb70:	000000db 00000062 00000095 00000099     ....b...........
 802fb80:	0000003c 00000043 00000090 00000041     <...C.......A...
 802fb90:	000000fe 00000051 00000063 000000ab     ....Q...c.......
 802fba0:	000000de 000000bb 000000c5 00000061     ............a...
 802fbb0:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
 802fbc0:	00000042 0000004d 000000d2 000000e0     B...M...........
 802fbd0:	00000006 00000049 0000002e 000000ea     ....I...........
 802fbe0:	00000009 000000d1 00000092 0000001c     ................
 802fbf0:	000000fe 0000001d 000000eb 0000001c     ................
 802fc00:	000000b1 00000029 000000a7 0000003e     ....).......>...
 802fc10:	000000e8 00000082 00000035 000000f5     ........5.......
 802fc20:	0000002e 000000bb 00000044 00000084     ........D.......
 802fc30:	000000e9 0000009c 00000070 00000026     ........p...&...
 802fc40:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
 802fc50:	00000039 00000091 000000d6 00000039     9...........9...
 802fc60:	00000083 00000053 00000039 000000f4     ....S...9.......
 802fc70:	0000009c 00000084 0000005f 0000008b     ........_.......
 802fc80:	000000bd 000000f9 00000028 0000003b     ........(...;...
 802fc90:	0000001f 000000f8 00000097 000000ff     ................
 802fca0:	000000de 00000005 00000098 0000000f     ................
 802fcb0:	000000ef 0000002f 00000011 0000008b     ..../...........
 802fcc0:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
 802fcd0:	0000006d 00000036 0000007e 000000cf     m...6...~.......
 802fce0:	00000027 000000cb 00000009 000000b7     '...............
 802fcf0:	0000004f 00000046 0000003f 00000066     O...F...?...f...
 802fd00:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
 802fd10:	00000075 00000027 000000ba 000000c7     u...'...........
 802fd20:	000000eb 000000e5 000000f1 0000007b     ............{...
 802fd30:	0000003d 00000007 00000039 000000f7     =.......9.......
 802fd40:	0000008a 00000052 00000092 000000ea     ....R...........
 802fd50:	0000006b 000000fb 0000005f 000000b1     k......._.......
 802fd60:	0000001f 0000008d 0000005d 00000008     ........].......
 802fd70:	00000056 00000003 00000030 00000046     V.......0...F...
 802fd80:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
 802fd90:	000000f0 000000cf 000000bc 00000020     ............ ...
 802fda0:	0000009a 000000f4 00000036 0000001d     ........6.......
 802fdb0:	000000a9 000000e3 00000091 00000061     ............a...
 802fdc0:	0000005e 000000e6 0000001b 00000008     ^...............
 802fdd0:	00000065 00000099 00000085 0000005f     e..........._...
 802fde0:	00000014 000000a0 00000068 00000040     ........h...@...
 802fdf0:	0000008d 000000ff 000000d8 00000080     ................
 802fe00:	0000004d 00000073 00000027 00000031     M...s...'...1...
 802fe10:	00000006 00000006 00000015 00000056     ............V...
 802fe20:	000000ca 00000073 000000a8 000000c9     ....s...........
 802fe30:	00000060 000000e2 0000007b 000000c0     `.......{.......
 802fe40:	0000008c 0000006b 00000000 00000000     ....k...........

0802fe50 <PIo2>:
 802fe50:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
 802fe60:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
 802fe70:	1fc40000 1bc60000 17440000 00000000     ..........D.....

0802fe80 <init_jk>:
 802fe80:	00000004 00000007 00000009 00000000     ................

0802fe90 <atanhi>:
 802fe90:	3eed6338 3f490fda 3f7b985e 3fc90fda     8c.>..I?^.{?...?

0802fea0 <atanlo>:
 802fea0:	31ac3769 33222168 33140fb4 33a22168     i7.1h!"3...3h!.3
 802feb0:	646c2565 00000000 00000000 00000000     e%ld............

0802fec0 <basefix.8622>:
 802fec0:	0001000a 00030002 00050004 00070006     ................
 802fed0:	00090008 000b000a 000d000c 000f000e     ................
 802fee0:	00000010 00000000 00000000 00000000     ................
 802fef0:	00000043 49534f50 00000058 00000000     C...POSIX.......
 802ff00:	0000666e 74696e69 00000079 00006e61     nf..inity...an..

0802ff10 <fpi.7443>:
 802ff10:	00000035 fffffbce 000003cb 00000001     5...............
	...

0802ff30 <fpinan.7479>:
 802ff30:	00000034 fffffbce 000003cb 00000001     4...............
	...

0802ff50 <tinytens>:
 802ff50:	97d889bc 3c9cd2b2 d5a8a733 3949f623     .......<3...#.I9
 802ff60:	44f4a73d 32a50ffd cf8c979d 255bba08     =..D...2......[%
 802ff70:	64ac6f43 11680628 00000000 00000000     Co.d(.h.........
 802ff80:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
 802ff90:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 802ffa0:	00000000 33323130 37363534 62613938     ....0123456789ab
 802ffb0:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
 802ffc0:	00000030 00000000 00000000 00000000     0...............

0802ffd0 <blanks.8551>:
 802ffd0:	20202020 20202020 20202020 20202020                     

0802ffe0 <zeroes.8552>:
 802ffe0:	30303030 30303030 30303030 30303030     0000000000000000

0802fff0 <_ctype_>:
 802fff0:	20202000 20202020 28282020 20282828     .         ((((( 
 8030000:	20202020 20202020 20202020 20202020                     
 8030010:	10108820 10101010 10101010 10101010      ...............
 8030020:	04040410 04040404 10040404 10101010     ................
 8030030:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8030040:	01010101 01010101 01010101 10101010     ................
 8030050:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8030060:	02020202 02020202 02020202 10101010     ................
 8030070:	00000020 00000000 00000000 00000000      ...............
	...
 8030100:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.

08030110 <__hexdig>:
	...
 8030140:	13121110 17161514 00001918 00000000     ................
 8030150:	1c1b1a00 001f1e1d 00000000 00000000     ................
	...
 8030170:	1c1b1a00 001f1e1d 00000000 00000000     ................
	...

08030210 <__mprec_bigtens>:
 8030210:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
 8030220:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
 8030230:	7f73bf3c 75154fdd 00000000 00000000     <.s..O.u........

08030240 <__mprec_tens>:
 8030240:	00000000 3ff00000 00000000 40240000     .......?......$@
 8030250:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
 8030260:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
 8030270:	00000000 412e8480 00000000 416312d0     .......A......cA
 8030280:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
 8030290:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
 80302a0:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
 80302b0:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
 80302c0:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
 80302d0:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
 80302e0:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
 80302f0:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
 8030300:	79d99db4 44ea7843 00000000 00000000     ...yCx.D........

08030310 <p05.7367>:
 8030310:	00000005 00000019 0000007d              ........}...
